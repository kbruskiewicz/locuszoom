/*! Locuszoom 0.13.0-beta.2 */
var LzWidgetAddons =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-widget-addons.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-widget-addons.js":
/*!*************************************!*\
  !*** ./esm/ext/lz-widget-addons.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Optional LocusZoom extension: must be included separately, and after LocusZoom has been loaded
 *
 * This contains (reusable) code to power some (rarely used) demo features:
 *  - The "covariates model" demo, in which an LZ toolbar widget is populated
 *    with information by selecting points on the plot (see "covariates model" demo)
 *  - The "data layers" button, which allows fine control over multiple data layers shown in the same panel
 *    (show/hide, fade, change order, etc). This is powerful, but rarely used because showing many datasets in a small
 *    space is hard to read. (see "multiple phenotypes layered" demo)
 * @module
 */
 // In order to work in a UMD context, this module imports the top-level LocusZoom symbol

var STATUS_VERBS = ['highlight', 'select', 'fade', 'hide'];
var STATUS_ADJECTIVES = ['highlighted', 'selected', 'faded', 'hidden'];
var STATUS_ANTIVERBS = ['unhighlight', 'deselect', 'unfade', 'show']; // LocusZoom plugins work by exporting a function that receives the `LocusZoom` object
// This allows them to work in many contexts (including script tags and ES6 imports)

function install(LocusZoom) {
  var _Button = LocusZoom.Widgets.get('_Button');

  var _BaseWidget = LocusZoom.Widgets.get('BaseWidget');
  /**
   * Special button/menu to allow model building by tracking individual covariants. Will track a list of covariate
   *   objects and store them in the special `model.covariates` field of plot `state`.
   * @param {object} layout
   * @param {string} layout.button_html The HTML to render inside the button
   * @param {string} layout.button_title Text to display as a tooltip when hovering over the button
   */


  var CovariatesModel = /*#__PURE__*/function (_BaseWidget2) {
    _inherits(CovariatesModel, _BaseWidget2);

    var _super = _createSuper(CovariatesModel);

    function CovariatesModel() {
      _classCallCheck(this, CovariatesModel);

      return _super.apply(this, arguments);
    }

    _createClass(CovariatesModel, [{
      key: "initialize",
      value: function initialize() {
        var _this = this;

        // Initialize state.model.covariates
        this.parent_plot.state.model = this.parent_plot.state.model || {};
        this.parent_plot.state.model.covariates = this.parent_plot.state.model.covariates || []; // Create an object at the plot level for easy access to interface methods in custom client-side JS

        /**
         * When a covariates model toolbar element is present, create (one) object at the plot level that exposes
         *   widget data and state for custom interactions with other plot elements.
         * @class CovariatesModel
         */

        this.parent_plot.CovariatesModel = {
          /** @member {Button} */
          button: this,

          /**
           * Add an element to the model and show a representation of it in the toolbar widget menu. If the
           *   element is already part of the model, do nothing (to avoid adding duplicates).
           * When plot state is changed, this will automatically trigger requests for new data accordingly.
           * @param {string|object} element_reference Can be any value that can be put through JSON.stringify()
           *   to create a serialized representation of itself.
           */
          add: function add(element_reference) {
            var plot = _this.parent_plot;
            var element = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(element_reference);

            if (_typeof(element_reference) == 'object' && typeof element.html != 'string') {
              element.html = typeof element_reference.toHTML == 'function' ? element_reference.toHTML() : element_reference.toString();
            } // Check if the element is already in the model covariates array and return if it is.


            for (var i = 0; i < plot.state.model.covariates.length; i++) {
              if (JSON.stringify(plot.state.model.covariates[i]) === JSON.stringify(element)) {
                return plot;
              }
            }

            plot.state.model.covariates.push(element);
            plot.applyState();
            plot.CovariatesModel.updateWidget();
            return plot;
          },

          /**
           * Remove an element from `state.model.covariates` (and from the toolbar widget menu's
           *  representation of the state model). When plot state is changed, this will automatically trigger
           *  requests for new data accordingly.
           * @param {number} idx Array index of the element, in the `state.model.covariates array`.
           */
          removeByIdx: function removeByIdx(idx) {
            var plot = _this.parent_plot;

            if (typeof plot.state.model.covariates[idx] == 'undefined') {
              throw new Error("Unable to remove model covariate, invalid index: ".concat(idx.toString()));
            }

            plot.state.model.covariates.splice(idx, 1);
            plot.applyState();
            plot.CovariatesModel.updateWidget();
            return plot;
          },

          /**
           * Empty the `state.model.covariates` array (and toolbar widget menu representation thereof) of all
           *  elements. When plot state is changed, this will automatically trigger requests for new data accordingly
           */
          removeAll: function removeAll() {
            var plot = _this.parent_plot;
            plot.state.model.covariates = [];
            plot.applyState();
            plot.CovariatesModel.updateWidget();
            return plot;
          },

          /**
           * Manually trigger the update methods on the toolbar widget's button and menu elements to force
           *   display of most up-to-date content. Can be used to force the toolbar to reflect changes made, eg if
           *   modifying `state.model.covariates` directly instead of via `plot.CovariatesModel`
           */
          updateWidget: function updateWidget() {
            _this.button.update();

            _this.button.menu.update();
          }
        };
      }
    }, {
      key: "update",
      value: function update() {
        var _this2 = this;

        if (this.button) {
          return this;
        }

        this.button = new _Button(this).setColor(this.layout.color).setHtml(this.layout.button_html).setTitle(this.layout.button_title).setOnclick(function () {
          _this2.button.menu.populate();
        });
        this.button.menu.setPopulate(function () {
          var selector = _this2.button.menu.inner_selector;
          selector.html(''); // General model HTML representation

          if (typeof _this2.parent_plot.state.model.html != 'undefined') {
            selector.append('div').html(_this2.parent_plot.state.model.html);
          } // Model covariates table


          if (!_this2.parent_plot.state.model.covariates.length) {
            selector.append('i').html('no covariates in model');
          } else {
            selector.append('h5').html("Model Covariates (".concat(_this2.parent_plot.state.model.covariates.length, ")"));
            var table = selector.append('table');

            _this2.parent_plot.state.model.covariates.forEach(function (covariate, idx) {
              var html = _typeof(covariate) == 'object' && typeof covariate.html == 'string' ? covariate.html : covariate.toString();
              var row = table.append('tr');
              row.append('td').append('button').attr('class', "lz-toolbar-button lz-toolbar-button-".concat(_this2.layout.color)).style('margin-left', '0em').on('click', function () {
                return _this2.parent_plot.CovariatesModel.removeByIdx(idx);
              }).html('×');
              row.append('td').html(html);
            });

            selector.append('button').attr('class', "lz-toolbar-button lz-toolbar-button-".concat(_this2.layout.color)).style('margin-left', '4px').html('× Remove All Covariates').on('click', function () {
              return _this2.parent_plot.CovariatesModel.removeAll();
            });
          }
        });

        this.button.preUpdate = function () {
          var html = 'Model';
          var count = _this2.parent_plot.state.model.covariates.length;

          if (count) {
            var noun = count > 1 ? 'covariates' : 'covariate';
            html += " (".concat(count, " ").concat(noun, ")");
          }

          _this2.button.setHtml(html).disable(false);
        };

        this.button.show();
        return this;
      }
    }]);

    return CovariatesModel;
  }(_BaseWidget);
  /**
   * Menu for manipulating multiple data layers in a single panel: show/hide, change order, etc.
   */


  var DataLayersWidget = /*#__PURE__*/function (_BaseWidget3) {
    _inherits(DataLayersWidget, _BaseWidget3);

    var _super2 = _createSuper(DataLayersWidget);

    function DataLayersWidget() {
      _classCallCheck(this, DataLayersWidget);

      return _super2.apply(this, arguments);
    }

    _createClass(DataLayersWidget, [{
      key: "update",
      value: function update() {
        var _this3 = this;

        if (typeof this.layout.button_html != 'string') {
          this.layout.button_html = 'Data Layers';
        }

        if (typeof this.layout.button_title != 'string') {
          this.layout.button_title = 'Manipulate Data Layers (sort, dim, show/hide, etc.)';
        }

        if (this.button) {
          return this;
        }

        this.button = new _Button(this).setColor(this.layout.color).setHtml(this.layout.button_html).setTitle(this.layout.button_title).setOnclick(function () {
          _this3.button.menu.populate();
        });
        this.button.menu.setPopulate(function () {
          _this3.button.menu.inner_selector.html('');

          var table = _this3.button.menu.inner_selector.append('table');

          _this3.parent_panel.data_layer_ids_by_z_index.slice().reverse().forEach(function (id, idx) {
            var data_layer = _this3.parent_panel.data_layers[id];
            var name = typeof data_layer.layout.name != 'string' ? data_layer.id : data_layer.layout.name;
            var row = table.append('tr'); // Layer name

            row.append('td').html(name); // Status toggle buttons

            _this3.layout.statuses.forEach(function (status_adj) {
              var status_idx = STATUS_ADJECTIVES.indexOf(status_adj);
              var status_verb = STATUS_VERBS[status_idx];
              var html, onclick, highlight;

              if (data_layer.global_statuses[status_adj]) {
                html = STATUS_ANTIVERBS[status_idx];
                onclick = "un".concat(status_verb, "AllElements");
                highlight = '-highlighted';
              } else {
                html = STATUS_VERBS[status_idx];
                onclick = "".concat(status_verb, "AllElements");
                highlight = '';
              }

              row.append('td').append('a').attr('class', "lz-toolbar-button lz-toolbar-button-".concat(_this3.layout.color).concat(highlight)).style('margin-left', '0em').on('click', function () {
                data_layer[onclick]();

                _this3.button.menu.populate();
              }).html(html);
            }); // Sort layer buttons


            var at_top = idx === 0;
            var at_bottom = idx === _this3.parent_panel.data_layer_ids_by_z_index.length - 1;
            var td = row.append('td');
            td.append('a').attr('class', "lz-toolbar-button lz-toolbar-button-group-start lz-toolbar-button-".concat(_this3.layout.color).concat(at_bottom ? '-disabled' : '')).style('margin-left', '0em').on('click', function () {
              data_layer.moveBack();

              _this3.button.menu.populate();
            }).html('▾').attr('title', 'Move layer down (further back)');
            td.append('a').attr('class', "lz-toolbar-button lz-toolbar-button-group-middle lz-toolbar-button-".concat(_this3.layout.color).concat(at_top ? '-disabled' : '')).style('margin-left', '0em').on('click', function () {
              data_layer.moveForward();

              _this3.button.menu.populate();
            }).html('▴').attr('title', 'Move layer up (further front)');
            td.append('a').attr('class', 'lz-toolbar-button lz-toolbar-button-group-end lz-toolbar-button-red').style('margin-left', '0em').on('click', function () {
              if (confirm("Are you sure you want to remove the ".concat(name, " layer? This cannot be undone."))) {
                data_layer.parent.removeDataLayer(id);
              }

              return _this3.button.menu.populate();
            }).html('×').attr('title', 'Remove layer');
          });

          return _this3;
        });
        this.button.show();
        return this;
      }
    }]);

    return DataLayersWidget;
  }(_BaseWidget);

  var covariates_model_tooltip = function () {
    var covariates_model_association = LocusZoom.Layouts.get('tooltip', 'standard_association', {
      unnamespaced: true
    });
    covariates_model_association.html += '<a href="javascript:void(0);" onclick="LocusZoom.getToolTipPlot(this).CovariatesModel.add(LocusZoom.getToolTipData(this));">Condition on Variant</a><br>';
    return covariates_model_association;
  }();

  var covariates_model_plot = function () {
    var covariates_model_plot_toolbar = LocusZoom.Layouts.get('toolbar', 'standard_association', {
      unnamespaced: true
    });
    covariates_model_plot_toolbar.widgets.push({
      type: 'covariates_model',
      button_html: 'Model',
      button_title: 'Show and edit covariates currently in model',
      position: 'left'
    });
    return covariates_model_plot_toolbar;
  }();

  LocusZoom.Widgets.add('covariates_model', CovariatesModel);
  LocusZoom.Widgets.add('data_layers', DataLayersWidget);
  LocusZoom.Layouts.add('tooltip', 'covariates_model_association', covariates_model_tooltip);
  LocusZoom.Layouts.add('toolbar', 'covariates_model_plot', covariates_model_plot);
}

if (typeof LocusZoom !== 'undefined') {
  // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
  // eslint-disable-next-line no-undef
  LocusZoom.use(install);
}

/* harmony default export */ __webpack_exports__["default"] = (install);

/***/ }),

/***/ "./esm/helpers/layouts.js":
/*!********************************!*\
  !*** ./esm/helpers/layouts.js ***!
  \********************************/
/*! exports provided: applyNamespaces, deepCopy, merge, nameToSymbol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyNamespaces", function() { return applyNamespaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepCopy", function() { return deepCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nameToSymbol", function() { return nameToSymbol; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Utilities for modifying or working with layout objects
 *  @module
 */

var sqrt3 = Math.sqrt(3); // D3 v5 does not provide a triangle down symbol shape, but it is very useful for showing direction of effect.
//  Modified from https://github.com/d3/d3-shape/blob/master/src/symbol/triangle.js

var triangledown = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, -y * 2);
    context.lineTo(-sqrt3 * y, y);
    context.lineTo(sqrt3 * y, y);
    context.closePath();
  }
};
/**
 * Apply namespaces to layout, recursively
 * @private
  */

function applyNamespaces(element, namespace, default_namespace) {
  if (namespace) {
    if (typeof namespace == 'string') {
      namespace = {
        "default": namespace
      };
    }
  } else {
    namespace = {
      "default": ''
    };
  }

  if (typeof element == 'string') {
    var re = /\{\{namespace(\[[A-Za-z_0-9]+\]|)\}\}/g;
    var match, base, key, resolved_namespace;
    var replace = [];

    while ((match = re.exec(element)) !== null) {
      base = match[0];
      key = match[1].length ? match[1].replace(/(\[|\])/g, '') : null;
      resolved_namespace = default_namespace;

      if (namespace != null && _typeof(namespace) == 'object' && typeof namespace[key] != 'undefined') {
        resolved_namespace = namespace[key] + (namespace[key].length ? ':' : '');
      }

      replace.push({
        base: base,
        namespace: resolved_namespace
      });
    }

    for (var r in replace) {
      element = element.replace(replace[r].base, replace[r].namespace);
    }
  } else if (_typeof(element) == 'object' && element != null) {
    if (typeof element.namespace != 'undefined') {
      var merge_namespace = typeof element.namespace == 'string' ? {
        "default": element.namespace
      } : element.namespace;
      namespace = merge(namespace, merge_namespace);
    }

    var namespaced_element, namespaced_property;

    for (var property in element) {
      if (property === 'namespace') {
        continue;
      }

      namespaced_element = applyNamespaces(element[property], namespace, default_namespace);
      namespaced_property = applyNamespaces(property, namespace, default_namespace);

      if (property !== namespaced_property) {
        delete element[property];
      }

      element[namespaced_property] = namespaced_element;
    }
  }

  return element;
}
/**
 * A helper method used for merging two objects. If a key is present in both, takes the value from the first object
 *   Values from `default_layout` will be cleanly copied over, ensuring no references or shared state.
 *
 * Frequently used for preparing custom layouts. Both objects should be JSON-serializable.
 *
 * @param {object} custom_layout An object containing configuration parameters that override or add to defaults
 * @param {object} default_layout An object containing default settings.
 * @returns {object} The custom layout is modified in place and also returned from this method.
 */


function merge(custom_layout, default_layout) {
  if (_typeof(custom_layout) !== 'object' || _typeof(default_layout) !== 'object') {
    throw new Error("LocusZoom.Layouts.merge only accepts two layout objects; ".concat(_typeof(custom_layout), ", ").concat(_typeof(default_layout), " given"));
  }

  for (var property in default_layout) {
    if (!Object.prototype.hasOwnProperty.call(default_layout, property)) {
      continue;
    } // Get types for comparison. Treat nulls in the custom layout as undefined for simplicity.
    // (javascript treats nulls as "object" when we just want to overwrite them as if they're undefined)
    // Also separate arrays from objects as a discrete type.


    var custom_type = custom_layout[property] === null ? 'undefined' : _typeof(custom_layout[property]);

    var default_type = _typeof(default_layout[property]);

    if (custom_type === 'object' && Array.isArray(custom_layout[property])) {
      custom_type = 'array';
    }

    if (default_type === 'object' && Array.isArray(default_layout[property])) {
      default_type = 'array';
    } // Unsupported property types: throw an exception


    if (custom_type === 'function' || default_type === 'function') {
      throw new Error('LocusZoom.Layouts.merge encountered an unsupported property type');
    } // Undefined custom value: pull the default value


    if (custom_type === 'undefined') {
      custom_layout[property] = deepCopy(default_layout[property]);
      continue;
    } // Both values are objects: merge recursively


    if (custom_type === 'object' && default_type === 'object') {
      custom_layout[property] = merge(custom_layout[property], default_layout[property]);
      continue;
    }
  }

  return custom_layout;
}

function deepCopy(item) {
  return JSON.parse(JSON.stringify(item));
}
/**
 * Convert name to symbol
 * Layout objects accept symbol names as strings (circle, triangle, etc). Convert to symbol objects.
 * @return {object|null} An object that implements a draw method (eg d3-shape symbols or extra LZ items)
 */


function nameToSymbol(shape) {
  if (!shape) {
    return null;
  }

  if (shape === 'triangledown') {
    // D3 does not provide this symbol natively
    return triangledown;
  } // Legend shape names are strings; need to connect this to factory. Eg circle --> d3.symbolCircle


  var factory_name = "symbol".concat(shape.charAt(0).toUpperCase() + shape.slice(1));
  return d3__WEBPACK_IMPORTED_MODULE_0__[factory_name] || null;
}



/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei13aWRnZXQtYWRkb25zLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9oZWxwZXJzL2xheW91dHMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6WyJTVEFUVVNfVkVSQlMiLCJTVEFUVVNfQURKRUNUSVZFUyIsIlNUQVRVU19BTlRJVkVSQlMiLCJpbnN0YWxsIiwiTG9jdXNab29tIiwiX0J1dHRvbiIsIldpZGdldHMiLCJnZXQiLCJfQmFzZVdpZGdldCIsIkNvdmFyaWF0ZXNNb2RlbCIsInBhcmVudF9wbG90Iiwic3RhdGUiLCJtb2RlbCIsImNvdmFyaWF0ZXMiLCJidXR0b24iLCJhZGQiLCJlbGVtZW50X3JlZmVyZW5jZSIsInBsb3QiLCJlbGVtZW50IiwiZGVlcENvcHkiLCJodG1sIiwidG9IVE1MIiwidG9TdHJpbmciLCJpIiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsInB1c2giLCJhcHBseVN0YXRlIiwidXBkYXRlV2lkZ2V0IiwicmVtb3ZlQnlJZHgiLCJpZHgiLCJFcnJvciIsInNwbGljZSIsInJlbW92ZUFsbCIsInVwZGF0ZSIsIm1lbnUiLCJzZXRDb2xvciIsImxheW91dCIsImNvbG9yIiwic2V0SHRtbCIsImJ1dHRvbl9odG1sIiwic2V0VGl0bGUiLCJidXR0b25fdGl0bGUiLCJzZXRPbmNsaWNrIiwicG9wdWxhdGUiLCJzZXRQb3B1bGF0ZSIsInNlbGVjdG9yIiwiaW5uZXJfc2VsZWN0b3IiLCJhcHBlbmQiLCJ0YWJsZSIsImZvckVhY2giLCJjb3ZhcmlhdGUiLCJyb3ciLCJhdHRyIiwic3R5bGUiLCJvbiIsInByZVVwZGF0ZSIsImNvdW50Iiwibm91biIsImRpc2FibGUiLCJzaG93IiwiRGF0YUxheWVyc1dpZGdldCIsInBhcmVudF9wYW5lbCIsImRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXgiLCJzbGljZSIsInJldmVyc2UiLCJpZCIsImRhdGFfbGF5ZXIiLCJkYXRhX2xheWVycyIsIm5hbWUiLCJzdGF0dXNlcyIsInN0YXR1c19hZGoiLCJzdGF0dXNfaWR4IiwiaW5kZXhPZiIsInN0YXR1c192ZXJiIiwib25jbGljayIsImhpZ2hsaWdodCIsImdsb2JhbF9zdGF0dXNlcyIsImF0X3RvcCIsImF0X2JvdHRvbSIsInRkIiwibW92ZUJhY2siLCJtb3ZlRm9yd2FyZCIsImNvbmZpcm0iLCJwYXJlbnQiLCJyZW1vdmVEYXRhTGF5ZXIiLCJjb3ZhcmlhdGVzX21vZGVsX3Rvb2x0aXAiLCJjb3ZhcmlhdGVzX21vZGVsX2Fzc29jaWF0aW9uIiwiTGF5b3V0cyIsInVubmFtZXNwYWNlZCIsImNvdmFyaWF0ZXNfbW9kZWxfcGxvdCIsImNvdmFyaWF0ZXNfbW9kZWxfcGxvdF90b29sYmFyIiwid2lkZ2V0cyIsInR5cGUiLCJwb3NpdGlvbiIsInVzZSIsInNxcnQzIiwiTWF0aCIsInNxcnQiLCJ0cmlhbmdsZWRvd24iLCJkcmF3IiwiY29udGV4dCIsInNpemUiLCJ5IiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwiYXBwbHlOYW1lc3BhY2VzIiwibmFtZXNwYWNlIiwiZGVmYXVsdF9uYW1lc3BhY2UiLCJyZSIsIm1hdGNoIiwiYmFzZSIsImtleSIsInJlc29sdmVkX25hbWVzcGFjZSIsInJlcGxhY2UiLCJleGVjIiwiciIsIm1lcmdlX25hbWVzcGFjZSIsIm1lcmdlIiwibmFtZXNwYWNlZF9lbGVtZW50IiwibmFtZXNwYWNlZF9wcm9wZXJ0eSIsInByb3BlcnR5IiwiY3VzdG9tX2xheW91dCIsImRlZmF1bHRfbGF5b3V0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY3VzdG9tX3R5cGUiLCJkZWZhdWx0X3R5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtIiwicGFyc2UiLCJuYW1lVG9TeW1ib2wiLCJzaGFwZSIsImZhY3RvcnlfbmFt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LENBQVgsQ0FBUDtBQUNIO0FBRUQ7Ozs7Ozs7QUFLQSxTQUFTRSxZQUFULENBQXNCQyxLQUF0QixFQUE2QjtBQUN6QixNQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNSLFdBQU8sSUFBUDtBQUNIOztBQUNELE1BQUlBLEtBQUssS0FBSyxjQUFkLEVBQThCO0FBQzFCO0FBQ0EsV0FBT3JDLFlBQVA7QUFDSCxHQVB3QixDQVF6Qjs7O0FBQ0EsTUFBTXNDLFlBQVksbUJBQVlELEtBQUssQ0FBQ0UsTUFBTixDQUFhLENBQWIsRUFBZ0JDLFdBQWhCLEtBQWdDSCxLQUFLLENBQUN4RSxLQUFOLENBQVksQ0FBWixDQUE1QyxDQUFsQjtBQUNBLFNBQU80RSwrQkFBRSxDQUFDSCxZQUFELENBQUYsSUFBb0IsSUFBM0I7QUFDSDs7Ozs7Ozs7Ozs7OztBQ3ZJRCxvQiIsImZpbGUiOiJleHQvbHotd2lkZ2V0LWFkZG9ucy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2VzbS9leHQvbHotd2lkZ2V0LWFkZG9ucy5qc1wiKTtcbiIsIi8qKlxuICogT3B0aW9uYWwgTG9jdXNab29tIGV4dGVuc2lvbjogbXVzdCBiZSBpbmNsdWRlZCBzZXBhcmF0ZWx5LCBhbmQgYWZ0ZXIgTG9jdXNab29tIGhhcyBiZWVuIGxvYWRlZFxuICpcbiAqIFRoaXMgY29udGFpbnMgKHJldXNhYmxlKSBjb2RlIHRvIHBvd2VyIHNvbWUgKHJhcmVseSB1c2VkKSBkZW1vIGZlYXR1cmVzOlxuICogIC0gVGhlIFwiY292YXJpYXRlcyBtb2RlbFwiIGRlbW8sIGluIHdoaWNoIGFuIExaIHRvb2xiYXIgd2lkZ2V0IGlzIHBvcHVsYXRlZFxuICogICAgd2l0aCBpbmZvcm1hdGlvbiBieSBzZWxlY3RpbmcgcG9pbnRzIG9uIHRoZSBwbG90IChzZWUgXCJjb3ZhcmlhdGVzIG1vZGVsXCIgZGVtbylcbiAqICAtIFRoZSBcImRhdGEgbGF5ZXJzXCIgYnV0dG9uLCB3aGljaCBhbGxvd3MgZmluZSBjb250cm9sIG92ZXIgbXVsdGlwbGUgZGF0YSBsYXllcnMgc2hvd24gaW4gdGhlIHNhbWUgcGFuZWxcbiAqICAgIChzaG93L2hpZGUsIGZhZGUsIGNoYW5nZSBvcmRlciwgZXRjKS4gVGhpcyBpcyBwb3dlcmZ1bCwgYnV0IHJhcmVseSB1c2VkIGJlY2F1c2Ugc2hvd2luZyBtYW55IGRhdGFzZXRzIGluIGEgc21hbGxcbiAqICAgIHNwYWNlIGlzIGhhcmQgdG8gcmVhZC4gKHNlZSBcIm11bHRpcGxlIHBoZW5vdHlwZXMgbGF5ZXJlZFwiIGRlbW8pXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7ZGVlcENvcHl9IGZyb20gJy4uL2hlbHBlcnMvbGF5b3V0cyc7XG5cbi8vIEluIG9yZGVyIHRvIHdvcmsgaW4gYSBVTUQgY29udGV4dCwgdGhpcyBtb2R1bGUgaW1wb3J0cyB0aGUgdG9wLWxldmVsIExvY3VzWm9vbSBzeW1ib2xcblxuY29uc3QgU1RBVFVTX1ZFUkJTID0gWydoaWdobGlnaHQnLCAnc2VsZWN0JywgJ2ZhZGUnLCAnaGlkZSddO1xuY29uc3QgU1RBVFVTX0FESkVDVElWRVMgPSBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJywgJ2ZhZGVkJywgJ2hpZGRlbiddO1xuY29uc3QgU1RBVFVTX0FOVElWRVJCUyA9IFsndW5oaWdobGlnaHQnLCAnZGVzZWxlY3QnLCAndW5mYWRlJywgJ3Nob3cnXTtcblxuXG4vLyBMb2N1c1pvb20gcGx1Z2lucyB3b3JrIGJ5IGV4cG9ydGluZyBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGBMb2N1c1pvb21gIG9iamVjdFxuLy8gVGhpcyBhbGxvd3MgdGhlbSB0byB3b3JrIGluIG1hbnkgY29udGV4dHMgKGluY2x1ZGluZyBzY3JpcHQgdGFncyBhbmQgRVM2IGltcG9ydHMpXG5mdW5jdGlvbiBpbnN0YWxsKExvY3VzWm9vbSkge1xuICAgIGNvbnN0IF9CdXR0b24gPSBMb2N1c1pvb20uV2lkZ2V0cy5nZXQoJ19CdXR0b24nKTtcbiAgICBjb25zdCBfQmFzZVdpZGdldCA9IExvY3VzWm9vbS5XaWRnZXRzLmdldCgnQmFzZVdpZGdldCcpO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGJ1dHRvbi9tZW51IHRvIGFsbG93IG1vZGVsIGJ1aWxkaW5nIGJ5IHRyYWNraW5nIGluZGl2aWR1YWwgY292YXJpYW50cy4gV2lsbCB0cmFjayBhIGxpc3Qgb2YgY292YXJpYXRlXG4gICAgICogICBvYmplY3RzIGFuZCBzdG9yZSB0aGVtIGluIHRoZSBzcGVjaWFsIGBtb2RlbC5jb3ZhcmlhdGVzYCBmaWVsZCBvZiBwbG90IGBzdGF0ZWAuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQuYnV0dG9uX2h0bWwgVGhlIEhUTUwgdG8gcmVuZGVyIGluc2lkZSB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheW91dC5idXR0b25fdGl0bGUgVGV4dCB0byBkaXNwbGF5IGFzIGEgdG9vbHRpcCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhlIGJ1dHRvblxuICAgICAqL1xuICAgIGNsYXNzIENvdmFyaWF0ZXNNb2RlbCBleHRlbmRzIF9CYXNlV2lkZ2V0IHtcbiAgICAgICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgc3RhdGUubW9kZWwuY292YXJpYXRlc1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5tb2RlbCA9IHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwgfHwge307XG4gICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXMgPSB0aGlzLnBhcmVudF9wbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXMgfHwgW107XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gb2JqZWN0IGF0IHRoZSBwbG90IGxldmVsIGZvciBlYXN5IGFjY2VzcyB0byBpbnRlcmZhY2UgbWV0aG9kcyBpbiBjdXN0b20gY2xpZW50LXNpZGUgSlNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIGNvdmFyaWF0ZXMgbW9kZWwgdG9vbGJhciBlbGVtZW50IGlzIHByZXNlbnQsIGNyZWF0ZSAob25lKSBvYmplY3QgYXQgdGhlIHBsb3QgbGV2ZWwgdGhhdCBleHBvc2VzXG4gICAgICAgICAgICAgKiAgIHdpZGdldCBkYXRhIGFuZCBzdGF0ZSBmb3IgY3VzdG9tIGludGVyYWN0aW9ucyB3aXRoIG90aGVyIHBsb3QgZWxlbWVudHMuXG4gICAgICAgICAgICAgKiBAY2xhc3MgQ292YXJpYXRlc01vZGVsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QuQ292YXJpYXRlc01vZGVsID0ge1xuICAgICAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtCdXR0b259ICovXG4gICAgICAgICAgICAgICAgYnV0dG9uOiB0aGlzLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZCBhbiBlbGVtZW50IHRvIHRoZSBtb2RlbCBhbmQgc2hvdyBhIHJlcHJlc2VudGF0aW9uIG9mIGl0IGluIHRoZSB0b29sYmFyIHdpZGdldCBtZW51LiBJZiB0aGVcbiAgICAgICAgICAgICAgICAgKiAgIGVsZW1lbnQgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2RlbCwgZG8gbm90aGluZyAodG8gYXZvaWQgYWRkaW5nIGR1cGxpY2F0ZXMpLlxuICAgICAgICAgICAgICAgICAqIFdoZW4gcGxvdCBzdGF0ZSBpcyBjaGFuZ2VkLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseSB0cmlnZ2VyIHJlcXVlc3RzIGZvciBuZXcgZGF0YSBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGVsZW1lbnRfcmVmZXJlbmNlIENhbiBiZSBhbnkgdmFsdWUgdGhhdCBjYW4gYmUgcHV0IHRocm91Z2ggSlNPTi5zdHJpbmdpZnkoKVxuICAgICAgICAgICAgICAgICAqICAgdG8gY3JlYXRlIGEgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYWRkOiAoZWxlbWVudF9yZWZlcmVuY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxvdCA9IHRoaXMucGFyZW50X3Bsb3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkZWVwQ29weShlbGVtZW50X3JlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudF9yZWZlcmVuY2UgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVsZW1lbnQuaHRtbCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5odG1sID0gKCAodHlwZW9mIGVsZW1lbnRfcmVmZXJlbmNlLnRvSFRNTCA9PSAnZnVuY3Rpb24nKSA/IGVsZW1lbnRfcmVmZXJlbmNlLnRvSFRNTCgpIDogZWxlbWVudF9yZWZlcmVuY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBpbiB0aGUgbW9kZWwgY292YXJpYXRlcyBhcnJheSBhbmQgcmV0dXJuIGlmIGl0IGlzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHBsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlc1tpXSkgPT09IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGxvdC5zdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuYXBwbHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LkNvdmFyaWF0ZXNNb2RlbC51cGRhdGVXaWRnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGBzdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzYCAoYW5kIGZyb20gdGhlIHRvb2xiYXIgd2lkZ2V0IG1lbnUnc1xuICAgICAgICAgICAgICAgICAqICByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RhdGUgbW9kZWwpLiBXaGVuIHBsb3Qgc3RhdGUgaXMgY2hhbmdlZCwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAqICByZXF1ZXN0cyBmb3IgbmV3IGRhdGEgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBBcnJheSBpbmRleCBvZiB0aGUgZWxlbWVudCwgaW4gdGhlIGBzdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzIGFycmF5YC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW1vdmVCeUlkeDogKGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbG90ID0gdGhpcy5wYXJlbnRfcGxvdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXNbaWR4XSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIG1vZGVsIGNvdmFyaWF0ZSwgaW52YWxpZCBpbmRleDogJHtpZHgudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuYXBwbHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LkNvdmFyaWF0ZXNNb2RlbC51cGRhdGVXaWRnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbXB0eSB0aGUgYHN0YXRlLm1vZGVsLmNvdmFyaWF0ZXNgIGFycmF5IChhbmQgdG9vbGJhciB3aWRnZXQgbWVudSByZXByZXNlbnRhdGlvbiB0aGVyZW9mKSBvZiBhbGxcbiAgICAgICAgICAgICAgICAgKiAgZWxlbWVudHMuIFdoZW4gcGxvdCBzdGF0ZSBpcyBjaGFuZ2VkLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseSB0cmlnZ2VyIHJlcXVlc3RzIGZvciBuZXcgZGF0YSBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbG90ID0gdGhpcy5wYXJlbnRfcGxvdDtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5zdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuYXBwbHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LkNvdmFyaWF0ZXNNb2RlbC51cGRhdGVXaWRnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNYW51YWxseSB0cmlnZ2VyIHRoZSB1cGRhdGUgbWV0aG9kcyBvbiB0aGUgdG9vbGJhciB3aWRnZXQncyBidXR0b24gYW5kIG1lbnUgZWxlbWVudHMgdG8gZm9yY2VcbiAgICAgICAgICAgICAgICAgKiAgIGRpc3BsYXkgb2YgbW9zdCB1cC10by1kYXRlIGNvbnRlbnQuIENhbiBiZSB1c2VkIHRvIGZvcmNlIHRoZSB0b29sYmFyIHRvIHJlZmxlY3QgY2hhbmdlcyBtYWRlLCBlZyBpZlxuICAgICAgICAgICAgICAgICAqICAgbW9kaWZ5aW5nIGBzdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzYCBkaXJlY3RseSBpbnN0ZWFkIG9mIHZpYSBgcGxvdC5Db3ZhcmlhdGVzTW9kZWxgXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdXBkYXRlV2lkZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5idXR0b24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgX0J1dHRvbih0aGlzKVxuICAgICAgICAgICAgICAgIC5zZXRDb2xvcih0aGlzLmxheW91dC5jb2xvcilcbiAgICAgICAgICAgICAgICAuc2V0SHRtbCh0aGlzLmxheW91dC5idXR0b25faHRtbClcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUodGhpcy5sYXlvdXQuYnV0dG9uX3RpdGxlKVxuICAgICAgICAgICAgICAgIC5zZXRPbmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5wb3B1bGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LnNldFBvcHVsYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuYnV0dG9uLm1lbnUuaW5uZXJfc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IuaHRtbCgnJyk7XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhbCBtb2RlbCBIVE1MIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmVudF9wbG90LnN0YXRlLm1vZGVsLmh0bWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdkaXYnKS5odG1sKHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1vZGVsIGNvdmFyaWF0ZXMgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdpJykuaHRtbCgnbm8gY292YXJpYXRlcyBpbiBtb2RlbCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLmFwcGVuZCgnaDUnKS5odG1sKGBNb2RlbCBDb3ZhcmlhdGVzICgke3RoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IHNlbGVjdG9yLmFwcGVuZCgndGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzLmZvckVhY2goKGNvdmFyaWF0ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sID0gKCh0eXBlb2YgY292YXJpYXRlID09ICdvYmplY3QnICYmIHR5cGVvZiBjb3ZhcmlhdGUuaHRtbCA9PSAnc3RyaW5nJykgPyBjb3ZhcmlhdGUuaHRtbCA6IGNvdmFyaWF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmFwcGVuZCgndHInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJ3RkJykuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi0ke3RoaXMubGF5b3V0LmNvbG9yfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsICcwZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB0aGlzLnBhcmVudF9wbG90LkNvdmFyaWF0ZXNNb2RlbC5yZW1vdmVCeUlkeChpZHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCfDlycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZCgndGQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYGx6LXRvb2xiYXItYnV0dG9uIGx6LXRvb2xiYXItYnV0dG9uLSR7dGhpcy5sYXlvdXQuY29sb3J9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnNHB4JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCfDlyBSZW1vdmUgQWxsIENvdmFyaWF0ZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHRoaXMucGFyZW50X3Bsb3QuQ292YXJpYXRlc01vZGVsLnJlbW92ZUFsbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24ucHJlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBodG1sID0gJ01vZGVsJztcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdW4gPSBjb3VudCA+IDEgPyAnY292YXJpYXRlcycgOiAnY292YXJpYXRlJztcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBgICgke2NvdW50fSAke25vdW59KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnNldEh0bWwoaHRtbCkuZGlzYWJsZShmYWxzZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNZW51IGZvciBtYW5pcHVsYXRpbmcgbXVsdGlwbGUgZGF0YSBsYXllcnMgaW4gYSBzaW5nbGUgcGFuZWw6IHNob3cvaGlkZSwgY2hhbmdlIG9yZGVyLCBldGMuXG4gICAgICovXG4gICAgY2xhc3MgRGF0YUxheWVyc1dpZGdldCBleHRlbmRzIF9CYXNlV2lkZ2V0IHtcbiAgICAgICAgdXBkYXRlKCkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF5b3V0LmJ1dHRvbl9odG1sICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuYnV0dG9uX2h0bWwgPSAnRGF0YSBMYXllcnMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxheW91dC5idXR0b25fdGl0bGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5idXR0b25fdGl0bGUgPSAnTWFuaXB1bGF0ZSBEYXRhIExheWVycyAoc29ydCwgZGltLCBzaG93L2hpZGUsIGV0Yy4pJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gbmV3IF9CdXR0b24odGhpcylcbiAgICAgICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAgICAgLnNldEh0bWwodGhpcy5sYXlvdXQuYnV0dG9uX2h0bWwpXG4gICAgICAgICAgICAgICAgLnNldFRpdGxlKHRoaXMubGF5b3V0LmJ1dHRvbl90aXRsZSlcbiAgICAgICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLm1lbnUucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5zZXRQb3B1bGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5pbm5lcl9zZWxlY3Rvci5odG1sKCcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMuYnV0dG9uLm1lbnUuaW5uZXJfc2VsZWN0b3IuYXBwZW5kKCd0YWJsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3BhbmVsLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXguc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaCgoaWQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gdGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcnNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKHR5cGVvZiBkYXRhX2xheWVyLmxheW91dC5uYW1lICE9ICdzdHJpbmcnKSA/IGRhdGFfbGF5ZXIuaWQgOiBkYXRhX2xheWVyLmxheW91dC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0YWJsZS5hcHBlbmQoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIExheWVyIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZCgndGQnKS5odG1sKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0dXMgdG9nZ2xlIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzX2FkaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzX2lkeCA9IFNUQVRVU19BREpFQ1RJVkVTLmluZGV4T2Yoc3RhdHVzX2Fkaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNfdmVyYiA9IFNUQVRVU19WRVJCU1tzdGF0dXNfaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBodG1sLCBvbmNsaWNrLCBoaWdobGlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YV9sYXllci5nbG9iYWxfc3RhdHVzZXNbc3RhdHVzX2Fkal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gU1RBVFVTX0FOVElWRVJCU1tzdGF0dXNfaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrID0gYHVuJHtzdGF0dXNfdmVyYn1BbGxFbGVtZW50c2A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gJy1oaWdobGlnaHRlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSBTVEFUVVNfVkVSQlNbc3RhdHVzX2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljayA9IGAke3N0YXR1c192ZXJifUFsbEVsZW1lbnRzYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJ3RkJykuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgbHotdG9vbGJhci1idXR0b24gbHotdG9vbGJhci1idXR0b24tJHt0aGlzLmxheW91dC5jb2xvcn0ke2hpZ2hsaWdodH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnMGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyW29uY2xpY2tdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLm1lbnUucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBsYXllciBidXR0b25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0X3RvcCA9IChpZHggPT09IDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdF9ib3R0b20gPSAoaWR4ID09PSAodGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRkID0gcm93LmFwcGVuZCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi1ncm91cC1zdGFydCBsei10b29sYmFyLWJ1dHRvbi0ke3RoaXMubGF5b3V0LmNvbG9yfSR7YXRfYm90dG9tID8gJy1kaXNhYmxlZCcgOiAnJ31gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsICcwZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyLm1vdmVCYWNrKCk7IHRoaXMuYnV0dG9uLm1lbnUucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuaHRtbCgn4pa+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsICdNb3ZlIGxheWVyIGRvd24gKGZ1cnRoZXIgYmFjayknKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi1ncm91cC1taWRkbGUgbHotdG9vbGJhci1idXR0b24tJHt0aGlzLmxheW91dC5jb2xvcn0ke2F0X3RvcCA/ICctZGlzYWJsZWQnIDogJyd9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnMGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9sYXllci5tb3ZlRm9yd2FyZCgpOyB0aGlzLmJ1dHRvbi5tZW51LnBvcHVsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoJ+KWtCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCAnTW92ZSBsYXllciB1cCAoZnVydGhlciBmcm9udCknKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi1ncm91cC1lbmQgbHotdG9vbGJhci1idXR0b24tcmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnMGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZW1vdmUgdGhlICR7bmFtZX0gbGF5ZXI/IFRoaXMgY2Fubm90IGJlIHVuZG9uZS5gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyLnBhcmVudC5yZW1vdmVEYXRhTGF5ZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idXR0b24ubWVudS5wb3B1bGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCfDlycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCAnUmVtb3ZlIGxheWVyJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvdmFyaWF0ZXNfbW9kZWxfdG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY292YXJpYXRlc19tb2RlbF9hc3NvY2lhdGlvbiA9IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbHRpcCcsICdzdGFuZGFyZF9hc3NvY2lhdGlvbicsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pO1xuICAgICAgICBjb3ZhcmlhdGVzX21vZGVsX2Fzc29jaWF0aW9uLmh0bWwgKz0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMCk7XCIgb25jbGljaz1cIkxvY3VzWm9vbS5nZXRUb29sVGlwUGxvdCh0aGlzKS5Db3ZhcmlhdGVzTW9kZWwuYWRkKExvY3VzWm9vbS5nZXRUb29sVGlwRGF0YSh0aGlzKSk7XCI+Q29uZGl0aW9uIG9uIFZhcmlhbnQ8L2E+PGJyPic7XG4gICAgICAgIHJldHVybiBjb3ZhcmlhdGVzX21vZGVsX2Fzc29jaWF0aW9uO1xuICAgIH0oKTtcblxuICAgIGNvbnN0IGNvdmFyaWF0ZXNfbW9kZWxfcGxvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY292YXJpYXRlc19tb2RlbF9wbG90X3Rvb2xiYXIgPSBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2xiYXInLCAnc3RhbmRhcmRfYXNzb2NpYXRpb24nLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KTtcbiAgICAgICAgY292YXJpYXRlc19tb2RlbF9wbG90X3Rvb2xiYXIud2lkZ2V0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb3ZhcmlhdGVzX21vZGVsJyxcbiAgICAgICAgICAgIGJ1dHRvbl9odG1sOiAnTW9kZWwnLFxuICAgICAgICAgICAgYnV0dG9uX3RpdGxlOiAnU2hvdyBhbmQgZWRpdCBjb3ZhcmlhdGVzIGN1cnJlbnRseSBpbiBtb2RlbCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvdmFyaWF0ZXNfbW9kZWxfcGxvdF90b29sYmFyO1xuICAgIH0oKTtcblxuICAgIExvY3VzWm9vbS5XaWRnZXRzLmFkZCgnY292YXJpYXRlc19tb2RlbCcsIENvdmFyaWF0ZXNNb2RlbCk7XG4gICAgTG9jdXNab29tLldpZGdldHMuYWRkKCdkYXRhX2xheWVycycsIERhdGFMYXllcnNXaWRnZXQpO1xuXG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCd0b29sdGlwJywgJ2NvdmFyaWF0ZXNfbW9kZWxfYXNzb2NpYXRpb24nLCBjb3ZhcmlhdGVzX21vZGVsX3Rvb2x0aXApO1xuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgndG9vbGJhcicsICdjb3ZhcmlhdGVzX21vZGVsX3Bsb3QnLCBjb3ZhcmlhdGVzX21vZGVsX3Bsb3QpO1xufVxuXG5pZiAodHlwZW9mIExvY3VzWm9vbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBBdXRvLXJlZ2lzdGVyIHRoZSBwbHVnaW4gd2hlbiBpbmNsdWRlZCBhcyBhIHNjcmlwdCB0YWcuIEVTNiBtb2R1bGUgdXNlcnMgbXVzdCByZWdpc3RlciB2aWEgTG9jdXNab29tLnVzZSgpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgTG9jdXNab29tLnVzZShpbnN0YWxsKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBpbnN0YWxsO1xuIiwiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1vZGlmeWluZyBvciB3b3JraW5nIHdpdGggbGF5b3V0IG9iamVjdHNcbiAqICBAbW9kdWxlXG4gKi9cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuY29uc3Qgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG4vLyBEMyB2NSBkb2VzIG5vdCBwcm92aWRlIGEgdHJpYW5nbGUgZG93biBzeW1ib2wgc2hhcGUsIGJ1dCBpdCBpcyB2ZXJ5IHVzZWZ1bCBmb3Igc2hvd2luZyBkaXJlY3Rpb24gb2YgZWZmZWN0LlxuLy8gIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL3NyYy9zeW1ib2wvdHJpYW5nbGUuanNcbmNvbnN0IHRyaWFuZ2xlZG93biA9IHtcbiAgICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgY29uc3QgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLXkgKiAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgeSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgeSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfSxcbn07XG5cbi8qKlxuICogQXBwbHkgbmFtZXNwYWNlcyB0byBsYXlvdXQsIHJlY3Vyc2l2ZWx5XG4gKiBAcHJpdmF0ZVxuICAqL1xuZnVuY3Rpb24gYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnQsIG5hbWVzcGFjZSwgZGVmYXVsdF9uYW1lc3BhY2UpIHtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB7IGRlZmF1bHQ6IG5hbWVzcGFjZSB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXNwYWNlID0geyBkZWZhdWx0OiAnJyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmUgPSAvXFx7XFx7bmFtZXNwYWNlKFxcW1tBLVphLXpfMC05XStcXF18KVxcfVxcfS9nO1xuICAgICAgICBsZXQgbWF0Y2gsIGJhc2UsIGtleSwgcmVzb2x2ZWRfbmFtZXNwYWNlO1xuICAgICAgICBjb25zdCByZXBsYWNlID0gW107XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGVsZW1lbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmFzZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAga2V5ID0gbWF0Y2hbMV0ubGVuZ3RoID8gbWF0Y2hbMV0ucmVwbGFjZSgvKFxcW3xcXF0pL2csICcnKSA6IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlZF9uYW1lc3BhY2UgPSBkZWZhdWx0X25hbWVzcGFjZTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT0gbnVsbCAmJiB0eXBlb2YgbmFtZXNwYWNlID09ICdvYmplY3QnICYmIHR5cGVvZiBuYW1lc3BhY2Vba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkX25hbWVzcGFjZSA9IG5hbWVzcGFjZVtrZXldICsgKG5hbWVzcGFjZVtrZXldLmxlbmd0aCA/ICc6JyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2UucHVzaCh7IGJhc2U6IGJhc2UsIG5hbWVzcGFjZTogcmVzb2x2ZWRfbmFtZXNwYWNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHIgaW4gcmVwbGFjZSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZShyZXBsYWNlW3JdLmJhc2UsIHJlcGxhY2Vbcl0ubmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlX25hbWVzcGFjZSA9ICh0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2UgPT0gJ3N0cmluZycpID8geyBkZWZhdWx0OiBlbGVtZW50Lm5hbWVzcGFjZSB9IDogZWxlbWVudC5uYW1lc3BhY2U7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBtZXJnZShuYW1lc3BhY2UsIG1lcmdlX25hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWVzcGFjZWRfZWxlbWVudCwgbmFtZXNwYWNlZF9wcm9wZXJ0eTtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnbmFtZXNwYWNlJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZXNwYWNlZF9lbGVtZW50ID0gYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnRbcHJvcGVydHldLCBuYW1lc3BhY2UsIGRlZmF1bHRfbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZWRfcHJvcGVydHkgPSBhcHBseU5hbWVzcGFjZXMocHJvcGVydHksIG5hbWVzcGFjZSwgZGVmYXVsdF9uYW1lc3BhY2UpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSBuYW1lc3BhY2VkX3Byb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudFtuYW1lc3BhY2VkX3Byb3BlcnR5XSA9IG5hbWVzcGFjZWRfZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBtZXRob2QgdXNlZCBmb3IgbWVyZ2luZyB0d28gb2JqZWN0cy4gSWYgYSBrZXkgaXMgcHJlc2VudCBpbiBib3RoLCB0YWtlcyB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3Qgb2JqZWN0XG4gKiAgIFZhbHVlcyBmcm9tIGBkZWZhdWx0X2xheW91dGAgd2lsbCBiZSBjbGVhbmx5IGNvcGllZCBvdmVyLCBlbnN1cmluZyBubyByZWZlcmVuY2VzIG9yIHNoYXJlZCBzdGF0ZS5cbiAqXG4gKiBGcmVxdWVudGx5IHVzZWQgZm9yIHByZXBhcmluZyBjdXN0b20gbGF5b3V0cy4gQm90aCBvYmplY3RzIHNob3VsZCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tX2xheW91dCBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdGhhdCBvdmVycmlkZSBvciBhZGQgdG8gZGVmYXVsdHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0X2xheW91dCBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHNldHRpbmdzLlxuICogQHJldHVybnMge29iamVjdH0gVGhlIGN1c3RvbSBsYXlvdXQgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIGFsc28gcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2UoY3VzdG9tX2xheW91dCwgZGVmYXVsdF9sYXlvdXQpIHtcbiAgICBpZiAodHlwZW9mIGN1c3RvbV9sYXlvdXQgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBkZWZhdWx0X2xheW91dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2N1c1pvb20uTGF5b3V0cy5tZXJnZSBvbmx5IGFjY2VwdHMgdHdvIGxheW91dCBvYmplY3RzOyAke3R5cGVvZiBjdXN0b21fbGF5b3V0fSwgJHt0eXBlb2YgZGVmYXVsdF9sYXlvdXR9IGdpdmVuYCk7XG4gICAgfVxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIGRlZmF1bHRfbGF5b3V0KSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRfbGF5b3V0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0eXBlcyBmb3IgY29tcGFyaXNvbi4gVHJlYXQgbnVsbHMgaW4gdGhlIGN1c3RvbSBsYXlvdXQgYXMgdW5kZWZpbmVkIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAvLyAoamF2YXNjcmlwdCB0cmVhdHMgbnVsbHMgYXMgXCJvYmplY3RcIiB3aGVuIHdlIGp1c3Qgd2FudCB0byBvdmVyd3JpdGUgdGhlbSBhcyBpZiB0aGV5J3JlIHVuZGVmaW5lZClcbiAgICAgICAgLy8gQWxzbyBzZXBhcmF0ZSBhcnJheXMgZnJvbSBvYmplY3RzIGFzIGEgZGlzY3JldGUgdHlwZS5cbiAgICAgICAgbGV0IGN1c3RvbV90eXBlID0gY3VzdG9tX2xheW91dFtwcm9wZXJ0eV0gPT09IG51bGwgPyAndW5kZWZpbmVkJyA6IHR5cGVvZiBjdXN0b21fbGF5b3V0W3Byb3BlcnR5XTtcbiAgICAgICAgbGV0IGRlZmF1bHRfdHlwZSA9IHR5cGVvZiBkZWZhdWx0X2xheW91dFtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChjdXN0b21fdHlwZSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShjdXN0b21fbGF5b3V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGN1c3RvbV90eXBlID0gJ2FycmF5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdF90eXBlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KGRlZmF1bHRfbGF5b3V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdHlwZSA9ICdhcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5zdXBwb3J0ZWQgcHJvcGVydHkgdHlwZXM6IHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgICBpZiAoY3VzdG9tX3R5cGUgPT09ICdmdW5jdGlvbicgfHwgZGVmYXVsdF90eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY3VzWm9vbS5MYXlvdXRzLm1lcmdlIGVuY291bnRlcmVkIGFuIHVuc3VwcG9ydGVkIHByb3BlcnR5IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmRlZmluZWQgY3VzdG9tIHZhbHVlOiBwdWxsIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIChjdXN0b21fdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGN1c3RvbV9sYXlvdXRbcHJvcGVydHldID0gZGVlcENvcHkoZGVmYXVsdF9sYXlvdXRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdGggdmFsdWVzIGFyZSBvYmplY3RzOiBtZXJnZSByZWN1cnNpdmVseVxuICAgICAgICBpZiAoY3VzdG9tX3R5cGUgPT09ICdvYmplY3QnICYmIGRlZmF1bHRfdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGN1c3RvbV9sYXlvdXRbcHJvcGVydHldID0gbWVyZ2UoY3VzdG9tX2xheW91dFtwcm9wZXJ0eV0sIGRlZmF1bHRfbGF5b3V0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VzdG9tX2xheW91dDtcbn1cblxuZnVuY3Rpb24gZGVlcENvcHkoaXRlbSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG5hbWUgdG8gc3ltYm9sXG4gKiBMYXlvdXQgb2JqZWN0cyBhY2NlcHQgc3ltYm9sIG5hbWVzIGFzIHN0cmluZ3MgKGNpcmNsZSwgdHJpYW5nbGUsIGV0YykuIENvbnZlcnQgdG8gc3ltYm9sIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gQW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyBhIGRyYXcgbWV0aG9kIChlZyBkMy1zaGFwZSBzeW1ib2xzIG9yIGV4dHJhIExaIGl0ZW1zKVxuICovXG5mdW5jdGlvbiBuYW1lVG9TeW1ib2woc2hhcGUpIHtcbiAgICBpZiAoIXNoYXBlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZWRvd24nKSB7XG4gICAgICAgIC8vIEQzIGRvZXMgbm90IHByb3ZpZGUgdGhpcyBzeW1ib2wgbmF0aXZlbHlcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlZG93bjtcbiAgICB9XG4gICAgLy8gTGVnZW5kIHNoYXBlIG5hbWVzIGFyZSBzdHJpbmdzOyBuZWVkIHRvIGNvbm5lY3QgdGhpcyB0byBmYWN0b3J5LiBFZyBjaXJjbGUgLS0+IGQzLnN5bWJvbENpcmNsZVxuICAgIGNvbnN0IGZhY3RvcnlfbmFtZSA9IGBzeW1ib2wke3NoYXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2hhcGUuc2xpY2UoMSl9YDtcbiAgICByZXR1cm4gZDNbZmFjdG9yeV9uYW1lXSB8fCBudWxsO1xufVxuXG5leHBvcnQgeyBhcHBseU5hbWVzcGFjZXMsIGRlZXBDb3B5LCBtZXJnZSwgbmFtZVRvU3ltYm9sIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGQzOyJdLCJzb3VyY2VSb290IjoiIn0=