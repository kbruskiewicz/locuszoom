{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/external \"d3\"","webpack://[name]/./esm/ext/lz-intervals-track.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","d3","install","LocusZoom","BaseApiAdapter","Adapters","_Button","Widgets","_BaseWidget","IntervalLZ","state","chain","fields","source","header","bedtracksource","this","params","query","chr","end","start","url","ToggleSplitTracks","layout","arguments","data_layer_id","parent_panel","data_layers","Error","data_layer","html","split_tracks","button","setHtml","show","parent","position","setColor","color","setTitle","setOnclick","toggleSplitTracks","scale_timeout","clearTimeout","setTimeout","scaleHeightToData","parent_plot","positionPanels","update","default_layout","start_field","end_field","track_label_field","track_split_field","track_split_order","track_split_legend_to_y_axis","track_height","track_vertical_spacing","bounding_box_padding","always_hide_legend","fill_opacity","tooltip_positioning","LzIntervalsTrack","Layouts","merge","tracks","previous_tracks","interval_track_index","1","element","getBaseId","replace","getElementId","self","base_layout","_base_layout","render_layout","base_color_scale","find","item","scale_function","color_scale","has_colors","parameters","categories","length","values","has_legend","legend","rgb_option","rgb_field","field","known_categories","_generateCategoriesFromData","data","colors","_makeColorScheme","map","pair","index","id","shape","width","label","_applyLayoutOptions","track_split_field_index","forEach","keys","reverse","val","display_range","x_scale","Math","max","min","display_domain","invert","track","push","potential_track","collision_on_potential_track","placed_interval","min_start","assignTracks","track_data","_applyFilters","svg","group","selectAll","remove","pseudoElement","insert","attr","getElementStatusNodeId","cliparea","getTrackHeight","style","selection","id_field","enter","append","each","interval","statusnodes","exit","rects","resolveScalableParameter","clickareas","interval_name","on","element_data","emit","applyBehaviors","updateSplitTrackAxis","render","tooltip","interval_bbox","node","getBBox","x_min","x_max","y_min","y","y_max","height","legend_axis","track_spacing","target_height","hide","axes","ticks","range","abs","text","y_axis","axis","floor","ceiling","margin","bottom","min_height","min_width","category_info","n_categories","unique_ids","DataLayers","intervals_tooltip_layout","namespace","closable","or","and","intervals_layer_layout","type","null_value","behaviors","onmouseover","action","status","onmouseout","onclick","exclusive","onshiftclick","intervals_panel_layout","top","right","left","toolbar","unnamespaced","widgets","interaction","drag_background_to_pan","scroll_to_zoom","x_linked","hidden","orientation","origin","x","pad_from_bottom","intervals_plot_layout","responsive_resize","min_region_scale","max_region_scale","panels","proportional_height","assign","add","ScaleFunctions","use"],"mappings":";iCACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,kBClFrDhC,EAAOD,QAAUkC,I,qnDCajB,SAASC,EAASC,GACd,IAAMC,EAAiBD,EAAUE,SAASvB,IAAI,kBACxCwB,EAAUH,EAAUI,QAAQzB,IAAI,WAChC0B,EAAcL,EAAUI,QAAQzB,IAAI,cAMpC2B,EATmB,6HAUdC,EAAOC,EAAOC,GACjB,IAAMC,EAASF,EAAMG,OAAOC,gBAAkBC,KAAKC,OAAOJ,OACpDK,EAAQ,iBAAH,OAAoBL,EAApB,+BAAiDH,EAAMS,IAAvD,0BAA4ET,EAAMU,IAAlF,uBAAoGV,EAAMW,OACrH,gBAAUL,KAAKM,KAAf,OAAqBJ,OAbJ,GASAd,GAWnBmB,EApBmB,8BAqBrB,WAAYC,GAAQ,MAKhB,GALgB,UAChB,eAASC,WACJD,EAAOE,gBACRF,EAAOE,cAAgB,cAEtB,EAAKC,aAAaC,YAAYJ,EAAOE,eACtC,MAAM,IAAIG,MAAM,iEANJ,SArBC,2CA+BZ,WACCC,EAAad,KAAKW,aAAaC,YAAYZ,KAAKQ,OAAOE,eACvDK,EAAOD,EAAWN,OAAOQ,aAAe,eAAiB,eAC/D,OAAIhB,KAAKiB,QACLjB,KAAKiB,OAAOC,QAAQH,GACpBf,KAAKiB,OAAOE,OACZnB,KAAKoB,OAAOC,WACLrB,OAEPA,KAAKiB,OAAS,IAAI3B,EAAQU,MACrBsB,SAAStB,KAAKQ,OAAOe,OACrBL,QAAQH,GACRS,SAAS,4DACTC,YAAW,WACRX,EAAWY,oBACP,EAAKC,eACLC,aAAa,EAAKD,eAEtB,EAAKA,cAAgBE,YAAW,WAC5B,EAAKlB,aAAamB,oBAClB,EAAKC,YAAYC,mBAClB,GACH,EAAKC,YAENjC,KAAKiC,cAvDC,GAoBOzC,GAoDhC,IAqiBctC,EAriBRgF,EAAiB,CACnBC,YAAa,QACbC,UAAW,MACXC,kBAAmB,aAKnBC,kBAAmB,WACnBC,kBAAmB,OACnBC,6BAA8B,EAC9BxB,cAAc,EACdyB,aAAc,GACdC,uBAAwB,EACxBC,qBAAsB,EACtBC,oBAAoB,EACpBrB,MAAO,UACPsB,aAAc,EACdC,oBAAqB,YASnBC,EAnGmB,8BAoGrB,WAAYvC,GAAQ,uBAChBrB,EAAU6D,QAAQC,MAAMzC,EAAQ0B,IAChC,eAASzB,YACJyC,OAAS,EACd,EAAKC,gBAAkB,EAGvB,EAAKC,qBAAuB,CAAEC,EAAG,IAPjB,EApGC,yDAoHEC,GACnB,OAAItD,KAAKQ,OAAOQ,aACL,UAAIhB,KAAKuD,YAAT,uBAAmCD,EAAQtD,KAAKQ,OAAO8B,oBAAsBkB,QAAQ,SAAU,KAE1G,UAAUxD,KAAKyD,aAAaH,GAA5B,iBAxHiB,uCA6HjB,OAAOtD,KAAKQ,OAAOiC,aACbzC,KAAKQ,OAAOkC,uBACX,EAAI1C,KAAKQ,OAAOmC,uBA/HN,4CAqIjB,IAAMe,EAAO1D,KACP2D,EAAc3D,KAAK4D,aACnBC,EAAgB7D,KAAKQ,OACrBsD,EAAmBH,EAAYpC,MAAMwC,MAAK,SAAUC,GACtD,OAAOA,EAAKC,gBAA0C,oBAAxBD,EAAKC,kBAEjCC,EAAcL,EAActC,MAAMwC,MAAK,SAAUC,GACnD,OAAOA,EAAKC,gBAA0C,oBAAxBD,EAAKC,kBAEvC,IAAKH,EAED,MAAM,IAAIjD,MAAM,+DAGpB,IAAMsD,EAAaL,EAAiBM,WAAWC,WAAWC,QAAUR,EAAiBM,WAAWG,OAAOD,OACjGE,EAAab,EAAYc,QAAUd,EAAYc,OAAOH,OAE5D,KAAMH,IAAeK,EAEjB,MAAM,IAAI3D,MAAM,wFAIpB,IAAM6D,EAAaf,EAAYpC,MAAMwC,MAAK,SAAUC,GAChD,OAAOA,EAAKC,gBAA0C,WAAxBD,EAAKC,kBAEjCU,EAAYD,GAAcA,EAAWE,MAGrCC,EAAmB7E,KAAK8E,4BAA4B9E,KAAK+E,KAAMJ,GAErE,IAAKR,IAAeK,EAAY,CAI5B,IAAMQ,EAAShF,KAAKiF,iBAAiBJ,GACrCX,EAAYE,WAAWC,WAAaQ,EAAiBK,KAAI,SAAUlB,GAC/D,OAAOA,EAAK,MAEhBE,EAAYE,WAAWG,OAASS,EAEhChF,KAAKQ,OAAOiE,OAASI,EAAiBK,KAAI,SAAUC,EAAMC,GACtD,IAAMC,EAAKF,EAAK,GAGVnB,EAAO,CAAEsB,MAAO,OAAQC,MAAO,EAAGC,MAF1BL,EAAK,GAEmC5D,MADnC2C,EAAYE,WAAWG,OAAOa,IAGjD,OADApB,EAAKN,EAAKlD,OAAO8B,mBAAqB+C,EAC/BrB,QApLE,qCA2LN,WAcX,GAZAhE,KAAKyF,sBAGLzF,KAAKmD,gBAAkBnD,KAAKkD,OAC5BlD,KAAKkD,OAAS,EACdlD,KAAKoD,qBAAuB,CAAEC,EAAG,IAEjCrD,KAAK0F,wBAA0B,GAK3B1F,KAAKQ,OAAO8B,mBAAqBtC,KAAKQ,OAAOQ,aAAc,CAC3DhB,KAAK+E,KAAKY,SAAQ,SAACpI,GACf,EAAKmI,wBAAwBnI,EAAE,EAAKiD,OAAO8B,oBAAsB,QAErE,IAAM8C,EAAQzH,OAAOiI,KAAK5F,KAAK0F,yBACO,SAAlC1F,KAAKQ,OAAO+B,mBACZ6C,EAAMS,UAEVT,EAAMO,SAAQ,SAACG,GACX,EAAKJ,wBAAwBI,GAAO,EAAK5C,OAAS,EAClD,EAAKE,qBAAqB,EAAKF,OAAS,GAAK,GAC7C,EAAKA,YAkEb,OA9DAlD,KAAK+E,KAAKY,QAAQ,SAASpI,EAAGN,GAAG,WAwB7B,GArBA+C,KAAK+E,KAAK9H,GAAGmE,OAASpB,KAItBA,KAAK+E,KAAK9H,GAAG8I,cAAgB,CACzB1F,MAAOL,KAAKoB,OAAO4E,QAAQC,KAAKC,IAAI3I,EAAEyC,KAAKQ,OAAO2B,aAAcnC,KAAKN,MAAMW,QAC3ED,IAAOJ,KAAKoB,OAAO4E,QAAQC,KAAKE,IAAI5I,EAAEyC,KAAKQ,OAAO4B,WAAYpC,KAAKN,MAAMU,OAE7EJ,KAAK+E,KAAK9H,GAAG8I,cAAcR,MAAQvF,KAAK+E,KAAK9H,GAAG8I,cAAc3F,IAAMJ,KAAK+E,KAAK9H,GAAG8I,cAAc1F,MAI/FL,KAAK+E,KAAK9H,GAAGmJ,eAAiB,CAC1B/F,MAAOL,KAAKoB,OAAO4E,QAAQK,OAAOrG,KAAK+E,KAAK9H,GAAG8I,cAAc1F,OAC7DD,IAAOJ,KAAKoB,OAAO4E,QAAQK,OAAOrG,KAAK+E,KAAK9H,GAAG8I,cAAc3F,MAEjEJ,KAAK+E,KAAK9H,GAAGmJ,eAAeb,MAAQvF,KAAK+E,KAAK9H,GAAGmJ,eAAehG,IAAMJ,KAAK+E,KAAK9H,GAAGmJ,eAAe/F,MAK9FL,KAAKQ,OAAO8B,mBAAqBtC,KAAKQ,OAAOQ,aAAc,CAC3D,IAAM8E,EAAM9F,KAAK+E,KAAK9H,GAAG+C,KAAKQ,OAAO8B,mBACrCtC,KAAK+E,KAAK9H,GAAGqJ,MAAQtG,KAAK0F,wBAAwBI,GAClD9F,KAAKoD,qBAAqBpD,KAAK+E,KAAK9H,GAAGqJ,OAAOC,KAAKtJ,OAChD,CAIH+C,KAAKkD,OAAS,EACdlD,KAAK+E,KAAK9H,GAAGqJ,MAAQ,KAErB,IADA,IAAIE,EAAkB,EANnB,aAQC,IAAIC,GAA+B,EACnC,EAAKrD,qBAAqBoD,GAAiBtB,IAAI,SAASwB,GACpD,IAAKD,EAA8B,CAC/B,IAAME,EAAYV,KAAKE,IAAIO,EAAgBX,cAAc1F,MAAOL,KAAK+F,cAAc1F,OACnE4F,KAAKC,IAAIQ,EAAgBX,cAAc3F,IAAKJ,KAAK+F,cAAc3F,KAChEuG,EAAcD,EAAgBX,cAAcR,MAAQvF,KAAK+F,cAAcR,QAClFkB,GAA+B,KAGzChI,KAAK,EAAKsG,KAAK9H,KACZwJ,IAIDD,EACsB,EAAKtD,SACvB,EAAKA,OAASsD,EACd,EAAKpD,qBAAqBoD,GAAmB,KANjD,EAAKzB,KAAK9H,GAAGqJ,MAAQE,EACrB,EAAKpD,qBAAqBoD,GAAiBD,KAAK,EAAKxB,KAAK9H,MAbpC,OAAvB+C,KAAK+E,KAAK9H,GAAGqJ,OAAgB,MAyB1C7H,KAAKuB,OAEAA,OAtRU,+BA0RZ,WAELA,KAAK4G,eAGL,IAAMC,EAAa7G,KAAK8G,gBAKxB9G,KAAK+G,IAAIC,MAAMC,UAAU,sEAAsEC,SAC/FvJ,OAAOiI,KAAK5F,KAAK0F,yBAAyBC,SAAQ,SAACnH,GAE/C,IAAM2I,EAAgB,GACtBA,EAAc,EAAK3G,OAAO8B,mBAAqB9D,EAE/C,EAAKuI,IAAIC,MAAMI,OAAO,OAAQ,gBACzBC,KAAK,KAAM,EAAKC,uBAAuBH,IACvCE,KAAK,QAAS,6FACdA,KAAK,KAAM,EAAK7G,OAAOmC,sBACvB0E,KAAK,KAAM,EAAK7G,OAAOmC,sBACvB0E,KAAK,QAAS,EAAKjG,OAAOZ,OAAO+G,SAAShC,OAC1C8B,KAAK,SAAU,EAAKG,iBAAmB,EAAKhH,OAAOkC,wBACnD2E,KAAK,IAAK,GACVA,KAAK,KAAM,EAAK3B,wBAAwBlH,GAAO,GAAK,EAAKgJ,kBACzDC,MAAM,UAAY,EAAKjH,OAAOQ,aAAe,KAAO,WAI7D,IAAM0G,EAAY1H,KAAK+G,IAAIC,MAAMC,UAAU,6BACtClC,KAAK8B,GAAY,SAACtJ,GACf,OAAOA,EAAE,EAAKiD,OAAOmH,aA0F7B,OAvFAD,EAAUE,QACLC,OAAO,KACPR,KAAK,QAAS,2BACdpE,MAAMyE,GACNL,KAAK,MAAM,SAAC9J,GAAD,OAAO,EAAKkG,aAAalG,MACpCuK,MAAK,SAASC,GACX,IAAMjH,EAAaiH,EAAS3G,OAGtB4G,EAAc/I,SAAUe,MAAMiH,UAAU,+GACzClC,KAAK,CAACgD,IAAW,SAACxK,GAAD,gBAAUuD,EAAW2C,aAAalG,GAAlC,kBACtByK,EAAYJ,QACPR,OAAO,OAAQ,gBACfC,KAAK,QAAS,0GACdpE,MAAM+E,GACNX,KAAK,MAAM,SAAC9J,GAAD,gBAAUuD,EAAW2C,aAAalG,GAAlC,kBACX8J,KAAK,KAAMvG,EAAWN,OAAOmC,sBAC7B0E,KAAK,KAAMvG,EAAWN,OAAOmC,sBAC7B8E,MAAM,UAAW3G,EAAWN,OAAOQ,aAAe,OAAS,MAC3DqG,KAAK,SAAS,SAAC9J,GAAD,OAAOA,EAAEwI,cAAcR,MAAS,EAAIzE,EAAWN,OAAOmC,wBACpE0E,KAAK,SAAUvG,EAAW0G,iBAAmB1G,EAAWN,OAAOkC,wBAC/D2E,KAAK,KAAK,SAAC9J,GAAD,OAAOA,EAAEwI,cAAc1F,MAAQS,EAAWN,OAAOmC,wBAC3D0E,KAAK,KAAK,SAAC9J,GAAD,OAASA,EAAE+I,MAAQ,GAAKxF,EAAW0G,oBAElDQ,EAAYC,OACPf,SAGL,IAAMgB,EAAQjJ,SAAUe,MAAMiH,UAAU,iDACnClC,KAAK,CAACgD,IAAW,SAACxK,GAAD,gBAAUA,EAAEuD,EAAWN,OAAOmH,UAA9B,qBAEtBO,EAAMN,QACDC,OAAO,QACPR,KAAK,QAAS,4CACdpE,MAAMiF,GACNb,KAAK,SAAS,SAAC9J,GAAD,OAAOA,EAAEwI,cAAcR,SACrC8B,KAAK,SAAUvG,EAAWN,OAAOiC,cACjC4E,KAAK,KAAK,SAAC9J,GAAD,OAAOA,EAAEwI,cAAc1F,SACjCgH,KAAK,KAAK,SAAC9J,GAAD,OAASA,EAAE+I,MAAQ,GAAKxF,EAAW0G,iBAAoB1G,EAAWN,OAAOmC,wBACnF0E,KAAK,QAAQ,SAAC9J,EAAGN,GAAJ,OAAU6D,EAAWqH,yBAAyBrH,EAAWN,OAAOe,MAAOhE,EAAGN,MACvFoK,KAAK,gBAAgB,SAAC9J,EAAGN,GAAJ,OAAU6D,EAAWqH,yBAAyBrH,EAAWN,OAAOqC,aAActF,EAAGN,MAE3GiL,EAAMD,OACDf,SAGL,IAAMkB,EAAanJ,SAAUe,MAAMiH,UAAU,6CACxClC,KAAK,CAACgD,IAAW,SAACxK,GAAD,gBAAUA,EAAE8K,cAAZ,iBAEtBD,EAAWR,QACNC,OAAO,QACPR,KAAK,QAAS,wCACdpE,MAAMmF,GACNf,KAAK,MAAM,SAAC9J,GAAD,gBAAUuD,EAAW2C,aAAalG,GAAlC,iBACX8J,KAAK,KAAMvG,EAAWN,OAAOmC,sBAC7B0E,KAAK,KAAMvG,EAAWN,OAAOmC,sBAC7B0E,KAAK,SAAS,SAAC9J,GAAD,OAAOA,EAAEwI,cAAcR,SACrC8B,KAAK,SAAUvG,EAAW0G,iBAAmB1G,EAAWN,OAAOkC,wBAC/D2E,KAAK,KAAK,SAAC9J,GAAD,OAAOA,EAAEwI,cAAc1F,SACjCgH,KAAK,KAAK,SAAC9J,GAAD,OAASA,EAAE+I,MAAQ,GAAKxF,EAAW0G,oBAE7Cc,GAAG,SAAS,SAACC,GACVA,EAAanH,OAAOA,OAAOoH,KAAK,kBAAmBD,GAAc,MAGpEnL,KAAK0D,EAAW2H,eAAehK,KAAKqC,IAGzCsH,EAAWH,OACNf,YAIbQ,EAAUO,OACLf,SAGDlH,KAAKmD,kBAAoBnD,KAAKkD,QAC9BlD,KAAK0I,uBAKL1I,KAAKoB,QAAUpB,KAAKoB,OAAOqD,QAC3BzE,KAAKoB,OAAOqD,OAAOkE,SAGhB3I,OAnZU,0CAsZD4I,GAChB,IAAMC,EAAgB5J,SAAA,WAAce,KAAKsH,uBAAuBsB,EAAQ7D,QAAS+D,OAAOC,UACxF,MAAO,CACHC,MAAOJ,EAAQ7D,KAAKgB,cAAc1F,MAClC4I,MAAOL,EAAQ7D,KAAKgB,cAAc3F,IAClC8I,MAAOL,EAAcM,EACrBC,MAAOP,EAAcM,EAAIN,EAAcQ,UA5Z1B,6CAkaE,WACbC,IAActJ,KAAKQ,OAAOgC,8BAAZ,WAA+CxC,KAAKQ,OAAOgC,8BAC/E,GAAIxC,KAAKQ,OAAOQ,aAAc,CAC1B,IAAMkC,GAAUlD,KAAKkD,QAAU,EACzBT,GAAgBzC,KAAKQ,OAAOiC,cAAgB,EAC5C8G,EAAgB,IAAMvJ,KAAKQ,OAAOmC,sBAAwB,KAAO3C,KAAKQ,OAAOkC,wBAA0B,GACvG8G,EAAiBtG,EAAST,GAAkBS,EAAS,GAAKqG,EAChEvJ,KAAKoB,OAAOU,kBAAkB0H,GAC1BF,GAAetJ,KAAKoB,OAAOqD,SAC3BzE,KAAKoB,OAAOqD,OAAOgF,OACnBzJ,KAAKoB,OAAOZ,OAAOkJ,KAAKJ,GAAe,CACnCX,QAAQ,EACRgB,MAAO,GACPC,MAAO,CACHvJ,MAAQmJ,EAAiBxJ,KAAKQ,OAAOiC,aAAe,EACpDrC,IAAMJ,KAAKQ,OAAOiC,aAAe,IAMzCzC,KAAKQ,OAAOiE,OAAOkB,SAAQ,SAACrC,GACxB,IAAM9E,EAAM8E,EAAQ,EAAK9C,OAAO8B,mBAC5BgE,EAAQ,EAAKZ,wBAAwBlH,GACrC8H,IACsC,SAAlC,EAAK9F,OAAO+B,oBACZ+D,EAAQL,KAAK4D,IAAIvD,EAAQpD,EAAS,IAEtC,EAAK9B,OAAOZ,OAAOkJ,KAAKJ,GAAaK,MAAMpD,KAAK,CAC5C4C,EAAG7C,EACHwD,KAAMxG,EAAQkC,YAI1BxF,KAAKQ,OAAOuJ,OAAS,CACjBC,KAAMhK,KAAKQ,OAAOgC,6BAClByH,MAAO,EACPC,QAAShH,GAEblD,KAAKoB,OAAOuH,UAEhB3I,KAAK+B,YAAYC,sBAEbsH,GAAetJ,KAAKoB,OAAOqD,SACtBzE,KAAKQ,OAAOoC,oBACb5C,KAAKoB,OAAOqD,OAAOtD,OAEvBnB,KAAKoB,OAAOZ,OAAOkJ,KAAKJ,GAAe,CAAEX,QAAQ,GACjD3I,KAAKoB,OAAOuH,UAGpB,OAAO3I,OArdU,0CAifjB,OApBAA,KAAKQ,OAAOQ,cAAgBhB,KAAKQ,OAAOQ,aAEpChB,KAAKoB,OAAOqD,SAAWzE,KAAKQ,OAAOoC,qBACnC5C,KAAKoB,OAAOZ,OAAO2J,OAAOC,OAAS,GAAKpK,KAAKQ,OAAOQ,aAAe,EAAIhB,KAAKoB,OAAOqD,OAAOjE,OAAO6I,OAAS,IAIzGrJ,KAAKQ,OAAOQ,eAEbhB,KAAKoB,OAAOiJ,WAAa,EACzBrK,KAAKoB,OAAOkJ,UAAY,GAM5BtK,KAAK2I,SAEL3I,KAAK0I,uBAEE1I,OAjfU,uCAwfJuK,GAGb,GAD4BA,EAAcxG,MAAK,SAACC,GAAD,OAAUA,EAAK,MAE1D,OAAOuG,EAAcrF,KAAI,SAAClB,GAAD,OAAUA,EAAK,MAO5C,IAAMwG,EAAeD,EAAcjG,OACnC,OAAIkG,GAAgB,GACT,CAAC,mBAAoB,mBAAoB,mBAAoB,mBAAoB,mBAAoB,iBAAkB,mBAAoB,mBAAoB,iBAAkB,iBAAkB,eAAgB,eAAgB,iBAAkB,gBAAiB,gBACtQA,GAAgB,GAChB,CAAC,mBAAoB,mBAAoB,mBAAoB,mBAAoB,iBAAkB,mBAAoB,mBAAoB,iBAAkB,kBAAmB,kBAAmB,iBAAkB,iBAAkB,eAAgB,eAAgB,gBAAiB,gBAAiB,gBAAiB,gBAG1T,CAAC,mBAAoB,mBAAoB,kBAAmB,mBAAoB,mBAAoB,mBAAoB,mBAAoB,iBAAkB,iBAAkB,iBAAkB,kBAAmB,kBAAmB,kBAAmB,iBAAkB,iBAAkB,iBAAkB,iBAAkB,eAAgB,eAAgB,eAAgB,eAAgB,gBAAiB,gBAAiB,gBAAiB,kBA1gBhb,kDAshBOzF,EAAMJ,GAAW,WACnCjB,EAAO1D,KAEPyE,EAASzE,KAAK4D,aAAaa,OACjC,GAAIA,GAAUA,EAAOH,OACjB,OAAOG,EAAOS,KAAI,SAAClB,GAAD,MAAU,CAACA,EAAK,EAAKxD,OAAO8B,mBAAoB0B,EAAKwB,MAAOxB,EAAKzC,UAIvF,IAAMkJ,EAAa,GACbpG,EAAa,GAUnB,OARAU,EAAKY,SAAQ,SAAC3B,GACV,IAAMqB,EAAKrB,EAAKN,EAAKlD,OAAO8B,mBACvB3E,OAAOkB,UAAUC,eAAe1B,KAAKqN,EAAYpF,KAClDoF,EAAWpF,GAAM,KAEjBhB,EAAWkC,KAAK,CAAClB,EAAIrB,EAAK,EAAKxD,OAAO6B,mBAAoB2B,EAAKW,SAGhEN,MA1iBU,GAkGPlF,EAAUuL,WAAW5M,IAAI,kBA4crC6M,EAA2B,CAC7BC,UAAW,CAAE,UAAa,aAC1BC,UAAU,EACV1J,KAAM,CAAE2J,GAAI,CAAC,cAAe,aAC5BrB,KAAM,CAAEsB,IAAK,CAAC,gBAAiB,eAC/BhK,KAAM,gJAGJiK,EAA0B,CAC5BJ,UAAW,CAAE,UAAa,aAC1BvF,GAAI,YACJ4F,KAAM,YACNrL,OAAQ,CAAC,gCAAiC,8BAA+B,mCAAoC,qCAAsC,mCACnJ+H,SAAU,gCACVxF,YAAa,gCACbC,UAAW,8BACXE,kBAAmB,qCACnBD,kBAAmB,qCACnBrB,cAAc,EACd4B,oBAAoB,EACpBrB,MAAO,CACH,CAEIqD,MAAO,kCACPX,eAAgB,UAEpB,CACIW,MAAO,qCACPX,eAAgB,kBAChBG,WAAY,CAERC,WAAY,GACZE,OAAQ,GACR2G,WAAY,aAIxBzG,OAAQ,GACR0G,UAAW,CACPC,YAAa,CACT,CAAEC,OAAQ,MAAOC,OAAQ,gBAE7BC,WAAY,CACR,CAAEF,OAAQ,QAASC,OAAQ,gBAE/BE,QAAS,CACL,CAAEH,OAAQ,SAAUC,OAAQ,WAAYG,WAAW,IAEvDC,aAAc,CACV,CAAEL,OAAQ,SAAUC,OAAQ,cAGpC1C,QAAS+B,GAGPgB,EAAyB,CAC3BtG,GAAI,YACJE,MAAO,IACP8D,OAAQ,GACRiB,UAAW,IACXD,WAAY,GACZF,OAAQ,CAAEyB,IAAK,GAAIC,MAAO,IAAKzB,OAAQ,EAAG0B,KAAM,IAChDC,SACU7O,EAAIiC,EAAU6D,QAAQlF,IAAI,UAAW,iBAAkB,CAAEkO,cAAc,IAC7E9O,EAAE+O,QAAQ1F,KAAK,CACX0E,KAAM,sBACNvK,cAAe,YACfW,SAAU,UAEPnE,GAEXwM,KAAM,GACNwC,YAAa,CACTC,wBAAwB,EACxBC,gBAAgB,EAChBC,UAAU,GAEd5H,OAAQ,CACJ6H,QAAQ,EACRC,YAAa,aACbC,OAAQ,CAAEC,EAAG,GAAItD,EAAG,GACpBuD,gBAAiB,GAErB9L,YAAa,CAACoK,IAGZ2B,EAAwB,CAC1BjN,MAAO,GACP6F,MAAO,IACP8D,OAAQ,IACRuD,mBAAmB,EACnBC,iBAAkB,IAClBC,iBAAkB,IAClBf,QAAS5M,EAAU6D,QAAQlF,IAAI,UAAW,uBAAwB,CAAEkO,cAAc,IAClFe,OAAQ,CACJ5N,EAAU6D,QAAQlF,IAAI,QAAS,cAAe,CAC1CkO,cAAc,EACdzG,MAAO,IACPyH,oBAAsB,IAAM,MAEhCrP,OAAOsP,OACH,CAAEjB,cAAc,EAAMgB,oBAAsB,IAAM,KAClDrB,GAEJxM,EAAU6D,QAAQlF,IAAI,QAAS,QAAS,CAAEkO,cAAc,EAAMzG,MAAO,IAAKyH,oBAAsB,IAAM,QAI9G7N,EAAUE,SAAS6N,IAAI,aAAczN,GACrCN,EAAUuL,WAAWwC,IAAI,YAAanK,GAEtC5D,EAAU6D,QAAQkK,IAAI,UAAW,qBAAsBvC,GACvDxL,EAAU6D,QAAQkK,IAAI,aAAc,YAAalC,GACjD7L,EAAU6D,QAAQkK,IAAI,QAAS,YAAavB,GAC5CxM,EAAU6D,QAAQkK,IAAI,OAAQ,uBAAwBP,GAEtDxN,EAAUgO,eAAeD,IAAI,UA9lB7B,SAAgB9I,EAAYlG,GACxB,OAAOA,EAAQ,OAAH,OAAUA,EAAV,KAAqB,QA+lBrCiB,EAAUI,QAAQ2N,IAAI,sBAAuB3M,GAGxB,oBAAdpB,WAGPA,UAAUiO,IAAIlO,GAIHA,e","file":"ext/lz-intervals-track.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = d3;","/**\nInterval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.\nThis is not part of the core LocusZoom library, but can be included as a standalone file.\n\nThe page must incorporate and load all libraries before this file can be used, including:\n - Vendor assets\n - LocusZoom\n @module\n*/\n\nimport * as d3 from 'd3';\n\n\nfunction install (LocusZoom) {\n    const BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');\n    const _Button = LocusZoom.Widgets.get('_Button');\n    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');\n\n    /**\n     * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n     * @public\n     */\n    class IntervalLZ extends BaseApiAdapter {\n        getURL(state, chain, fields) {\n            const source = chain.header.bedtracksource || this.params.source;\n            const query = `?filter=id in ${source} and chromosome eq '${state.chr}' and start le ${state.end} and end ge ${state.start}`;\n            return `${this.url}${query}`;\n        }\n    }\n\n    /**\n     * Button to toggle split tracks\n     */\n    class ToggleSplitTracks extends _BaseWidget {\n        constructor(layout) {\n            super(...arguments);\n            if (!layout.data_layer_id) {\n                layout.data_layer_id = 'intervals';\n            }\n            if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n                throw new Error('Toggle split tracks widget specifies an invalid data layer ID');\n            }\n        }\n\n        update() {\n            const data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];\n            const html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n            if (this.button) {\n                this.button.setHtml(html);\n                this.button.show();\n                this.parent.position();\n                return this;\n            } else {\n                this.button = new _Button(this)\n                    .setColor(this.layout.color)\n                    .setHtml(html)\n                    .setTitle('Toggle whether tracks are split apart or merged together')\n                    .setOnclick(() => {\n                        data_layer.toggleSplitTracks();\n                        if (this.scale_timeout) {\n                            clearTimeout(this.scale_timeout);\n                        }\n                        this.scale_timeout = setTimeout(() => {\n                            this.parent_panel.scaleHeightToData();\n                            this.parent_plot.positionPanels();\n                        }, 0);\n                        this.update();\n                    });\n                return this.update();\n            }\n        }\n    }\n\n\n    /**\n     * Convert a value \"\"rr,gg,bb\" (if given) to a css-friendly color string: \"rgb(rr,gg,bb)\".\n     * This is tailored specifically to the color specification format embraced by the BED file standard.\n     * @function to_rgb\n     * @param {Object} parameters This function has no defined configuration options\n     * @param {String|null} value The value to convert to rgb\n     */\n    function to_rgb(parameters, value) {\n        return value ? `rgb(${value})` : null;\n    }\n\n    const default_layout = {\n        start_field: 'start',\n        end_field: 'end',\n        track_label_field: 'state_name', // Used to label items on the y-axis\n        // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting\n        //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,\n        //  not just choose unique colors within a particular narrow region. (where changing region might lead to more\n        //  categories and different colors)\n        track_split_field: 'state_id',\n        track_split_order: 'DESC',\n        track_split_legend_to_y_axis: 2,\n        split_tracks: true,\n        track_height: 15,\n        track_vertical_spacing: 3,\n        bounding_box_padding: 2,\n        always_hide_legend: false,\n        color: '#B8B8B8',\n        fill_opacity: 1,\n        tooltip_positioning: 'vertical',\n    };\n\n\n    /**\n     * Intervals Data Layer\n     * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n     */\n    const BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');\n    class LzIntervalsTrack extends BaseLayer {\n        constructor(layout) {\n            LocusZoom.Layouts.merge(layout, default_layout);\n            super(...arguments);\n            this.tracks = 1;\n            this.previous_tracks = 1;\n\n            // track-number-indexed object with arrays of interval indexes in the dataset\n            this.interval_track_index = { 1: [] };\n        }\n\n        /**\n         * To define shared highlighting on the track split field define the status node id override\n         * to generate an ID common to the track when we're actively splitting data out to separate tracks\n         * @override\n         * @returns {String}\n         */\n        getElementStatusNodeId(element) {\n            if (this.layout.split_tracks) {\n                return (`${this.getBaseId()}-statusnode-${element[this.layout.track_split_field]}`).replace(/[^\\w]/g, '_');\n            }\n            return `${this.getElementId(element)}-statusnode`;\n        }\n\n        // Helper function to sum layout values to derive total height for a single interval track\n        getTrackHeight() {\n            return this.layout.track_height\n                + this.layout.track_vertical_spacing\n                + (2 * this.layout.bounding_box_padding);\n        }\n\n        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available\n        // Even when not displayed, the legend is used to generate the y-axis ticks\n        _applyLayoutOptions() {\n            const self = this;\n            const base_layout = this._base_layout;\n            const render_layout = this.layout;\n            const base_color_scale = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            const color_scale = render_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            if (!base_color_scale) {\n                // This can be a placeholder (empty categories & values), but it needs to be there\n                throw new Error('Interval tracks must define a `categorical_bin` color scale');\n            }\n\n            const has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;\n            const has_legend = base_layout.legend && base_layout.legend.length;\n\n            if (!!has_colors ^ !!has_legend) {\n                // Don't allow color OR legend to be set manually. It must be both, or neither.\n                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');\n            }\n\n            // Harvest any information about an explicit color field that should be considered when generating colors\n            const rgb_option = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'to_rgb';\n            });\n            const rgb_field = rgb_option && rgb_option.field;\n\n            // Auto-generate legend based on data\n            const known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items\n\n            if (!has_colors && !has_legend) {\n                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot\n                // The legend must match the color scheme. If we generate one, then we must generate both.\n\n                const colors = this._makeColorScheme(known_categories);\n                color_scale.parameters.categories = known_categories.map(function (item) {\n                    return item[0];\n                });\n                color_scale.parameters.values = colors;\n\n                this.layout.legend = known_categories.map(function (pair, index) {\n                    const id = pair[0];\n                    const label = pair[1];\n                    const item_color = color_scale.parameters.values[index];\n                    const item = { shape: 'rect', width: 9, label: label, color: item_color };\n                    item[self.layout.track_split_field] = id;\n                    return item;\n                });\n            }\n        }\n\n        // After we've loaded interval data interpret it to assign\n        // each to a track so that they do not overlap in the view\n        assignTracks() {\n            // Autogenerate layout options if not provided\n            this._applyLayoutOptions();\n\n            // Reinitialize some metadata\n            this.previous_tracks = this.tracks;\n            this.tracks = 0;\n            this.interval_track_index = { 1: [] };\n            // This maps unique values of track_split_field to unique y indices. It controls the ordering of separate tracks.\n            this.track_split_field_index = {};\n\n            // If splitting tracks by a field's value then determine how to order them. There are two options here:\n            // a) numeric IDs get sorted in numeric order (JS quirk: int object keys act like array indices), or\n            // b) text labels get sorted based on order in the source data (hash preserves insertion order)\n            if (this.layout.track_split_field && this.layout.split_tracks) {\n                this.data.forEach((d) => {\n                    this.track_split_field_index[d[this.layout.track_split_field]] = null;\n                });\n                const index = Object.keys(this.track_split_field_index);\n                if (this.layout.track_split_order === 'DESC') {\n                    index.reverse();\n                }\n                index.forEach((val) => {\n                    this.track_split_field_index[val] = this.tracks + 1;\n                    this.interval_track_index[this.tracks + 1] = [];\n                    this.tracks++;\n                });\n            }\n\n            this.data.forEach(function(d, i) {\n\n                // Stash a parent reference on the interval\n                this.data[i].parent = this;\n\n                // Determine display range start and end, based on minimum allowable interval display width,\n                // bounded by what we can see (range: values in terms of pixels on the screen)\n                this.data[i].display_range = {\n                    start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),\n                    end:   this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end)),\n                };\n                this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start;\n\n                // Convert and stash display range values into domain values\n                // (domain: values in terms of the data set, e.g. megabases)\n                this.data[i].display_domain = {\n                    start: this.parent.x_scale.invert(this.data[i].display_range.start),\n                    end:   this.parent.x_scale.invert(this.data[i].display_range.end),\n                };\n                this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start;\n\n                // If splitting to tracks based on the value of the designated track split field\n                // then don't bother with collision detection (intervals will be grouped on tracks\n                // solely by the value of track_split_field)\n                if (this.layout.track_split_field && this.layout.split_tracks) {\n                    const val = this.data[i][this.layout.track_split_field];\n                    this.data[i].track = this.track_split_field_index[val];\n                    this.interval_track_index[this.data[i].track].push(i);\n                } else {\n                    // If not splitting to tracks based on a field value then do so based on collision\n                    // detection (as how it's done for genes). Use display range/domain data generated\n                    // above and cast each interval to tracks such that none overlap\n                    this.tracks = 1;\n                    this.data[i].track = null;\n                    let potential_track = 1;\n                    while (this.data[i].track === null) {\n                        let collision_on_potential_track = false;\n                        this.interval_track_index[potential_track].map(function(placed_interval) {\n                            if (!collision_on_potential_track) {\n                                const min_start = Math.min(placed_interval.display_range.start, this.display_range.start);\n                                const max_end = Math.max(placed_interval.display_range.end, this.display_range.end);\n                                if ((max_end - min_start) < (placed_interval.display_range.width + this.display_range.width)) {\n                                    collision_on_potential_track = true;\n                                }\n                            }\n                        }.bind(this.data[i]));\n                        if (!collision_on_potential_track) {\n                            this.data[i].track = potential_track;\n                            this.interval_track_index[potential_track].push(this.data[i]);\n                        } else {\n                            potential_track++;\n                            if (potential_track > this.tracks) {\n                                this.tracks = potential_track;\n                                this.interval_track_index[potential_track] = [];\n                            }\n                        }\n                    }\n\n                }\n\n            }.bind(this));\n\n            return this;\n        }\n\n        // Implement the main render function\n        render() {\n            // Lay out space first\n            this.assignTracks();\n\n            // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.\n            const track_data = this._applyFilters();\n\n            // Remove any shared highlight nodes and re-render them if we're splitting on tracks\n            // At most there will only be dozen or so nodes here (one per track) and each time\n            // we render data we may have new tracks, so wiping/redrawing all is reasonable.\n            this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();\n            Object.keys(this.track_split_field_index).forEach((key) => {\n                // Make a psuedo-element so that we can generate an id for the shared node\n                const pseudoElement = {};\n                pseudoElement[this.layout.track_split_field] = key;\n                // Insert the shared node\n                this.svg.group.insert('rect', ':first-child')\n                    .attr('id', this.getElementStatusNodeId(pseudoElement))\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                    .attr('rx', this.layout.bounding_box_padding)\n                    .attr('ry', this.layout.bounding_box_padding)\n                    .attr('width', this.parent.layout.cliparea.width)\n                    .attr('height', this.getTrackHeight() - this.layout.track_vertical_spacing)\n                    .attr('x', 0)\n                    .attr('y', (this.track_split_field_index[key] - 1) * this.getTrackHeight())\n                    .style('display', (this.layout.split_tracks ? null : 'none'));\n            });\n\n            // Render interval groups\n            const selection = this.svg.group.selectAll('g.lz-data_layer-intervals')\n                .data(track_data, (d) => {\n                    return d[this.layout.id_field];\n                });\n\n            selection.enter()\n                .append('g')\n                .attr('class', 'lz-data_layer-intervals')\n                .merge(selection)\n                .attr('id', (d) => this.getElementId(d))\n                .each(function(interval) {\n                    const data_layer = interval.parent;\n                    // Render interval status nodes (displayed behind intervals to show highlight\n                    // without needing to modify interval display element(s))\n                    const statusnodes = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete')\n                        .data([interval], (d) => `${data_layer.getElementId(d)}-statusnode`);\n                    statusnodes.enter()\n                        .insert('rect', ':first-child')\n                        .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete')\n                        .merge(statusnodes)\n                        .attr('id', (d) => `${data_layer.getElementId(d)}-statusnode`)\n                        .attr('rx', data_layer.layout.bounding_box_padding)\n                        .attr('ry', data_layer.layout.bounding_box_padding)\n                        .style('display', data_layer.layout.split_tracks ? 'none' : null)\n                        .attr('width', (d) => d.display_range.width + (2 * data_layer.layout.bounding_box_padding))\n                        .attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing)\n                        .attr('x', (d) => d.display_range.start - data_layer.layout.bounding_box_padding)\n                        .attr('y', (d) => ((d.track - 1) * data_layer.getTrackHeight()));\n\n                    statusnodes.exit()\n                        .remove();\n\n                    // Render primary interval rects\n                    const rects = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect')\n                        .data([interval], (d) => `${d[data_layer.layout.id_field]}_interval_rect`);\n\n                    rects.enter()\n                        .append('rect')\n                        .attr('class', 'lz-data_layer-intervals lz-interval_rect')\n                        .merge(rects)\n                        .attr('width', (d) => d.display_range.width)\n                        .attr('height', data_layer.layout.track_height)\n                        .attr('x', (d) => d.display_range.start)\n                        .attr('y', (d) => ((d.track - 1) * data_layer.getTrackHeight()) + data_layer.layout.bounding_box_padding)\n                        .attr('fill', (d, i) => data_layer.resolveScalableParameter(data_layer.layout.color, d, i))\n                        .attr('fill-opacity', (d, i) => data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d, i));\n\n                    rects.exit()\n                        .remove();\n\n                    // Render interval click areas\n                    const clickareas = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-clickarea')\n                        .data([interval], (d) => `${d.interval_name}_clickarea`);\n\n                    clickareas.enter()\n                        .append('rect')\n                        .attr('class', 'lz-data_layer-intervals lz-clickarea')\n                        .merge(clickareas)\n                        .attr('id', (d) => `${data_layer.getElementId(d)}_clickarea`)\n                        .attr('rx', data_layer.layout.bounding_box_padding)\n                        .attr('ry', data_layer.layout.bounding_box_padding)\n                        .attr('width', (d) => d.display_range.width)\n                        .attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing)\n                        .attr('x', (d) => d.display_range.start)\n                        .attr('y', (d) => ((d.track - 1) * data_layer.getTrackHeight()))\n                        // Apply default event emitters to clickareas\n                        .on('click', (element_data) => {\n                            element_data.parent.parent.emit('element_clicked', element_data, true);\n                        })\n                        // Apply mouse behaviors to clickareas\n                        .call(data_layer.applyBehaviors.bind(data_layer));\n\n                    // Remove old clickareas as needed\n                    clickareas.exit()\n                        .remove();\n                });\n\n            // Remove old elements as needed\n            selection.exit()\n                .remove();\n\n            // Update the legend axis if the number of ticks changed\n            if (this.previous_tracks !== this.tracks) {\n                this.updateSplitTrackAxis();\n            }\n\n            // The intervals track allows legends to be dynamically generated, in which case space can only be\n            //  allocated after the panel has been rendered.\n            if (this.parent && this.parent.legend) {\n                this.parent.legend.render();\n            }\n\n            return this;\n        }\n\n        _getTooltipPosition(tooltip) {\n            const interval_bbox = d3.select(`#${this.getElementStatusNodeId(tooltip.data)}`).node().getBBox();\n            return {\n                x_min: tooltip.data.display_range.start,\n                x_max: tooltip.data.display_range.end,\n                y_min: interval_bbox.y,\n                y_max: interval_bbox.y + interval_bbox.height,\n            };\n        }\n\n        // Redraw split track axis or hide it, and show/hide the legend, as determined\n        // by current layout parameters and data\n        updateSplitTrackAxis() {\n            const legend_axis = this.layout.track_split_legend_to_y_axis ? `y${this.layout.track_split_legend_to_y_axis}` : false;\n            if (this.layout.split_tracks) {\n                const tracks = +this.tracks || 0;\n                const track_height = +this.layout.track_height || 0;\n                const track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                const target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n                this.parent.scaleHeightToData(target_height);\n                if (legend_axis && this.parent.legend) {\n                    this.parent.legend.hide();\n                    this.parent.layout.axes[legend_axis] = {\n                        render: true,\n                        ticks: [],\n                        range: {\n                            start: (target_height - (this.layout.track_height / 2)),\n                            end: (this.layout.track_height / 2),\n                        },\n                    };\n                    // There is a very tight coupling between the display directives: each legend item must identify a key\n                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)\n                    // The list of unique keys corresponds to the order along the y-axis\n                    this.layout.legend.forEach((element) => {\n                        const key = element[this.layout.track_split_field];\n                        let track = this.track_split_field_index[key];\n                        if (track) {\n                            if (this.layout.track_split_order === 'DESC') {\n                                track = Math.abs(track - tracks - 1);\n                            }\n                            this.parent.layout.axes[legend_axis].ticks.push({\n                                y: track,\n                                text: element.label,\n                            });\n                        }\n                    });\n                    this.layout.y_axis = {\n                        axis: this.layout.track_split_legend_to_y_axis,\n                        floor: 1,\n                        ceiling: tracks,\n                    };\n                    this.parent.render();\n                }\n                this.parent_plot.positionPanels();\n            } else {\n                if (legend_axis && this.parent.legend) {\n                    if (!this.layout.always_hide_legend) {\n                        this.parent.legend.show();\n                    }\n                    this.parent.layout.axes[legend_axis] = { render: false };\n                    this.parent.render();\n                }\n            }\n            return this;\n        }\n\n        // Method to not only toggle the split tracks boolean but also update\n        // necessary display values to animate a complete merge/split\n        toggleSplitTracks() {\n\n\n            this.layout.split_tracks = !this.layout.split_tracks;\n\n            if (this.parent.legend && !this.layout.always_hide_legend) {\n                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n            }\n            \n            \n            if (!this.layout.split_tracks) {\n                // Allow the plot to shrink when panels are removed, by forcing it to recalculate min dimensions from scratch\n                this.parent.min_height = 1;\n                this.parent.min_width = 1;                \n                // // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n                // // positioning. TODO: make this additional call unnecessary.\n                // this.setDimensions(this.parent.width, this.parent.height);\n            }\n            \n            this.render();\n\n            this.updateSplitTrackAxis();\n\n            return this;\n        }\n\n\n\n        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are\n        //  using explicitly provided itemRgb information\n        _makeColorScheme(category_info) {\n            // If at least one element has an explicit itemRgb, assume the entire dataset has colors\n            const has_explicit_colors = category_info.find((item) => item[2]);\n            if (has_explicit_colors) {\n                return category_info.map((item) => item[2]);\n            }\n\n            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:\n            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html\n            // These are actually reversed so that dim colors come first, on the premise that usually these are the\n            //  most common states\n            const n_categories = category_info.length;\n            if (n_categories <= 15) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else if (n_categories <= 18) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else {\n                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option\n                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            }\n        }\n\n        /**\n         * Find all of the unique tracks (a combination of name and ID information)\n         * @param {Object} data\n         * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column\n         * @private\n         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings\n         *  most unambiguously.\n         */\n        _generateCategoriesFromData(data, rgb_field) {\n            const self = this;\n            // Use the hard-coded legend if available (ignoring any mods on re-render)\n            const legend = this._base_layout.legend;\n            if (legend && legend.length) {\n                return legend.map((item) => [item[this.layout.track_split_field], item.label, item.color]);\n            }\n\n            // Generate options from data, if no preset legend exists\n            const unique_ids = {}; // make categories unique\n            const categories = [];\n\n            data.forEach((item) => {\n                const id = item[self.layout.track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {\n                    unique_ids[id] = null;\n                    // If rgbfield is null, then the last entry is undefined/null as well\n                    categories.push([id, item[this.layout.track_label_field], item[rgb_field]]);\n                }\n            });\n            return categories;\n        }\n    }\n\n    const intervals_tooltip_layout = {\n        namespace: { 'intervals': 'intervals' },\n        closable: false,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}',\n    };\n\n    const intervals_layer_layout =  {\n        namespace: { 'intervals': 'intervals' },\n        id: 'intervals',\n        type: 'intervals',\n        fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],\n        id_field: '{{namespace[intervals]}}start',\n        start_field: '{{namespace[intervals]}}start',\n        end_field: '{{namespace[intervals]}}end',\n        track_split_field: '{{namespace[intervals]}}state_name',\n        track_label_field: '{{namespace[intervals]}}state_name',\n        split_tracks: false,\n        always_hide_legend: true,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: '{{namespace[intervals]}}itemRgb',\n                scale_function: 'to_rgb',\n            },\n            {\n                field: '{{namespace[intervals]}}state_name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8',\n                },\n            },\n        ],\n        legend: [], // Placeholder; auto-filled when data loads.\n        behaviors: {\n            onmouseover: [\n                { action: 'set', status: 'highlighted' },\n            ],\n            onmouseout: [\n                { action: 'unset', status: 'highlighted' },\n            ],\n            onclick: [\n                { action: 'toggle', status: 'selected', exclusive: true },\n            ],\n            onshiftclick: [\n                { action: 'toggle', status: 'selected' },\n            ],\n        },\n        tooltip: intervals_tooltip_layout,\n    };\n\n    const intervals_panel_layout = {\n        id: 'intervals',\n        width: 1000,\n        height: 50,\n        min_width: 500,\n        min_height: 50,\n        margin: { top: 25, right: 150, bottom: 5, left: 50 },\n        toolbar: (function () {\n            const l = LocusZoom.Layouts.get('toolbar', 'standard_panel', { unnamespaced: true });\n            l.widgets.push({\n                type: 'toggle_split_tracks',\n                data_layer_id: 'intervals',\n                position: 'right',\n            });\n            return l;\n        })(),\n        axes: {},\n        interaction: {\n            drag_background_to_pan: true,\n            scroll_to_zoom: true,\n            x_linked: true,\n        },\n        legend: {\n            hidden: true,\n            orientation: 'horizontal',\n            origin: { x: 50, y: 0 },\n            pad_from_bottom: 5,\n        },\n        data_layers: [intervals_layer_layout],\n    };\n\n    const intervals_plot_layout = {\n        state: {},\n        width: 800,\n        height: 550,\n        responsive_resize: true,\n        min_region_scale: 20000,\n        max_region_scale: 1000000,\n        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true }),\n        panels: [\n            LocusZoom.Layouts.get('panel', 'association', {\n                unnamespaced: true,\n                width: 800,\n                proportional_height: (225 / 570),\n            }),\n            Object.assign(\n                { unnamespaced: true, proportional_height: (120 / 570) },\n                intervals_panel_layout\n            ),\n            LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true, width: 800, proportional_height: (225 / 570) }),\n        ],\n    };\n\n    LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);\n    LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);\n\n    LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);\n    LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);\n    LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);\n    LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);\n\n    LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);\n\n    LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);\n}\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n"],"sourceRoot":""}