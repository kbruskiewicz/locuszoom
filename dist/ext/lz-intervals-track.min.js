/*! Locuszoom 0.13.0-beta.2 */
var LzIntervalsTrack =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-intervals-track.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-intervals-track.js":
/*!***************************************!*\
  !*** ./esm/ext/lz-intervals-track.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.
This is not part of the core LocusZoom library, but can be included as a standalone file.

The page must incorporate and load all libraries before this file can be used, including:
 - Vendor assets
 - LocusZoom
 @module
*/


function install(LocusZoom) {
  var BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');

  var _Button = LocusZoom.Widgets.get('_Button');

  var _BaseWidget = LocusZoom.Widgets.get('BaseWidget');
  /**
   * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)
   * @public
   */


  var IntervalLZ = /*#__PURE__*/function (_BaseApiAdapter) {
    _inherits(IntervalLZ, _BaseApiAdapter);

    var _super = _createSuper(IntervalLZ);

    function IntervalLZ() {
      _classCallCheck(this, IntervalLZ);

      return _super.apply(this, arguments);
    }

    _createClass(IntervalLZ, [{
      key: "getURL",
      value: function getURL(state, chain, fields) {
        var source = chain.header.bedtracksource || this.params.source;
        var query = "?filter=id in ".concat(source, " and chromosome eq '").concat(state.chr, "' and start le ").concat(state.end, " and end ge ").concat(state.start);
        return "".concat(this.url).concat(query);
      }
    }]);

    return IntervalLZ;
  }(BaseApiAdapter);
  /**
   * Button to toggle split tracks
   */


  var ToggleSplitTracks = /*#__PURE__*/function (_BaseWidget2) {
    _inherits(ToggleSplitTracks, _BaseWidget2);

    var _super2 = _createSuper(ToggleSplitTracks);

    function ToggleSplitTracks(layout) {
      var _this;

      _classCallCheck(this, ToggleSplitTracks);

      _this = _super2.apply(this, arguments);

      if (!layout.data_layer_id) {
        layout.data_layer_id = 'intervals';
      }

      if (!_this.parent_panel.data_layers[layout.data_layer_id]) {
        throw new Error('Toggle split tracks widget specifies an invalid data layer ID');
      }

      return _this;
    }

    _createClass(ToggleSplitTracks, [{
      key: "update",
      value: function update() {
        var _this2 = this;

        var data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];
        var html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';

        if (this.button) {
          this.button.setHtml(html);
          this.button.show();
          this.parent.position();
          return this;
        } else {
          this.button = new _Button(this).setColor(this.layout.color).setHtml(html).setTitle('Toggle whether tracks are split apart or merged together').setOnclick(function () {
            data_layer.toggleSplitTracks();

            if (_this2.scale_timeout) {
              clearTimeout(_this2.scale_timeout);
            }

            _this2.scale_timeout = setTimeout(function () {
              // NOTE: This can override changes made in toggleSplitTracks
              _this2.parent_panel.scaleHeightToData(); // DEFECT


              _this2.parent_plot.positionPanels();
            }, 0);

            _this2.update();
          });
          return this.update();
        }
      }
    }]);

    return ToggleSplitTracks;
  }(_BaseWidget);
  /**
   * Convert a value ""rr,gg,bb" (if given) to a css-friendly color string: "rgb(rr,gg,bb)".
   * This is tailored specifically to the color specification format embraced by the BED file standard.
   * @function to_rgb
   * @param {Object} parameters This function has no defined configuration options
   * @param {String|null} value The value to convert to rgb
   */


  function to_rgb(parameters, value) {
    return value ? "rgb(".concat(value, ")") : null;
  }

  var default_layout = {
    start_field: 'start',
    end_field: 'end',
    track_label_field: 'state_name',
    // Used to label items on the y-axis
    // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting
    //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,
    //  not just choose unique colors within a particular narrow region. (where changing region might lead to more
    //  categories and different colors)
    track_split_field: 'state_id',
    track_split_order: 'DESC',
    track_split_legend_to_y_axis: 2,
    split_tracks: true,
    track_height: 15,
    track_vertical_spacing: 3,
    bounding_box_padding: 2,
    always_hide_legend: false,
    color: '#B8B8B8',
    fill_opacity: 1,
    tooltip_positioning: 'vertical'
  };
  /**
   * Intervals Data Layer
   * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)
   */

  var BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');

  var LzIntervalsTrack = /*#__PURE__*/function (_BaseLayer) {
    _inherits(LzIntervalsTrack, _BaseLayer);

    var _super3 = _createSuper(LzIntervalsTrack);

    function LzIntervalsTrack(layout) {
      var _this3;

      _classCallCheck(this, LzIntervalsTrack);

      LocusZoom.Layouts.merge(layout, default_layout);
      _this3 = _super3.apply(this, arguments);
      _this3.tracks = 1;
      _this3.previous_tracks = 1; // track-number-indexed object with arrays of interval indexes in the dataset

      _this3.interval_track_index = {
        1: []
      };
      return _this3;
    }
    /**
     * To define shared highlighting on the track split field define the status node id override
     * to generate an ID common to the track when we're actively splitting data out to separate tracks
     * @override
     * @returns {String}
     */


    _createClass(LzIntervalsTrack, [{
      key: "getElementStatusNodeId",
      value: function getElementStatusNodeId(element) {
        if (this.layout.split_tracks) {
          return "".concat(this.getBaseId(), "-statusnode-").concat(element[this.layout.track_split_field]).replace(/[^\w]/g, '_');
        }

        return "".concat(this.getElementId(element), "-statusnode");
      } // Helper function to sum layout values to derive total height for a single interval track

    }, {
      key: "getTrackHeight",
      value: function getTrackHeight() {
        return this.layout.track_height + this.layout.track_vertical_spacing + 2 * this.layout.bounding_box_padding;
      } // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available
      // Even when not displayed, the legend is used to generate the y-axis ticks

    }, {
      key: "_applyLayoutOptions",
      value: function _applyLayoutOptions() {
        var self = this;
        var base_layout = this._base_layout;
        var render_layout = this.layout;
        var base_color_scale = base_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'categorical_bin';
        });
        var color_scale = render_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'categorical_bin';
        });

        if (!base_color_scale) {
          // This can be a placeholder (empty categories & values), but it needs to be there
          throw new Error('Interval tracks must define a `categorical_bin` color scale');
        }

        var has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;
        var has_legend = base_layout.legend && base_layout.legend.length;

        if (!!has_colors ^ !!has_legend) {
          // Don't allow color OR legend to be set manually. It must be both, or neither.
          throw new Error('To use a manually specified color scheme, both color and legend options must be set.');
        } // Harvest any information about an explicit color field that should be considered when generating colors


        var rgb_option = base_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'to_rgb';
        });
        var rgb_field = rgb_option && rgb_option.field; // Auto-generate legend based on data

        var known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items


        if (!has_colors && !has_legend) {
          // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot
          // The legend must match the color scheme. If we generate one, then we must generate both.
          var colors = this._makeColorScheme(known_categories);

          color_scale.parameters.categories = known_categories.map(function (item) {
            return item[0];
          });
          color_scale.parameters.values = colors;
          this.layout.legend = known_categories.map(function (pair, index) {
            var id = pair[0];
            var label = pair[1];
            var item_color = color_scale.parameters.values[index];
            var item = {
              shape: 'rect',
              width: 9,
              label: label,
              color: item_color
            };
            item[self.layout.track_split_field] = id;
            return item;
          });
        }
      } // After we've loaded interval data interpret it to assign
      // each to a track so that they do not overlap in the view

    }, {
      key: "assignTracks",
      value: function assignTracks() {
        var _this4 = this;

        // Autogenerate layout options if not provided
        this._applyLayoutOptions(); // Reinitialize some metadata


        this.previous_tracks = this.tracks;
        this.tracks = 0;
        this.interval_track_index = {
          1: []
        }; // This maps unique values of track_split_field to unique y indices. It controls the ordering of separate tracks.

        this.track_split_field_index = {}; // If splitting tracks by a field's value then determine how to order them. There are two options here:
        // a) numeric IDs get sorted in numeric order (JS quirk: int object keys act like array indices), or
        // b) text labels get sorted based on order in the source data (hash preserves insertion order)

        if (this.layout.track_split_field && this.layout.split_tracks) {
          this.data.forEach(function (d) {
            _this4.track_split_field_index[d[_this4.layout.track_split_field]] = null;
          });
          var index = Object.keys(this.track_split_field_index);

          if (this.layout.track_split_order === 'DESC') {
            index.reverse();
          }

          index.forEach(function (val) {
            _this4.track_split_field_index[val] = _this4.tracks + 1;
            _this4.interval_track_index[_this4.tracks + 1] = [];
            _this4.tracks++;
          });
        }

        this.data.forEach(function (d, i) {
          var _this5 = this;

          // Stash a parent reference on the interval
          this.data[i].parent = this; // Determine display range start and end, based on minimum allowable interval display width,
          // bounded by what we can see (range: values in terms of pixels on the screen)

          this.data[i].display_range = {
            start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),
            end: this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end))
          };
          this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start; // Convert and stash display range values into domain values
          // (domain: values in terms of the data set, e.g. megabases)

          this.data[i].display_domain = {
            start: this.parent.x_scale.invert(this.data[i].display_range.start),
            end: this.parent.x_scale.invert(this.data[i].display_range.end)
          };
          this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start; // If splitting to tracks based on the value of the designated track split field
          // then don't bother with collision detection (intervals will be grouped on tracks
          // solely by the value of track_split_field)

          if (this.layout.track_split_field && this.layout.split_tracks) {
            var val = this.data[i][this.layout.track_split_field];
            this.data[i].track = this.track_split_field_index[val];
            this.interval_track_index[this.data[i].track].push(i);
          } else {
            // If not splitting to tracks based on a field value then do so based on collision
            // detection (as how it's done for genes). Use display range/domain data generated
            // above and cast each interval to tracks such that none overlap
            this.tracks = 1;
            this.data[i].track = null;
            var potential_track = 1;

            var _loop = function _loop() {
              var collision_on_potential_track = false;

              _this5.interval_track_index[potential_track].map(function (placed_interval) {
                if (!collision_on_potential_track) {
                  var min_start = Math.min(placed_interval.display_range.start, this.display_range.start);
                  var max_end = Math.max(placed_interval.display_range.end, this.display_range.end);

                  if (max_end - min_start < placed_interval.display_range.width + this.display_range.width) {
                    collision_on_potential_track = true;
                  }
                }
              }.bind(_this5.data[i]));

              if (!collision_on_potential_track) {
                _this5.data[i].track = potential_track;

                _this5.interval_track_index[potential_track].push(_this5.data[i]);
              } else {
                potential_track++;

                if (potential_track > _this5.tracks) {
                  _this5.tracks = potential_track;
                  _this5.interval_track_index[potential_track] = [];
                }
              }
            };

            while (this.data[i].track === null) {
              _loop();
            }
          }
        }.bind(this));
        return this;
      } // Implement the main render function

    }, {
      key: "render",
      value: function render() {
        var _this6 = this;

        // Lay out space first
        this.assignTracks(); // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.

        var track_data = this._applyFilters(); // Remove any shared highlight nodes and re-render them if we're splitting on tracks
        // At most there will only be dozen or so nodes here (one per track) and each time
        // we render data we may have new tracks, so wiping/redrawing all is reasonable.


        this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();
        Object.keys(this.track_split_field_index).forEach(function (key) {
          // Make a psuedo-element so that we can generate an id for the shared node
          var pseudoElement = {};
          pseudoElement[_this6.layout.track_split_field] = key; // Insert the shared node

          _this6.svg.group.insert('rect', ':first-child').attr('id', _this6.getElementStatusNodeId(pseudoElement)).attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared').attr('rx', _this6.layout.bounding_box_padding).attr('ry', _this6.layout.bounding_box_padding).attr('width', _this6.parent.layout.cliparea.width).attr('height', _this6.getTrackHeight() - _this6.layout.track_vertical_spacing).attr('x', 0).attr('y', (_this6.track_split_field_index[key] - 1) * _this6.getTrackHeight()).style('display', _this6.layout.split_tracks ? null : 'none');
        }); // Render interval groups

        var selection = this.svg.group.selectAll('g.lz-data_layer-intervals').data(track_data, function (d) {
          return d[_this6.layout.id_field];
        });
        selection.enter().append('g').attr('class', 'lz-data_layer-intervals').merge(selection).attr('id', function (d) {
          return _this6.getElementId(d);
        }).each(function (interval) {
          var data_layer = interval.parent; // Render interval status nodes (displayed behind intervals to show highlight
          // without needing to modify interval display element(s))

          var statusnodes = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete').data([interval], function (d) {
            return "".concat(data_layer.getElementId(d), "-statusnode");
          });
          statusnodes.enter().insert('rect', ':first-child').attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete').merge(statusnodes).attr('id', function (d) {
            return "".concat(data_layer.getElementId(d), "-statusnode");
          }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).style('display', data_layer.layout.split_tracks ? 'none' : null).attr('width', function (d) {
            return d.display_range.width + 2 * data_layer.layout.bounding_box_padding;
          }).attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing).attr('x', function (d) {
            return d.display_range.start - data_layer.layout.bounding_box_padding;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight();
          });
          statusnodes.exit().remove(); // Render primary interval rects

          var rects = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect').data([interval], function (d) {
            return "".concat(d[data_layer.layout.id_field], "_interval_rect");
          });
          rects.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-interval_rect').merge(rects).attr('width', function (d) {
            return d.display_range.width;
          }).attr('height', data_layer.layout.track_height).attr('x', function (d) {
            return d.display_range.start;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding;
          }).attr('fill', function (d, i) {
            return data_layer.resolveScalableParameter(data_layer.layout.color, d, i);
          }).attr('fill-opacity', function (d, i) {
            return data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d, i);
          });
          rects.exit().remove(); // Render interval click areas

          var clickareas = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-clickarea').data([interval], function (d) {
            return "".concat(d.interval_name, "_clickarea");
          });
          clickareas.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-clickarea').merge(clickareas).attr('id', function (d) {
            return "".concat(data_layer.getElementId(d), "_clickarea");
          }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).attr('width', function (d) {
            return d.display_range.width;
          }).attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing).attr('x', function (d) {
            return d.display_range.start;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight();
          }) // Apply default event emitters to clickareas
          .on('click', function (element_data) {
            element_data.parent.parent.emit('element_clicked', element_data, true);
          }) // Apply mouse behaviors to clickareas
          .call(data_layer.applyBehaviors.bind(data_layer)); // Remove old clickareas as needed

          clickareas.exit().remove();
        }); // // Remove old elements as needed

        selection.exit().remove(); // // Update the legend axis if the number of ticks changed
        // if (this.previous_tracks !== this.tracks) {
        //     this.updateSplitTrackAxis();
        // }
        // // The intervals track allows legends to be dynamically generated, in which case space can only be
        // //  allocated after the panel has been rendered.

        if (this.parent && this.parent.legend) {
          this.parent.legend.render();
        }

        return this;
      }
    }, {
      key: "_getTooltipPosition",
      value: function _getTooltipPosition(tooltip) {
        var interval_bbox = d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(this.getElementStatusNodeId(tooltip.data))).node().getBBox();
        return {
          x_min: tooltip.data.display_range.start,
          x_max: tooltip.data.display_range.end,
          y_min: interval_bbox.y,
          y_max: interval_bbox.y + interval_bbox.height
        };
      } // Redraw split track axis or hide it, and show/hide the legend, as determined
      // by current layout parameters and data

    }, {
      key: "updateSplitTrackAxis",
      value: function updateSplitTrackAxis() {
        var _this7 = this;

        var legend_axis = this.layout.track_split_legend_to_y_axis ? "y".concat(this.layout.track_split_legend_to_y_axis) : false;

        if (this.layout.split_tracks) {
          var tracks = +this.tracks || 0;
          var track_height = +this.layout.track_height || 0;
          var track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);
          var target_height = tracks * track_height + (tracks - 1) * track_spacing;
          this.parent.scaleHeightToData(target_height); // DEFECT

          if (legend_axis && this.parent.legend) {
            this.parent.legend.hide();
            this.parent.layout.axes[legend_axis] = {
              render: true,
              ticks: [],
              range: {
                start: target_height - this.layout.track_height / 2,
                end: this.layout.track_height / 2
              }
            }; // There is a very tight coupling between the display directives: each legend item must identify a key
            //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)
            // The list of unique keys corresponds to the order along the y-axis

            this.layout.legend.forEach(function (element) {
              var key = element[_this7.layout.track_split_field];
              var track = _this7.track_split_field_index[key];

              if (track) {
                if (_this7.layout.track_split_order === 'DESC') {
                  track = Math.abs(track - tracks - 1);
                }

                _this7.parent.layout.axes[legend_axis].ticks.push({
                  y: track,
                  text: element.label
                });
              }
            });
            this.layout.y_axis = {
              axis: this.layout.track_split_legend_to_y_axis,
              floor: 1,
              ceiling: tracks
            };
            this.parent.render();
          }

          this.parent_plot.positionPanels();
        } else {
          if (legend_axis && this.parent.legend) {
            if (!this.layout.always_hide_legend) {
              this.parent.legend.show();
            }

            this.parent.layout.axes[legend_axis] = {
              render: false
            };
            this.parent.render();
          }
        }

        return this;
      } // Method to not only toggle the split tracks boolean but also update
      // necessary display values to animate a complete merge/split

    }, {
      key: "toggleSplitTracks",
      value: function toggleSplitTracks() {
        this.layout.split_tracks = !this.layout.split_tracks;

        if (this.parent.legend && !this.layout.always_hide_legend) {
          this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);
        }

        this.render();

        if (!this.layout.split_tracks) {
          // forcing these to go to one will cause a recalculation of the dimensions for the parent_plot
          // otherwise when `scaleHeightToData` runs, min_height (which can get quite large) will dominate plot's
          // layout from updating and can potentially lead to a large amount of whitespace on the screen, as well as stretching panels.
          this.parent_plot.layout.height = 1;
          this.parent_plot.layout.min_height = 1;
          this.parent_plot.layout.min_width = 1; // recalculate proportional heights and widths

          this.parent_plot.positionPanels(); // this.parent_plot.layout.min_height = this.parent_plot._base_layout.min_height;
          // this.parent_plot.layout.min_width = this.parent_plot._base_layout.min_width;
        }

        this.updateSplitTrackAxis();
        return this;
      } // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are
      //  using explicitly provided itemRgb information

    }, {
      key: "_makeColorScheme",
      value: function _makeColorScheme(category_info) {
        // If at least one element has an explicit itemRgb, assume the entire dataset has colors
        var has_explicit_colors = category_info.find(function (item) {
          return item[2];
        });

        if (has_explicit_colors) {
          return category_info.map(function (item) {
            return item[2];
          });
        } // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:
        //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html
        // These are actually reversed so that dim colors come first, on the premise that usually these are the
        //  most common states


        var n_categories = category_info.length;

        if (n_categories <= 15) {
          return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        } else if (n_categories <= 18) {
          return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        } else {
          // If there are more than 25 categories, the interval layer will fall back to the 'null value' option
          return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        }
      }
      /**
       * Find all of the unique tracks (a combination of name and ID information)
       * @param {Object} data
       * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column
       * @private
       * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings
       *  most unambiguously.
       */

    }, {
      key: "_generateCategoriesFromData",
      value: function _generateCategoriesFromData(data, rgb_field) {
        var _this8 = this;

        var self = this; // Use the hard-coded legend if available (ignoring any mods on re-render)

        var legend = this._base_layout.legend;

        if (legend && legend.length) {
          return legend.map(function (item) {
            return [item[_this8.layout.track_split_field], item.label, item.color];
          });
        } // Generate options from data, if no preset legend exists


        var unique_ids = {}; // make categories unique

        var categories = [];
        data.forEach(function (item) {
          var id = item[self.layout.track_split_field];

          if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {
            unique_ids[id] = null; // If rgbfield is null, then the last entry is undefined/null as well

            categories.push([id, item[_this8.layout.track_label_field], item[rgb_field]]);
          }
        });
        return categories;
      }
    }]);

    return LzIntervalsTrack;
  }(BaseLayer);

  var intervals_tooltip_layout = {
    namespace: {
      'intervals': 'intervals'
    },
    closable: false,
    show: {
      or: ['highlighted', 'selected']
    },
    hide: {
      and: ['unhighlighted', 'unselected']
    },
    html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}'
  };
  var intervals_layer_layout = {
    namespace: {
      'intervals': 'intervals'
    },
    id: 'intervals',
    type: 'intervals',
    fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],
    id_field: '{{namespace[intervals]}}start',
    start_field: '{{namespace[intervals]}}start',
    end_field: '{{namespace[intervals]}}end',
    track_split_field: '{{namespace[intervals]}}state_name',
    track_label_field: '{{namespace[intervals]}}state_name',
    split_tracks: false,
    always_hide_legend: true,
    color: [{
      // If present, an explicit color field will override any other option (and be used to auto-generate legend)
      field: '{{namespace[intervals]}}itemRgb',
      scale_function: 'to_rgb'
    }, {
      field: '{{namespace[intervals]}}state_name',
      scale_function: 'categorical_bin',
      parameters: {
        // Placeholder. Empty categories and values will automatically be filled in when new data loads.
        categories: [],
        values: [],
        null_value: '#B8B8B8'
      }
    }],
    legend: [],
    // Placeholder; auto-filled when data loads.
    behaviors: {
      onmouseover: [{
        action: 'set',
        status: 'highlighted'
      }],
      onmouseout: [{
        action: 'unset',
        status: 'highlighted'
      }],
      onclick: [{
        action: 'toggle',
        status: 'selected',
        exclusive: true
      }],
      onshiftclick: [{
        action: 'toggle',
        status: 'selected'
      }]
    },
    tooltip: intervals_tooltip_layout
  };
  var intervals_panel_layout = {
    id: 'intervals',
    width: 1000,
    height: 50,
    min_width: 500,
    min_height: 50,
    margin: {
      top: 25,
      right: 150,
      bottom: 5,
      left: 50
    },
    toolbar: function () {
      var l = LocusZoom.Layouts.get('toolbar', 'standard_panel', {
        unnamespaced: true
      });
      l.widgets.push({
        type: 'toggle_split_tracks',
        data_layer_id: 'intervals',
        position: 'right'
      });
      return l;
    }(),
    axes: {},
    interaction: {
      drag_background_to_pan: true,
      scroll_to_zoom: true,
      x_linked: true
    },
    legend: {
      hidden: true,
      orientation: 'horizontal',
      origin: {
        x: 50,
        y: 0
      },
      pad_from_bottom: 5
    },
    data_layers: [intervals_layer_layout]
  };
  var intervals_plot_layout = {
    state: {},
    width: 800,
    height: 550,
    responsive_resize: true,
    min_region_scale: 20000,
    max_region_scale: 1000000,
    toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', {
      unnamespaced: true
    }),
    panels: [LocusZoom.Layouts.get('panel', 'association', {
      unnamespaced: true,
      width: 800,
      proportional_height: 225 / 570
    }), Object.assign({
      unnamespaced: true,
      proportional_height: 120 / 570
    }, intervals_panel_layout), LocusZoom.Layouts.get('panel', 'genes', {
      unnamespaced: true,
      width: 800,
      proportional_height: 225 / 570
    })]
  };
  LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);
  LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);
  LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);
  LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);
  LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);
  LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);
  LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);
  LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);
}

if (typeof LocusZoom !== 'undefined') {
  // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
  // eslint-disable-next-line no-undef
  LocusZoom.use(install);
}

/* harmony default export */ __webpack_exports__["default"] = (install);

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1pbnRlcnZhbHMtdHJhY2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6WyJpbnN0YWxsIiwiTG9jdXNab29tIiwiQmFzZUFwaUFkYXB0ZXIiLCJBZGFwdGVycyIsImdldCIsIl9CdXR0b24iLCJXaWRnZXRzIiwiX0Jhc2VXaWRnZXQiLCJJbnRlcnZhbExaIiwic3RhdGUiLCJjaGFpbiIsImZpZWxkcyIsInNvdXJjZSIsImhlYWRlciIsImJlZHRyYWNrc291cmNlIiwicGFyYW1zIiwicXVlcnkiLCJjaHIiLCJlbmQiLCJzdGFydCIsInVybCIsIlRvZ2dsZVNwbGl0VHJhY2tzIiwibGF5b3V0IiwiYXJndW1lbnRzIiwiZGF0YV9sYXllcl9pZCIsInBhcmVudF9wYW5lbCIsImRhdGFfbGF5ZXJzIiwiRXJyb3IiLCJkYXRhX2xheWVyIiwiaHRtbCIsInNwbGl0X3RyYWNrcyIsImJ1dHRvbiIsInNldEh0bWwiLCJzaG93IiwicGFyZW50IiwicG9zaXRpb24iLCJzZXRDb2xvciIsImNvbG9yIiwic2V0VGl0bGUiLCJzZXRPbmNsaWNrIiwidG9nZ2xlU3BsaXRUcmFja3MiLCJzY2FsZV90aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInNjYWxlSGVpZ2h0VG9EYXRhIiwicGFyZW50X3Bsb3QiLCJwb3NpdGlvblBhbmVscyIsInVwZGF0ZSIsInRvX3JnYiIsInBhcmFtZXRlcnMiLCJ2YWx1ZSIsImRlZmF1bHRfbGF5b3V0Iiwic3RhcnRfZmllbGQiLCJlbmRfZmllbGQiLCJ0cmFja19sYWJlbF9maWVsZCIsInRyYWNrX3NwbGl0X2ZpZWxkIiwidHJhY2tfc3BsaXRfb3JkZXIiLCJ0cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzIiwidHJhY2tfaGVpZ2h0IiwidHJhY2tfdmVydGljYWxfc3BhY2luZyIsImJvdW5kaW5nX2JveF9wYWRkaW5nIiwiYWx3YXlzX2hpZGVfbGVnZW5kIiwiZmlsbF9vcGFjaXR5IiwidG9vbHRpcF9wb3NpdGlvbmluZyIsIkJhc2VMYXllciIsIkRhdGFMYXllcnMiLCJMekludGVydmFsc1RyYWNrIiwiTGF5b3V0cyIsIm1lcmdlIiwidHJhY2tzIiwicHJldmlvdXNfdHJhY2tzIiwiaW50ZXJ2YWxfdHJhY2tfaW5kZXgiLCJlbGVtZW50IiwiZ2V0QmFzZUlkIiwicmVwbGFjZSIsImdldEVsZW1lbnRJZCIsInNlbGYiLCJiYXNlX2xheW91dCIsIl9iYXNlX2xheW91dCIsInJlbmRlcl9sYXlvdXQiLCJiYXNlX2NvbG9yX3NjYWxlIiwiZmluZCIsIml0ZW0iLCJzY2FsZV9mdW5jdGlvbiIsImNvbG9yX3NjYWxlIiwiaGFzX2NvbG9ycyIsImNhdGVnb3JpZXMiLCJsZW5ndGgiLCJ2YWx1ZXMiLCJoYXNfbGVnZW5kIiwibGVnZW5kIiwicmdiX29wdGlvbiIsInJnYl9maWVsZCIsImZpZWxkIiwia25vd25fY2F0ZWdvcmllcyIsIl9nZW5lcmF0ZUNhdGVnb3JpZXNGcm9tRGF0YSIsImRhdGEiLCJjb2xvcnMiLCJfbWFrZUNvbG9yU2NoZW1lIiwibWFwIiwicGFpciIsImluZGV4IiwiaWQiLCJsYWJlbCIsIml0ZW1fY29sb3IiLCJzaGFwZSIsIndpZHRoIiwiX2FwcGx5TGF5b3V0T3B0aW9ucyIsInRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4IiwiZm9yRWFjaCIsImQiLCJPYmplY3QiLCJrZXlzIiwicmV2ZXJzZSIsInZhbCIsImkiLCJkaXNwbGF5X3JhbmdlIiwieF9zY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJkaXNwbGF5X2RvbWFpbiIsImludmVydCIsInRyYWNrIiwicHVzaCIsInBvdGVudGlhbF90cmFjayIsImNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2siLCJwbGFjZWRfaW50ZXJ2YWwiLCJtaW5fc3RhcnQiLCJtYXhfZW5kIiwiYmluZCIsImFzc2lnblRyYWNrcyIsInRyYWNrX2RhdGEiLCJfYXBwbHlGaWx0ZXJzIiwic3ZnIiwiZ3JvdXAiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJrZXkiLCJwc2V1ZG9FbGVtZW50IiwiaW5zZXJ0IiwiYXR0ciIsImdldEVsZW1lbnRTdGF0dXNOb2RlSWQiLCJjbGlwYXJlYSIsImdldFRyYWNrSGVpZ2h0Iiwic3R5bGUiLCJzZWxlY3Rpb24iLCJpZF9maWVsZCIsImVudGVyIiwiYXBwZW5kIiwiZWFjaCIsImludGVydmFsIiwic3RhdHVzbm9kZXMiLCJkMyIsImV4aXQiLCJyZWN0cyIsInJlc29sdmVTY2FsYWJsZVBhcmFtZXRlciIsImNsaWNrYXJlYXMiLCJpbnRlcnZhbF9uYW1lIiwib24iLCJlbGVtZW50X2RhdGEiLCJlbWl0IiwiY2FsbCIsImFwcGx5QmVoYXZpb3JzIiwicmVuZGVyIiwidG9vbHRpcCIsImludGVydmFsX2Jib3giLCJub2RlIiwiZ2V0QkJveCIsInhfbWluIiwieF9tYXgiLCJ5X21pbiIsInkiLCJ5X21heCIsImhlaWdodCIsImxlZ2VuZF9heGlzIiwidHJhY2tfc3BhY2luZyIsInRhcmdldF9oZWlnaHQiLCJoaWRlIiwiYXhlcyIsInRpY2tzIiwicmFuZ2UiLCJhYnMiLCJ0ZXh0IiwieV9heGlzIiwiYXhpcyIsImZsb29yIiwiY2VpbGluZyIsIm1hcmdpbiIsImJvdHRvbSIsIm1pbl9oZWlnaHQiLCJtaW5fd2lkdGgiLCJ1cGRhdGVTcGxpdFRyYWNrQXhpcyIsImNhdGVnb3J5X2luZm8iLCJoYXNfZXhwbGljaXRfY29sb3JzIiwibl9jYXRlZ29yaWVzIiwidW5pcXVlX2lkcyIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaW50ZXJ2YWxzX3Rvb2x0aXBfbGF5b3V0IiwibmFtZXNwYWNlIiwiY2xvc2FibGUiLCJvciIsImFuZCIsImludGVydmFsc19sYXllcl9sYXlvdXQiLCJ0eXBlIiwibnVsbF92YWx1ZSIsImJlaGF2aW9ycyIsIm9ubW91c2VvdmVyIiwiYWN0aW9uIiwic3RhdHVzIiwib25tb3VzZW91dCIsIm9uY2xpY2siLCJleGNsdXNpdmUiLCJvbnNoaWZ0Y2xpY2siLCJpbnRlcnZhbHNfcGFuZWxfbGF5b3V0IiwidG9wIiwicmlnaHQiLCJsZWZ0IiwidG9vbGJhciIsImwiLCJ1bm5hbWVzcGFjZWQiLCJ3aWRnZXRzIiwiaW50ZXJhY3Rpb24iLCJkcmFnX2JhY2tncm91bmRfdG9fcGFuIiwic2Nyb2xsX3RvX3pvb20iLCJ4X2xpbmtlZCIsImhpZGRlbiIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwieCIsInBhZF9mcm9tX2JvdHRvbSIsImludGVydmFsc19wbG90X2xheW91dCIsInJlc3BvbnNpdmVfcmVzaXplIiwibWluX3JlZ2lvbl9zY2FsZSIsIm1heF9yZWdpb25fc2NhbGUiLCJwYW5lbHMiLCJwcm9wb3J0aW9uYWxfaGVpZ2h0IiwiYXNzaWduIiwiYWRkIiwiU2NhbGVGdW5jdGlvbnMiLCJ1c2UiXSwibWFwcGluZ3MiOiI7OztRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7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QXRCLEVBQTZDMU4saUJBQTdDO0FBQ0g7O0FBRUQsSUFBSSxPQUFPcEIsU0FBUCxLQUFxQixXQUF6QixFQUFzQztBQUNsQztBQUNBO0FBQ0FBLFdBQVMsQ0FBQ2dQLEdBQVYsQ0FBY2pQLE9BQWQ7QUFDSDs7QUFHY0Esc0VBQWYsRTs7Ozs7Ozs7Ozs7QUN2c0JBLG9CIiwiZmlsZSI6ImV4dC9sei1pbnRlcnZhbHMtdHJhY2subWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9lc20vZXh0L2x6LWludGVydmFscy10cmFjay5qc1wiKTtcbiIsIi8qKlxuSW50ZXJ2YWwgYW5ub3RhdGlvbiB0cmFjayAoZm9yIGNocm9tYXRpbiBzdGF0ZSwgZXRjKS4gVXNlZnVsIGZvciBCRUQgZmlsZSBkYXRhIHdpdGggbm9uLW92ZXJsYXBwaW5nIGludGVydmFscy5cblRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIGNvcmUgTG9jdXNab29tIGxpYnJhcnksIGJ1dCBjYW4gYmUgaW5jbHVkZWQgYXMgYSBzdGFuZGFsb25lIGZpbGUuXG5cblRoZSBwYWdlIG11c3QgaW5jb3Jwb3JhdGUgYW5kIGxvYWQgYWxsIGxpYnJhcmllcyBiZWZvcmUgdGhpcyBmaWxlIGNhbiBiZSB1c2VkLCBpbmNsdWRpbmc6XG4gLSBWZW5kb3IgYXNzZXRzXG4gLSBMb2N1c1pvb21cbiBAbW9kdWxlXG4qL1xuXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cblxuZnVuY3Rpb24gaW5zdGFsbCAoTG9jdXNab29tKSB7XG4gICAgY29uc3QgQmFzZUFwaUFkYXB0ZXIgPSBMb2N1c1pvb20uQWRhcHRlcnMuZ2V0KCdCYXNlQXBpQWRhcHRlcicpO1xuICAgIGNvbnN0IF9CdXR0b24gPSBMb2N1c1pvb20uV2lkZ2V0cy5nZXQoJ19CdXR0b24nKTtcbiAgICBjb25zdCBfQmFzZVdpZGdldCA9IExvY3VzWm9vbS5XaWRnZXRzLmdldCgnQmFzZVdpZGdldCcpO1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBTb3VyY2UgZm9yIEludGVydmFsIEFubm90YXRpb24gRGF0YSAoZS5nLiBCRUQgVHJhY2tzKSwgYXMgZmV0Y2hlZCBmcm9tIHRoZSBMb2N1c1pvb20gQVBJIHNlcnZlciAob3IgY29tcGF0aWJsZSlcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgSW50ZXJ2YWxMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICAgICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjaGFpbi5oZWFkZXIuYmVkdHJhY2tzb3VyY2UgfHwgdGhpcy5wYXJhbXMuc291cmNlO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBgP2ZpbHRlcj1pZCBpbiAke3NvdXJjZX0gYW5kIGNocm9tb3NvbWUgZXEgJyR7c3RhdGUuY2hyfScgYW5kIHN0YXJ0IGxlICR7c3RhdGUuZW5kfSBhbmQgZW5kIGdlICR7c3RhdGUuc3RhcnR9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnVybH0ke3F1ZXJ5fWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdXR0b24gdG8gdG9nZ2xlIHNwbGl0IHRyYWNrc1xuICAgICAqL1xuICAgIGNsYXNzIFRvZ2dsZVNwbGl0VHJhY2tzIGV4dGVuZHMgX0Jhc2VXaWRnZXQge1xuICAgICAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIWxheW91dC5kYXRhX2xheWVyX2lkKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0LmRhdGFfbGF5ZXJfaWQgPSAnaW50ZXJ2YWxzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcnNbbGF5b3V0LmRhdGFfbGF5ZXJfaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2dnbGUgc3BsaXQgdHJhY2tzIHdpZGdldCBzcGVjaWZpZXMgYW4gaW52YWxpZCBkYXRhIGxheWVyIElEJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gdGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcnNbdGhpcy5sYXlvdXQuZGF0YV9sYXllcl9pZF07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gZGF0YV9sYXllci5sYXlvdXQuc3BsaXRfdHJhY2tzID8gJ01lcmdlIFRyYWNrcycgOiAnU3BsaXQgVHJhY2tzJztcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnNldEh0bWwoaHRtbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gbmV3IF9CdXR0b24odGhpcylcbiAgICAgICAgICAgICAgICAgICAgLnNldENvbG9yKHRoaXMubGF5b3V0LmNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAuc2V0SHRtbChodG1sKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VGl0bGUoJ1RvZ2dsZSB3aGV0aGVyIHRyYWNrcyBhcmUgc3BsaXQgYXBhcnQgb3IgbWVyZ2VkIHRvZ2V0aGVyJylcbiAgICAgICAgICAgICAgICAgICAgLnNldE9uY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9sYXllci50b2dnbGVTcGxpdFRyYWNrcygpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlX3RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY2FsZV90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgY2FuIG92ZXJyaWRlIGNoYW5nZXMgbWFkZSBpbiB0b2dnbGVTcGxpdFRyYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3BhbmVsLnNjYWxlSGVpZ2h0VG9EYXRhKCk7IC8vIERFRkVDVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QucG9zaXRpb25QYW5lbHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmFsdWUgXCJcInJyLGdnLGJiXCIgKGlmIGdpdmVuKSB0byBhIGNzcy1mcmllbmRseSBjb2xvciBzdHJpbmc6IFwicmdiKHJyLGdnLGJiKVwiLlxuICAgICAqIFRoaXMgaXMgdGFpbG9yZWQgc3BlY2lmaWNhbGx5IHRvIHRoZSBjb2xvciBzcGVjaWZpY2F0aW9uIGZvcm1hdCBlbWJyYWNlZCBieSB0aGUgQkVEIGZpbGUgc3RhbmRhcmQuXG4gICAgICogQGZ1bmN0aW9uIHRvX3JnYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIFRoaXMgZnVuY3Rpb24gaGFzIG5vIGRlZmluZWQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gcmdiXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9fcmdiKHBhcmFtZXRlcnMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGByZ2IoJHt2YWx1ZX0pYCA6IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdF9sYXlvdXQgPSB7XG4gICAgICAgIHN0YXJ0X2ZpZWxkOiAnc3RhcnQnLFxuICAgICAgICBlbmRfZmllbGQ6ICdlbmQnLFxuICAgICAgICB0cmFja19sYWJlbF9maWVsZDogJ3N0YXRlX25hbWUnLCAvLyBVc2VkIHRvIGxhYmVsIGl0ZW1zIG9uIHRoZSB5LWF4aXNcbiAgICAgICAgLy8gVXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSB0cmFja3MgZm9yIGNvbG9yaW5nLiBUaGlzIHRlbmRzIHRvIGxlYWQgdG8gbW9yZSBzdGFibGUgY29sb3Jpbmcvc29ydGluZ1xuICAgICAgICAvLyAgdGhhbiB1c2luZyB0aGUgbGFiZWwgZmllbGQtIGVnLCBzdGF0ZV9pZHMgYWxsb3cgdXMgdG8gc2V0IGdsb2JhbCBjb2xvcnMgYWNyb3NzIHRoZSBlbnRpcmUgZGF0YXNldCxcbiAgICAgICAgLy8gIG5vdCBqdXN0IGNob29zZSB1bmlxdWUgY29sb3JzIHdpdGhpbiBhIHBhcnRpY3VsYXIgbmFycm93IHJlZ2lvbi4gKHdoZXJlIGNoYW5naW5nIHJlZ2lvbiBtaWdodCBsZWFkIHRvIG1vcmVcbiAgICAgICAgLy8gIGNhdGVnb3JpZXMgYW5kIGRpZmZlcmVudCBjb2xvcnMpXG4gICAgICAgIHRyYWNrX3NwbGl0X2ZpZWxkOiAnc3RhdGVfaWQnLFxuICAgICAgICB0cmFja19zcGxpdF9vcmRlcjogJ0RFU0MnLFxuICAgICAgICB0cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzOiAyLFxuICAgICAgICBzcGxpdF90cmFja3M6IHRydWUsXG4gICAgICAgIHRyYWNrX2hlaWdodDogMTUsXG4gICAgICAgIHRyYWNrX3ZlcnRpY2FsX3NwYWNpbmc6IDMsXG4gICAgICAgIGJvdW5kaW5nX2JveF9wYWRkaW5nOiAyLFxuICAgICAgICBhbHdheXNfaGlkZV9sZWdlbmQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJyNCOEI4QjgnLFxuICAgICAgICBmaWxsX29wYWNpdHk6IDEsXG4gICAgICAgIHRvb2x0aXBfcG9zaXRpb25pbmc6ICd2ZXJ0aWNhbCcsXG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJ2YWxzIERhdGEgTGF5ZXJcbiAgICAgKiBJbXBsZW1lbnRzIGEgZGF0YSBsYXllciB0aGF0IHdpbGwgcmVuZGVyIGludGVydmFsIGFubm90YXRpb24gdHJhY2tzIChpbnRlcnZhbHMgbXVzdCBwcm92aWRlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzKVxuICAgICAqL1xuICAgIGNvbnN0IEJhc2VMYXllciA9IExvY3VzWm9vbS5EYXRhTGF5ZXJzLmdldCgnQmFzZURhdGFMYXllcicpO1xuICAgIGNsYXNzIEx6SW50ZXJ2YWxzVHJhY2sgZXh0ZW5kcyBCYXNlTGF5ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLm1lcmdlKGxheW91dCwgZGVmYXVsdF9sYXlvdXQpO1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzID0gMTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNfdHJhY2tzID0gMTtcblxuICAgICAgICAgICAgLy8gdHJhY2stbnVtYmVyLWluZGV4ZWQgb2JqZWN0IHdpdGggYXJyYXlzIG9mIGludGVydmFsIGluZGV4ZXMgaW4gdGhlIGRhdGFzZXRcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxfdHJhY2tfaW5kZXggPSB7IDE6IFtdIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVG8gZGVmaW5lIHNoYXJlZCBoaWdobGlnaHRpbmcgb24gdGhlIHRyYWNrIHNwbGl0IGZpZWxkIGRlZmluZSB0aGUgc3RhdHVzIG5vZGUgaWQgb3ZlcnJpZGVcbiAgICAgICAgICogdG8gZ2VuZXJhdGUgYW4gSUQgY29tbW9uIHRvIHRoZSB0cmFjayB3aGVuIHdlJ3JlIGFjdGl2ZWx5IHNwbGl0dGluZyBkYXRhIG91dCB0byBzZXBhcmF0ZSB0cmFja3NcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbGVtZW50U3RhdHVzTm9kZUlkKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGAke3RoaXMuZ2V0QmFzZUlkKCl9LXN0YXR1c25vZGUtJHtlbGVtZW50W3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXX1gKS5yZXBsYWNlKC9bXlxcd10vZywgJ18nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEVsZW1lbnRJZChlbGVtZW50KX0tc3RhdHVzbm9kZWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gc3VtIGxheW91dCB2YWx1ZXMgdG8gZGVyaXZlIHRvdGFsIGhlaWdodCBmb3IgYSBzaW5nbGUgaW50ZXJ2YWwgdHJhY2tcbiAgICAgICAgZ2V0VHJhY2tIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQudHJhY2tfaGVpZ2h0XG4gICAgICAgICAgICAgICAgKyB0aGlzLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nXG4gICAgICAgICAgICAgICAgKyAoMiAqIHRoaXMubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vZGlmeSB0aGUgbGF5b3V0IGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBhcHByb3ByaWF0ZSBjb2xvciwgbGFiZWwsIGFuZCBsZWdlbmQgb3B0aW9ucyBhcmUgYXZhaWxhYmxlXG4gICAgICAgIC8vIEV2ZW4gd2hlbiBub3QgZGlzcGxheWVkLCB0aGUgbGVnZW5kIGlzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHktYXhpcyB0aWNrc1xuICAgICAgICBfYXBwbHlMYXlvdXRPcHRpb25zKCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBiYXNlX2xheW91dCA9IHRoaXMuX2Jhc2VfbGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyX2xheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgYmFzZV9jb2xvcl9zY2FsZSA9IGJhc2VfbGF5b3V0LmNvbG9yLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zY2FsZV9mdW5jdGlvbiAmJiBpdGVtLnNjYWxlX2Z1bmN0aW9uID09PSAnY2F0ZWdvcmljYWxfYmluJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29sb3Jfc2NhbGUgPSByZW5kZXJfbGF5b3V0LmNvbG9yLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zY2FsZV9mdW5jdGlvbiAmJiBpdGVtLnNjYWxlX2Z1bmN0aW9uID09PSAnY2F0ZWdvcmljYWxfYmluJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFiYXNlX2NvbG9yX3NjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gYmUgYSBwbGFjZWhvbGRlciAoZW1wdHkgY2F0ZWdvcmllcyAmIHZhbHVlcyksIGJ1dCBpdCBuZWVkcyB0byBiZSB0aGVyZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJ2YWwgdHJhY2tzIG11c3QgZGVmaW5lIGEgYGNhdGVnb3JpY2FsX2JpbmAgY29sb3Igc2NhbGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaGFzX2NvbG9ycyA9IGJhc2VfY29sb3Jfc2NhbGUucGFyYW1ldGVycy5jYXRlZ29yaWVzLmxlbmd0aCAmJiBiYXNlX2NvbG9yX3NjYWxlLnBhcmFtZXRlcnMudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhhc19sZWdlbmQgPSBiYXNlX2xheW91dC5sZWdlbmQgJiYgYmFzZV9sYXlvdXQubGVnZW5kLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCEhaGFzX2NvbG9ycyBeICEhaGFzX2xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGFsbG93IGNvbG9yIE9SIGxlZ2VuZCB0byBiZSBzZXQgbWFudWFsbHkuIEl0IG11c3QgYmUgYm90aCwgb3IgbmVpdGhlci5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSBhIG1hbnVhbGx5IHNwZWNpZmllZCBjb2xvciBzY2hlbWUsIGJvdGggY29sb3IgYW5kIGxlZ2VuZCBvcHRpb25zIG11c3QgYmUgc2V0LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYXJ2ZXN0IGFueSBpbmZvcm1hdGlvbiBhYm91dCBhbiBleHBsaWNpdCBjb2xvciBmaWVsZCB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHdoZW4gZ2VuZXJhdGluZyBjb2xvcnNcbiAgICAgICAgICAgIGNvbnN0IHJnYl9vcHRpb24gPSBiYXNlX2xheW91dC5jb2xvci5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc2NhbGVfZnVuY3Rpb24gJiYgaXRlbS5zY2FsZV9mdW5jdGlvbiA9PT0gJ3RvX3JnYic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJnYl9maWVsZCA9IHJnYl9vcHRpb24gJiYgcmdiX29wdGlvbi5maWVsZDtcblxuICAgICAgICAgICAgLy8gQXV0by1nZW5lcmF0ZSBsZWdlbmQgYmFzZWQgb24gZGF0YVxuICAgICAgICAgICAgY29uc3Qga25vd25fY2F0ZWdvcmllcyA9IHRoaXMuX2dlbmVyYXRlQ2F0ZWdvcmllc0Zyb21EYXRhKHRoaXMuZGF0YSwgcmdiX2ZpZWxkKTsgLy8gW2lkLCBsYWJlbCwgaXRlbVJnYl0gaXRlbXNcblxuICAgICAgICAgICAgaWYgKCFoYXNfY29sb3JzICYmICFoYXNfbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gY29sb3Igc2NoZW1lIHByZS1kZWZpbmVkLCB0aGVuIG1ha2UgYSBjb2xvciBzY2hlbWUgdGhhdCBpcyBhcHByb3ByaWF0ZSBhbmQgYXBwbHkgdG8gdGhlIHBsb3RcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGVnZW5kIG11c3QgbWF0Y2ggdGhlIGNvbG9yIHNjaGVtZS4gSWYgd2UgZ2VuZXJhdGUgb25lLCB0aGVuIHdlIG11c3QgZ2VuZXJhdGUgYm90aC5cblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX21ha2VDb2xvclNjaGVtZShrbm93bl9jYXRlZ29yaWVzKTtcbiAgICAgICAgICAgICAgICBjb2xvcl9zY2FsZS5wYXJhbWV0ZXJzLmNhdGVnb3JpZXMgPSBrbm93bl9jYXRlZ29yaWVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVswXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2xvcl9zY2FsZS5wYXJhbWV0ZXJzLnZhbHVlcyA9IGNvbG9ycztcblxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmxlZ2VuZCA9IGtub3duX2NhdGVnb3JpZXMubWFwKGZ1bmN0aW9uIChwYWlyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHBhaXJbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gcGFpclsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbV9jb2xvciA9IGNvbG9yX3NjYWxlLnBhcmFtZXRlcnMudmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHsgc2hhcGU6ICdyZWN0Jywgd2lkdGg6IDksIGxhYmVsOiBsYWJlbCwgY29sb3I6IGl0ZW1fY29sb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtzZWxmLmxheW91dC50cmFja19zcGxpdF9maWVsZF0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZnRlciB3ZSd2ZSBsb2FkZWQgaW50ZXJ2YWwgZGF0YSBpbnRlcnByZXQgaXQgdG8gYXNzaWduXG4gICAgICAgIC8vIGVhY2ggdG8gYSB0cmFjayBzbyB0aGF0IHRoZXkgZG8gbm90IG92ZXJsYXAgaW4gdGhlIHZpZXdcbiAgICAgICAgYXNzaWduVHJhY2tzKCkge1xuICAgICAgICAgICAgLy8gQXV0b2dlbmVyYXRlIGxheW91dCBvcHRpb25zIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRPcHRpb25zKCk7XG5cbiAgICAgICAgICAgIC8vIFJlaW5pdGlhbGl6ZSBzb21lIG1ldGFkYXRhXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzX3RyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgICAgICAgICAgdGhpcy50cmFja3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleCA9IHsgMTogW10gfTtcbiAgICAgICAgICAgIC8vIFRoaXMgbWFwcyB1bmlxdWUgdmFsdWVzIG9mIHRyYWNrX3NwbGl0X2ZpZWxkIHRvIHVuaXF1ZSB5IGluZGljZXMuIEl0IGNvbnRyb2xzIHRoZSBvcmRlcmluZyBvZiBzZXBhcmF0ZSB0cmFja3MuXG4gICAgICAgICAgICB0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4ID0ge307XG5cbiAgICAgICAgICAgIC8vIElmIHNwbGl0dGluZyB0cmFja3MgYnkgYSBmaWVsZCdzIHZhbHVlIHRoZW4gZGV0ZXJtaW5lIGhvdyB0byBvcmRlciB0aGVtLiBUaGVyZSBhcmUgdHdvIG9wdGlvbnMgaGVyZTpcbiAgICAgICAgICAgIC8vIGEpIG51bWVyaWMgSURzIGdldCBzb3J0ZWQgaW4gbnVtZXJpYyBvcmRlciAoSlMgcXVpcms6IGludCBvYmplY3Qga2V5cyBhY3QgbGlrZSBhcnJheSBpbmRpY2VzKSwgb3JcbiAgICAgICAgICAgIC8vIGIpIHRleHQgbGFiZWxzIGdldCBzb3J0ZWQgYmFzZWQgb24gb3JkZXIgaW4gdGhlIHNvdXJjZSBkYXRhIChoYXNoIHByZXNlcnZlcyBpbnNlcnRpb24gb3JkZXIpXG4gICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGQgJiYgdGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFtkW3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gT2JqZWN0LmtleXModGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X29yZGVyID09PSAnREVTQycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleC5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFt2YWxdID0gdGhpcy50cmFja3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4W3RoaXMudHJhY2tzICsgMV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja3MrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3Rhc2ggYSBwYXJlbnQgcmVmZXJlbmNlIG9uIHRoZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGRpc3BsYXkgcmFuZ2Ugc3RhcnQgYW5kIGVuZCwgYmFzZWQgb24gbWluaW11bSBhbGxvd2FibGUgaW50ZXJ2YWwgZGlzcGxheSB3aWR0aCxcbiAgICAgICAgICAgICAgICAvLyBib3VuZGVkIGJ5IHdoYXQgd2UgY2FuIHNlZSAocmFuZ2U6IHZhbHVlcyBpbiB0ZXJtcyBvZiBwaXhlbHMgb24gdGhlIHNjcmVlbilcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0uZGlzcGxheV9yYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucGFyZW50Lnhfc2NhbGUoTWF0aC5tYXgoZFt0aGlzLmxheW91dC5zdGFydF9maWVsZF0sIHRoaXMuc3RhdGUuc3RhcnQpKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAgIHRoaXMucGFyZW50Lnhfc2NhbGUoTWF0aC5taW4oZFt0aGlzLmxheW91dC5lbmRfZmllbGRdLCB0aGlzLnN0YXRlLmVuZCkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLmRpc3BsYXlfcmFuZ2Uud2lkdGggPSB0aGlzLmRhdGFbaV0uZGlzcGxheV9yYW5nZS5lbmQgLSB0aGlzLmRhdGFbaV0uZGlzcGxheV9yYW5nZS5zdGFydDtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYW5kIHN0YXNoIGRpc3BsYXkgcmFuZ2UgdmFsdWVzIGludG8gZG9tYWluIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIChkb21haW46IHZhbHVlcyBpbiB0ZXJtcyBvZiB0aGUgZGF0YSBzZXQsIGUuZy4gbWVnYWJhc2VzKVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS5kaXNwbGF5X2RvbWFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucGFyZW50Lnhfc2NhbGUuaW52ZXJ0KHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAgIHRoaXMucGFyZW50Lnhfc2NhbGUuaW52ZXJ0KHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0uZGlzcGxheV9kb21haW4ud2lkdGggPSB0aGlzLmRhdGFbaV0uZGlzcGxheV9kb21haW4uZW5kIC0gdGhpcy5kYXRhW2ldLmRpc3BsYXlfZG9tYWluLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3BsaXR0aW5nIHRvIHRyYWNrcyBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhlIGRlc2lnbmF0ZWQgdHJhY2sgc3BsaXQgZmllbGRcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB3aXRoIGNvbGxpc2lvbiBkZXRlY3Rpb24gKGludGVydmFscyB3aWxsIGJlIGdyb3VwZWQgb24gdHJhY2tzXG4gICAgICAgICAgICAgICAgLy8gc29sZWx5IGJ5IHRoZSB2YWx1ZSBvZiB0cmFja19zcGxpdF9maWVsZClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGQgJiYgdGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuZGF0YVtpXVt0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS50cmFjayA9IHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXhbdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleFt0aGlzLmRhdGFbaV0udHJhY2tdLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IHNwbGl0dGluZyB0byB0cmFja3MgYmFzZWQgb24gYSBmaWVsZCB2YWx1ZSB0aGVuIGRvIHNvIGJhc2VkIG9uIGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlY3Rpb24gKGFzIGhvdyBpdCdzIGRvbmUgZm9yIGdlbmVzKS4gVXNlIGRpc3BsYXkgcmFuZ2UvZG9tYWluIGRhdGEgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFib3ZlIGFuZCBjYXN0IGVhY2ggaW50ZXJ2YWwgdG8gdHJhY2tzIHN1Y2ggdGhhdCBub25lIG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0udHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG90ZW50aWFsX3RyYWNrID0gMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuZGF0YVtpXS50cmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxfdHJhY2tfaW5kZXhbcG90ZW50aWFsX3RyYWNrXS5tYXAoZnVuY3Rpb24ocGxhY2VkX2ludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25fb25fcG90ZW50aWFsX3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbl9zdGFydCA9IE1hdGgubWluKHBsYWNlZF9pbnRlcnZhbC5kaXNwbGF5X3JhbmdlLnN0YXJ0LCB0aGlzLmRpc3BsYXlfcmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhfZW5kID0gTWF0aC5tYXgocGxhY2VkX2ludGVydmFsLmRpc3BsYXlfcmFuZ2UuZW5kLCB0aGlzLmRpc3BsYXlfcmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXhfZW5kIC0gbWluX3N0YXJ0KSA8IChwbGFjZWRfaW50ZXJ2YWwuZGlzcGxheV9yYW5nZS53aWR0aCArIHRoaXMuZGlzcGxheV9yYW5nZS53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMuZGF0YVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25fb25fcG90ZW50aWFsX3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLnRyYWNrID0gcG90ZW50aWFsX3RyYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxfdHJhY2tfaW5kZXhbcG90ZW50aWFsX3RyYWNrXS5wdXNoKHRoaXMuZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbF90cmFjaysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxfdHJhY2sgPiB0aGlzLnRyYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcyA9IHBvdGVudGlhbF90cmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleFtwb3RlbnRpYWxfdHJhY2tdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW1wbGVtZW50IHRoZSBtYWluIHJlbmRlciBmdW5jdGlvblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvLyBMYXkgb3V0IHNwYWNlIGZpcnN0XG4gICAgICAgICAgICB0aGlzLmFzc2lnblRyYWNrcygpO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBmaWx0ZXJzIHRvIG9ubHkgcmVuZGVyIGEgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMuIEhpZGRlbiBmaWVsZHMgd2lsbCBzdGlsbCBiZSBnaXZlbiBzcGFjZSB0byByZW5kZXIsIGJ1dCBub3Qgc2hvd24uXG4gICAgICAgICAgICBjb25zdCB0cmFja19kYXRhID0gdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgc2hhcmVkIGhpZ2hsaWdodCBub2RlcyBhbmQgcmUtcmVuZGVyIHRoZW0gaWYgd2UncmUgc3BsaXR0aW5nIG9uIHRyYWNrc1xuICAgICAgICAgICAgLy8gQXQgbW9zdCB0aGVyZSB3aWxsIG9ubHkgYmUgZG96ZW4gb3Igc28gbm9kZXMgaGVyZSAob25lIHBlciB0cmFjaykgYW5kIGVhY2ggdGltZVxuICAgICAgICAgICAgLy8gd2UgcmVuZGVyIGRhdGEgd2UgbWF5IGhhdmUgbmV3IHRyYWNrcywgc28gd2lwaW5nL3JlZHJhd2luZyBhbGwgaXMgcmVhc29uYWJsZS5cbiAgICAgICAgICAgIHRoaXMuc3ZnLmdyb3VwLnNlbGVjdEFsbCgnLmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUubHotZGF0YV9sYXllci1pbnRlcnZhbHMtc2hhcmVkJykucmVtb3ZlKCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgcHN1ZWRvLWVsZW1lbnQgc28gdGhhdCB3ZSBjYW4gZ2VuZXJhdGUgYW4gaWQgZm9yIHRoZSBzaGFyZWQgbm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBzZXVkb0VsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgICAgICBwc2V1ZG9FbGVtZW50W3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXSA9IGtleTtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIHNoYXJlZCBub2RlXG4gICAgICAgICAgICAgICAgdGhpcy5zdmcuZ3JvdXAuaW5zZXJ0KCdyZWN0JywgJzpmaXJzdC1jaGlsZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0RWxlbWVudFN0YXR1c05vZGVJZChwc2V1ZG9FbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzIGx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUgbHotZGF0YV9sYXllci1pbnRlcnZhbHMtc2hhcmVkJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeScsIHRoaXMubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnBhcmVudC5sYXlvdXQuY2xpcGFyZWEud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmdldFRyYWNrSGVpZ2h0KCkgLSB0aGlzLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXhba2V5XSAtIDEpICogdGhpcy5nZXRUcmFja0hlaWdodCgpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAodGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzID8gbnVsbCA6ICdub25lJykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlbmRlciBpbnRlcnZhbCBncm91cHNcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc3ZnLmdyb3VwLnNlbGVjdEFsbCgnZy5sei1kYXRhX2xheWVyLWludGVydmFscycpXG4gICAgICAgICAgICAgICAgLmRhdGEodHJhY2tfZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbdGhpcy5sYXlvdXQuaWRfZmllbGRdO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZWxlY3Rpb24uZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscycpXG4gICAgICAgICAgICAgICAgLm1lcmdlKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gdGhpcy5nZXRFbGVtZW50SWQoZCkpXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YV9sYXllciA9IGludGVydmFsLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIGludGVydmFsIHN0YXR1cyBub2RlcyAoZGlzcGxheWVkIGJlaGluZCBpbnRlcnZhbHMgdG8gc2hvdyBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBuZWVkaW5nIHRvIG1vZGlmeSBpbnRlcnZhbCBkaXNwbGF5IGVsZW1lbnQocykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c25vZGVzID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgncmVjdC5sei1kYXRhX2xheWVyLWludGVydmFscy5sei1kYXRhX2xheWVyLWludGVydmFscy1zdGF0dXNub2RlLmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUtZGlzY3JldGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2ludGVydmFsXSwgKGQpID0+IGAke2RhdGFfbGF5ZXIuZ2V0RWxlbWVudElkKGQpfS1zdGF0dXNub2RlYCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c25vZGVzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAnOmZpcnN0LWNoaWxkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscyBsei1kYXRhX2xheWVyLWludGVydmFscy1zdGF0dXNub2RlIGx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUtZGlzY3JldGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKHN0YXR1c25vZGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IGAke2RhdGFfbGF5ZXIuZ2V0RWxlbWVudElkKGQpfS1zdGF0dXNub2RlYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeCcsIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J5JywgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCBkYXRhX2xheWVyLmxheW91dC5zcGxpdF90cmFja3MgPyAnbm9uZScgOiBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS53aWR0aCArICgyICogZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGRhdGFfbGF5ZXIuZ2V0VHJhY2tIZWlnaHQoKSAtIGRhdGFfbGF5ZXIubGF5b3V0LnRyYWNrX3ZlcnRpY2FsX3NwYWNpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2Uuc3RhcnQgLSBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+ICgoZC50cmFjayAtIDEpICogZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzbm9kZXMuZXhpdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIHByaW1hcnkgaW50ZXJ2YWwgcmVjdHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdHMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdyZWN0Lmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLmx6LWludGVydmFsX3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2ludGVydmFsXSwgKGQpID0+IGAke2RbZGF0YV9sYXllci5sYXlvdXQuaWRfZmllbGRdfV9pbnRlcnZhbF9yZWN0YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVjdHMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1pbnRlcnZhbHMgbHotaW50ZXJ2YWxfcmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UocmVjdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLndpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGRhdGFfbGF5ZXIubGF5b3V0LnRyYWNrX2hlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+ICgoZC50cmFjayAtIDEpICogZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpKSArIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4gZGF0YV9sYXllci5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIoZGF0YV9sYXllci5sYXlvdXQuY29sb3IsIGQsIGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIChkLCBpKSA9PiBkYXRhX2xheWVyLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcihkYXRhX2xheWVyLmxheW91dC5maWxsX29wYWNpdHksIGQsIGkpKTtcblxuICAgICAgICAgICAgICAgICAgICByZWN0cy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgaW50ZXJ2YWwgY2xpY2sgYXJlYXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpY2thcmVhcyA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3JlY3QubHotZGF0YV9sYXllci1pbnRlcnZhbHMubHotY2xpY2thcmVhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKFtpbnRlcnZhbF0sIChkKSA9PiBgJHtkLmludGVydmFsX25hbWV9X2NsaWNrYXJlYWApO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrYXJlYXMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1pbnRlcnZhbHMgbHotY2xpY2thcmVhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tZXJnZShjbGlja2FyZWFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IGAke2RhdGFfbGF5ZXIuZ2V0RWxlbWVudElkKGQpfV9jbGlja2FyZWFgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncnknLCBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2Uud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpIC0gZGF0YV9sYXllci5sYXlvdXQudHJhY2tfdmVydGljYWxfc3BhY2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+ICgoZC50cmFjayAtIDEpICogZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGRlZmF1bHQgZXZlbnQgZW1pdHRlcnMgdG8gY2xpY2thcmVhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIChlbGVtZW50X2RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X2RhdGEucGFyZW50LnBhcmVudC5lbWl0KCdlbGVtZW50X2NsaWNrZWQnLCBlbGVtZW50X2RhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IG1vdXNlIGJlaGF2aW9ycyB0byBjbGlja2FyZWFzXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChkYXRhX2xheWVyLmFwcGx5QmVoYXZpb3JzLmJpbmQoZGF0YV9sYXllcikpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgY2xpY2thcmVhcyBhcyBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgY2xpY2thcmVhcy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gLy8gUmVtb3ZlIG9sZCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgICAgIHNlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIC8vIFVwZGF0ZSB0aGUgbGVnZW5kIGF4aXMgaWYgdGhlIG51bWJlciBvZiB0aWNrcyBjaGFuZ2VkXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5wcmV2aW91c190cmFja3MgIT09IHRoaXMudHJhY2tzKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy51cGRhdGVTcGxpdFRyYWNrQXhpcygpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyAvLyBUaGUgaW50ZXJ2YWxzIHRyYWNrIGFsbG93cyBsZWdlbmRzIHRvIGJlIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCwgaW4gd2hpY2ggY2FzZSBzcGFjZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgLy8gLy8gIGFsbG9jYXRlZCBhZnRlciB0aGUgcGFuZWwgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQubGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVnZW5kLnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRUb29sdGlwUG9zaXRpb24odG9vbHRpcCkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWxfYmJveCA9IGQzLnNlbGVjdChgIyR7dGhpcy5nZXRFbGVtZW50U3RhdHVzTm9kZUlkKHRvb2x0aXAuZGF0YSl9YCkubm9kZSgpLmdldEJCb3goKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeF9taW46IHRvb2x0aXAuZGF0YS5kaXNwbGF5X3JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIHhfbWF4OiB0b29sdGlwLmRhdGEuZGlzcGxheV9yYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgeV9taW46IGludGVydmFsX2Jib3gueSxcbiAgICAgICAgICAgICAgICB5X21heDogaW50ZXJ2YWxfYmJveC55ICsgaW50ZXJ2YWxfYmJveC5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVkcmF3IHNwbGl0IHRyYWNrIGF4aXMgb3IgaGlkZSBpdCwgYW5kIHNob3cvaGlkZSB0aGUgbGVnZW5kLCBhcyBkZXRlcm1pbmVkXG4gICAgICAgIC8vIGJ5IGN1cnJlbnQgbGF5b3V0IHBhcmFtZXRlcnMgYW5kIGRhdGFcbiAgICAgICAgdXBkYXRlU3BsaXRUcmFja0F4aXMoKSB7XG4gICAgICAgICAgICBjb25zdCBsZWdlbmRfYXhpcyA9IHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2xlZ2VuZF90b195X2F4aXMgPyBgeSR7dGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfbGVnZW5kX3RvX3lfYXhpc31gIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tzID0gK3RoaXMudHJhY2tzIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tfaGVpZ2h0ID0gK3RoaXMubGF5b3V0LnRyYWNrX2hlaWdodCB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrX3NwYWNpbmcgPSAyICogKCt0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZyB8fCAwKSArICgrdGhpcy5sYXlvdXQudHJhY2tfdmVydGljYWxfc3BhY2luZyB8fCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRfaGVpZ2h0ID0gKHRyYWNrcyAqIHRyYWNrX2hlaWdodCkgKyAoKHRyYWNrcyAtIDEpICogdHJhY2tfc3BhY2luZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2NhbGVIZWlnaHRUb0RhdGEodGFyZ2V0X2hlaWdodCk7IC8vIERFRkVDVFxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRfYXhpcyAmJiB0aGlzLnBhcmVudC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVnZW5kLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0LmF4ZXNbbGVnZW5kX2F4aXNdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlja3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogKHRhcmdldF9oZWlnaHQgLSAodGhpcy5sYXlvdXQudHJhY2tfaGVpZ2h0IC8gMikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogKHRoaXMubGF5b3V0LnRyYWNrX2hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB2ZXJ5IHRpZ2h0IGNvdXBsaW5nIGJldHdlZW4gdGhlIGRpc3BsYXkgZGlyZWN0aXZlczogZWFjaCBsZWdlbmQgaXRlbSBtdXN0IGlkZW50aWZ5IGEga2V5XG4gICAgICAgICAgICAgICAgICAgIC8vICBmaWVsZCBmb3IgdW5pcXVlIHRyYWNrcy4gKFR5cGljYWxseSB0aGlzIGlzIGBzdGF0ZV9pZGAsIHRoZSBzYW1lIGtleSBmaWVsZCB1c2VkIHRvIGFzc2lnbiB1bmlxdWUgY29sb3JzKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGlzdCBvZiB1bmlxdWUga2V5cyBjb3JyZXNwb25kcyB0byB0aGUgb3JkZXIgYWxvbmcgdGhlIHktYXhpc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5sZWdlbmQuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZWxlbWVudFt0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2sgPSB0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfb3JkZXIgPT09ICdERVNDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjayA9IE1hdGguYWJzKHRyYWNrIC0gdHJhY2tzIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dC5heGVzW2xlZ2VuZF9heGlzXS50aWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdHJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGVsZW1lbnQubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dC55X2F4aXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzOiB0aGlzLmxheW91dC50cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvb3I6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWlsaW5nOiB0cmFja3MsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LnBvc2l0aW9uUGFuZWxzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRfYXhpcyAmJiB0aGlzLnBhcmVudC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxheW91dC5hbHdheXNfaGlkZV9sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlZ2VuZC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0LmF4ZXNbbGVnZW5kX2F4aXNdID0geyByZW5kZXI6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWV0aG9kIHRvIG5vdCBvbmx5IHRvZ2dsZSB0aGUgc3BsaXQgdHJhY2tzIGJvb2xlYW4gYnV0IGFsc28gdXBkYXRlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkaXNwbGF5IHZhbHVlcyB0byBhbmltYXRlIGEgY29tcGxldGUgbWVyZ2Uvc3BsaXRcbiAgICAgICAgdG9nZ2xlU3BsaXRUcmFja3MoKSB7XG5cblxuICAgICAgICAgICAgdGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzID0gIXRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcztcblxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmxlZ2VuZCAmJiAhdGhpcy5sYXlvdXQuYWx3YXlzX2hpZGVfbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0Lm1hcmdpbi5ib3R0b20gPSA1ICsgKHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcyA/IDAgOiB0aGlzLnBhcmVudC5sZWdlbmQubGF5b3V0LmhlaWdodCArIDUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpOyAgICAgXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yY2luZyB0aGVzZSB0byBnbyB0byBvbmUgd2lsbCBjYXVzZSBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIGRpbWVuc2lvbnMgZm9yIHRoZSBwYXJlbnRfcGxvdFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3aGVuIGBzY2FsZUhlaWdodFRvRGF0YWAgcnVucywgbWluX2hlaWdodCAod2hpY2ggY2FuIGdldCBxdWl0ZSBsYXJnZSkgd2lsbCBkb21pbmF0ZSBwbG90J3NcbiAgICAgICAgICAgICAgICAvLyBsYXlvdXQgZnJvbSB1cGRhdGluZyBhbmQgY2FuIHBvdGVudGlhbGx5IGxlYWQgdG8gYSBsYXJnZSBhbW91bnQgb2Ygd2hpdGVzcGFjZSBvbiB0aGUgc2NyZWVuLCBhcyB3ZWxsIGFzIHN0cmV0Y2hpbmcgcGFuZWxzLlxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QubGF5b3V0LmhlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWluX2hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWluX3dpZHRoID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHByb3BvcnRpb25hbCBoZWlnaHRzIGFuZCB3aWR0aHNcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LnBvc2l0aW9uUGFuZWxzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBhcmVudF9wbG90LmxheW91dC5taW5faGVpZ2h0ID0gdGhpcy5wYXJlbnRfcGxvdC5fYmFzZV9sYXlvdXQubWluX2hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBhcmVudF9wbG90LmxheW91dC5taW5fd2lkdGggPSB0aGlzLnBhcmVudF9wbG90Ll9iYXNlX2xheW91dC5taW5fd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3BsaXRUcmFja0F4aXMoKTtcblxuXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8vIENob29zZSBhbiBhcHByb3ByaWF0ZSBjb2xvciBzY2hlbWUgYmFzZWQgb24gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdHJhY2ssIGFuZCB3aGV0aGVyIG9yIG5vdCB3ZSBhcmVcbiAgICAgICAgLy8gIHVzaW5nIGV4cGxpY2l0bHkgcHJvdmlkZWQgaXRlbVJnYiBpbmZvcm1hdGlvblxuICAgICAgICBfbWFrZUNvbG9yU2NoZW1lKGNhdGVnb3J5X2luZm8pIHtcbiAgICAgICAgICAgIC8vIElmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBpdGVtUmdiLCBhc3N1bWUgdGhlIGVudGlyZSBkYXRhc2V0IGhhcyBjb2xvcnNcbiAgICAgICAgICAgIGNvbnN0IGhhc19leHBsaWNpdF9jb2xvcnMgPSBjYXRlZ29yeV9pbmZvLmZpbmQoKGl0ZW0pID0+IGl0ZW1bMl0pO1xuICAgICAgICAgICAgaWYgKGhhc19leHBsaWNpdF9jb2xvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlfaW5mby5tYXAoKGl0ZW0pID0+IGl0ZW1bMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYSBzZXQgb2YgY29sb3Igc2NoZW1lcyBmb3IgY29tbW9uIDE1LCAxOCwgb3IgMjUgc3RhdGUgbW9kZWxzLCBhcyBzcGVjaWZpZWQgZnJvbTpcbiAgICAgICAgICAgIC8vICBodHRwczovL2VnZzIud3VzdGwuZWR1L3JvYWRtYXAvd2ViX3BvcnRhbC9jaHJfc3RhdGVfbGVhcm5pbmcuaHRtbFxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGFjdHVhbGx5IHJldmVyc2VkIHNvIHRoYXQgZGltIGNvbG9ycyBjb21lIGZpcnN0LCBvbiB0aGUgcHJlbWlzZSB0aGF0IHVzdWFsbHkgdGhlc2UgYXJlIHRoZVxuICAgICAgICAgICAgLy8gIG1vc3QgY29tbW9uIHN0YXRlc1xuICAgICAgICAgICAgY29uc3Qgbl9jYXRlZ29yaWVzID0gY2F0ZWdvcnlfaW5mby5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobl9jYXRlZ29yaWVzIDw9IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsncmdiKDIxMiwyMTIsMjEyKScsICdyZ2IoMTkyLDE5MiwxOTIpJywgJ3JnYigxMjgsMTI4LDEyOCknLCAncmdiKDE4OSwxODMsMTA3KScsICdyZ2IoMjMzLDE1MCwxMjIpJywgJ3JnYigyMDUsOTIsOTIpJywgJ3JnYigxMzgsMTQ1LDIwOCknLCAncmdiKDEwMiwyMDUsMTcwKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMCwxMDAsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYig1MCwyMDUsNTApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSwwLDApJ107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5fY2F0ZWdvcmllcyA8PSAxOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ3JnYigyMTIsMjEyLDIxMiknLCAncmdiKDE5MiwxOTIsMTkyKScsICdyZ2IoMTI4LDEyOCwxMjgpJywgJ3JnYigxODksMTgzLDEwNyknLCAncmdiKDIwNSw5Miw5MiknLCAncmdiKDEzOCwxNDUsMjA4KScsICdyZ2IoMTAyLDIwNSwxNzApJywgJ3JnYigyNTUsMjU1LDApJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMjU1LDE5NSw3NyknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDAsMTAwLDApJywgJ3JnYigwLDEyOCwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDAsMCknXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiAyNSBjYXRlZ29yaWVzLCB0aGUgaW50ZXJ2YWwgbGF5ZXIgd2lsbCBmYWxsIGJhY2sgdG8gdGhlICdudWxsIHZhbHVlJyBvcHRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gWydyZ2IoMjEyLDIxMiwyMTIpJywgJ3JnYigxMjgsMTI4LDEyOCknLCAncmdiKDExMiw0OCwxNjApJywgJ3JnYigyMzAsMTg0LDE4MyknLCAncmdiKDEzOCwxNDUsMjA4KScsICdyZ2IoMTAyLDIwNSwxNzApJywgJ3JnYigyNTUsMjU1LDEwMiknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwxOTUsNzcpJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMjU1LDE5NSw3NyknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDAsMTUwLDApJywgJ3JnYigwLDEyOCwwKScsICdyZ2IoMCwxMjgsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsMCwwKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgYWxsIG9mIHRoZSB1bmlxdWUgdHJhY2tzIChhIGNvbWJpbmF0aW9uIG9mIG5hbWUgYW5kIElEIGluZm9ybWF0aW9uKVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3JnYl9maWVsZF0gQSBmaWVsZCB0aGF0IGNvbnRhaW5zIGFuIFJHQiB2YWx1ZS4gQWltZWQgYXQgQkVEIGZpbGVzIHdpdGggYW4gaXRlbVJnYiBjb2x1bW5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBBbGwgW3VuaXF1ZV9pZCwgbGFiZWwsIGNvbG9yXSBwYWlycyBpbiBkYXRhLiBUaGUgdW5pcXVlX2lkIGlzIHRoZSB0aGluZyB1c2VkIHRvIGRlZmluZSBncm91cGluZ3NcbiAgICAgICAgICogIG1vc3QgdW5hbWJpZ3VvdXNseS5cbiAgICAgICAgICovXG4gICAgICAgIF9nZW5lcmF0ZUNhdGVnb3JpZXNGcm9tRGF0YShkYXRhLCByZ2JfZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBoYXJkLWNvZGVkIGxlZ2VuZCBpZiBhdmFpbGFibGUgKGlnbm9yaW5nIGFueSBtb2RzIG9uIHJlLXJlbmRlcilcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZCA9IHRoaXMuX2Jhc2VfbGF5b3V0LmxlZ2VuZDtcbiAgICAgICAgICAgIGlmIChsZWdlbmQgJiYgbGVnZW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWdlbmQubWFwKChpdGVtKSA9PiBbaXRlbVt0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZF0sIGl0ZW0ubGFiZWwsIGl0ZW0uY29sb3JdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgb3B0aW9ucyBmcm9tIGRhdGEsIGlmIG5vIHByZXNldCBsZWdlbmQgZXhpc3RzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVfaWRzID0ge307IC8vIG1ha2UgY2F0ZWdvcmllcyB1bmlxdWVcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBbXTtcblxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpdGVtW3NlbGYubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXTtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1bmlxdWVfaWRzLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlX2lkc1tpZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiByZ2JmaWVsZCBpcyBudWxsLCB0aGVuIHRoZSBsYXN0IGVudHJ5IGlzIHVuZGVmaW5lZC9udWxsIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKFtpZCwgaXRlbVt0aGlzLmxheW91dC50cmFja19sYWJlbF9maWVsZF0sIGl0ZW1bcmdiX2ZpZWxkXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfdG9vbHRpcF9sYXlvdXQgPSB7XG4gICAgICAgIG5hbWVzcGFjZTogeyAnaW50ZXJ2YWxzJzogJ2ludGVydmFscycgfSxcbiAgICAgICAgY2xvc2FibGU6IGZhbHNlLFxuICAgICAgICBzaG93OiB7IG9yOiBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJ10gfSxcbiAgICAgICAgaGlkZTogeyBhbmQ6IFsndW5oaWdobGlnaHRlZCcsICd1bnNlbGVjdGVkJ10gfSxcbiAgICAgICAgaHRtbDogJ3t7e3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhdGVfbmFtZXxodG1sZXNjYXBlfX08YnI+e3t7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGFydHxodG1sZXNjYXBlfX0te3t7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1lbmR8aHRtbGVzY2FwZX19JyxcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJ2YWxzX2xheWVyX2xheW91dCA9ICB7XG4gICAgICAgIG5hbWVzcGFjZTogeyAnaW50ZXJ2YWxzJzogJ2ludGVydmFscycgfSxcbiAgICAgICAgaWQ6ICdpbnRlcnZhbHMnLFxuICAgICAgICB0eXBlOiAnaW50ZXJ2YWxzJyxcbiAgICAgICAgZmllbGRzOiBbJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXJ0JywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWVuZCcsICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9pZCcsICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9uYW1lJywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWl0ZW1SZ2InXSxcbiAgICAgICAgaWRfZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGFydCcsXG4gICAgICAgIHN0YXJ0X2ZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhcnQnLFxuICAgICAgICBlbmRfZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1lbmQnLFxuICAgICAgICB0cmFja19zcGxpdF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICB0cmFja19sYWJlbF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICBzcGxpdF90cmFja3M6IGZhbHNlLFxuICAgICAgICBhbHdheXNfaGlkZV9sZWdlbmQ6IHRydWUsXG4gICAgICAgIGNvbG9yOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJlc2VudCwgYW4gZXhwbGljaXQgY29sb3IgZmllbGQgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgb3B0aW9uIChhbmQgYmUgdXNlZCB0byBhdXRvLWdlbmVyYXRlIGxlZ2VuZClcbiAgICAgICAgICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWl0ZW1SZ2InLFxuICAgICAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAndG9fcmdiJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9uYW1lJyxcbiAgICAgICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ2NhdGVnb3JpY2FsX2JpbicsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZWhvbGRlci4gRW1wdHkgY2F0ZWdvcmllcyBhbmQgdmFsdWVzIHdpbGwgYXV0b21hdGljYWxseSBiZSBmaWxsZWQgaW4gd2hlbiBuZXcgZGF0YSBsb2Fkcy5cbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICAgICAgICAgIG51bGxfdmFsdWU6ICcjQjhCOEI4JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kOiBbXSwgLy8gUGxhY2Vob2xkZXI7IGF1dG8tZmlsbGVkIHdoZW4gZGF0YSBsb2Fkcy5cbiAgICAgICAgYmVoYXZpb3JzOiB7XG4gICAgICAgICAgICBvbm1vdXNlb3ZlcjogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAnc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25tb3VzZW91dDogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndW5zZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbmNsaWNrOiBbXG4gICAgICAgICAgICAgICAgeyBhY3Rpb246ICd0b2dnbGUnLCBzdGF0dXM6ICdzZWxlY3RlZCcsIGV4Y2x1c2l2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uc2hpZnRjbGljazogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndG9nZ2xlJywgc3RhdHVzOiAnc2VsZWN0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiBpbnRlcnZhbHNfdG9vbHRpcF9sYXlvdXQsXG4gICAgfTtcblxuICAgIGNvbnN0IGludGVydmFsc19wYW5lbF9sYXlvdXQgPSB7XG4gICAgICAgIGlkOiAnaW50ZXJ2YWxzJyxcbiAgICAgICAgd2lkdGg6IDEwMDAsXG4gICAgICAgIGhlaWdodDogNTAsXG4gICAgICAgIG1pbl93aWR0aDogNTAwLFxuICAgICAgICBtaW5faGVpZ2h0OiA1MCxcbiAgICAgICAgbWFyZ2luOiB7IHRvcDogMjUsIHJpZ2h0OiAxNTAsIGJvdHRvbTogNSwgbGVmdDogNTAgfSxcbiAgICAgICAgdG9vbGJhcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2xiYXInLCAnc3RhbmRhcmRfcGFuZWwnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGwud2lkZ2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG9nZ2xlX3NwbGl0X3RyYWNrcycsXG4gICAgICAgICAgICAgICAgZGF0YV9sYXllcl9pZDogJ2ludGVydmFscycsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9KSgpLFxuICAgICAgICBheGVzOiB7fSxcbiAgICAgICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgICAgIGRyYWdfYmFja2dyb3VuZF90b19wYW46IHRydWUsXG4gICAgICAgICAgICBzY3JvbGxfdG9fem9vbTogdHJ1ZSxcbiAgICAgICAgICAgIHhfbGlua2VkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICBvcmlnaW46IHsgeDogNTAsIHk6IDAgfSxcbiAgICAgICAgICAgIHBhZF9mcm9tX2JvdHRvbTogNSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YV9sYXllcnM6IFtpbnRlcnZhbHNfbGF5ZXJfbGF5b3V0XSxcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJ2YWxzX3Bsb3RfbGF5b3V0ID0ge1xuICAgICAgICBzdGF0ZToge30sXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNTUwLFxuICAgICAgICByZXNwb25zaXZlX3Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgbWluX3JlZ2lvbl9zY2FsZTogMjAwMDAsXG4gICAgICAgIG1heF9yZWdpb25fc2NhbGU6IDEwMDAwMDAsXG4gICAgICAgIHRvb2xiYXI6IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbGJhcicsICdzdGFuZGFyZF9hc3NvY2lhdGlvbicsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pLFxuICAgICAgICBwYW5lbHM6IFtcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLmdldCgncGFuZWwnLCAnYXNzb2NpYXRpb24nLCB7XG4gICAgICAgICAgICAgICAgdW5uYW1lc3BhY2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgcHJvcG9ydGlvbmFsX2hlaWdodDogKDIyNSAvIDU3MCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgeyB1bm5hbWVzcGFjZWQ6IHRydWUsIHByb3BvcnRpb25hbF9oZWlnaHQ6ICgxMjAgLyA1NzApIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzX3BhbmVsX2xheW91dFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLmdldCgncGFuZWwnLCAnZ2VuZXMnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSwgd2lkdGg6IDgwMCwgcHJvcG9ydGlvbmFsX2hlaWdodDogKDIyNSAvIDU3MCkgfSksXG4gICAgICAgIF0sXG4gICAgfTtcblxuICAgIExvY3VzWm9vbS5BZGFwdGVycy5hZGQoJ0ludGVydmFsTFonLCBJbnRlcnZhbExaKTtcbiAgICBMb2N1c1pvb20uRGF0YUxheWVycy5hZGQoJ2ludGVydmFscycsIEx6SW50ZXJ2YWxzVHJhY2spO1xuXG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCd0b29sdGlwJywgJ3N0YW5kYXJkX2ludGVydmFscycsIGludGVydmFsc190b29sdGlwX2xheW91dCk7XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdkYXRhX2xheWVyJywgJ2ludGVydmFscycsIGludGVydmFsc19sYXllcl9sYXlvdXQpO1xuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgncGFuZWwnLCAnaW50ZXJ2YWxzJywgaW50ZXJ2YWxzX3BhbmVsX2xheW91dCk7XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdwbG90JywgJ2ludGVydmFsX2Fzc29jaWF0aW9uJywgaW50ZXJ2YWxzX3Bsb3RfbGF5b3V0KTtcblxuICAgIExvY3VzWm9vbS5TY2FsZUZ1bmN0aW9ucy5hZGQoJ3RvX3JnYicsIHRvX3JnYik7XG5cbiAgICBMb2N1c1pvb20uV2lkZ2V0cy5hZGQoJ3RvZ2dsZV9zcGxpdF90cmFja3MnLCBUb2dnbGVTcGxpdFRyYWNrcyk7XG59XG5cbmlmICh0eXBlb2YgTG9jdXNab29tICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEF1dG8tcmVnaXN0ZXIgdGhlIHBsdWdpbiB3aGVuIGluY2x1ZGVkIGFzIGEgc2NyaXB0IHRhZy4gRVM2IG1vZHVsZSB1c2VycyBtdXN0IHJlZ2lzdGVyIHZpYSBMb2N1c1pvb20udXNlKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBMb2N1c1pvb20udXNlKGluc3RhbGwpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbGw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGQzOyJdLCJzb3VyY2VSb290IjoiIn0=