/*! Locuszoom 0.13.0-beta.2 */
var LzIntervalsTrack =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-intervals-track.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-intervals-track.js":
/*!***************************************!*\
  !*** ./esm/ext/lz-intervals-track.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.
This is not part of the core LocusZoom library, but can be included as a standalone file.

The page must incorporate and load all libraries before this file can be used, including:
 - Vendor assets
 - LocusZoom
 @module
*/


function install(LocusZoom) {
  var BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');

  var _Button = LocusZoom.Widgets.get('_Button');

  var _BaseWidget = LocusZoom.Widgets.get('BaseWidget');
  /**
   * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)
   * @public
   */


  var IntervalLZ = /*#__PURE__*/function (_BaseApiAdapter) {
    _inherits(IntervalLZ, _BaseApiAdapter);

    var _super = _createSuper(IntervalLZ);

    function IntervalLZ() {
      _classCallCheck(this, IntervalLZ);

      return _super.apply(this, arguments);
    }

    _createClass(IntervalLZ, [{
      key: "getURL",
      value: function getURL(state, chain, fields) {
        var source = chain.header.bedtracksource || this.params.source;
        var query = "?filter=id in ".concat(source, " and chromosome eq '").concat(state.chr, "' and start le ").concat(state.end, " and end ge ").concat(state.start);
        return "".concat(this.url).concat(query);
      }
    }]);

    return IntervalLZ;
  }(BaseApiAdapter);
  /**
   * Button to toggle split tracks
   */


  var ToggleSplitTracks = /*#__PURE__*/function (_BaseWidget2) {
    _inherits(ToggleSplitTracks, _BaseWidget2);

    var _super2 = _createSuper(ToggleSplitTracks);

    function ToggleSplitTracks(layout) {
      var _this;

      _classCallCheck(this, ToggleSplitTracks);

      _this = _super2.apply(this, arguments);

      if (!layout.data_layer_id) {
        layout.data_layer_id = 'intervals';
      }

      if (!_this.parent_panel.data_layers[layout.data_layer_id]) {
        throw new Error('Toggle split tracks widget specifies an invalid data layer ID');
      }

      return _this;
    }

    _createClass(ToggleSplitTracks, [{
      key: "update",
      value: function update() {
        var _this2 = this;

        var data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];
        var html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';

        if (this.button) {
          this.button.setHtml(html);
          this.button.show();
          this.parent.position();
          return this;
        } else {
          this.button = new _Button(this).setColor(this.layout.color).setHtml(html).setTitle('Toggle whether tracks are split apart or merged together').setOnclick(function () {
            data_layer.toggleSplitTracks();

            if (_this2.scale_timeout) {
              clearTimeout(_this2.scale_timeout);
            }

            _this2.scale_timeout = setTimeout(function () {
              // NOTE: This can override changes made in toggleSplitTracks
              _this2.parent_panel.scaleHeightToData(); // DEFECT


              _this2.parent_plot.positionPanels();
            }, 0);

            _this2.update();
          });
          return this.update();
        }
      }
    }]);

    return ToggleSplitTracks;
  }(_BaseWidget);
  /**
   * Convert a value ""rr,gg,bb" (if given) to a css-friendly color string: "rgb(rr,gg,bb)".
   * This is tailored specifically to the color specification format embraced by the BED file standard.
   * @function to_rgb
   * @param {Object} parameters This function has no defined configuration options
   * @param {String|null} value The value to convert to rgb
   */


  function to_rgb(parameters, value) {
    return value ? "rgb(".concat(value, ")") : null;
  }

  var default_layout = {
    start_field: 'start',
    end_field: 'end',
    track_label_field: 'state_name',
    // Used to label items on the y-axis
    // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting
    //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,
    //  not just choose unique colors within a particular narrow region. (where changing region might lead to more
    //  categories and different colors)
    track_split_field: 'state_id',
    track_split_order: 'DESC',
    track_split_legend_to_y_axis: 2,
    split_tracks: true,
    track_height: 15,
    track_vertical_spacing: 3,
    bounding_box_padding: 2,
    always_hide_legend: false,
    color: '#B8B8B8',
    fill_opacity: 1,
    tooltip_positioning: 'vertical'
  };
  /**
   * Intervals Data Layer
   * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)
   */

  var BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');

  var LzIntervalsTrack = /*#__PURE__*/function (_BaseLayer) {
    _inherits(LzIntervalsTrack, _BaseLayer);

    var _super3 = _createSuper(LzIntervalsTrack);

    function LzIntervalsTrack(layout) {
      var _this3;

      _classCallCheck(this, LzIntervalsTrack);

      LocusZoom.Layouts.merge(layout, default_layout);
      _this3 = _super3.apply(this, arguments);
      _this3.tracks = 1;
      _this3.previous_tracks = 1; // track-number-indexed object with arrays of interval indexes in the dataset

      _this3.interval_track_index = {
        1: []
      };
      return _this3;
    }
    /**
     * To define shared highlighting on the track split field define the status node id override
     * to generate an ID common to the track when we're actively splitting data out to separate tracks
     * @override
     * @returns {String}
     */


    _createClass(LzIntervalsTrack, [{
      key: "getElementStatusNodeId",
      value: function getElementStatusNodeId(element) {
        if (this.layout.split_tracks) {
          return "".concat(this.getBaseId(), "-statusnode-").concat(element[this.layout.track_split_field]).replace(/[^\w]/g, '_');
        }

        return "".concat(this.getElementId(element), "-statusnode");
      } // Helper function to sum layout values to derive total height for a single interval track

    }, {
      key: "getTrackHeight",
      value: function getTrackHeight() {
        return this.layout.track_height + this.layout.track_vertical_spacing + 2 * this.layout.bounding_box_padding;
      } // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available
      // Even when not displayed, the legend is used to generate the y-axis ticks

    }, {
      key: "_applyLayoutOptions",
      value: function _applyLayoutOptions() {
        var self = this;
        var base_layout = this._base_layout;
        var render_layout = this.layout;
        var base_color_scale = base_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'categorical_bin';
        });
        var color_scale = render_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'categorical_bin';
        });

        if (!base_color_scale) {
          // This can be a placeholder (empty categories & values), but it needs to be there
          throw new Error('Interval tracks must define a `categorical_bin` color scale');
        }

        var has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;
        var has_legend = base_layout.legend && base_layout.legend.length;

        if (!!has_colors ^ !!has_legend) {
          // Don't allow color OR legend to be set manually. It must be both, or neither.
          throw new Error('To use a manually specified color scheme, both color and legend options must be set.');
        } // Harvest any information about an explicit color field that should be considered when generating colors


        var rgb_option = base_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'to_rgb';
        });
        var rgb_field = rgb_option && rgb_option.field; // Auto-generate legend based on data

        var known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items


        if (!has_colors && !has_legend) {
          // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot
          // The legend must match the color scheme. If we generate one, then we must generate both.
          var colors = this._makeColorScheme(known_categories);

          color_scale.parameters.categories = known_categories.map(function (item) {
            return item[0];
          });
          color_scale.parameters.values = colors;
          this.layout.legend = known_categories.map(function (pair, index) {
            var id = pair[0];
            var label = pair[1];
            var item_color = color_scale.parameters.values[index];
            var item = {
              shape: 'rect',
              width: 9,
              label: label,
              color: item_color
            };
            item[self.layout.track_split_field] = id;
            return item;
          });
        }
      } // After we've loaded interval data interpret it to assign
      // each to a track so that they do not overlap in the view

    }, {
      key: "assignTracks",
      value: function assignTracks() {
        var _this4 = this;

        // Autogenerate layout options if not provided
        this._applyLayoutOptions(); // Reinitialize some metadata


        this.previous_tracks = this.tracks;
        this.tracks = 0;
        this.interval_track_index = {
          1: []
        }; // This maps unique values of track_split_field to unique y indices. It controls the ordering of separate tracks.

        this.track_split_field_index = {}; // If splitting tracks by a field's value then determine how to order them. There are two options here:
        // a) numeric IDs get sorted in numeric order (JS quirk: int object keys act like array indices), or
        // b) text labels get sorted based on order in the source data (hash preserves insertion order)

        if (this.layout.track_split_field && this.layout.split_tracks) {
          this.data.forEach(function (d) {
            _this4.track_split_field_index[d[_this4.layout.track_split_field]] = null;
          });
          var index = Object.keys(this.track_split_field_index);

          if (this.layout.track_split_order === 'DESC') {
            index.reverse();
          }

          index.forEach(function (val) {
            _this4.track_split_field_index[val] = _this4.tracks + 1;
            _this4.interval_track_index[_this4.tracks + 1] = [];
            _this4.tracks++;
          });
        }

        this.data.forEach(function (d, i) {
          var _this5 = this;

          // Stash a parent reference on the interval
          this.data[i].parent = this; // Determine display range start and end, based on minimum allowable interval display width,
          // bounded by what we can see (range: values in terms of pixels on the screen)

          this.data[i].display_range = {
            start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),
            end: this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end))
          };
          this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start; // Convert and stash display range values into domain values
          // (domain: values in terms of the data set, e.g. megabases)

          this.data[i].display_domain = {
            start: this.parent.x_scale.invert(this.data[i].display_range.start),
            end: this.parent.x_scale.invert(this.data[i].display_range.end)
          };
          this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start; // If splitting to tracks based on the value of the designated track split field
          // then don't bother with collision detection (intervals will be grouped on tracks
          // solely by the value of track_split_field)

          if (this.layout.track_split_field && this.layout.split_tracks) {
            var val = this.data[i][this.layout.track_split_field];
            this.data[i].track = this.track_split_field_index[val];
            this.interval_track_index[this.data[i].track].push(i);
          } else {
            // If not splitting to tracks based on a field value then do so based on collision
            // detection (as how it's done for genes). Use display range/domain data generated
            // above and cast each interval to tracks such that none overlap
            this.tracks = 1;
            this.data[i].track = null;
            var potential_track = 1;

            var _loop = function _loop() {
              var collision_on_potential_track = false;

              _this5.interval_track_index[potential_track].map(function (placed_interval) {
                if (!collision_on_potential_track) {
                  var min_start = Math.min(placed_interval.display_range.start, this.display_range.start);
                  var max_end = Math.max(placed_interval.display_range.end, this.display_range.end);

                  if (max_end - min_start < placed_interval.display_range.width + this.display_range.width) {
                    collision_on_potential_track = true;
                  }
                }
              }.bind(_this5.data[i]));

              if (!collision_on_potential_track) {
                _this5.data[i].track = potential_track;

                _this5.interval_track_index[potential_track].push(_this5.data[i]);
              } else {
                potential_track++;

                if (potential_track > _this5.tracks) {
                  _this5.tracks = potential_track;
                  _this5.interval_track_index[potential_track] = [];
                }
              }
            };

            while (this.data[i].track === null) {
              _loop();
            }
          }
        }.bind(this));
        return this;
      } // Implement the main render function

    }, {
      key: "render",
      value: function render() {
        var _this6 = this;

        // Lay out space first
        this.assignTracks(); // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.

        var track_data = this._applyFilters(); // Remove any shared highlight nodes and re-render them if we're splitting on tracks
        // At most there will only be dozen or so nodes here (one per track) and each time
        // we render data we may have new tracks, so wiping/redrawing all is reasonable.


        this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();
        Object.keys(this.track_split_field_index).forEach(function (key) {
          // Make a psuedo-element so that we can generate an id for the shared node
          var pseudoElement = {};
          pseudoElement[_this6.layout.track_split_field] = key; // Insert the shared node

          _this6.svg.group.insert('rect', ':first-child').attr('id', _this6.getElementStatusNodeId(pseudoElement)).attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared').attr('rx', _this6.layout.bounding_box_padding).attr('ry', _this6.layout.bounding_box_padding).attr('width', _this6.parent.layout.cliparea.width).attr('height', _this6.getTrackHeight() - _this6.layout.track_vertical_spacing).attr('x', 0).attr('y', (_this6.track_split_field_index[key] - 1) * _this6.getTrackHeight()).style('display', _this6.layout.split_tracks ? null : 'none');
        }); // Render interval groups

        var selection = this.svg.group.selectAll('g.lz-data_layer-intervals').data(track_data, function (d) {
          return d[_this6.layout.id_field];
        });
        selection.enter().append('g').attr('class', 'lz-data_layer-intervals').merge(selection).attr('id', function (d) {
          return _this6.getElementId(d);
        }).each(function (interval) {
          var data_layer = interval.parent; // Render interval status nodes (displayed behind intervals to show highlight
          // without needing to modify interval display element(s))

          var statusnodes = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete').data([interval], function (d) {
            return "".concat(data_layer.getElementId(d), "-statusnode");
          });
          statusnodes.enter().insert('rect', ':first-child').attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete').merge(statusnodes).attr('id', function (d) {
            return "".concat(data_layer.getElementId(d), "-statusnode");
          }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).style('display', data_layer.layout.split_tracks ? 'none' : null).attr('width', function (d) {
            return d.display_range.width + 2 * data_layer.layout.bounding_box_padding;
          }).attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing).attr('x', function (d) {
            return d.display_range.start - data_layer.layout.bounding_box_padding;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight();
          });
          statusnodes.exit().remove(); // Render primary interval rects

          var rects = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect').data([interval], function (d) {
            return "".concat(d[data_layer.layout.id_field], "_interval_rect");
          });
          rects.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-interval_rect').merge(rects).attr('width', function (d) {
            return d.display_range.width;
          }).attr('height', data_layer.layout.track_height).attr('x', function (d) {
            return d.display_range.start;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding;
          }).attr('fill', function (d, i) {
            return data_layer.resolveScalableParameter(data_layer.layout.color, d, i);
          }).attr('fill-opacity', function (d, i) {
            return data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d, i);
          });
          rects.exit().remove(); // Render interval click areas

          var clickareas = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-clickarea').data([interval], function (d) {
            return "".concat(d.interval_name, "_clickarea");
          });
          clickareas.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-clickarea').merge(clickareas).attr('id', function (d) {
            return "".concat(data_layer.getElementId(d), "_clickarea");
          }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).attr('width', function (d) {
            return d.display_range.width;
          }).attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing).attr('x', function (d) {
            return d.display_range.start;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight();
          }) // Apply default event emitters to clickareas
          .on('click', function (element_data) {
            element_data.parent.parent.emit('element_clicked', element_data, true);
          }) // Apply mouse behaviors to clickareas
          .call(data_layer.applyBehaviors.bind(data_layer)); // Remove old clickareas as needed

          clickareas.exit().remove();
        }); // // Remove old elements as needed

        selection.exit().remove(); // // Update the legend axis if the number of ticks changed
        // if (this.previous_tracks !== this.tracks) {
        //     this.updateSplitTrackAxis();
        // }
        // // The intervals track allows legends to be dynamically generated, in which case space can only be
        // //  allocated after the panel has been rendered.

        if (this.parent && this.parent.legend) {
          this.parent.legend.render();
        }

        return this;
      }
    }, {
      key: "_getTooltipPosition",
      value: function _getTooltipPosition(tooltip) {
        var interval_bbox = d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(this.getElementStatusNodeId(tooltip.data))).node().getBBox();
        return {
          x_min: tooltip.data.display_range.start,
          x_max: tooltip.data.display_range.end,
          y_min: interval_bbox.y,
          y_max: interval_bbox.y + interval_bbox.height
        };
      } // Redraw split track axis or hide it, and show/hide the legend, as determined
      // by current layout parameters and data

    }, {
      key: "updateSplitTrackAxis",
      value: function updateSplitTrackAxis() {
        var _this7 = this;

        var legend_axis = this.layout.track_split_legend_to_y_axis ? "y".concat(this.layout.track_split_legend_to_y_axis) : false;

        if (this.layout.split_tracks) {
          var tracks = +this.tracks || 0;
          var track_height = +this.layout.track_height || 0;
          var track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);
          var target_height = tracks * track_height + (tracks - 1) * track_spacing;
          this.parent.scaleHeightToData(target_height); // DEFECT

          if (legend_axis && this.parent.legend) {
            this.parent.legend.hide();
            this.parent.layout.axes[legend_axis] = {
              render: true,
              ticks: [],
              range: {
                start: target_height - this.layout.track_height / 2,
                end: this.layout.track_height / 2
              }
            }; // There is a very tight coupling between the display directives: each legend item must identify a key
            //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)
            // The list of unique keys corresponds to the order along the y-axis

            this.layout.legend.forEach(function (element) {
              var key = element[_this7.layout.track_split_field];
              var track = _this7.track_split_field_index[key];

              if (track) {
                if (_this7.layout.track_split_order === 'DESC') {
                  track = Math.abs(track - tracks - 1);
                }

                _this7.parent.layout.axes[legend_axis].ticks.push({
                  y: track,
                  text: element.label
                });
              }
            });
            this.layout.y_axis = {
              axis: this.layout.track_split_legend_to_y_axis,
              floor: 1,
              ceiling: tracks
            };
            this.parent.render();
          }

          this.parent_plot.positionPanels();
        } else {
          if (legend_axis && this.parent.legend) {
            if (!this.layout.always_hide_legend) {
              this.parent.legend.show();
            }

            this.parent.layout.axes[legend_axis] = {
              render: false
            };
            this.parent.render();
          }
        }

        return this;
      } // Method to not only toggle the split tracks boolean but also update
      // necessary display values to animate a complete merge/split

    }, {
      key: "toggleSplitTracks",
      value: function toggleSplitTracks() {
        this.layout.split_tracks = !this.layout.split_tracks;

        if (this.parent.legend && !this.layout.always_hide_legend) {
          this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);
        }

        this.render();

        if (!this.layout.split_tracks) {
          // forcing these to go to one will cause a recalculation of the dimensions for the parent_plot
          // otherwise when `scaleHeightToData` runs, min_height (which can get quite large) will dominate plot's
          // layout from updating and can potentially lead to a large amount of whitespace on the screen, as well as stretching panels.
          this.parent_plot.layout.min_height = 1;
          this.parent_plot.layout.min_width = 1; // this.parent_plot.layout.min_height = this.parent_plot._base_layout.min_height;
          // this.parent_plot.layout.min_width = this.parent_plot._base_layout.min_width;
        }

        this.updateSplitTrackAxis();
        return this;
      } // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are
      //  using explicitly provided itemRgb information

    }, {
      key: "_makeColorScheme",
      value: function _makeColorScheme(category_info) {
        // If at least one element has an explicit itemRgb, assume the entire dataset has colors
        var has_explicit_colors = category_info.find(function (item) {
          return item[2];
        });

        if (has_explicit_colors) {
          return category_info.map(function (item) {
            return item[2];
          });
        } // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:
        //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html
        // These are actually reversed so that dim colors come first, on the premise that usually these are the
        //  most common states


        var n_categories = category_info.length;

        if (n_categories <= 15) {
          return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        } else if (n_categories <= 18) {
          return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        } else {
          // If there are more than 25 categories, the interval layer will fall back to the 'null value' option
          return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        }
      }
      /**
       * Find all of the unique tracks (a combination of name and ID information)
       * @param {Object} data
       * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column
       * @private
       * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings
       *  most unambiguously.
       */

    }, {
      key: "_generateCategoriesFromData",
      value: function _generateCategoriesFromData(data, rgb_field) {
        var _this8 = this;

        var self = this; // Use the hard-coded legend if available (ignoring any mods on re-render)

        var legend = this._base_layout.legend;

        if (legend && legend.length) {
          return legend.map(function (item) {
            return [item[_this8.layout.track_split_field], item.label, item.color];
          });
        } // Generate options from data, if no preset legend exists


        var unique_ids = {}; // make categories unique

        var categories = [];
        data.forEach(function (item) {
          var id = item[self.layout.track_split_field];

          if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {
            unique_ids[id] = null; // If rgbfield is null, then the last entry is undefined/null as well

            categories.push([id, item[_this8.layout.track_label_field], item[rgb_field]]);
          }
        });
        return categories;
      }
    }]);

    return LzIntervalsTrack;
  }(BaseLayer);

  var intervals_tooltip_layout = {
    namespace: {
      'intervals': 'intervals'
    },
    closable: false,
    show: {
      or: ['highlighted', 'selected']
    },
    hide: {
      and: ['unhighlighted', 'unselected']
    },
    html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}'
  };
  var intervals_layer_layout = {
    namespace: {
      'intervals': 'intervals'
    },
    id: 'intervals',
    type: 'intervals',
    fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],
    id_field: '{{namespace[intervals]}}start',
    start_field: '{{namespace[intervals]}}start',
    end_field: '{{namespace[intervals]}}end',
    track_split_field: '{{namespace[intervals]}}state_name',
    track_label_field: '{{namespace[intervals]}}state_name',
    split_tracks: false,
    always_hide_legend: true,
    color: [{
      // If present, an explicit color field will override any other option (and be used to auto-generate legend)
      field: '{{namespace[intervals]}}itemRgb',
      scale_function: 'to_rgb'
    }, {
      field: '{{namespace[intervals]}}state_name',
      scale_function: 'categorical_bin',
      parameters: {
        // Placeholder. Empty categories and values will automatically be filled in when new data loads.
        categories: [],
        values: [],
        null_value: '#B8B8B8'
      }
    }],
    legend: [],
    // Placeholder; auto-filled when data loads.
    behaviors: {
      onmouseover: [{
        action: 'set',
        status: 'highlighted'
      }],
      onmouseout: [{
        action: 'unset',
        status: 'highlighted'
      }],
      onclick: [{
        action: 'toggle',
        status: 'selected',
        exclusive: true
      }],
      onshiftclick: [{
        action: 'toggle',
        status: 'selected'
      }]
    },
    tooltip: intervals_tooltip_layout
  };
  var intervals_panel_layout = {
    id: 'intervals',
    width: 1000,
    height: 50,
    min_width: 500,
    min_height: 50,
    margin: {
      top: 25,
      right: 150,
      bottom: 5,
      left: 50
    },
    toolbar: function () {
      var l = LocusZoom.Layouts.get('toolbar', 'standard_panel', {
        unnamespaced: true
      });
      l.widgets.push({
        type: 'toggle_split_tracks',
        data_layer_id: 'intervals',
        position: 'right'
      });
      return l;
    }(),
    axes: {},
    interaction: {
      drag_background_to_pan: true,
      scroll_to_zoom: true,
      x_linked: true
    },
    legend: {
      hidden: true,
      orientation: 'horizontal',
      origin: {
        x: 50,
        y: 0
      },
      pad_from_bottom: 5
    },
    data_layers: [intervals_layer_layout]
  };
  var intervals_plot_layout = {
    state: {},
    width: 800,
    height: 550,
    responsive_resize: true,
    min_region_scale: 20000,
    max_region_scale: 1000000,
    toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', {
      unnamespaced: true
    }),
    panels: [LocusZoom.Layouts.get('panel', 'association', {
      unnamespaced: true,
      width: 800,
      proportional_height: 225 / 570
    }), Object.assign({
      unnamespaced: true,
      proportional_height: 120 / 570
    }, intervals_panel_layout), LocusZoom.Layouts.get('panel', 'genes', {
      unnamespaced: true,
      width: 800,
      proportional_height: 225 / 570
    })]
  };
  LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);
  LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);
  LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);
  LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);
  LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);
  LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);
  LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);
  LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);
}

if (typeof LocusZoom !== 'undefined') {
  // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
  // eslint-disable-next-line no-undef
  LocusZoom.use(install);
}

/* harmony default export */ __webpack_exports__["default"] = (install);

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1pbnRlcnZhbHMtdHJhY2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6WyJpbnN0YWxsIiwiTG9jdXNab29tIiwiQmFzZUFwaUFkYXB0ZXIiLCJBZGFwdGVycyIsImdldCIsIl9CdXR0b24iLCJXaWRnZXRzIiwiX0Jhc2VXaWRnZXQiLCJJbnRlcnZhbExaIiwic3RhdGUiLCJjaGFpbiIsImZpZWxkcyIsInNvdXJjZSIsImhlYWRlciIsImJlZHRyYWNrc291cmNlIiwicGFyYW1zIiwicXVlcnkiLCJjaHIiLCJlbmQiLCJzdGFydCIsInVybCIsIlRvZ2dsZVNwbGl0VHJhY2tzIiwibGF5b3V0IiwiYXJndW1lbnRzIiwiZGF0YV9sYXllcl9pZCIsInBhcmVudF9wYW5lbCIsImRhdGFfbGF5ZXJzIiwiRXJyb3IiLCJkYXRhX2xheWVyIiwiaHRtbCIsInNwbGl0X3RyYWNrcyIsImJ1dHRvbiIsInNldEh0bWwiLCJzaG93IiwicGFyZW50IiwicG9zaXRpb24iLCJzZXRDb2xvciIsImNvbG9yIiwic2V0VGl0bGUiLCJzZXRPbmNsaWNrIiwidG9nZ2xlU3BsaXRUcmFja3MiLCJzY2FsZV90aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInNjYWxlSGVpZ2h0VG9EYXRhIiwicGFyZW50X3Bsb3QiLCJwb3NpdGlvblBhbmVscyIsInVwZGF0ZSIsInRvX3JnYiIsInBhcmFtZXRlcnMiLCJ2YWx1ZSIsImRlZmF1bHRfbGF5b3V0Iiwic3RhcnRfZmllbGQiLCJlbmRfZmllbGQiLCJ0cmFja19sYWJlbF9maWVsZCIsInRyYWNrX3NwbGl0X2ZpZWxkIiwidHJhY2tfc3BsaXRfb3JkZXIiLCJ0cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzIiwidHJhY2tfaGVpZ2h0IiwidHJhY2tfdmVydGljYWxfc3BhY2luZyIsImJvdW5kaW5nX2JveF9wYWRkaW5nIiwiYWx3YXlzX2hpZGVfbGVnZW5kIiwiZmlsbF9vcGFjaXR5IiwidG9vbHRpcF9wb3NpdGlvbmluZyIsIkJhc2VMYXllciIsIkRhdGFMYXllcnMiLCJMekludGVydmFsc1RyYWNrIiwiTGF5b3V0cyIsIm1lcmdlIiwidHJhY2tzIiwicHJldmlvdXNfdHJhY2tzIiwiaW50ZXJ2YWxfdHJhY2tfaW5kZXgiLCJlbGVtZW50IiwiZ2V0QmFzZUlkIiwicmVwbGFjZSIsImdldEVsZW1lbnRJZCIsInNlbGYiLCJiYXNlX2xheW91dCIsIl9iYXNlX2xheW91dCIsInJlbmRlcl9sYXlvdXQiLCJiYXNlX2NvbG9yX3NjYWxlIiwiZmluZCIsIml0ZW0iLCJzY2FsZV9mdW5jdGlvbiIsImNvbG9yX3NjYWxlIiwiaGFzX2NvbG9ycyIsImNhdGVnb3JpZXMiLCJsZW5ndGgiLCJ2YWx1ZXMiLCJoYXNfbGVnZW5kIiwibGVnZW5kIiwicmdiX29wdGlvbiIsInJnYl9maWVsZCIsImZpZWxkIiwia25vd25fY2F0ZWdvcmllcyIsIl9nZW5lcmF0ZUNhdGVnb3JpZXNGcm9tRGF0YSIsImRhdGEiLCJjb2xvcnMiLCJfbWFrZUNvbG9yU2NoZW1lIiwibWFwIiwicGFpciIsImluZGV4IiwiaWQiLCJsYWJlbCIsIml0ZW1fY29sb3IiLCJzaGFwZSIsIndpZHRoIiwiX2FwcGx5TGF5b3V0T3B0aW9ucyIsInRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4IiwiZm9yRWFjaCIsImQiLCJPYmplY3QiLCJrZXlzIiwicmV2ZXJzZSIsInZhbCIsImkiLCJkaXNwbGF5X3JhbmdlIiwieF9zY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJkaXNwbGF5X2RvbWFpbiIsImludmVydCIsInRyYWNrIiwicHVzaCIsInBvdGVudGlhbF90cmFjayIsImNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2siLCJwbGFjZWRfaW50ZXJ2YWwiLCJtaW5fc3RhcnQiLCJtYXhfZW5kIiwiYmluZCIsImFzc2lnblRyYWNrcyIsInRyYWNrX2RhdGEiLCJfYXBwbHlGaWx0ZXJzIiwic3ZnIiwiZ3JvdXAiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJrZXkiLCJwc2V1ZG9FbGVtZW50IiwiaW5zZXJ0IiwiYXR0ciIsImdldEVsZW1lbnRTdGF0dXNOb2RlSWQiLCJjbGlwYXJlYSIsImdldFRyYWNrSGVpZ2h0Iiwic3R5bGUiLCJzZWxlY3Rpb24iLCJpZF9maWVsZCIsImVudGVyIiwiYXBwZW5kIiwiZWFjaCIsImludGVydmFsIiwic3RhdHVzbm9kZXMiLCJkMyIsImV4aXQiLCJyZWN0cyIsInJlc29sdmVTY2FsYWJsZVBhcmFtZXRlciIsImNsaWNrYXJlYXMiLCJpbnRlcnZhbF9uYW1lIiwib24iLCJlbGVtZW50X2RhdGEiLCJlbWl0IiwiY2FsbCIsImFwcGx5QmVoYXZpb3JzIiwicmVuZGVyIiwidG9vbHRpcCIsImludGVydmFsX2Jib3giLCJub2RlIiwiZ2V0QkJveCIsInhfbWluIiwieF9tYXgiLCJ5X21pbiIsInkiLCJ5X21heCIsImhlaWdodCIsImxlZ2VuZF9heGlzIiwidHJhY2tfc3BhY2luZyIsInRhcmdldF9oZWlnaHQiLCJoaWRlIiwiYXhlcyIsInRpY2tzIiwicmFuZ2UiLCJhYnMiLCJ0ZXh0IiwieV9heGlzIiwiYXhpcyIsImZsb29yIiwiY2VpbGluZyIsIm1hcmdpbiIsImJvdHRvbSIsIm1pbl9oZWlnaHQiLCJtaW5fd2lkdGgiLCJ1cGRhdGVTcGxpdFRyYWNrQXhpcyIsImNhdGVnb3J5X2luZm8iLCJoYXNfZXhwbGljaXRfY29sb3JzIiwibl9jYXRlZ29yaWVzIiwidW5pcXVlX2lkcyIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiaW50ZXJ2YWxzX3Rvb2x0aXBfbGF5b3V0IiwibmFtZXNwYWNlIiwiY2xvc2FibGUiLCJvciIsImFuZCIsImludGVydmFsc19sYXllcl9sYXlvdXQiLCJ0eXBlIiwibnVsbF92YWx1ZSIsImJlaGF2aW9ycyIsIm9ubW91c2VvdmVyIiwiYWN0aW9uIiwic3RhdHVzIiwib25tb3VzZW91dCIsIm9uY2xpY2siLCJleGNsdXNpdmUiLCJvbnNoaWZ0Y2xpY2siLCJpbnRlcnZhbHNfcGFuZWxfbGF5b3V0IiwidG9wIiwicmlnaHQiLCJsZWZ0IiwidG9vbGJhciIsImwiLCJ1bm5hbWVzcGFjZWQiLCJ3aWRnZXRzIiwiaW50ZXJhY3Rpb24iLCJkcmFnX2JhY2tncm91bmRfdG9fcGFuIiwic2Nyb2xsX3RvX3pvb20iLCJ4X2xpbmtlZCIsImhpZGRlbiIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwieCIsInBhZF9mcm9tX2JvdHRvbSIsImludGVydmFsc19wbG90X2xheW91dCIsInJlc3BvbnNpdmVfcmVzaXplIiwibWluX3JlZ2lvbl9zY2FsZSIsIm1heF9yZWdpb25fc2NhbGUiLCJwYW5lbHMiLCJwcm9wb3J0aW9uYWxfaGVpZ2h0IiwiYXNzaWduIiwiYWRkIiwiU2NhbGVGdW5jdGlvbnMiLCJ1c2UiXSwibWFwcGluZ3MiOiI7OztRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7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T0FBZDtBQUNIOztBQUdjQSxzRUFBZixFOzs7Ozs7Ozs7OztBQ2xzQkEsb0IiLCJmaWxlIjoiZXh0L2x6LWludGVydmFscy10cmFjay5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2VzbS9leHQvbHotaW50ZXJ2YWxzLXRyYWNrLmpzXCIpO1xuIiwiLyoqXG5JbnRlcnZhbCBhbm5vdGF0aW9uIHRyYWNrIChmb3IgY2hyb21hdGluIHN0YXRlLCBldGMpLiBVc2VmdWwgZm9yIEJFRCBmaWxlIGRhdGEgd2l0aCBub24tb3ZlcmxhcHBpbmcgaW50ZXJ2YWxzLlxuVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgY29yZSBMb2N1c1pvb20gbGlicmFyeSwgYnV0IGNhbiBiZSBpbmNsdWRlZCBhcyBhIHN0YW5kYWxvbmUgZmlsZS5cblxuVGhlIHBhZ2UgbXVzdCBpbmNvcnBvcmF0ZSBhbmQgbG9hZCBhbGwgbGlicmFyaWVzIGJlZm9yZSB0aGlzIGZpbGUgY2FuIGJlIHVzZWQsIGluY2x1ZGluZzpcbiAtIFZlbmRvciBhc3NldHNcbiAtIExvY3VzWm9vbVxuIEBtb2R1bGVcbiovXG5cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuXG5mdW5jdGlvbiBpbnN0YWxsIChMb2N1c1pvb20pIHtcbiAgICBjb25zdCBCYXNlQXBpQWRhcHRlciA9IExvY3VzWm9vbS5BZGFwdGVycy5nZXQoJ0Jhc2VBcGlBZGFwdGVyJyk7XG4gICAgY29uc3QgX0J1dHRvbiA9IExvY3VzWm9vbS5XaWRnZXRzLmdldCgnX0J1dHRvbicpO1xuICAgIGNvbnN0IF9CYXNlV2lkZ2V0ID0gTG9jdXNab29tLldpZGdldHMuZ2V0KCdCYXNlV2lkZ2V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIFNvdXJjZSBmb3IgSW50ZXJ2YWwgQW5ub3RhdGlvbiBEYXRhIChlLmcuIEJFRCBUcmFja3MpLCBhcyBmZXRjaGVkIGZyb20gdGhlIExvY3VzWm9vbSBBUEkgc2VydmVyIChvciBjb21wYXRpYmxlKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBJbnRlcnZhbExaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgICAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGNoYWluLmhlYWRlci5iZWR0cmFja3NvdXJjZSB8fCB0aGlzLnBhcmFtcy5zb3VyY2U7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGA/ZmlsdGVyPWlkIGluICR7c291cmNlfSBhbmQgY2hyb21vc29tZSBlcSAnJHtzdGF0ZS5jaHJ9JyBhbmQgc3RhcnQgbGUgJHtzdGF0ZS5lbmR9IGFuZCBlbmQgZ2UgJHtzdGF0ZS5zdGFydH1gO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMudXJsfSR7cXVlcnl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1dHRvbiB0byB0b2dnbGUgc3BsaXQgdHJhY2tzXG4gICAgICovXG4gICAgY2xhc3MgVG9nZ2xlU3BsaXRUcmFja3MgZXh0ZW5kcyBfQmFzZVdpZGdldCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICghbGF5b3V0LmRhdGFfbGF5ZXJfaWQpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQuZGF0YV9sYXllcl9pZCA9ICdpbnRlcnZhbHMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudF9wYW5lbC5kYXRhX2xheWVyc1tsYXlvdXQuZGF0YV9sYXllcl9pZF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvZ2dsZSBzcGxpdCB0cmFja3Mgd2lkZ2V0IHNwZWNpZmllcyBhbiBpbnZhbGlkIGRhdGEgbGF5ZXIgSUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFfbGF5ZXIgPSB0aGlzLnBhcmVudF9wYW5lbC5kYXRhX2xheWVyc1t0aGlzLmxheW91dC5kYXRhX2xheWVyX2lkXTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBkYXRhX2xheWVyLmxheW91dC5zcGxpdF90cmFja3MgPyAnTWVyZ2UgVHJhY2tzJyA6ICdTcGxpdCBUcmFja3MnO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2V0SHRtbChodG1sKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgX0J1dHRvbih0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRIdG1sKGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUaXRsZSgnVG9nZ2xlIHdoZXRoZXIgdHJhY2tzIGFyZSBzcGxpdCBhcGFydCBvciBtZXJnZWQgdG9nZXRoZXInKVxuICAgICAgICAgICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyLnRvZ2dsZVNwbGl0VHJhY2tzKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVfdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjYWxlX3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZV90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gb3ZlcnJpZGUgY2hhbmdlcyBtYWRlIGluIHRvZ2dsZVNwbGl0VHJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGFuZWwuc2NhbGVIZWlnaHRUb0RhdGEoKTsgLy8gREVGRUNUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB2YWx1ZSBcIlwicnIsZ2csYmJcIiAoaWYgZ2l2ZW4pIHRvIGEgY3NzLWZyaWVuZGx5IGNvbG9yIHN0cmluZzogXCJyZ2IocnIsZ2csYmIpXCIuXG4gICAgICogVGhpcyBpcyB0YWlsb3JlZCBzcGVjaWZpY2FsbHkgdG8gdGhlIGNvbG9yIHNwZWNpZmljYXRpb24gZm9ybWF0IGVtYnJhY2VkIGJ5IHRoZSBCRUQgZmlsZSBzdGFuZGFyZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9fcmdiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgVGhpcyBmdW5jdGlvbiBoYXMgbm8gZGVmaW5lZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydCB0byByZ2JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b19yZ2IocGFyYW1ldGVycywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gYHJnYigke3ZhbHVlfSlgIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0X2xheW91dCA9IHtcbiAgICAgICAgc3RhcnRfZmllbGQ6ICdzdGFydCcsXG4gICAgICAgIGVuZF9maWVsZDogJ2VuZCcsXG4gICAgICAgIHRyYWNrX2xhYmVsX2ZpZWxkOiAnc3RhdGVfbmFtZScsIC8vIFVzZWQgdG8gbGFiZWwgaXRlbXMgb24gdGhlIHktYXhpc1xuICAgICAgICAvLyBVc2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRyYWNrcyBmb3IgY29sb3JpbmcuIFRoaXMgdGVuZHMgdG8gbGVhZCB0byBtb3JlIHN0YWJsZSBjb2xvcmluZy9zb3J0aW5nXG4gICAgICAgIC8vICB0aGFuIHVzaW5nIHRoZSBsYWJlbCBmaWVsZC0gZWcsIHN0YXRlX2lkcyBhbGxvdyB1cyB0byBzZXQgZ2xvYmFsIGNvbG9ycyBhY3Jvc3MgdGhlIGVudGlyZSBkYXRhc2V0LFxuICAgICAgICAvLyAgbm90IGp1c3QgY2hvb3NlIHVuaXF1ZSBjb2xvcnMgd2l0aGluIGEgcGFydGljdWxhciBuYXJyb3cgcmVnaW9uLiAod2hlcmUgY2hhbmdpbmcgcmVnaW9uIG1pZ2h0IGxlYWQgdG8gbW9yZVxuICAgICAgICAvLyAgY2F0ZWdvcmllcyBhbmQgZGlmZmVyZW50IGNvbG9ycylcbiAgICAgICAgdHJhY2tfc3BsaXRfZmllbGQ6ICdzdGF0ZV9pZCcsXG4gICAgICAgIHRyYWNrX3NwbGl0X29yZGVyOiAnREVTQycsXG4gICAgICAgIHRyYWNrX3NwbGl0X2xlZ2VuZF90b195X2F4aXM6IDIsXG4gICAgICAgIHNwbGl0X3RyYWNrczogdHJ1ZSxcbiAgICAgICAgdHJhY2tfaGVpZ2h0OiAxNSxcbiAgICAgICAgdHJhY2tfdmVydGljYWxfc3BhY2luZzogMyxcbiAgICAgICAgYm91bmRpbmdfYm94X3BhZGRpbmc6IDIsXG4gICAgICAgIGFsd2F5c19oaWRlX2xlZ2VuZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAnI0I4QjhCOCcsXG4gICAgICAgIGZpbGxfb3BhY2l0eTogMSxcbiAgICAgICAgdG9vbHRpcF9wb3NpdGlvbmluZzogJ3ZlcnRpY2FsJyxcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnZhbHMgRGF0YSBMYXllclxuICAgICAqIEltcGxlbWVudHMgYSBkYXRhIGxheWVyIHRoYXQgd2lsbCByZW5kZXIgaW50ZXJ2YWwgYW5ub3RhdGlvbiB0cmFja3MgKGludGVydmFscyBtdXN0IHByb3ZpZGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMpXG4gICAgICovXG4gICAgY29uc3QgQmFzZUxheWVyID0gTG9jdXNab29tLkRhdGFMYXllcnMuZ2V0KCdCYXNlRGF0YUxheWVyJyk7XG4gICAgY2xhc3MgTHpJbnRlcnZhbHNUcmFjayBleHRlbmRzIEJhc2VMYXllciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICAgICAgTG9jdXNab29tLkxheW91dHMubWVyZ2UobGF5b3V0LCBkZWZhdWx0X2xheW91dCk7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy50cmFja3MgPSAxO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c190cmFja3MgPSAxO1xuXG4gICAgICAgICAgICAvLyB0cmFjay1udW1iZXItaW5kZXhlZCBvYmplY3Qgd2l0aCBhcnJheXMgb2YgaW50ZXJ2YWwgaW5kZXhlcyBpbiB0aGUgZGF0YXNldFxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleCA9IHsgMTogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUbyBkZWZpbmUgc2hhcmVkIGhpZ2hsaWdodGluZyBvbiB0aGUgdHJhY2sgc3BsaXQgZmllbGQgZGVmaW5lIHRoZSBzdGF0dXMgbm9kZSBpZCBvdmVycmlkZVxuICAgICAgICAgKiB0byBnZW5lcmF0ZSBhbiBJRCBjb21tb24gdG8gdGhlIHRyYWNrIHdoZW4gd2UncmUgYWN0aXZlbHkgc3BsaXR0aW5nIGRhdGEgb3V0IHRvIHNlcGFyYXRlIHRyYWNrc1xuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEVsZW1lbnRTdGF0dXNOb2RlSWQoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYCR7dGhpcy5nZXRCYXNlSWQoKX0tc3RhdHVzbm9kZS0ke2VsZW1lbnRbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdfWApLnJlcGxhY2UoL1teXFx3XS9nLCAnXycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0RWxlbWVudElkKGVsZW1lbnQpfS1zdGF0dXNub2RlYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzdW0gbGF5b3V0IHZhbHVlcyB0byBkZXJpdmUgdG90YWwgaGVpZ2h0IGZvciBhIHNpbmdsZSBpbnRlcnZhbCB0cmFja1xuICAgICAgICBnZXRUcmFja0hlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC50cmFja19oZWlnaHRcbiAgICAgICAgICAgICAgICArIHRoaXMubGF5b3V0LnRyYWNrX3ZlcnRpY2FsX3NwYWNpbmdcbiAgICAgICAgICAgICAgICArICgyICogdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9kaWZ5IHRoZSBsYXlvdXQgYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IGFwcHJvcHJpYXRlIGNvbG9yLCBsYWJlbCwgYW5kIGxlZ2VuZCBvcHRpb25zIGFyZSBhdmFpbGFibGVcbiAgICAgICAgLy8gRXZlbiB3aGVuIG5vdCBkaXNwbGF5ZWQsIHRoZSBsZWdlbmQgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgeS1heGlzIHRpY2tzXG4gICAgICAgIF9hcHBseUxheW91dE9wdGlvbnMoKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGJhc2VfbGF5b3V0ID0gdGhpcy5fYmFzZV9sYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJfbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCBiYXNlX2NvbG9yX3NjYWxlID0gYmFzZV9sYXlvdXQuY29sb3IuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNjYWxlX2Z1bmN0aW9uICYmIGl0ZW0uc2NhbGVfZnVuY3Rpb24gPT09ICdjYXRlZ29yaWNhbF9iaW4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb2xvcl9zY2FsZSA9IHJlbmRlcl9sYXlvdXQuY29sb3IuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNjYWxlX2Z1bmN0aW9uICYmIGl0ZW0uc2NhbGVfZnVuY3Rpb24gPT09ICdjYXRlZ29yaWNhbF9iaW4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWJhc2VfY29sb3Jfc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBhIHBsYWNlaG9sZGVyIChlbXB0eSBjYXRlZ29yaWVzICYgdmFsdWVzKSwgYnV0IGl0IG5lZWRzIHRvIGJlIHRoZXJlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcnZhbCB0cmFja3MgbXVzdCBkZWZpbmUgYSBgY2F0ZWdvcmljYWxfYmluYCBjb2xvciBzY2FsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoYXNfY29sb3JzID0gYmFzZV9jb2xvcl9zY2FsZS5wYXJhbWV0ZXJzLmNhdGVnb3JpZXMubGVuZ3RoICYmIGJhc2VfY29sb3Jfc2NhbGUucGFyYW1ldGVycy52YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGFzX2xlZ2VuZCA9IGJhc2VfbGF5b3V0LmxlZ2VuZCAmJiBiYXNlX2xheW91dC5sZWdlbmQubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISFoYXNfY29sb3JzIF4gISFoYXNfbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgY29sb3IgT1IgbGVnZW5kIHRvIGJlIHNldCBtYW51YWxseS4gSXQgbXVzdCBiZSBib3RoLCBvciBuZWl0aGVyLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gdXNlIGEgbWFudWFsbHkgc3BlY2lmaWVkIGNvbG9yIHNjaGVtZSwgYm90aCBjb2xvciBhbmQgbGVnZW5kIG9wdGlvbnMgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhcnZlc3QgYW55IGluZm9ybWF0aW9uIGFib3V0IGFuIGV4cGxpY2l0IGNvbG9yIGZpZWxkIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgd2hlbiBnZW5lcmF0aW5nIGNvbG9yc1xuICAgICAgICAgICAgY29uc3QgcmdiX29wdGlvbiA9IGJhc2VfbGF5b3V0LmNvbG9yLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zY2FsZV9mdW5jdGlvbiAmJiBpdGVtLnNjYWxlX2Z1bmN0aW9uID09PSAndG9fcmdiJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmdiX2ZpZWxkID0gcmdiX29wdGlvbiAmJiByZ2Jfb3B0aW9uLmZpZWxkO1xuXG4gICAgICAgICAgICAvLyBBdXRvLWdlbmVyYXRlIGxlZ2VuZCBiYXNlZCBvbiBkYXRhXG4gICAgICAgICAgICBjb25zdCBrbm93bl9jYXRlZ29yaWVzID0gdGhpcy5fZ2VuZXJhdGVDYXRlZ29yaWVzRnJvbURhdGEodGhpcy5kYXRhLCByZ2JfZmllbGQpOyAvLyBbaWQsIGxhYmVsLCBpdGVtUmdiXSBpdGVtc1xuXG4gICAgICAgICAgICBpZiAoIWhhc19jb2xvcnMgJiYgIWhhc19sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBjb2xvciBzY2hlbWUgcHJlLWRlZmluZWQsIHRoZW4gbWFrZSBhIGNvbG9yIHNjaGVtZSB0aGF0IGlzIGFwcHJvcHJpYXRlIGFuZCBhcHBseSB0byB0aGUgcGxvdFxuICAgICAgICAgICAgICAgIC8vIFRoZSBsZWdlbmQgbXVzdCBtYXRjaCB0aGUgY29sb3Igc2NoZW1lLiBJZiB3ZSBnZW5lcmF0ZSBvbmUsIHRoZW4gd2UgbXVzdCBnZW5lcmF0ZSBib3RoLlxuXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5fbWFrZUNvbG9yU2NoZW1lKGtub3duX2NhdGVnb3JpZXMpO1xuICAgICAgICAgICAgICAgIGNvbG9yX3NjYWxlLnBhcmFtZXRlcnMuY2F0ZWdvcmllcyA9IGtub3duX2NhdGVnb3JpZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbG9yX3NjYWxlLnBhcmFtZXRlcnMudmFsdWVzID0gY29sb3JzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQubGVnZW5kID0ga25vd25fY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24gKHBhaXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gcGFpclswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBwYWlyWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtX2NvbG9yID0gY29sb3Jfc2NhbGUucGFyYW1ldGVycy52YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0geyBzaGFwZTogJ3JlY3QnLCB3aWR0aDogOSwgbGFiZWw6IGxhYmVsLCBjb2xvcjogaXRlbV9jb2xvciB9O1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3NlbGYubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFmdGVyIHdlJ3ZlIGxvYWRlZCBpbnRlcnZhbCBkYXRhIGludGVycHJldCBpdCB0byBhc3NpZ25cbiAgICAgICAgLy8gZWFjaCB0byBhIHRyYWNrIHNvIHRoYXQgdGhleSBkbyBub3Qgb3ZlcmxhcCBpbiB0aGUgdmlld1xuICAgICAgICBhc3NpZ25UcmFja3MoKSB7XG4gICAgICAgICAgICAvLyBBdXRvZ2VuZXJhdGUgbGF5b3V0IG9wdGlvbnMgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dE9wdGlvbnMoKTtcblxuICAgICAgICAgICAgLy8gUmVpbml0aWFsaXplIHNvbWUgbWV0YWRhdGFcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNfdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICAgICAgICB0aGlzLnRyYWNrcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4ID0geyAxOiBbXSB9O1xuICAgICAgICAgICAgLy8gVGhpcyBtYXBzIHVuaXF1ZSB2YWx1ZXMgb2YgdHJhY2tfc3BsaXRfZmllbGQgdG8gdW5pcXVlIHkgaW5kaWNlcy4gSXQgY29udHJvbHMgdGhlIG9yZGVyaW5nIG9mIHNlcGFyYXRlIHRyYWNrcy5cbiAgICAgICAgICAgIHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXggPSB7fTtcblxuICAgICAgICAgICAgLy8gSWYgc3BsaXR0aW5nIHRyYWNrcyBieSBhIGZpZWxkJ3MgdmFsdWUgdGhlbiBkZXRlcm1pbmUgaG93IHRvIG9yZGVyIHRoZW0uIFRoZXJlIGFyZSB0d28gb3B0aW9ucyBoZXJlOlxuICAgICAgICAgICAgLy8gYSkgbnVtZXJpYyBJRHMgZ2V0IHNvcnRlZCBpbiBudW1lcmljIG9yZGVyIChKUyBxdWlyazogaW50IG9iamVjdCBrZXlzIGFjdCBsaWtlIGFycmF5IGluZGljZXMpLCBvclxuICAgICAgICAgICAgLy8gYikgdGV4dCBsYWJlbHMgZ2V0IHNvcnRlZCBiYXNlZCBvbiBvcmRlciBpbiB0aGUgc291cmNlIGRhdGEgKGhhc2ggcHJlc2VydmVzIGluc2VydGlvbiBvcmRlcilcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZCAmJiB0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4W2RbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfb3JkZXIgPT09ICdERVNDJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4LmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4W3ZhbF0gPSB0aGlzLnRyYWNrcyArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxfdHJhY2tfaW5kZXhbdGhpcy50cmFja3MgKyAxXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcysrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGFzaCBhIHBhcmVudCByZWZlcmVuY2Ugb24gdGhlIGludGVydmFsXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZGlzcGxheSByYW5nZSBzdGFydCBhbmQgZW5kLCBiYXNlZCBvbiBtaW5pbXVtIGFsbG93YWJsZSBpbnRlcnZhbCBkaXNwbGF5IHdpZHRoLFxuICAgICAgICAgICAgICAgIC8vIGJvdW5kZWQgYnkgd2hhdCB3ZSBjYW4gc2VlIChyYW5nZTogdmFsdWVzIGluIHRlcm1zIG9mIHBpeGVscyBvbiB0aGUgc2NyZWVuKVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJlbnQueF9zY2FsZShNYXRoLm1heChkW3RoaXMubGF5b3V0LnN0YXJ0X2ZpZWxkXSwgdGhpcy5zdGF0ZS5zdGFydCkpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6ICAgdGhpcy5wYXJlbnQueF9zY2FsZShNYXRoLm1pbihkW3RoaXMubGF5b3V0LmVuZF9maWVsZF0sIHRoaXMuc3RhdGUuZW5kKSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0uZGlzcGxheV9yYW5nZS53aWR0aCA9IHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlLmVuZCAtIHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhbmQgc3Rhc2ggZGlzcGxheSByYW5nZSB2YWx1ZXMgaW50byBkb21haW4gdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gKGRvbWFpbjogdmFsdWVzIGluIHRlcm1zIG9mIHRoZSBkYXRhIHNldCwgZS5nLiBtZWdhYmFzZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLmRpc3BsYXlfZG9tYWluID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJlbnQueF9zY2FsZS5pbnZlcnQodGhpcy5kYXRhW2ldLmRpc3BsYXlfcmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6ICAgdGhpcy5wYXJlbnQueF9zY2FsZS5pbnZlcnQodGhpcy5kYXRhW2ldLmRpc3BsYXlfcmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS5kaXNwbGF5X2RvbWFpbi53aWR0aCA9IHRoaXMuZGF0YVtpXS5kaXNwbGF5X2RvbWFpbi5lbmQgLSB0aGlzLmRhdGFbaV0uZGlzcGxheV9kb21haW4uc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzcGxpdHRpbmcgdG8gdHJhY2tzIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgZGVzaWduYXRlZCB0cmFjayBzcGxpdCBmaWVsZFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYm90aGVyIHdpdGggY29sbGlzaW9uIGRldGVjdGlvbiAoaW50ZXJ2YWxzIHdpbGwgYmUgZ3JvdXBlZCBvbiB0cmFja3NcbiAgICAgICAgICAgICAgICAvLyBzb2xlbHkgYnkgdGhlIHZhbHVlIG9mIHRyYWNrX3NwbGl0X2ZpZWxkKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZCAmJiB0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5kYXRhW2ldW3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLnRyYWNrID0gdGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFt2YWxdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4W3RoaXMuZGF0YVtpXS50cmFja10ucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3Qgc3BsaXR0aW5nIHRvIHRyYWNrcyBiYXNlZCBvbiBhIGZpZWxkIHZhbHVlIHRoZW4gZG8gc28gYmFzZWQgb24gY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdGlvbiAoYXMgaG93IGl0J3MgZG9uZSBmb3IgZ2VuZXMpLiBVc2UgZGlzcGxheSByYW5nZS9kb21haW4gZGF0YSBnZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvdmUgYW5kIGNhc3QgZWFjaCBpbnRlcnZhbCB0byB0cmFja3Mgc3VjaCB0aGF0IG5vbmUgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS50cmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3RlbnRpYWxfdHJhY2sgPSAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5kYXRhW2ldLnRyYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlzaW9uX29uX3BvdGVudGlhbF90cmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleFtwb3RlbnRpYWxfdHJhY2tdLm1hcChmdW5jdGlvbihwbGFjZWRfaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluX3N0YXJ0ID0gTWF0aC5taW4ocGxhY2VkX2ludGVydmFsLmRpc3BsYXlfcmFuZ2Uuc3RhcnQsIHRoaXMuZGlzcGxheV9yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heF9lbmQgPSBNYXRoLm1heChwbGFjZWRfaW50ZXJ2YWwuZGlzcGxheV9yYW5nZS5lbmQsIHRoaXMuZGlzcGxheV9yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1heF9lbmQgLSBtaW5fc3RhcnQpIDwgKHBsYWNlZF9pbnRlcnZhbC5kaXNwbGF5X3JhbmdlLndpZHRoICsgdGhpcy5kaXNwbGF5X3JhbmdlLndpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uX29uX3BvdGVudGlhbF90cmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcy5kYXRhW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0udHJhY2sgPSBwb3RlbnRpYWxfdHJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleFtwb3RlbnRpYWxfdHJhY2tdLnB1c2godGhpcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsX3RyYWNrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbF90cmFjayA+IHRoaXMudHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzID0gcG90ZW50aWFsX3RyYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4W3BvdGVudGlhbF90cmFja10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbXBsZW1lbnQgdGhlIG1haW4gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8vIExheSBvdXQgc3BhY2UgZmlyc3RcbiAgICAgICAgICAgIHRoaXMuYXNzaWduVHJhY2tzKCk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGZpbHRlcnMgdG8gb25seSByZW5kZXIgYSBzcGVjaWZpZWQgc2V0IG9mIHBvaW50cy4gSGlkZGVuIGZpZWxkcyB3aWxsIHN0aWxsIGJlIGdpdmVuIHNwYWNlIHRvIHJlbmRlciwgYnV0IG5vdCBzaG93bi5cbiAgICAgICAgICAgIGNvbnN0IHRyYWNrX2RhdGEgPSB0aGlzLl9hcHBseUZpbHRlcnMoKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBzaGFyZWQgaGlnaGxpZ2h0IG5vZGVzIGFuZCByZS1yZW5kZXIgdGhlbSBpZiB3ZSdyZSBzcGxpdHRpbmcgb24gdHJhY2tzXG4gICAgICAgICAgICAvLyBBdCBtb3N0IHRoZXJlIHdpbGwgb25seSBiZSBkb3plbiBvciBzbyBub2RlcyBoZXJlIChvbmUgcGVyIHRyYWNrKSBhbmQgZWFjaCB0aW1lXG4gICAgICAgICAgICAvLyB3ZSByZW5kZXIgZGF0YSB3ZSBtYXkgaGF2ZSBuZXcgdHJhY2tzLCBzbyB3aXBpbmcvcmVkcmF3aW5nIGFsbCBpcyByZWFzb25hYmxlLlxuICAgICAgICAgICAgdGhpcy5zdmcuZ3JvdXAuc2VsZWN0QWxsKCcubHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZS5sei1kYXRhX2xheWVyLWludGVydmFscy1zaGFyZWQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBwc3VlZG8tZWxlbWVudCBzbyB0aGF0IHdlIGNhbiBnZW5lcmF0ZSBhbiBpZCBmb3IgdGhlIHNoYXJlZCBub2RlXG4gICAgICAgICAgICAgICAgY29uc3QgcHNldWRvRWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgICAgIHBzZXVkb0VsZW1lbnRbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdID0ga2V5O1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgc2hhcmVkIG5vZGVcbiAgICAgICAgICAgICAgICB0aGlzLnN2Zy5ncm91cC5pbnNlcnQoJ3JlY3QnLCAnOmZpcnN0LWNoaWxkJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgdGhpcy5nZXRFbGVtZW50U3RhdHVzTm9kZUlkKHBzZXVkb0VsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1pbnRlcnZhbHMgbHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZSBsei1kYXRhX2xheWVyLWludGVydmFscy1zaGFyZWQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncngnLCB0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J5JywgdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMucGFyZW50LmxheW91dC5jbGlwYXJlYS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuZ2V0VHJhY2tIZWlnaHQoKSAtIHRoaXMubGF5b3V0LnRyYWNrX3ZlcnRpY2FsX3NwYWNpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAodGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFtrZXldIC0gMSkgKiB0aGlzLmdldFRyYWNrSGVpZ2h0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MgPyBudWxsIDogJ25vbmUnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIGludGVydmFsIGdyb3Vwc1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zdmcuZ3JvdXAuc2VsZWN0QWxsKCdnLmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzJylcbiAgICAgICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFt0aGlzLmxheW91dC5pZF9maWVsZF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzJylcbiAgICAgICAgICAgICAgICAubWVyZ2Uoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiB0aGlzLmdldEVsZW1lbnRJZChkKSlcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gaW50ZXJ2YWwucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgaW50ZXJ2YWwgc3RhdHVzIG5vZGVzIChkaXNwbGF5ZWQgYmVoaW5kIGludGVydmFscyB0byBzaG93IGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IG5lZWRpbmcgdG8gbW9kaWZ5IGludGVydmFsIGRpc3BsYXkgZWxlbWVudChzKSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzbm9kZXMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdyZWN0Lmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUubHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZS1kaXNjcmV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbaW50ZXJ2YWxdLCAoZCkgPT4gYCR7ZGF0YV9sYXllci5nZXRFbGVtZW50SWQoZCl9LXN0YXR1c25vZGVgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzbm9kZXMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydCgncmVjdCcsICc6Zmlyc3QtY2hpbGQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzIGx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUgbHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZS1kaXNjcmV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWVyZ2Uoc3RhdHVzbm9kZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gYCR7ZGF0YV9sYXllci5nZXRFbGVtZW50SWQoZCl9LXN0YXR1c25vZGVgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncnknLCBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGRhdGFfbGF5ZXIubGF5b3V0LnNwbGl0X3RyYWNrcyA/ICdub25lJyA6IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLndpZHRoICsgKDIgKiBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpIC0gZGF0YV9sYXllci5sYXlvdXQudHJhY2tfdmVydGljYWxfc3BhY2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS5zdGFydCAtIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNub2Rlcy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgcHJpbWFyeSBpbnRlcnZhbCByZWN0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0cyA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3JlY3QubHotZGF0YV9sYXllci1pbnRlcnZhbHMubHotaW50ZXJ2YWxfcmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbaW50ZXJ2YWxdLCAoZCkgPT4gYCR7ZFtkYXRhX2xheWVyLmxheW91dC5pZF9maWVsZF19X2ludGVydmFsX3JlY3RgKTtcblxuICAgICAgICAgICAgICAgICAgICByZWN0cy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscyBsei1pbnRlcnZhbF9yZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tZXJnZShyZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2Uud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZGF0YV9sYXllci5sYXlvdXQudHJhY2tfaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpICsgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBkYXRhX2xheWVyLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcihkYXRhX2xheWVyLmxheW91dC5jb2xvciwgZCwgaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgKGQsIGkpID0+IGRhdGFfbGF5ZXIucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKGRhdGFfbGF5ZXIubGF5b3V0LmZpbGxfb3BhY2l0eSwgZCwgaSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlY3RzLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciBpbnRlcnZhbCBjbGljayBhcmVhc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2FyZWFzID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgncmVjdC5sei1kYXRhX2xheWVyLWludGVydmFscy5sei1jbGlja2FyZWEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2ludGVydmFsXSwgKGQpID0+IGAke2QuaW50ZXJ2YWxfbmFtZX1fY2xpY2thcmVhYCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpY2thcmVhcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscyBsei1jbGlja2FyZWEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGNsaWNrYXJlYXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gYCR7ZGF0YV9sYXllci5nZXRFbGVtZW50SWQoZCl9X2NsaWNrYXJlYWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncngnLCBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeScsIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkgLSBkYXRhX2xheWVyLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgZGVmYXVsdCBldmVudCBlbWl0dGVycyB0byBjbGlja2FyZWFzXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgKGVsZW1lbnRfZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRfZGF0YS5wYXJlbnQucGFyZW50LmVtaXQoJ2VsZW1lbnRfY2xpY2tlZCcsIGVsZW1lbnRfZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgbW91c2UgYmVoYXZpb3JzIHRvIGNsaWNrYXJlYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGRhdGFfbGF5ZXIuYXBwbHlCZWhhdmlvcnMuYmluZChkYXRhX2xheWVyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBjbGlja2FyZWFzIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBjbGlja2FyZWFzLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyAvLyBSZW1vdmUgb2xkIGVsZW1lbnRzIGFzIG5lZWRlZFxuICAgICAgICAgICAgc2VsZWN0aW9uLmV4aXQoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gLy8gVXBkYXRlIHRoZSBsZWdlbmQgYXhpcyBpZiB0aGUgbnVtYmVyIG9mIHRpY2tzIGNoYW5nZWRcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnByZXZpb3VzX3RyYWNrcyAhPT0gdGhpcy50cmFja3MpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnVwZGF0ZVNwbGl0VHJhY2tBeGlzKCk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIC8vIFRoZSBpbnRlcnZhbHMgdHJhY2sgYWxsb3dzIGxlZ2VuZHMgdG8gYmUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkLCBpbiB3aGljaCBjYXNlIHNwYWNlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAvLyAvLyAgYWxsb2NhdGVkIGFmdGVyIHRoZSBwYW5lbCBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWdlbmQucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dldFRvb2x0aXBQb3NpdGlvbih0b29sdGlwKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbF9iYm94ID0gZDMuc2VsZWN0KGAjJHt0aGlzLmdldEVsZW1lbnRTdGF0dXNOb2RlSWQodG9vbHRpcC5kYXRhKX1gKS5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4X21pbjogdG9vbHRpcC5kYXRhLmRpc3BsYXlfcmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgeF9tYXg6IHRvb2x0aXAuZGF0YS5kaXNwbGF5X3JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICB5X21pbjogaW50ZXJ2YWxfYmJveC55LFxuICAgICAgICAgICAgICAgIHlfbWF4OiBpbnRlcnZhbF9iYm94LnkgKyBpbnRlcnZhbF9iYm94LmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWRyYXcgc3BsaXQgdHJhY2sgYXhpcyBvciBoaWRlIGl0LCBhbmQgc2hvdy9oaWRlIHRoZSBsZWdlbmQsIGFzIGRldGVybWluZWRcbiAgICAgICAgLy8gYnkgY3VycmVudCBsYXlvdXQgcGFyYW1ldGVycyBhbmQgZGF0YVxuICAgICAgICB1cGRhdGVTcGxpdFRyYWNrQXhpcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZF9heGlzID0gdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfbGVnZW5kX3RvX3lfYXhpcyA/IGB5JHt0aGlzLmxheW91dC50cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzfWAgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja3MgPSArdGhpcy50cmFja3MgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja19oZWlnaHQgPSArdGhpcy5sYXlvdXQudHJhY2tfaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tfc3BhY2luZyA9IDIgKiAoK3RoaXMubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nIHx8IDApICsgKCt0aGlzLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nIHx8IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldF9oZWlnaHQgPSAodHJhY2tzICogdHJhY2tfaGVpZ2h0KSArICgodHJhY2tzIC0gMSkgKiB0cmFja19zcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY2FsZUhlaWdodFRvRGF0YSh0YXJnZXRfaGVpZ2h0KTsgLy8gREVGRUNUXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZF9heGlzICYmIHRoaXMucGFyZW50LmxlZ2VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWdlbmQuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQuYXhlc1tsZWdlbmRfYXhpc10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAodGFyZ2V0X2hlaWdodCAtICh0aGlzLmxheW91dC50cmFja19oZWlnaHQgLyAyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiAodGhpcy5sYXlvdXQudHJhY2tfaGVpZ2h0IC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHZlcnkgdGlnaHQgY291cGxpbmcgYmV0d2VlbiB0aGUgZGlzcGxheSBkaXJlY3RpdmVzOiBlYWNoIGxlZ2VuZCBpdGVtIG11c3QgaWRlbnRpZnkgYSBrZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gIGZpZWxkIGZvciB1bmlxdWUgdHJhY2tzLiAoVHlwaWNhbGx5IHRoaXMgaXMgYHN0YXRlX2lkYCwgdGhlIHNhbWUga2V5IGZpZWxkIHVzZWQgdG8gYXNzaWduIHVuaXF1ZSBjb2xvcnMpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsaXN0IG9mIHVuaXF1ZSBrZXlzIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmRlciBhbG9uZyB0aGUgeS1heGlzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmxlZ2VuZC5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBlbGVtZW50W3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXhba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC50cmFja19zcGxpdF9vcmRlciA9PT0gJ0RFU0MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrID0gTWF0aC5hYnModHJhY2sgLSB0cmFja3MgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0LmF4ZXNbbGVnZW5kX2F4aXNdLnRpY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZWxlbWVudC5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnlfYXhpcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM6IHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2xlZ2VuZF90b195X2F4aXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9vcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlaWxpbmc6IHRyYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QucG9zaXRpb25QYW5lbHMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZF9heGlzICYmIHRoaXMucGFyZW50LmxlZ2VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0LmFsd2F5c19oaWRlX2xlZ2VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVnZW5kLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQuYXhlc1tsZWdlbmRfYXhpc10gPSB7IHJlbmRlcjogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNZXRob2QgdG8gbm90IG9ubHkgdG9nZ2xlIHRoZSBzcGxpdCB0cmFja3MgYm9vbGVhbiBidXQgYWxzbyB1cGRhdGVcbiAgICAgICAgLy8gbmVjZXNzYXJ5IGRpc3BsYXkgdmFsdWVzIHRvIGFuaW1hdGUgYSBjb21wbGV0ZSBtZXJnZS9zcGxpdFxuICAgICAgICB0b2dnbGVTcGxpdFRyYWNrcygpIHtcblxuXG4gICAgICAgICAgICB0aGlzLmxheW91dC5zcGxpdF90cmFja3MgPSAhdGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQubGVnZW5kICYmICF0aGlzLmxheW91dC5hbHdheXNfaGlkZV9sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQubWFyZ2luLmJvdHRvbSA9IDUgKyAodGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzID8gMCA6IHRoaXMucGFyZW50LmxlZ2VuZC5sYXlvdXQuaGVpZ2h0ICsgNSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7ICAgICBcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3JjaW5nIHRoZXNlIHRvIGdvIHRvIG9uZSB3aWxsIGNhdXNlIGEgcmVjYWxjdWxhdGlvbiBvZiB0aGUgZGltZW5zaW9ucyBmb3IgdGhlIHBhcmVudF9wbG90XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdoZW4gYHNjYWxlSGVpZ2h0VG9EYXRhYCBydW5zLCBtaW5faGVpZ2h0ICh3aGljaCBjYW4gZ2V0IHF1aXRlIGxhcmdlKSB3aWxsIGRvbWluYXRlIHBsb3Qnc1xuICAgICAgICAgICAgICAgIC8vIGxheW91dCBmcm9tIHVwZGF0aW5nIGFuZCBjYW4gcG90ZW50aWFsbHkgbGVhZCB0byBhIGxhcmdlIGFtb3VudCBvZiB3aGl0ZXNwYWNlIG9uIHRoZSBzY3JlZW4sIGFzIHdlbGwgYXMgc3RyZXRjaGluZyBwYW5lbHMuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWluX2hlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWluX3dpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBhcmVudF9wbG90LmxheW91dC5taW5faGVpZ2h0ID0gdGhpcy5wYXJlbnRfcGxvdC5fYmFzZV9sYXlvdXQubWluX2hlaWdodDtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnBhcmVudF9wbG90LmxheW91dC5taW5fd2lkdGggPSB0aGlzLnBhcmVudF9wbG90Ll9iYXNlX2xheW91dC5taW5fd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3BsaXRUcmFja0F4aXMoKTtcblxuXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8vIENob29zZSBhbiBhcHByb3ByaWF0ZSBjb2xvciBzY2hlbWUgYmFzZWQgb24gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgdHJhY2ssIGFuZCB3aGV0aGVyIG9yIG5vdCB3ZSBhcmVcbiAgICAgICAgLy8gIHVzaW5nIGV4cGxpY2l0bHkgcHJvdmlkZWQgaXRlbVJnYiBpbmZvcm1hdGlvblxuICAgICAgICBfbWFrZUNvbG9yU2NoZW1lKGNhdGVnb3J5X2luZm8pIHtcbiAgICAgICAgICAgIC8vIElmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBpdGVtUmdiLCBhc3N1bWUgdGhlIGVudGlyZSBkYXRhc2V0IGhhcyBjb2xvcnNcbiAgICAgICAgICAgIGNvbnN0IGhhc19leHBsaWNpdF9jb2xvcnMgPSBjYXRlZ29yeV9pbmZvLmZpbmQoKGl0ZW0pID0+IGl0ZW1bMl0pO1xuICAgICAgICAgICAgaWYgKGhhc19leHBsaWNpdF9jb2xvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlfaW5mby5tYXAoKGl0ZW0pID0+IGl0ZW1bMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYSBzZXQgb2YgY29sb3Igc2NoZW1lcyBmb3IgY29tbW9uIDE1LCAxOCwgb3IgMjUgc3RhdGUgbW9kZWxzLCBhcyBzcGVjaWZpZWQgZnJvbTpcbiAgICAgICAgICAgIC8vICBodHRwczovL2VnZzIud3VzdGwuZWR1L3JvYWRtYXAvd2ViX3BvcnRhbC9jaHJfc3RhdGVfbGVhcm5pbmcuaHRtbFxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGFjdHVhbGx5IHJldmVyc2VkIHNvIHRoYXQgZGltIGNvbG9ycyBjb21lIGZpcnN0LCBvbiB0aGUgcHJlbWlzZSB0aGF0IHVzdWFsbHkgdGhlc2UgYXJlIHRoZVxuICAgICAgICAgICAgLy8gIG1vc3QgY29tbW9uIHN0YXRlc1xuICAgICAgICAgICAgY29uc3Qgbl9jYXRlZ29yaWVzID0gY2F0ZWdvcnlfaW5mby5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobl9jYXRlZ29yaWVzIDw9IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsncmdiKDIxMiwyMTIsMjEyKScsICdyZ2IoMTkyLDE5MiwxOTIpJywgJ3JnYigxMjgsMTI4LDEyOCknLCAncmdiKDE4OSwxODMsMTA3KScsICdyZ2IoMjMzLDE1MCwxMjIpJywgJ3JnYigyMDUsOTIsOTIpJywgJ3JnYigxMzgsMTQ1LDIwOCknLCAncmdiKDEwMiwyMDUsMTcwKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMCwxMDAsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYig1MCwyMDUsNTApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSwwLDApJ107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5fY2F0ZWdvcmllcyA8PSAxOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ3JnYigyMTIsMjEyLDIxMiknLCAncmdiKDE5MiwxOTIsMTkyKScsICdyZ2IoMTI4LDEyOCwxMjgpJywgJ3JnYigxODksMTgzLDEwNyknLCAncmdiKDIwNSw5Miw5MiknLCAncmdiKDEzOCwxNDUsMjA4KScsICdyZ2IoMTAyLDIwNSwxNzApJywgJ3JnYigyNTUsMjU1LDApJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMjU1LDE5NSw3NyknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDAsMTAwLDApJywgJ3JnYigwLDEyOCwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDAsMCknXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiAyNSBjYXRlZ29yaWVzLCB0aGUgaW50ZXJ2YWwgbGF5ZXIgd2lsbCBmYWxsIGJhY2sgdG8gdGhlICdudWxsIHZhbHVlJyBvcHRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gWydyZ2IoMjEyLDIxMiwyMTIpJywgJ3JnYigxMjgsMTI4LDEyOCknLCAncmdiKDExMiw0OCwxNjApJywgJ3JnYigyMzAsMTg0LDE4MyknLCAncmdiKDEzOCwxNDUsMjA4KScsICdyZ2IoMTAyLDIwNSwxNzApJywgJ3JnYigyNTUsMjU1LDEwMiknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwxOTUsNzcpJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMjU1LDE5NSw3NyknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDE5NCwyMjUsNSknLCAncmdiKDAsMTUwLDApJywgJ3JnYigwLDEyOCwwKScsICdyZ2IoMCwxMjgsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsMCwwKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgYWxsIG9mIHRoZSB1bmlxdWUgdHJhY2tzIChhIGNvbWJpbmF0aW9uIG9mIG5hbWUgYW5kIElEIGluZm9ybWF0aW9uKVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3JnYl9maWVsZF0gQSBmaWVsZCB0aGF0IGNvbnRhaW5zIGFuIFJHQiB2YWx1ZS4gQWltZWQgYXQgQkVEIGZpbGVzIHdpdGggYW4gaXRlbVJnYiBjb2x1bW5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBBbGwgW3VuaXF1ZV9pZCwgbGFiZWwsIGNvbG9yXSBwYWlycyBpbiBkYXRhLiBUaGUgdW5pcXVlX2lkIGlzIHRoZSB0aGluZyB1c2VkIHRvIGRlZmluZSBncm91cGluZ3NcbiAgICAgICAgICogIG1vc3QgdW5hbWJpZ3VvdXNseS5cbiAgICAgICAgICovXG4gICAgICAgIF9nZW5lcmF0ZUNhdGVnb3JpZXNGcm9tRGF0YShkYXRhLCByZ2JfZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBoYXJkLWNvZGVkIGxlZ2VuZCBpZiBhdmFpbGFibGUgKGlnbm9yaW5nIGFueSBtb2RzIG9uIHJlLXJlbmRlcilcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZCA9IHRoaXMuX2Jhc2VfbGF5b3V0LmxlZ2VuZDtcbiAgICAgICAgICAgIGlmIChsZWdlbmQgJiYgbGVnZW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWdlbmQubWFwKChpdGVtKSA9PiBbaXRlbVt0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZF0sIGl0ZW0ubGFiZWwsIGl0ZW0uY29sb3JdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgb3B0aW9ucyBmcm9tIGRhdGEsIGlmIG5vIHByZXNldCBsZWdlbmQgZXhpc3RzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVfaWRzID0ge307IC8vIG1ha2UgY2F0ZWdvcmllcyB1bmlxdWVcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBbXTtcblxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpdGVtW3NlbGYubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXTtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1bmlxdWVfaWRzLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlX2lkc1tpZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiByZ2JmaWVsZCBpcyBudWxsLCB0aGVuIHRoZSBsYXN0IGVudHJ5IGlzIHVuZGVmaW5lZC9udWxsIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKFtpZCwgaXRlbVt0aGlzLmxheW91dC50cmFja19sYWJlbF9maWVsZF0sIGl0ZW1bcmdiX2ZpZWxkXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfdG9vbHRpcF9sYXlvdXQgPSB7XG4gICAgICAgIG5hbWVzcGFjZTogeyAnaW50ZXJ2YWxzJzogJ2ludGVydmFscycgfSxcbiAgICAgICAgY2xvc2FibGU6IGZhbHNlLFxuICAgICAgICBzaG93OiB7IG9yOiBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJ10gfSxcbiAgICAgICAgaGlkZTogeyBhbmQ6IFsndW5oaWdobGlnaHRlZCcsICd1bnNlbGVjdGVkJ10gfSxcbiAgICAgICAgaHRtbDogJ3t7e3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhdGVfbmFtZXxodG1sZXNjYXBlfX08YnI+e3t7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGFydHxodG1sZXNjYXBlfX0te3t7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1lbmR8aHRtbGVzY2FwZX19JyxcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJ2YWxzX2xheWVyX2xheW91dCA9ICB7XG4gICAgICAgIG5hbWVzcGFjZTogeyAnaW50ZXJ2YWxzJzogJ2ludGVydmFscycgfSxcbiAgICAgICAgaWQ6ICdpbnRlcnZhbHMnLFxuICAgICAgICB0eXBlOiAnaW50ZXJ2YWxzJyxcbiAgICAgICAgZmllbGRzOiBbJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXJ0JywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWVuZCcsICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9pZCcsICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9uYW1lJywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWl0ZW1SZ2InXSxcbiAgICAgICAgaWRfZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGFydCcsXG4gICAgICAgIHN0YXJ0X2ZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhcnQnLFxuICAgICAgICBlbmRfZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1lbmQnLFxuICAgICAgICB0cmFja19zcGxpdF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICB0cmFja19sYWJlbF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICBzcGxpdF90cmFja3M6IGZhbHNlLFxuICAgICAgICBhbHdheXNfaGlkZV9sZWdlbmQ6IHRydWUsXG4gICAgICAgIGNvbG9yOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJlc2VudCwgYW4gZXhwbGljaXQgY29sb3IgZmllbGQgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgb3B0aW9uIChhbmQgYmUgdXNlZCB0byBhdXRvLWdlbmVyYXRlIGxlZ2VuZClcbiAgICAgICAgICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWl0ZW1SZ2InLFxuICAgICAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAndG9fcmdiJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9uYW1lJyxcbiAgICAgICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ2NhdGVnb3JpY2FsX2JpbicsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZWhvbGRlci4gRW1wdHkgY2F0ZWdvcmllcyBhbmQgdmFsdWVzIHdpbGwgYXV0b21hdGljYWxseSBiZSBmaWxsZWQgaW4gd2hlbiBuZXcgZGF0YSBsb2Fkcy5cbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICAgICAgICAgIG51bGxfdmFsdWU6ICcjQjhCOEI4JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kOiBbXSwgLy8gUGxhY2Vob2xkZXI7IGF1dG8tZmlsbGVkIHdoZW4gZGF0YSBsb2Fkcy5cbiAgICAgICAgYmVoYXZpb3JzOiB7XG4gICAgICAgICAgICBvbm1vdXNlb3ZlcjogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAnc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25tb3VzZW91dDogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndW5zZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbmNsaWNrOiBbXG4gICAgICAgICAgICAgICAgeyBhY3Rpb246ICd0b2dnbGUnLCBzdGF0dXM6ICdzZWxlY3RlZCcsIGV4Y2x1c2l2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uc2hpZnRjbGljazogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndG9nZ2xlJywgc3RhdHVzOiAnc2VsZWN0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiBpbnRlcnZhbHNfdG9vbHRpcF9sYXlvdXQsXG4gICAgfTtcblxuICAgIGNvbnN0IGludGVydmFsc19wYW5lbF9sYXlvdXQgPSB7XG4gICAgICAgIGlkOiAnaW50ZXJ2YWxzJyxcbiAgICAgICAgd2lkdGg6IDEwMDAsXG4gICAgICAgIGhlaWdodDogNTAsXG4gICAgICAgIG1pbl93aWR0aDogNTAwLFxuICAgICAgICBtaW5faGVpZ2h0OiA1MCxcbiAgICAgICAgbWFyZ2luOiB7IHRvcDogMjUsIHJpZ2h0OiAxNTAsIGJvdHRvbTogNSwgbGVmdDogNTAgfSxcbiAgICAgICAgdG9vbGJhcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2xiYXInLCAnc3RhbmRhcmRfcGFuZWwnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGwud2lkZ2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG9nZ2xlX3NwbGl0X3RyYWNrcycsXG4gICAgICAgICAgICAgICAgZGF0YV9sYXllcl9pZDogJ2ludGVydmFscycsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9KSgpLFxuICAgICAgICBheGVzOiB7fSxcbiAgICAgICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgICAgIGRyYWdfYmFja2dyb3VuZF90b19wYW46IHRydWUsXG4gICAgICAgICAgICBzY3JvbGxfdG9fem9vbTogdHJ1ZSxcbiAgICAgICAgICAgIHhfbGlua2VkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICBvcmlnaW46IHsgeDogNTAsIHk6IDAgfSxcbiAgICAgICAgICAgIHBhZF9mcm9tX2JvdHRvbTogNSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YV9sYXllcnM6IFtpbnRlcnZhbHNfbGF5ZXJfbGF5b3V0XSxcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJ2YWxzX3Bsb3RfbGF5b3V0ID0ge1xuICAgICAgICBzdGF0ZToge30sXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNTUwLFxuICAgICAgICByZXNwb25zaXZlX3Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgbWluX3JlZ2lvbl9zY2FsZTogMjAwMDAsXG4gICAgICAgIG1heF9yZWdpb25fc2NhbGU6IDEwMDAwMDAsXG4gICAgICAgIHRvb2xiYXI6IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbGJhcicsICdzdGFuZGFyZF9hc3NvY2lhdGlvbicsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pLFxuICAgICAgICBwYW5lbHM6IFtcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLmdldCgncGFuZWwnLCAnYXNzb2NpYXRpb24nLCB7XG4gICAgICAgICAgICAgICAgdW5uYW1lc3BhY2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgcHJvcG9ydGlvbmFsX2hlaWdodDogKDIyNSAvIDU3MCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgeyB1bm5hbWVzcGFjZWQ6IHRydWUsIHByb3BvcnRpb25hbF9oZWlnaHQ6ICgxMjAgLyA1NzApIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzX3BhbmVsX2xheW91dFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLmdldCgncGFuZWwnLCAnZ2VuZXMnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSwgd2lkdGg6IDgwMCwgcHJvcG9ydGlvbmFsX2hlaWdodDogKDIyNSAvIDU3MCkgfSksXG4gICAgICAgIF0sXG4gICAgfTtcblxuICAgIExvY3VzWm9vbS5BZGFwdGVycy5hZGQoJ0ludGVydmFsTFonLCBJbnRlcnZhbExaKTtcbiAgICBMb2N1c1pvb20uRGF0YUxheWVycy5hZGQoJ2ludGVydmFscycsIEx6SW50ZXJ2YWxzVHJhY2spO1xuXG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCd0b29sdGlwJywgJ3N0YW5kYXJkX2ludGVydmFscycsIGludGVydmFsc190b29sdGlwX2xheW91dCk7XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdkYXRhX2xheWVyJywgJ2ludGVydmFscycsIGludGVydmFsc19sYXllcl9sYXlvdXQpO1xuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgncGFuZWwnLCAnaW50ZXJ2YWxzJywgaW50ZXJ2YWxzX3BhbmVsX2xheW91dCk7XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdwbG90JywgJ2ludGVydmFsX2Fzc29jaWF0aW9uJywgaW50ZXJ2YWxzX3Bsb3RfbGF5b3V0KTtcblxuICAgIExvY3VzWm9vbS5TY2FsZUZ1bmN0aW9ucy5hZGQoJ3RvX3JnYicsIHRvX3JnYik7XG5cbiAgICBMb2N1c1pvb20uV2lkZ2V0cy5hZGQoJ3RvZ2dsZV9zcGxpdF90cmFja3MnLCBUb2dnbGVTcGxpdFRyYWNrcyk7XG59XG5cbmlmICh0eXBlb2YgTG9jdXNab29tICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEF1dG8tcmVnaXN0ZXIgdGhlIHBsdWdpbiB3aGVuIGluY2x1ZGVkIGFzIGEgc2NyaXB0IHRhZy4gRVM2IG1vZHVsZSB1c2VycyBtdXN0IHJlZ2lzdGVyIHZpYSBMb2N1c1pvb20udXNlKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBMb2N1c1pvb20udXNlKGluc3RhbGwpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbGw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGQzOyJdLCJzb3VyY2VSb290IjoiIn0=