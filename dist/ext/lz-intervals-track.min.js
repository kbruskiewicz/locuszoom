/*! Locuszoom 0.13.0-beta.2 */
var LzIntervalsTrack =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-intervals-track.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-intervals-track.js":
/*!***************************************!*\
  !*** ./esm/ext/lz-intervals-track.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.
This is not part of the core LocusZoom library, but can be included as a standalone file.

The page must incorporate and load all libraries before this file can be used, including:
 - Vendor assets
 - LocusZoom
 @module
*/


function install(LocusZoom) {
  var BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');

  var _Button = LocusZoom.Widgets.get('_Button');

  var _BaseWidget = LocusZoom.Widgets.get('BaseWidget');
  /**
   * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)
   * @public
   */


  var IntervalLZ = /*#__PURE__*/function (_BaseApiAdapter) {
    _inherits(IntervalLZ, _BaseApiAdapter);

    var _super = _createSuper(IntervalLZ);

    function IntervalLZ() {
      _classCallCheck(this, IntervalLZ);

      return _super.apply(this, arguments);
    }

    _createClass(IntervalLZ, [{
      key: "getURL",
      value: function getURL(state, chain, fields) {
        var source = chain.header.bedtracksource || this.params.source;
        var query = "?filter=id in ".concat(source, " and chromosome eq '").concat(state.chr, "' and start le ").concat(state.end, " and end ge ").concat(state.start);
        return "".concat(this.url).concat(query);
      }
    }]);

    return IntervalLZ;
  }(BaseApiAdapter);
  /**
   * Button to toggle split tracks
   */


  var ToggleSplitTracks = /*#__PURE__*/function (_BaseWidget2) {
    _inherits(ToggleSplitTracks, _BaseWidget2);

    var _super2 = _createSuper(ToggleSplitTracks);

    function ToggleSplitTracks(layout) {
      var _this;

      _classCallCheck(this, ToggleSplitTracks);

      _this = _super2.apply(this, arguments);

      if (!layout.data_layer_id) {
        layout.data_layer_id = 'intervals';
      }

      if (!_this.parent_panel.data_layers[layout.data_layer_id]) {
        throw new Error('Toggle split tracks widget specifies an invalid data layer ID');
      }

      return _this;
    }

    _createClass(ToggleSplitTracks, [{
      key: "update",
      value: function update() {
        var _this2 = this;

        var data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];
        var html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';

        if (this.button) {
          this.button.setHtml(html);
          this.button.show();
          this.parent.position();
          return this;
        } else {
          this.button = new _Button(this).setColor(this.layout.color).setHtml(html).setTitle('Toggle whether tracks are split apart or merged together').setOnclick(function () {
            data_layer.toggleSplitTracks();

            if (_this2.scale_timeout) {
              clearTimeout(_this2.scale_timeout);
            }

            _this2.scale_timeout = setTimeout(function () {
              _this2.parent_panel.scaleHeightToData();

              _this2.parent_plot.positionPanels();
            }, 0);

            _this2.update();
          });
          return this.update();
        }
      }
    }]);

    return ToggleSplitTracks;
  }(_BaseWidget);
  /**
   * Convert a value ""rr,gg,bb" (if given) to a css-friendly color string: "rgb(rr,gg,bb)".
   * This is tailored specifically to the color specification format embraced by the BED file standard.
   * @function to_rgb
   * @param {Object} parameters This function has no defined configuration options
   * @param {String|null} value The value to convert to rgb
   */


  function to_rgb(parameters, value) {
    return value ? "rgb(".concat(value, ")") : null;
  }

  var default_layout = {
    start_field: 'start',
    end_field: 'end',
    track_label_field: 'state_name',
    // Used to label items on the y-axis
    // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting
    //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,
    //  not just choose unique colors within a particular narrow region. (where changing region might lead to more
    //  categories and different colors)
    track_split_field: 'state_id',
    track_split_order: 'DESC',
    track_split_legend_to_y_axis: 2,
    split_tracks: true,
    track_height: 15,
    track_vertical_spacing: 3,
    bounding_box_padding: 2,
    always_hide_legend: false,
    color: '#B8B8B8',
    fill_opacity: 1,
    tooltip_positioning: 'vertical'
  };
  /**
   * Intervals Data Layer
   * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)
   */

  var BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');

  var LzIntervalsTrack = /*#__PURE__*/function (_BaseLayer) {
    _inherits(LzIntervalsTrack, _BaseLayer);

    var _super3 = _createSuper(LzIntervalsTrack);

    function LzIntervalsTrack(layout) {
      var _this3;

      _classCallCheck(this, LzIntervalsTrack);

      LocusZoom.Layouts.merge(layout, default_layout);
      _this3 = _super3.apply(this, arguments);
      _this3.tracks = 1;
      _this3.previous_tracks = 1; // track-number-indexed object with arrays of interval indexes in the dataset

      _this3.interval_track_index = {
        1: []
      };
      return _this3;
    }
    /**
     * To define shared highlighting on the track split field define the status node id override
     * to generate an ID common to the track when we're actively splitting data out to separate tracks
     * @override
     * @returns {String}
     */


    _createClass(LzIntervalsTrack, [{
      key: "getElementStatusNodeId",
      value: function getElementStatusNodeId(element) {
        if (this.layout.split_tracks) {
          return "".concat(this.getBaseId(), "-statusnode-").concat(element[this.layout.track_split_field]).replace(/[^\w]/g, '_');
        }

        return "".concat(this.getElementId(element), "-statusnode");
      } // Helper function to sum layout values to derive total height for a single interval track

    }, {
      key: "getTrackHeight",
      value: function getTrackHeight() {
        return this.layout.track_height + this.layout.track_vertical_spacing + 2 * this.layout.bounding_box_padding;
      } // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available
      // Even when not displayed, the legend is used to generate the y-axis ticks

    }, {
      key: "_applyLayoutOptions",
      value: function _applyLayoutOptions() {
        var self = this;
        var base_layout = this._base_layout;
        var render_layout = this.layout;
        var base_color_scale = base_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'categorical_bin';
        });
        var color_scale = render_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'categorical_bin';
        });

        if (!base_color_scale) {
          // This can be a placeholder (empty categories & values), but it needs to be there
          throw new Error('Interval tracks must define a `categorical_bin` color scale');
        }

        var has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;
        var has_legend = base_layout.legend && base_layout.legend.length;

        if (!!has_colors ^ !!has_legend) {
          // Don't allow color OR legend to be set manually. It must be both, or neither.
          throw new Error('To use a manually specified color scheme, both color and legend options must be set.');
        } // Harvest any information about an explicit color field that should be considered when generating colors


        var rgb_option = base_layout.color.find(function (item) {
          return item.scale_function && item.scale_function === 'to_rgb';
        });
        var rgb_field = rgb_option && rgb_option.field; // Auto-generate legend based on data

        var known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items


        if (!has_colors && !has_legend) {
          // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot
          // The legend must match the color scheme. If we generate one, then we must generate both.
          var colors = this._makeColorScheme(known_categories);

          color_scale.parameters.categories = known_categories.map(function (item) {
            return item[0];
          });
          color_scale.parameters.values = colors;
          this.layout.legend = known_categories.map(function (pair, index) {
            var id = pair[0];
            var label = pair[1];
            var item_color = color_scale.parameters.values[index];
            var item = {
              shape: 'rect',
              width: 9,
              label: label,
              color: item_color
            };
            item[self.layout.track_split_field] = id;
            return item;
          });
        }
      } // After we've loaded interval data interpret it to assign
      // each to a track so that they do not overlap in the view

    }, {
      key: "assignTracks",
      value: function assignTracks() {
        var _this4 = this;

        // Autogenerate layout options if not provided
        this._applyLayoutOptions(); // Reinitialize some metadata


        this.previous_tracks = this.tracks;
        this.tracks = 0;
        this.interval_track_index = {
          1: []
        }; // This maps unique values of track_split_field to unique y indices. It controls the ordering of separate tracks.

        this.track_split_field_index = {}; // If splitting tracks by a field's value then determine how to order them. There are two options here:
        // a) numeric IDs get sorted in numeric order (JS quirk: int object keys act like array indices), or
        // b) text labels get sorted based on order in the source data (hash preserves insertion order)

        if (this.layout.track_split_field && this.layout.split_tracks) {
          this.data.forEach(function (d) {
            _this4.track_split_field_index[d[_this4.layout.track_split_field]] = null;
          });
          var index = Object.keys(this.track_split_field_index);

          if (this.layout.track_split_order === 'DESC') {
            index.reverse();
          }

          index.forEach(function (val) {
            _this4.track_split_field_index[val] = _this4.tracks + 1;
            _this4.interval_track_index[_this4.tracks + 1] = [];
            _this4.tracks++;
          });
        }

        this.data.forEach(function (d, i) {
          var _this5 = this;

          // Stash a parent reference on the interval
          this.data[i].parent = this; // Determine display range start and end, based on minimum allowable interval display width,
          // bounded by what we can see (range: values in terms of pixels on the screen)

          this.data[i].display_range = {
            start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),
            end: this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end))
          };
          this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start; // Convert and stash display range values into domain values
          // (domain: values in terms of the data set, e.g. megabases)

          this.data[i].display_domain = {
            start: this.parent.x_scale.invert(this.data[i].display_range.start),
            end: this.parent.x_scale.invert(this.data[i].display_range.end)
          };
          this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start; // If splitting to tracks based on the value of the designated track split field
          // then don't bother with collision detection (intervals will be grouped on tracks
          // solely by the value of track_split_field)

          if (this.layout.track_split_field && this.layout.split_tracks) {
            var val = this.data[i][this.layout.track_split_field];
            this.data[i].track = this.track_split_field_index[val];
            this.interval_track_index[this.data[i].track].push(i);
          } else {
            // If not splitting to tracks based on a field value then do so based on collision
            // detection (as how it's done for genes). Use display range/domain data generated
            // above and cast each interval to tracks such that none overlap
            this.tracks = 1;
            this.data[i].track = null;
            var potential_track = 1;

            var _loop = function _loop() {
              var collision_on_potential_track = false;

              _this5.interval_track_index[potential_track].map(function (placed_interval) {
                if (!collision_on_potential_track) {
                  var min_start = Math.min(placed_interval.display_range.start, this.display_range.start);
                  var max_end = Math.max(placed_interval.display_range.end, this.display_range.end);

                  if (max_end - min_start < placed_interval.display_range.width + this.display_range.width) {
                    collision_on_potential_track = true;
                  }
                }
              }.bind(_this5.data[i]));

              if (!collision_on_potential_track) {
                _this5.data[i].track = potential_track;

                _this5.interval_track_index[potential_track].push(_this5.data[i]);
              } else {
                potential_track++;

                if (potential_track > _this5.tracks) {
                  _this5.tracks = potential_track;
                  _this5.interval_track_index[potential_track] = [];
                }
              }
            };

            while (this.data[i].track === null) {
              _loop();
            }
          }
        }.bind(this));
        return this;
      } // Implement the main render function

    }, {
      key: "render",
      value: function render() {
        var _this6 = this;

        // Lay out space first
        this.assignTracks(); // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.

        var track_data = this._applyFilters(); // Remove any shared highlight nodes and re-render them if we're splitting on tracks
        // At most there will only be dozen or so nodes here (one per track) and each time
        // we render data we may have new tracks, so wiping/redrawing all is reasonable.


        this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();
        Object.keys(this.track_split_field_index).forEach(function (key) {
          // Make a psuedo-element so that we can generate an id for the shared node
          var pseudoElement = {};
          pseudoElement[_this6.layout.track_split_field] = key; // Insert the shared node

          _this6.svg.group.insert('rect', ':first-child').attr('id', _this6.getElementStatusNodeId(pseudoElement)).attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared').attr('rx', _this6.layout.bounding_box_padding).attr('ry', _this6.layout.bounding_box_padding).attr('width', _this6.parent.layout.cliparea.width).attr('height', _this6.getTrackHeight() - _this6.layout.track_vertical_spacing).attr('x', 0).attr('y', (_this6.track_split_field_index[key] - 1) * _this6.getTrackHeight()).style('display', _this6.layout.split_tracks ? null : 'none');
        }); // Render interval groups

        var selection = this.svg.group.selectAll('g.lz-data_layer-intervals').data(track_data, function (d) {
          return d[_this6.layout.id_field];
        });
        selection.enter().append('g').attr('class', 'lz-data_layer-intervals').merge(selection).attr('id', function (d) {
          return _this6.getElementId(d);
        }).each(function (interval) {
          var data_layer = interval.parent; // Render interval status nodes (displayed behind intervals to show highlight
          // without needing to modify interval display element(s))

          var statusnodes = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete').data([interval], function (d) {
            return "".concat(data_layer.getElementId(d), "-statusnode");
          });
          statusnodes.enter().insert('rect', ':first-child').attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete').merge(statusnodes).attr('id', function (d) {
            return "".concat(data_layer.getElementId(d), "-statusnode");
          }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).style('display', data_layer.layout.split_tracks ? 'none' : null).attr('width', function (d) {
            return d.display_range.width + 2 * data_layer.layout.bounding_box_padding;
          }).attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing).attr('x', function (d) {
            return d.display_range.start - data_layer.layout.bounding_box_padding;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight();
          });
          statusnodes.exit().remove(); // Render primary interval rects

          var rects = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect').data([interval], function (d) {
            return "".concat(d[data_layer.layout.id_field], "_interval_rect");
          });
          rects.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-interval_rect').merge(rects).attr('width', function (d) {
            return d.display_range.width;
          }).attr('height', data_layer.layout.track_height).attr('x', function (d) {
            return d.display_range.start;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding;
          }).attr('fill', function (d, i) {
            return data_layer.resolveScalableParameter(data_layer.layout.color, d, i);
          }).attr('fill-opacity', function (d, i) {
            return data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d, i);
          });
          rects.exit().remove(); // Render interval click areas

          var clickareas = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-intervals.lz-clickarea').data([interval], function (d) {
            return "".concat(d.interval_name, "_clickarea");
          });
          clickareas.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-clickarea').merge(clickareas).attr('id', function (d) {
            return "".concat(data_layer.getElementId(d), "_clickarea");
          }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).attr('width', function (d) {
            return d.display_range.width;
          }).attr('height', data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing).attr('x', function (d) {
            return d.display_range.start;
          }).attr('y', function (d) {
            return (d.track - 1) * data_layer.getTrackHeight();
          }) // Apply default event emitters to clickareas
          .on('click', function (element_data) {
            element_data.parent.parent.emit('element_clicked', element_data, true);
          }) // Apply mouse behaviors to clickareas
          .call(data_layer.applyBehaviors.bind(data_layer)); // Remove old clickareas as needed

          clickareas.exit().remove();
        }); // // Remove old elements as needed

        selection.exit().remove(); // // Update the legend axis if the number of ticks changed
        // if (this.previous_tracks !== this.tracks) {
        //     this.updateSplitTrackAxis();
        // }
        // // The intervals track allows legends to be dynamically generated, in which case space can only be
        // //  allocated after the panel has been rendered.

        if (this.parent && this.parent.legend) {
          this.parent.legend.render();
        }

        return this;
      }
    }, {
      key: "_getTooltipPosition",
      value: function _getTooltipPosition(tooltip) {
        var interval_bbox = d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(this.getElementStatusNodeId(tooltip.data))).node().getBBox();
        return {
          x_min: tooltip.data.display_range.start,
          x_max: tooltip.data.display_range.end,
          y_min: interval_bbox.y,
          y_max: interval_bbox.y + interval_bbox.height
        };
      } // Redraw split track axis or hide it, and show/hide the legend, as determined
      // by current layout parameters and data

    }, {
      key: "updateSplitTrackAxis",
      value: function updateSplitTrackAxis() {
        var _this7 = this;

        var legend_axis = this.layout.track_split_legend_to_y_axis ? "y".concat(this.layout.track_split_legend_to_y_axis) : false;

        if (this.layout.split_tracks) {
          var tracks = +this.tracks || 0;
          var track_height = +this.layout.track_height || 0;
          var track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);
          var target_height = tracks * track_height + (tracks - 1) * track_spacing;
          this.parent.scaleHeightToData(target_height);

          if (legend_axis && this.parent.legend) {
            this.parent.legend.hide();
            this.parent.layout.axes[legend_axis] = {
              render: true,
              ticks: [],
              range: {
                start: target_height - this.layout.track_height / 2,
                end: this.layout.track_height / 2
              }
            }; // There is a very tight coupling between the display directives: each legend item must identify a key
            //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)
            // The list of unique keys corresponds to the order along the y-axis

            this.layout.legend.forEach(function (element) {
              var key = element[_this7.layout.track_split_field];
              var track = _this7.track_split_field_index[key];

              if (track) {
                if (_this7.layout.track_split_order === 'DESC') {
                  track = Math.abs(track - tracks - 1);
                }

                _this7.parent.layout.axes[legend_axis].ticks.push({
                  y: track,
                  text: element.label
                });
              }
            });
            this.layout.y_axis = {
              axis: this.layout.track_split_legend_to_y_axis,
              floor: 1,
              ceiling: tracks
            };
            this.parent.render();
          }

          this.parent_plot.positionPanels();
        } else {
          if (legend_axis && this.parent.legend) {
            if (!this.layout.always_hide_legend) {
              this.parent.legend.show();
            }

            this.parent.layout.axes[legend_axis] = {
              render: false
            };
            this.parent.render();
          }
        }

        return this;
      } // Method to not only toggle the split tracks boolean but also update
      // necessary display values to animate a complete merge/split

    }, {
      key: "toggleSplitTracks",
      value: function toggleSplitTracks() {
        this.layout.split_tracks = !this.layout.split_tracks;

        if (this.parent.legend && !this.layout.always_hide_legend) {
          this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);
        }

        this.render();
        this.updateSplitTrackAxis();

        if (!this.layout.split_tracks) {
          // console.log(this)
          // console.log(this.parent_plot.layout.width, this.parent_plot.layout.height)
          this.parent_plot.layout.min_height = this.parent_plot._base_layout.min_height;
          this.parent_plot.layout.min_width = this.parent_plot._base_layout.min_width;
          console.log(this.parent_plot.layout, this.parent_plot._base_layout);
          this.parent_plot.positionPanels();
        }

        return this;
      } // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are
      //  using explicitly provided itemRgb information

    }, {
      key: "_makeColorScheme",
      value: function _makeColorScheme(category_info) {
        // If at least one element has an explicit itemRgb, assume the entire dataset has colors
        var has_explicit_colors = category_info.find(function (item) {
          return item[2];
        });

        if (has_explicit_colors) {
          return category_info.map(function (item) {
            return item[2];
          });
        } // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:
        //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html
        // These are actually reversed so that dim colors come first, on the premise that usually these are the
        //  most common states


        var n_categories = category_info.length;

        if (n_categories <= 15) {
          return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        } else if (n_categories <= 18) {
          return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        } else {
          // If there are more than 25 categories, the interval layer will fall back to the 'null value' option
          return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
        }
      }
      /**
       * Find all of the unique tracks (a combination of name and ID information)
       * @param {Object} data
       * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column
       * @private
       * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings
       *  most unambiguously.
       */

    }, {
      key: "_generateCategoriesFromData",
      value: function _generateCategoriesFromData(data, rgb_field) {
        var _this8 = this;

        var self = this; // Use the hard-coded legend if available (ignoring any mods on re-render)

        var legend = this._base_layout.legend;

        if (legend && legend.length) {
          return legend.map(function (item) {
            return [item[_this8.layout.track_split_field], item.label, item.color];
          });
        } // Generate options from data, if no preset legend exists


        var unique_ids = {}; // make categories unique

        var categories = [];
        data.forEach(function (item) {
          var id = item[self.layout.track_split_field];

          if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {
            unique_ids[id] = null; // If rgbfield is null, then the last entry is undefined/null as well

            categories.push([id, item[_this8.layout.track_label_field], item[rgb_field]]);
          }
        });
        return categories;
      }
    }]);

    return LzIntervalsTrack;
  }(BaseLayer);

  var intervals_tooltip_layout = {
    namespace: {
      'intervals': 'intervals'
    },
    closable: false,
    show: {
      or: ['highlighted', 'selected']
    },
    hide: {
      and: ['unhighlighted', 'unselected']
    },
    html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}'
  };
  var intervals_layer_layout = {
    namespace: {
      'intervals': 'intervals'
    },
    id: 'intervals',
    type: 'intervals',
    fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],
    id_field: '{{namespace[intervals]}}start',
    start_field: '{{namespace[intervals]}}start',
    end_field: '{{namespace[intervals]}}end',
    track_split_field: '{{namespace[intervals]}}state_name',
    track_label_field: '{{namespace[intervals]}}state_name',
    split_tracks: false,
    always_hide_legend: true,
    color: [{
      // If present, an explicit color field will override any other option (and be used to auto-generate legend)
      field: '{{namespace[intervals]}}itemRgb',
      scale_function: 'to_rgb'
    }, {
      field: '{{namespace[intervals]}}state_name',
      scale_function: 'categorical_bin',
      parameters: {
        // Placeholder. Empty categories and values will automatically be filled in when new data loads.
        categories: [],
        values: [],
        null_value: '#B8B8B8'
      }
    }],
    legend: [],
    // Placeholder; auto-filled when data loads.
    behaviors: {
      onmouseover: [{
        action: 'set',
        status: 'highlighted'
      }],
      onmouseout: [{
        action: 'unset',
        status: 'highlighted'
      }],
      onclick: [{
        action: 'toggle',
        status: 'selected',
        exclusive: true
      }],
      onshiftclick: [{
        action: 'toggle',
        status: 'selected'
      }]
    },
    tooltip: intervals_tooltip_layout
  };
  var intervals_panel_layout = {
    id: 'intervals',
    width: 1000,
    height: 50,
    min_width: 500,
    min_height: 50,
    margin: {
      top: 25,
      right: 150,
      bottom: 5,
      left: 50
    },
    toolbar: function () {
      var l = LocusZoom.Layouts.get('toolbar', 'standard_panel', {
        unnamespaced: true
      });
      l.widgets.push({
        type: 'toggle_split_tracks',
        data_layer_id: 'intervals',
        position: 'right'
      });
      return l;
    }(),
    axes: {},
    interaction: {
      drag_background_to_pan: true,
      scroll_to_zoom: true,
      x_linked: true
    },
    legend: {
      hidden: true,
      orientation: 'horizontal',
      origin: {
        x: 50,
        y: 0
      },
      pad_from_bottom: 5
    },
    data_layers: [intervals_layer_layout]
  };
  var intervals_plot_layout = {
    state: {},
    width: 800,
    height: 550,
    responsive_resize: true,
    min_region_scale: 20000,
    max_region_scale: 1000000,
    toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', {
      unnamespaced: true
    }),
    panels: [LocusZoom.Layouts.get('panel', 'association', {
      unnamespaced: true,
      width: 800,
      proportional_height: 225 / 570
    }), Object.assign({
      unnamespaced: true,
      proportional_height: 120 / 570
    }, intervals_panel_layout), LocusZoom.Layouts.get('panel', 'genes', {
      unnamespaced: true,
      width: 800,
      proportional_height: 225 / 570
    })]
  };
  LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);
  LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);
  LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);
  LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);
  LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);
  LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);
  LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);
  LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);
}

if (typeof LocusZoom !== 'undefined') {
  // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
  // eslint-disable-next-line no-undef
  LocusZoom.use(install);
}

/* harmony default export */ __webpack_exports__["default"] = (install);

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1pbnRlcnZhbHMtdHJhY2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6WyJpbnN0YWxsIiwiTG9jdXNab29tIiwiQmFzZUFwaUFkYXB0ZXIiLCJBZGFwdGVycyIsImdldCIsIl9CdXR0b24iLCJXaWRnZXRzIiwiX0Jhc2VXaWRnZXQiLCJJbnRlcnZhbExaIiwic3RhdGUiLCJjaGFpbiIsImZpZWxkcyIsInNvdXJjZSIsImhlYWRlciIsImJlZHRyYWNrc291cmNlIiwicGFyYW1zIiwicXVlcnkiLCJjaHIiLCJlbmQiLCJzdGFydCIsInVybCIsIlRvZ2dsZVNwbGl0VHJhY2tzIiwibGF5b3V0IiwiYXJndW1lbnRzIiwiZGF0YV9sYXllcl9pZCIsInBhcmVudF9wYW5lbCIsImRhdGFfbGF5ZXJzIiwiRXJyb3IiLCJkYXRhX2xheWVyIiwiaHRtbCIsInNwbGl0X3RyYWNrcyIsImJ1dHRvbiIsInNldEh0bWwiLCJzaG93IiwicGFyZW50IiwicG9zaXRpb24iLCJzZXRDb2xvciIsImNvbG9yIiwic2V0VGl0bGUiLCJzZXRPbmNsaWNrIiwidG9nZ2xlU3BsaXRUcmFja3MiLCJzY2FsZV90aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInNjYWxlSGVpZ2h0VG9EYXRhIiwicGFyZW50X3Bsb3QiLCJwb3NpdGlvblBhbmVscyIsInVwZGF0ZSIsInRvX3JnYiIsInBhcmFtZXRlcnMiLCJ2YWx1ZSIsImRlZmF1bHRfbGF5b3V0Iiwic3RhcnRfZmllbGQiLCJlbmRfZmllbGQiLCJ0cmFja19sYWJlbF9maWVsZCIsInRyYWNrX3NwbGl0X2ZpZWxkIiwidHJhY2tfc3BsaXRfb3JkZXIiLCJ0cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzIiwidHJhY2tfaGVpZ2h0IiwidHJhY2tfdmVydGljYWxfc3BhY2luZyIsImJvdW5kaW5nX2JveF9wYWRkaW5nIiwiYWx3YXlzX2hpZGVfbGVnZW5kIiwiZmlsbF9vcGFjaXR5IiwidG9vbHRpcF9wb3NpdGlvbmluZyIsIkJhc2VMYXllciIsIkRhdGFMYXllcnMiLCJMekludGVydmFsc1RyYWNrIiwiTGF5b3V0cyIsIm1lcmdlIiwidHJhY2tzIiwicHJldmlvdXNfdHJhY2tzIiwiaW50ZXJ2YWxfdHJhY2tfaW5kZXgiLCJlbGVtZW50IiwiZ2V0QmFzZUlkIiwicmVwbGFjZSIsImdldEVsZW1lbnRJZCIsInNlbGYiLCJiYXNlX2xheW91dCIsIl9iYXNlX2xheW91dCIsInJlbmRlcl9sYXlvdXQiLCJiYXNlX2NvbG9yX3NjYWxlIiwiZmluZCIsIml0ZW0iLCJzY2FsZV9mdW5jdGlvbiIsImNvbG9yX3NjYWxlIiwiaGFzX2NvbG9ycyIsImNhdGVnb3JpZXMiLCJsZW5ndGgiLCJ2YWx1ZXMiLCJoYXNfbGVnZW5kIiwibGVnZW5kIiwicmdiX29wdGlvbiIsInJnYl9maWVsZCIsImZpZWxkIiwia25vd25fY2F0ZWdvcmllcyIsIl9nZW5lcmF0ZUNhdGVnb3JpZXNGcm9tRGF0YSIsImRhdGEiLCJjb2xvcnMiLCJfbWFrZUNvbG9yU2NoZW1lIiwibWFwIiwicGFpciIsImluZGV4IiwiaWQiLCJsYWJlbCIsIml0ZW1fY29sb3IiLCJzaGFwZSIsIndpZHRoIiwiX2FwcGx5TGF5b3V0T3B0aW9ucyIsInRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4IiwiZm9yRWFjaCIsImQiLCJPYmplY3QiLCJrZXlzIiwicmV2ZXJzZSIsInZhbCIsImkiLCJkaXNwbGF5X3JhbmdlIiwieF9zY2FsZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJkaXNwbGF5X2RvbWFpbiIsImludmVydCIsInRyYWNrIiwicHVzaCIsInBvdGVudGlhbF90cmFjayIsImNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2siLCJwbGFjZWRfaW50ZXJ2YWwiLCJtaW5fc3RhcnQiLCJtYXhfZW5kIiwiYmluZCIsImFzc2lnblRyYWNrcyIsInRyYWNrX2RhdGEiLCJfYXBwbHlGaWx0ZXJzIiwic3ZnIiwiZ3JvdXAiLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJrZXkiLCJwc2V1ZG9FbGVtZW50IiwiaW5zZXJ0IiwiYXR0ciIsImdldEVsZW1lbnRTdGF0dXNOb2RlSWQiLCJjbGlwYXJlYSIsImdldFRyYWNrSGVpZ2h0Iiwic3R5bGUiLCJzZWxlY3Rpb24iLCJpZF9maWVsZCIsImVudGVyIiwiYXBwZW5kIiwiZWFjaCIsImludGVydmFsIiwic3RhdHVzbm9kZXMiLCJkMyIsImV4aXQiLCJyZWN0cyIsInJlc29sdmVTY2FsYWJsZVBhcmFtZXRlciIsImNsaWNrYXJlYXMiLCJpbnRlcnZhbF9uYW1lIiwib24iLCJlbGVtZW50X2RhdGEiLCJlbWl0IiwiY2FsbCIsImFwcGx5QmVoYXZpb3JzIiwicmVuZGVyIiwidG9vbHRpcCIsImludGVydmFsX2Jib3giLCJub2RlIiwiZ2V0QkJveCIsInhfbWluIiwieF9tYXgiLCJ5X21pbiIsInkiLCJ5X21heCIsImhlaWdodCIsImxlZ2VuZF9heGlzIiwidHJhY2tfc3BhY2luZyIsInRhcmdldF9oZWlnaHQiLCJoaWRlIiwiYXhlcyIsInRpY2tzIiwicmFuZ2UiLCJhYnMiLCJ0ZXh0IiwieV9heGlzIiwiYXhpcyIsImZsb29yIiwiY2VpbGluZyIsIm1hcmdpbiIsImJvdHRvbSIsInVwZGF0ZVNwbGl0VHJhY2tBeGlzIiwibWluX2hlaWdodCIsIm1pbl93aWR0aCIsImNvbnNvbGUiLCJsb2ciLCJjYXRlZ29yeV9pbmZvIiwiaGFzX2V4cGxpY2l0X2NvbG9ycyIsIm5fY2F0ZWdvcmllcyIsInVuaXF1ZV9pZHMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImludGVydmFsc190b29sdGlwX2xheW91dCIsIm5hbWVzcGFjZSIsImNsb3NhYmxlIiwib3IiLCJhbmQiLCJpbnRlcnZhbHNfbGF5ZXJfbGF5b3V0IiwidHlwZSIsIm51bGxfdmFsdWUiLCJiZWhhdmlvcnMiLCJvbm1vdXNlb3ZlciIsImFjdGlvbiIsInN0YXR1cyIsIm9ubW91c2VvdXQiLCJvbmNsaWNrIiwiZXhjbHVzaXZlIiwib25zaGlmdGNsaWNrIiwiaW50ZXJ2YWxzX3BhbmVsX2xheW91dCIsInRvcCIsInJpZ2h0IiwibGVmdCIsInRvb2xiYXIiLCJsIiwidW5uYW1lc3BhY2VkIiwid2lkZ2V0cyIsImludGVyYWN0aW9uIiwiZHJhZ19iYWNrZ3JvdW5kX3RvX3BhbiIsInNjcm9sbF90b196b29tIiwieF9saW5rZWQiLCJoaWRkZW4iLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIngiLCJwYWRfZnJvbV9ib3R0b20iLCJpbnRlcnZhbHNfcGxvdF9sYXlvdXQiLCJyZXNwb25zaXZlX3Jlc2l6ZSIsIm1pbl9yZWdpb25fc2NhbGUiLCJtYXhfcmVnaW9uX3NjYWxlIiwicGFuZWxzIiwicHJvcG9ydGlvbmFsX2hlaWdodCIsImFzc2lnbiIsImFkZCIsIlNjYWxlRnVuY3Rpb25zIiwidXNlIl0sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBOzs7Ozs7Ozs7QUFVQTs7QUFHQSxTQUFTQSxPQUFULENBQWtCQyxTQUFsQixFQUE2QjtBQUN6QixNQUFNQyxjQUFjLEdBQUdELFNBQVMsQ0FBQ0UsUUFBVixDQUFtQkMsR0FBbkIsQ0FBdUIsZ0JBQXZCLENBQXZCOztBQUNBLE1BQU1DLE9BQU8sR0FBR0osU0FBUyxDQUFDSyxPQUFWLENBQWtCRixHQUFsQixDQUFzQixTQUF0QixDQUFoQjs7QUFDQSxNQUFNRyxXQUFXLEdBQUdOLFNBQVMsQ0FBQ0ssT0FBVixDQUFrQkYsR0FBbEIsQ0FBc0IsWUFBdEIsQ0FBcEI7QUFFQTs7Ozs7O0FBTHlCLE1BU25CSSxVQVRtQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsNkJBVWRDLEtBVmMsRUFVUEMsS0FWTyxFQVVBQyxNQVZBLEVBVVE7QUFDekIsWUFBTUMsTUFBTSxHQUFHRixLQUFLLENBQUNHLE1BQU4sQ0FBYUMsY0FBYixJQUErQixLQUFLQyxNQUFMLENBQVlILE1BQTFEO0FBQ0EsWUFBTUksS0FBSywyQkFBb0JKLE1BQXBCLGlDQUFpREgsS0FBSyxDQUFDUSxHQUF2RCw0QkFBNEVSLEtBQUssQ0FBQ1MsR0FBbEYseUJBQW9HVCxLQUFLLENBQUNVLEtBQTFHLENBQVg7QUFDQSx5QkFBVSxLQUFLQyxHQUFmLFNBQXFCSixLQUFyQjtBQUNIO0FBZG9COztBQUFBO0FBQUEsSUFTQWQsY0FUQTtBQWlCekI7Ozs7O0FBakJ5QixNQW9CbkJtQixpQkFwQm1CO0FBQUE7O0FBQUE7O0FBcUJyQiwrQkFBWUMsTUFBWixFQUFvQjtBQUFBOztBQUFBOztBQUNoQixrQ0FBU0MsU0FBVDs7QUFDQSxVQUFJLENBQUNELE1BQU0sQ0FBQ0UsYUFBWixFQUEyQjtBQUN2QkYsY0FBTSxDQUFDRSxhQUFQLEdBQXVCLFdBQXZCO0FBQ0g7O0FBQ0QsVUFBSSxDQUFDLE1BQUtDLFlBQUwsQ0FBa0JDLFdBQWxCLENBQThCSixNQUFNLENBQUNFLGFBQXJDLENBQUwsRUFBMEQ7QUFDdEQsY0FBTSxJQUFJRyxLQUFKLENBQVUsK0RBQVYsQ0FBTjtBQUNIOztBQVBlO0FBUW5COztBQTdCb0I7QUFBQTtBQUFBLCtCQStCWjtBQUFBOztBQUNMLFlBQU1DLFVBQVUsR0FBRyxLQUFLSCxZQUFMLENBQWtCQyxXQUFsQixDQUE4QixLQUFLSixNQUFMLENBQVlFLGFBQTFDLENBQW5CO0FBQ0EsWUFBTUssSUFBSSxHQUFHRCxVQUFVLENBQUNOLE1BQVgsQ0FBa0JRLFlBQWxCLEdBQWlDLGNBQWpDLEdBQWtELGNBQS9EOztBQUNBLFlBQUksS0FBS0MsTUFBVCxFQUFpQjtBQUNiLGVBQUtBLE1BQUwsQ0FBWUMsT0FBWixDQUFvQkgsSUFBcEI7QUFDQSxlQUFLRSxNQUFMLENBQVlFLElBQVo7QUFDQSxlQUFLQyxNQUFMLENBQVlDLFFBQVo7QUFDQSxpQkFBTyxJQUFQO0FBQ0gsU0FMRCxNQUtPO0FBQ0gsZUFBS0osTUFBTCxHQUFjLElBQUkxQixPQUFKLENBQVksSUFBWixFQUNUK0IsUUFEUyxDQUNBLEtBQUtkLE1BQUwsQ0FBWWUsS0FEWixFQUVUTCxPQUZTLENBRURILElBRkMsRUFHVFMsUUFIUyxDQUdBLDBEQUhBLEVBSVRDLFVBSlMsQ0FJRSxZQUFNO0FBQ2RYLHNCQUFVLENBQUNZLGlCQUFYOztBQUNBLGdCQUFJLE1BQUksQ0FBQ0MsYUFBVCxFQUF3QjtBQUNwQkMsMEJBQVksQ0FBQyxNQUFJLENBQUNELGFBQU4sQ0FBWjtBQUNIOztBQUNELGtCQUFJLENBQUNBLGFBQUwsR0FBcUJFLFVBQVUsQ0FBQyxZQUFNO0FBQ2xDLG9CQUFJLENBQUNsQixZQUFMLENBQWtCbUIsaUJBQWxCOztBQUNBLG9CQUFJLENBQUNDLFdBQUwsQ0FBaUJDLGNBQWpCO0FBQ0gsYUFIOEIsRUFHNUIsQ0FINEIsQ0FBL0I7O0FBSUEsa0JBQUksQ0FBQ0MsTUFBTDtBQUNILFdBZFMsQ0FBZDtBQWVBLGlCQUFPLEtBQUtBLE1BQUwsRUFBUDtBQUNIO0FBQ0o7QUF6RG9COztBQUFBO0FBQUEsSUFvQk94QyxXQXBCUDtBQTZEekI7Ozs7Ozs7OztBQU9BLFdBQVN5QyxNQUFULENBQWdCQyxVQUFoQixFQUE0QkMsS0FBNUIsRUFBbUM7QUFDL0IsV0FBT0EsS0FBSyxpQkFBVUEsS0FBVixTQUFxQixJQUFqQztBQUNIOztBQUVELE1BQU1DLGNBQWMsR0FBRztBQUNuQkMsZUFBVyxFQUFFLE9BRE07QUFFbkJDLGFBQVMsRUFBRSxLQUZRO0FBR25CQyxxQkFBaUIsRUFBRSxZQUhBO0FBR2M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQUMscUJBQWlCLEVBQUUsVUFSQTtBQVNuQkMscUJBQWlCLEVBQUUsTUFUQTtBQVVuQkMsZ0NBQTRCLEVBQUUsQ0FWWDtBQVduQjNCLGdCQUFZLEVBQUUsSUFYSztBQVluQjRCLGdCQUFZLEVBQUUsRUFaSztBQWFuQkMsMEJBQXNCLEVBQUUsQ0FiTDtBQWNuQkMsd0JBQW9CLEVBQUUsQ0FkSDtBQWVuQkMsc0JBQWtCLEVBQUUsS0FmRDtBQWdCbkJ4QixTQUFLLEVBQUUsU0FoQlk7QUFpQm5CeUIsZ0JBQVksRUFBRSxDQWpCSztBQWtCbkJDLHVCQUFtQixFQUFFO0FBbEJGLEdBQXZCO0FBc0JBOzs7OztBQUlBLE1BQU1DLFNBQVMsR0FBRy9ELFNBQVMsQ0FBQ2dFLFVBQVYsQ0FBcUI3RCxHQUFyQixDQUF5QixlQUF6QixDQUFsQjs7QUFsR3lCLE1BbUduQjhELGdCQW5HbUI7QUFBQTs7QUFBQTs7QUFvR3JCLDhCQUFZNUMsTUFBWixFQUFvQjtBQUFBOztBQUFBOztBQUNoQnJCLGVBQVMsQ0FBQ2tFLE9BQVYsQ0FBa0JDLEtBQWxCLENBQXdCOUMsTUFBeEIsRUFBZ0M2QixjQUFoQztBQUNBLG1DQUFTNUIsU0FBVDtBQUNBLGFBQUs4QyxNQUFMLEdBQWMsQ0FBZDtBQUNBLGFBQUtDLGVBQUwsR0FBdUIsQ0FBdkIsQ0FKZ0IsQ0FNaEI7O0FBQ0EsYUFBS0Msb0JBQUwsR0FBNEI7QUFBRSxXQUFHO0FBQUwsT0FBNUI7QUFQZ0I7QUFRbkI7QUFFRDs7Ozs7Ozs7QUE5R3FCO0FBQUE7QUFBQSw2Q0FvSEVDLE9BcEhGLEVBb0hXO0FBQzVCLFlBQUksS0FBS2xELE1BQUwsQ0FBWVEsWUFBaEIsRUFBOEI7QUFDMUIsaUJBQU8sVUFBSSxLQUFLMkMsU0FBTCxFQUFKLHlCQUFtQ0QsT0FBTyxDQUFDLEtBQUtsRCxNQUFMLENBQVlpQyxpQkFBYixDQUExQyxFQUE2RW1CLE9BQTdFLENBQXFGLFFBQXJGLEVBQStGLEdBQS9GLENBQVA7QUFDSDs7QUFDRCx5QkFBVSxLQUFLQyxZQUFMLENBQWtCSCxPQUFsQixDQUFWO0FBQ0gsT0F6SG9CLENBMkhyQjs7QUEzSHFCO0FBQUE7QUFBQSx1Q0E0SEo7QUFDYixlQUFPLEtBQUtsRCxNQUFMLENBQVlvQyxZQUFaLEdBQ0QsS0FBS3BDLE1BQUwsQ0FBWXFDLHNCQURYLEdBRUEsSUFBSSxLQUFLckMsTUFBTCxDQUFZc0Msb0JBRnZCO0FBR0gsT0FoSW9CLENBa0lyQjtBQUNBOztBQW5JcUI7QUFBQTtBQUFBLDRDQW9JQztBQUNsQixZQUFNZ0IsSUFBSSxHQUFHLElBQWI7QUFDQSxZQUFNQyxXQUFXLEdBQUcsS0FBS0MsWUFBekI7QUFDQSxZQUFNQyxhQUFhLEdBQUcsS0FBS3pELE1BQTNCO0FBQ0EsWUFBTTBELGdCQUFnQixHQUFHSCxXQUFXLENBQUN4QyxLQUFaLENBQWtCNEMsSUFBbEIsQ0FBdUIsVUFBVUMsSUFBVixFQUFnQjtBQUM1RCxpQkFBT0EsSUFBSSxDQUFDQyxjQUFMLElBQXVCRCxJQUFJLENBQUNDLGNBQUwsS0FBd0IsaUJBQXREO0FBQ0gsU0FGd0IsQ0FBekI7QUFHQSxZQUFNQyxXQUFXLEdBQUdMLGFBQWEsQ0FBQzFDLEtBQWQsQ0FBb0I0QyxJQUFwQixDQUF5QixVQUFVQyxJQUFWLEVBQWdCO0FBQ3pELGlCQUFPQSxJQUFJLENBQUNDLGNBQUwsSUFBdUJELElBQUksQ0FBQ0MsY0FBTCxLQUF3QixpQkFBdEQ7QUFDSCxTQUZtQixDQUFwQjs7QUFHQSxZQUFJLENBQUNILGdCQUFMLEVBQXVCO0FBQ25CO0FBQ0EsZ0JBQU0sSUFBSXJELEtBQUosQ0FBVSw2REFBVixDQUFOO0FBQ0g7O0FBRUQsWUFBTTBELFVBQVUsR0FBR0wsZ0JBQWdCLENBQUMvQixVQUFqQixDQUE0QnFDLFVBQTVCLENBQXVDQyxNQUF2QyxJQUFpRFAsZ0JBQWdCLENBQUMvQixVQUFqQixDQUE0QnVDLE1BQTVCLENBQW1DRCxNQUF2RztBQUNBLFlBQU1FLFVBQVUsR0FBR1osV0FBVyxDQUFDYSxNQUFaLElBQXNCYixXQUFXLENBQUNhLE1BQVosQ0FBbUJILE1BQTVEOztBQUVBLFlBQUksQ0FBQyxDQUFDRixVQUFGLEdBQWUsQ0FBQyxDQUFDSSxVQUFyQixFQUFpQztBQUM3QjtBQUNBLGdCQUFNLElBQUk5RCxLQUFKLENBQVUsc0ZBQVYsQ0FBTjtBQUNILFNBckJpQixDQXVCbEI7OztBQUNBLFlBQU1nRSxVQUFVLEdBQUdkLFdBQVcsQ0FBQ3hDLEtBQVosQ0FBa0I0QyxJQUFsQixDQUF1QixVQUFVQyxJQUFWLEVBQWdCO0FBQ3RELGlCQUFPQSxJQUFJLENBQUNDLGNBQUwsSUFBdUJELElBQUksQ0FBQ0MsY0FBTCxLQUF3QixRQUF0RDtBQUNILFNBRmtCLENBQW5CO0FBR0EsWUFBTVMsU0FBUyxHQUFHRCxVQUFVLElBQUlBLFVBQVUsQ0FBQ0UsS0FBM0MsQ0EzQmtCLENBNkJsQjs7QUFDQSxZQUFNQyxnQkFBZ0IsR0FBRyxLQUFLQywyQkFBTCxDQUFpQyxLQUFLQyxJQUF0QyxFQUE0Q0osU0FBNUMsQ0FBekIsQ0E5QmtCLENBOEIrRDs7O0FBRWpGLFlBQUksQ0FBQ1AsVUFBRCxJQUFlLENBQUNJLFVBQXBCLEVBQWdDO0FBQzVCO0FBQ0E7QUFFQSxjQUFNUSxNQUFNLEdBQUcsS0FBS0MsZ0JBQUwsQ0FBc0JKLGdCQUF0QixDQUFmOztBQUNBVixxQkFBVyxDQUFDbkMsVUFBWixDQUF1QnFDLFVBQXZCLEdBQW9DUSxnQkFBZ0IsQ0FBQ0ssR0FBakIsQ0FBcUIsVUFBVWpCLElBQVYsRUFBZ0I7QUFDckUsbUJBQU9BLElBQUksQ0FBQyxDQUFELENBQVg7QUFDSCxXQUZtQyxDQUFwQztBQUdBRSxxQkFBVyxDQUFDbkMsVUFBWixDQUF1QnVDLE1BQXZCLEdBQWdDUyxNQUFoQztBQUVBLGVBQUszRSxNQUFMLENBQVlvRSxNQUFaLEdBQXFCSSxnQkFBZ0IsQ0FBQ0ssR0FBakIsQ0FBcUIsVUFBVUMsSUFBVixFQUFnQkMsS0FBaEIsRUFBdUI7QUFDN0QsZ0JBQU1DLEVBQUUsR0FBR0YsSUFBSSxDQUFDLENBQUQsQ0FBZjtBQUNBLGdCQUFNRyxLQUFLLEdBQUdILElBQUksQ0FBQyxDQUFELENBQWxCO0FBQ0EsZ0JBQU1JLFVBQVUsR0FBR3BCLFdBQVcsQ0FBQ25DLFVBQVosQ0FBdUJ1QyxNQUF2QixDQUE4QmEsS0FBOUIsQ0FBbkI7QUFDQSxnQkFBTW5CLElBQUksR0FBRztBQUFFdUIsbUJBQUssRUFBRSxNQUFUO0FBQWlCQyxtQkFBSyxFQUFFLENBQXhCO0FBQTJCSCxtQkFBSyxFQUFFQSxLQUFsQztBQUF5Q2xFLG1CQUFLLEVBQUVtRTtBQUFoRCxhQUFiO0FBQ0F0QixnQkFBSSxDQUFDTixJQUFJLENBQUN0RCxNQUFMLENBQVlpQyxpQkFBYixDQUFKLEdBQXNDK0MsRUFBdEM7QUFDQSxtQkFBT3BCLElBQVA7QUFDSCxXQVBvQixDQUFyQjtBQVFIO0FBQ0osT0F2TG9CLENBeUxyQjtBQUNBOztBQTFMcUI7QUFBQTtBQUFBLHFDQTJMTjtBQUFBOztBQUNYO0FBQ0EsYUFBS3lCLG1CQUFMLEdBRlcsQ0FJWDs7O0FBQ0EsYUFBS3JDLGVBQUwsR0FBdUIsS0FBS0QsTUFBNUI7QUFDQSxhQUFLQSxNQUFMLEdBQWMsQ0FBZDtBQUNBLGFBQUtFLG9CQUFMLEdBQTRCO0FBQUUsYUFBRztBQUFMLFNBQTVCLENBUFcsQ0FRWDs7QUFDQSxhQUFLcUMsdUJBQUwsR0FBK0IsRUFBL0IsQ0FUVyxDQVdYO0FBQ0E7QUFDQTs7QUFDQSxZQUFJLEtBQUt0RixNQUFMLENBQVlpQyxpQkFBWixJQUFpQyxLQUFLakMsTUFBTCxDQUFZUSxZQUFqRCxFQUErRDtBQUMzRCxlQUFLa0UsSUFBTCxDQUFVYSxPQUFWLENBQWtCLFVBQUNDLENBQUQsRUFBTztBQUNyQixrQkFBSSxDQUFDRix1QkFBTCxDQUE2QkUsQ0FBQyxDQUFDLE1BQUksQ0FBQ3hGLE1BQUwsQ0FBWWlDLGlCQUFiLENBQTlCLElBQWlFLElBQWpFO0FBQ0gsV0FGRDtBQUdBLGNBQU04QyxLQUFLLEdBQUdVLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLEtBQUtKLHVCQUFqQixDQUFkOztBQUNBLGNBQUksS0FBS3RGLE1BQUwsQ0FBWWtDLGlCQUFaLEtBQWtDLE1BQXRDLEVBQThDO0FBQzFDNkMsaUJBQUssQ0FBQ1ksT0FBTjtBQUNIOztBQUNEWixlQUFLLENBQUNRLE9BQU4sQ0FBYyxVQUFDSyxHQUFELEVBQVM7QUFDbkIsa0JBQUksQ0FBQ04sdUJBQUwsQ0FBNkJNLEdBQTdCLElBQW9DLE1BQUksQ0FBQzdDLE1BQUwsR0FBYyxDQUFsRDtBQUNBLGtCQUFJLENBQUNFLG9CQUFMLENBQTBCLE1BQUksQ0FBQ0YsTUFBTCxHQUFjLENBQXhDLElBQTZDLEVBQTdDO0FBQ0Esa0JBQUksQ0FBQ0EsTUFBTDtBQUNILFdBSkQ7QUFLSDs7QUFFRCxhQUFLMkIsSUFBTCxDQUFVYSxPQUFWLENBQWtCLFVBQVNDLENBQVQsRUFBWUssQ0FBWixFQUFlO0FBQUE7O0FBRTdCO0FBQ0EsZUFBS25CLElBQUwsQ0FBVW1CLENBQVYsRUFBYWpGLE1BQWIsR0FBc0IsSUFBdEIsQ0FINkIsQ0FLN0I7QUFDQTs7QUFDQSxlQUFLOEQsSUFBTCxDQUFVbUIsQ0FBVixFQUFhQyxhQUFiLEdBQTZCO0FBQ3pCakcsaUJBQUssRUFBRSxLQUFLZSxNQUFMLENBQVltRixPQUFaLENBQW9CQyxJQUFJLENBQUNDLEdBQUwsQ0FBU1QsQ0FBQyxDQUFDLEtBQUt4RixNQUFMLENBQVk4QixXQUFiLENBQVYsRUFBcUMsS0FBSzNDLEtBQUwsQ0FBV1UsS0FBaEQsQ0FBcEIsQ0FEa0I7QUFFekJELGVBQUcsRUFBSSxLQUFLZ0IsTUFBTCxDQUFZbUYsT0FBWixDQUFvQkMsSUFBSSxDQUFDRSxHQUFMLENBQVNWLENBQUMsQ0FBQyxLQUFLeEYsTUFBTCxDQUFZK0IsU0FBYixDQUFWLEVBQW1DLEtBQUs1QyxLQUFMLENBQVdTLEdBQTlDLENBQXBCO0FBRmtCLFdBQTdCO0FBSUEsZUFBSzhFLElBQUwsQ0FBVW1CLENBQVYsRUFBYUMsYUFBYixDQUEyQlYsS0FBM0IsR0FBbUMsS0FBS1YsSUFBTCxDQUFVbUIsQ0FBVixFQUFhQyxhQUFiLENBQTJCbEcsR0FBM0IsR0FBaUMsS0FBSzhFLElBQUwsQ0FBVW1CLENBQVYsRUFBYUMsYUFBYixDQUEyQmpHLEtBQS9GLENBWDZCLENBYTdCO0FBQ0E7O0FBQ0EsZUFBSzZFLElBQUwsQ0FBVW1CLENBQVYsRUFBYU0sY0FBYixHQUE4QjtBQUMxQnRHLGlCQUFLLEVBQUUsS0FBS2UsTUFBTCxDQUFZbUYsT0FBWixDQUFvQkssTUFBcEIsQ0FBMkIsS0FBSzFCLElBQUwsQ0FBVW1CLENBQVYsRUFBYUMsYUFBYixDQUEyQmpHLEtBQXRELENBRG1CO0FBRTFCRCxlQUFHLEVBQUksS0FBS2dCLE1BQUwsQ0FBWW1GLE9BQVosQ0FBb0JLLE1BQXBCLENBQTJCLEtBQUsxQixJQUFMLENBQVVtQixDQUFWLEVBQWFDLGFBQWIsQ0FBMkJsRyxHQUF0RDtBQUZtQixXQUE5QjtBQUlBLGVBQUs4RSxJQUFMLENBQVVtQixDQUFWLEVBQWFNLGNBQWIsQ0FBNEJmLEtBQTVCLEdBQW9DLEtBQUtWLElBQUwsQ0FBVW1CLENBQVYsRUFBYU0sY0FBYixDQUE0QnZHLEdBQTVCLEdBQWtDLEtBQUs4RSxJQUFMLENBQVVtQixDQUFWLEVBQWFNLGNBQWIsQ0FBNEJ0RyxLQUFsRyxDQW5CNkIsQ0FxQjdCO0FBQ0E7QUFDQTs7QUFDQSxjQUFJLEtBQUtHLE1BQUwsQ0FBWWlDLGlCQUFaLElBQWlDLEtBQUtqQyxNQUFMLENBQVlRLFlBQWpELEVBQStEO0FBQzNELGdCQUFNb0YsR0FBRyxHQUFHLEtBQUtsQixJQUFMLENBQVVtQixDQUFWLEVBQWEsS0FBSzdGLE1BQUwsQ0FBWWlDLGlCQUF6QixDQUFaO0FBQ0EsaUJBQUt5QyxJQUFMLENBQVVtQixDQUFWLEVBQWFRLEtBQWIsR0FBcUIsS0FBS2YsdUJBQUwsQ0FBNkJNLEdBQTdCLENBQXJCO0FBQ0EsaUJBQUszQyxvQkFBTCxDQUEwQixLQUFLeUIsSUFBTCxDQUFVbUIsQ0FBVixFQUFhUSxLQUF2QyxFQUE4Q0MsSUFBOUMsQ0FBbURULENBQW5EO0FBQ0gsV0FKRCxNQUlPO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQUs5QyxNQUFMLEdBQWMsQ0FBZDtBQUNBLGlCQUFLMkIsSUFBTCxDQUFVbUIsQ0FBVixFQUFhUSxLQUFiLEdBQXFCLElBQXJCO0FBQ0EsZ0JBQUlFLGVBQWUsR0FBRyxDQUF0Qjs7QUFORztBQVFDLGtCQUFJQyw0QkFBNEIsR0FBRyxLQUFuQzs7QUFDQSxvQkFBSSxDQUFDdkQsb0JBQUwsQ0FBMEJzRCxlQUExQixFQUEyQzFCLEdBQTNDLENBQStDLFVBQVM0QixlQUFULEVBQTBCO0FBQ3JFLG9CQUFJLENBQUNELDRCQUFMLEVBQW1DO0FBQy9CLHNCQUFNRSxTQUFTLEdBQUdWLElBQUksQ0FBQ0UsR0FBTCxDQUFTTyxlQUFlLENBQUNYLGFBQWhCLENBQThCakcsS0FBdkMsRUFBOEMsS0FBS2lHLGFBQUwsQ0FBbUJqRyxLQUFqRSxDQUFsQjtBQUNBLHNCQUFNOEcsT0FBTyxHQUFHWCxJQUFJLENBQUNDLEdBQUwsQ0FBU1EsZUFBZSxDQUFDWCxhQUFoQixDQUE4QmxHLEdBQXZDLEVBQTRDLEtBQUtrRyxhQUFMLENBQW1CbEcsR0FBL0QsQ0FBaEI7O0FBQ0Esc0JBQUsrRyxPQUFPLEdBQUdELFNBQVgsR0FBeUJELGVBQWUsQ0FBQ1gsYUFBaEIsQ0FBOEJWLEtBQTlCLEdBQXNDLEtBQUtVLGFBQUwsQ0FBbUJWLEtBQXRGLEVBQThGO0FBQzFGb0IsZ0RBQTRCLEdBQUcsSUFBL0I7QUFDSDtBQUNKO0FBQ0osZUFSOEMsQ0FRN0NJLElBUjZDLENBUXhDLE1BQUksQ0FBQ2xDLElBQUwsQ0FBVW1CLENBQVYsQ0FSd0MsQ0FBL0M7O0FBU0Esa0JBQUksQ0FBQ1csNEJBQUwsRUFBbUM7QUFDL0Isc0JBQUksQ0FBQzlCLElBQUwsQ0FBVW1CLENBQVYsRUFBYVEsS0FBYixHQUFxQkUsZUFBckI7O0FBQ0Esc0JBQUksQ0FBQ3RELG9CQUFMLENBQTBCc0QsZUFBMUIsRUFBMkNELElBQTNDLENBQWdELE1BQUksQ0FBQzVCLElBQUwsQ0FBVW1CLENBQVYsQ0FBaEQ7QUFDSCxlQUhELE1BR087QUFDSFUsK0JBQWU7O0FBQ2Ysb0JBQUlBLGVBQWUsR0FBRyxNQUFJLENBQUN4RCxNQUEzQixFQUFtQztBQUMvQix3QkFBSSxDQUFDQSxNQUFMLEdBQWN3RCxlQUFkO0FBQ0Esd0JBQUksQ0FBQ3RELG9CQUFMLENBQTBCc0QsZUFBMUIsSUFBNkMsRUFBN0M7QUFDSDtBQUNKO0FBM0JGOztBQU9ILG1CQUFPLEtBQUs3QixJQUFMLENBQVVtQixDQUFWLEVBQWFRLEtBQWIsS0FBdUIsSUFBOUIsRUFBb0M7QUFBQTtBQXFCbkM7QUFFSjtBQUVKLFNBNURpQixDQTREaEJPLElBNURnQixDQTREWCxJQTVEVyxDQUFsQjtBQThEQSxlQUFPLElBQVA7QUFDSCxPQXZSb0IsQ0F5UnJCOztBQXpScUI7QUFBQTtBQUFBLCtCQTBSWjtBQUFBOztBQUNMO0FBQ0EsYUFBS0MsWUFBTCxHQUZLLENBSUw7O0FBQ0EsWUFBTUMsVUFBVSxHQUFHLEtBQUtDLGFBQUwsRUFBbkIsQ0FMSyxDQU9MO0FBQ0E7QUFDQTs7O0FBQ0EsYUFBS0MsR0FBTCxDQUFTQyxLQUFULENBQWVDLFNBQWYsQ0FBeUIsb0VBQXpCLEVBQStGQyxNQUEvRjtBQUNBMUIsY0FBTSxDQUFDQyxJQUFQLENBQVksS0FBS0osdUJBQWpCLEVBQTBDQyxPQUExQyxDQUFrRCxVQUFDNkIsR0FBRCxFQUFTO0FBQ3ZEO0FBQ0EsY0FBTUMsYUFBYSxHQUFHLEVBQXRCO0FBQ0FBLHVCQUFhLENBQUMsTUFBSSxDQUFDckgsTUFBTCxDQUFZaUMsaUJBQWIsQ0FBYixHQUErQ21GLEdBQS9DLENBSHVELENBSXZEOztBQUNBLGdCQUFJLENBQUNKLEdBQUwsQ0FBU0MsS0FBVCxDQUFlSyxNQUFmLENBQXNCLE1BQXRCLEVBQThCLGNBQTlCLEVBQ0tDLElBREwsQ0FDVSxJQURWLEVBQ2dCLE1BQUksQ0FBQ0Msc0JBQUwsQ0FBNEJILGFBQTVCLENBRGhCLEVBRUtFLElBRkwsQ0FFVSxPQUZWLEVBRW1CLDJGQUZuQixFQUdLQSxJQUhMLENBR1UsSUFIVixFQUdnQixNQUFJLENBQUN2SCxNQUFMLENBQVlzQyxvQkFINUIsRUFJS2lGLElBSkwsQ0FJVSxJQUpWLEVBSWdCLE1BQUksQ0FBQ3ZILE1BQUwsQ0FBWXNDLG9CQUo1QixFQUtLaUYsSUFMTCxDQUtVLE9BTFYsRUFLbUIsTUFBSSxDQUFDM0csTUFBTCxDQUFZWixNQUFaLENBQW1CeUgsUUFBbkIsQ0FBNEJyQyxLQUwvQyxFQU1LbUMsSUFOTCxDQU1VLFFBTlYsRUFNb0IsTUFBSSxDQUFDRyxjQUFMLEtBQXdCLE1BQUksQ0FBQzFILE1BQUwsQ0FBWXFDLHNCQU54RCxFQU9La0YsSUFQTCxDQU9VLEdBUFYsRUFPZSxDQVBmLEVBUUtBLElBUkwsQ0FRVSxHQVJWLEVBUWUsQ0FBQyxNQUFJLENBQUNqQyx1QkFBTCxDQUE2QjhCLEdBQTdCLElBQW9DLENBQXJDLElBQTBDLE1BQUksQ0FBQ00sY0FBTCxFQVJ6RCxFQVNLQyxLQVRMLENBU1csU0FUWCxFQVN1QixNQUFJLENBQUMzSCxNQUFMLENBQVlRLFlBQVosR0FBMkIsSUFBM0IsR0FBa0MsTUFUekQ7QUFVSCxTQWZELEVBWEssQ0E0Qkw7O0FBQ0EsWUFBTW9ILFNBQVMsR0FBRyxLQUFLWixHQUFMLENBQVNDLEtBQVQsQ0FBZUMsU0FBZixDQUF5QiwyQkFBekIsRUFDYnhDLElBRGEsQ0FDUm9DLFVBRFEsRUFDSSxVQUFDdEIsQ0FBRCxFQUFPO0FBQ3JCLGlCQUFPQSxDQUFDLENBQUMsTUFBSSxDQUFDeEYsTUFBTCxDQUFZNkgsUUFBYixDQUFSO0FBQ0gsU0FIYSxDQUFsQjtBQUtBRCxpQkFBUyxDQUFDRSxLQUFWLEdBQ0tDLE1BREwsQ0FDWSxHQURaLEVBRUtSLElBRkwsQ0FFVSxPQUZWLEVBRW1CLHlCQUZuQixFQUdLekUsS0FITCxDQUdXOEUsU0FIWCxFQUlLTCxJQUpMLENBSVUsSUFKVixFQUlnQixVQUFDL0IsQ0FBRDtBQUFBLGlCQUFPLE1BQUksQ0FBQ25DLFlBQUwsQ0FBa0JtQyxDQUFsQixDQUFQO0FBQUEsU0FKaEIsRUFLS3dDLElBTEwsQ0FLVSxVQUFTQyxRQUFULEVBQW1CO0FBQ3JCLGNBQU0zSCxVQUFVLEdBQUcySCxRQUFRLENBQUNySCxNQUE1QixDQURxQixDQUVyQjtBQUNBOztBQUNBLGNBQU1zSCxXQUFXLEdBQUdDLHlDQUFBLENBQVUsSUFBVixFQUFnQmpCLFNBQWhCLENBQTBCLDZHQUExQixFQUNmeEMsSUFEZSxDQUNWLENBQUN1RCxRQUFELENBRFUsRUFDRSxVQUFDekMsQ0FBRDtBQUFBLDZCQUFVbEYsVUFBVSxDQUFDK0MsWUFBWCxDQUF3Qm1DLENBQXhCLENBQVY7QUFBQSxXQURGLENBQXBCO0FBRUEwQyxxQkFBVyxDQUFDSixLQUFaLEdBQ0tSLE1BREwsQ0FDWSxNQURaLEVBQ29CLGNBRHBCLEVBRUtDLElBRkwsQ0FFVSxPQUZWLEVBRW1CLHdHQUZuQixFQUdLekUsS0FITCxDQUdXb0YsV0FIWCxFQUlLWCxJQUpMLENBSVUsSUFKVixFQUlnQixVQUFDL0IsQ0FBRDtBQUFBLDZCQUFVbEYsVUFBVSxDQUFDK0MsWUFBWCxDQUF3Qm1DLENBQXhCLENBQVY7QUFBQSxXQUpoQixFQUtLK0IsSUFMTCxDQUtVLElBTFYsRUFLZ0JqSCxVQUFVLENBQUNOLE1BQVgsQ0FBa0JzQyxvQkFMbEMsRUFNS2lGLElBTkwsQ0FNVSxJQU5WLEVBTWdCakgsVUFBVSxDQUFDTixNQUFYLENBQWtCc0Msb0JBTmxDLEVBT0txRixLQVBMLENBT1csU0FQWCxFQU9zQnJILFVBQVUsQ0FBQ04sTUFBWCxDQUFrQlEsWUFBbEIsR0FBaUMsTUFBakMsR0FBMEMsSUFQaEUsRUFRSytHLElBUkwsQ0FRVSxPQVJWLEVBUW1CLFVBQUMvQixDQUFEO0FBQUEsbUJBQU9BLENBQUMsQ0FBQ00sYUFBRixDQUFnQlYsS0FBaEIsR0FBeUIsSUFBSTlFLFVBQVUsQ0FBQ04sTUFBWCxDQUFrQnNDLG9CQUF0RDtBQUFBLFdBUm5CLEVBU0tpRixJQVRMLENBU1UsUUFUVixFQVNvQmpILFVBQVUsQ0FBQ29ILGNBQVgsS0FBOEJwSCxVQUFVLENBQUNOLE1BQVgsQ0FBa0JxQyxzQkFUcEUsRUFVS2tGLElBVkwsQ0FVVSxHQVZWLEVBVWUsVUFBQy9CLENBQUQ7QUFBQSxtQkFBT0EsQ0FBQyxDQUFDTSxhQUFGLENBQWdCakcsS0FBaEIsR0FBd0JTLFVBQVUsQ0FBQ04sTUFBWCxDQUFrQnNDLG9CQUFqRDtBQUFBLFdBVmYsRUFXS2lGLElBWEwsQ0FXVSxHQVhWLEVBV2UsVUFBQy9CLENBQUQ7QUFBQSxtQkFBUSxDQUFDQSxDQUFDLENBQUNhLEtBQUYsR0FBVSxDQUFYLElBQWdCL0YsVUFBVSxDQUFDb0gsY0FBWCxFQUF4QjtBQUFBLFdBWGY7QUFhQVEscUJBQVcsQ0FBQ0UsSUFBWixHQUNLakIsTUFETCxHQW5CcUIsQ0FzQnJCOztBQUNBLGNBQU1rQixLQUFLLEdBQUdGLHlDQUFBLENBQVUsSUFBVixFQUFnQmpCLFNBQWhCLENBQTBCLCtDQUExQixFQUNUeEMsSUFEUyxDQUNKLENBQUN1RCxRQUFELENBREksRUFDUSxVQUFDekMsQ0FBRDtBQUFBLDZCQUFVQSxDQUFDLENBQUNsRixVQUFVLENBQUNOLE1BQVgsQ0FBa0I2SCxRQUFuQixDQUFYO0FBQUEsV0FEUixDQUFkO0FBR0FRLGVBQUssQ0FBQ1AsS0FBTixHQUNLQyxNQURMLENBQ1ksTUFEWixFQUVLUixJQUZMLENBRVUsT0FGVixFQUVtQiwwQ0FGbkIsRUFHS3pFLEtBSEwsQ0FHV3VGLEtBSFgsRUFJS2QsSUFKTCxDQUlVLE9BSlYsRUFJbUIsVUFBQy9CLENBQUQ7QUFBQSxtQkFBT0EsQ0FBQyxDQUFDTSxhQUFGLENBQWdCVixLQUF2QjtBQUFBLFdBSm5CLEVBS0ttQyxJQUxMLENBS1UsUUFMVixFQUtvQmpILFVBQVUsQ0FBQ04sTUFBWCxDQUFrQm9DLFlBTHRDLEVBTUttRixJQU5MLENBTVUsR0FOVixFQU1lLFVBQUMvQixDQUFEO0FBQUEsbUJBQU9BLENBQUMsQ0FBQ00sYUFBRixDQUFnQmpHLEtBQXZCO0FBQUEsV0FOZixFQU9LMEgsSUFQTCxDQU9VLEdBUFYsRUFPZSxVQUFDL0IsQ0FBRDtBQUFBLG1CQUFRLENBQUNBLENBQUMsQ0FBQ2EsS0FBRixHQUFVLENBQVgsSUFBZ0IvRixVQUFVLENBQUNvSCxjQUFYLEVBQWpCLEdBQWdEcEgsVUFBVSxDQUFDTixNQUFYLENBQWtCc0Msb0JBQXpFO0FBQUEsV0FQZixFQVFLaUYsSUFSTCxDQVFVLE1BUlYsRUFRa0IsVUFBQy9CLENBQUQsRUFBSUssQ0FBSjtBQUFBLG1CQUFVdkYsVUFBVSxDQUFDZ0ksd0JBQVgsQ0FBb0NoSSxVQUFVLENBQUNOLE1BQVgsQ0FBa0JlLEtBQXRELEVBQTZEeUUsQ0FBN0QsRUFBZ0VLLENBQWhFLENBQVY7QUFBQSxXQVJsQixFQVNLMEIsSUFUTCxDQVNVLGNBVFYsRUFTMEIsVUFBQy9CLENBQUQsRUFBSUssQ0FBSjtBQUFBLG1CQUFVdkYsVUFBVSxDQUFDZ0ksd0JBQVgsQ0FBb0NoSSxVQUFVLENBQUNOLE1BQVgsQ0FBa0J3QyxZQUF0RCxFQUFvRWdELENBQXBFLEVBQXVFSyxDQUF2RSxDQUFWO0FBQUEsV0FUMUI7QUFXQXdDLGVBQUssQ0FBQ0QsSUFBTixHQUNLakIsTUFETCxHQXJDcUIsQ0F3Q3JCOztBQUNBLGNBQU1vQixVQUFVLEdBQUdKLHlDQUFBLENBQVUsSUFBVixFQUFnQmpCLFNBQWhCLENBQTBCLDJDQUExQixFQUNkeEMsSUFEYyxDQUNULENBQUN1RCxRQUFELENBRFMsRUFDRyxVQUFDekMsQ0FBRDtBQUFBLDZCQUFVQSxDQUFDLENBQUNnRCxhQUFaO0FBQUEsV0FESCxDQUFuQjtBQUdBRCxvQkFBVSxDQUFDVCxLQUFYLEdBQ0tDLE1BREwsQ0FDWSxNQURaLEVBRUtSLElBRkwsQ0FFVSxPQUZWLEVBRW1CLHNDQUZuQixFQUdLekUsS0FITCxDQUdXeUYsVUFIWCxFQUlLaEIsSUFKTCxDQUlVLElBSlYsRUFJZ0IsVUFBQy9CLENBQUQ7QUFBQSw2QkFBVWxGLFVBQVUsQ0FBQytDLFlBQVgsQ0FBd0JtQyxDQUF4QixDQUFWO0FBQUEsV0FKaEIsRUFLSytCLElBTEwsQ0FLVSxJQUxWLEVBS2dCakgsVUFBVSxDQUFDTixNQUFYLENBQWtCc0Msb0JBTGxDLEVBTUtpRixJQU5MLENBTVUsSUFOVixFQU1nQmpILFVBQVUsQ0FBQ04sTUFBWCxDQUFrQnNDLG9CQU5sQyxFQU9LaUYsSUFQTCxDQU9VLE9BUFYsRUFPbUIsVUFBQy9CLENBQUQ7QUFBQSxtQkFBT0EsQ0FBQyxDQUFDTSxhQUFGLENBQWdCVixLQUF2QjtBQUFBLFdBUG5CLEVBUUttQyxJQVJMLENBUVUsUUFSVixFQVFvQmpILFVBQVUsQ0FBQ29ILGNBQVgsS0FBOEJwSCxVQUFVLENBQUNOLE1BQVgsQ0FBa0JxQyxzQkFScEUsRUFTS2tGLElBVEwsQ0FTVSxHQVRWLEVBU2UsVUFBQy9CLENBQUQ7QUFBQSxtQkFBT0EsQ0FBQyxDQUFDTSxhQUFGLENBQWdCakcsS0FBdkI7QUFBQSxXQVRmLEVBVUswSCxJQVZMLENBVVUsR0FWVixFQVVlLFVBQUMvQixDQUFEO0FBQUEsbUJBQVEsQ0FBQ0EsQ0FBQyxDQUFDYSxLQUFGLEdBQVUsQ0FBWCxJQUFnQi9GLFVBQVUsQ0FBQ29ILGNBQVgsRUFBeEI7QUFBQSxXQVZmLEVBV0k7QUFYSixXQVlLZSxFQVpMLENBWVEsT0FaUixFQVlpQixVQUFDQyxZQUFELEVBQWtCO0FBQzNCQSx3QkFBWSxDQUFDOUgsTUFBYixDQUFvQkEsTUFBcEIsQ0FBMkIrSCxJQUEzQixDQUFnQyxpQkFBaEMsRUFBbURELFlBQW5ELEVBQWlFLElBQWpFO0FBQ0gsV0FkTCxFQWVJO0FBZkosV0FnQktFLElBaEJMLENBZ0JVdEksVUFBVSxDQUFDdUksY0FBWCxDQUEwQmpDLElBQTFCLENBQStCdEcsVUFBL0IsQ0FoQlYsRUE1Q3FCLENBOERyQjs7QUFDQWlJLG9CQUFVLENBQUNILElBQVgsR0FDS2pCLE1BREw7QUFFSCxTQXRFTCxFQWxDSyxDQTBHTDs7QUFDQVMsaUJBQVMsQ0FBQ1EsSUFBVixHQUNLakIsTUFETCxHQTNHSyxDQThHTDtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0EsWUFBSSxLQUFLdkcsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWXdELE1BQS9CLEVBQXVDO0FBQ25DLGVBQUt4RCxNQUFMLENBQVl3RCxNQUFaLENBQW1CMEUsTUFBbkI7QUFDSDs7QUFFRCxlQUFPLElBQVA7QUFDSDtBQXBab0I7QUFBQTtBQUFBLDBDQXNaREMsT0F0WkMsRUFzWlE7QUFDekIsWUFBTUMsYUFBYSxHQUFHYix5Q0FBQSxZQUFjLEtBQUtYLHNCQUFMLENBQTRCdUIsT0FBTyxDQUFDckUsSUFBcEMsQ0FBZCxHQUEyRHVFLElBQTNELEdBQWtFQyxPQUFsRSxFQUF0QjtBQUNBLGVBQU87QUFDSEMsZUFBSyxFQUFFSixPQUFPLENBQUNyRSxJQUFSLENBQWFvQixhQUFiLENBQTJCakcsS0FEL0I7QUFFSHVKLGVBQUssRUFBRUwsT0FBTyxDQUFDckUsSUFBUixDQUFhb0IsYUFBYixDQUEyQmxHLEdBRi9CO0FBR0h5SixlQUFLLEVBQUVMLGFBQWEsQ0FBQ00sQ0FIbEI7QUFJSEMsZUFBSyxFQUFFUCxhQUFhLENBQUNNLENBQWQsR0FBa0JOLGFBQWEsQ0FBQ1E7QUFKcEMsU0FBUDtBQU1ILE9BOVpvQixDQWdhckI7QUFDQTs7QUFqYXFCO0FBQUE7QUFBQSw2Q0FrYUU7QUFBQTs7QUFDbkIsWUFBTUMsV0FBVyxHQUFHLEtBQUt6SixNQUFMLENBQVltQyw0QkFBWixjQUErQyxLQUFLbkMsTUFBTCxDQUFZbUMsNEJBQTNELElBQTRGLEtBQWhIOztBQUNBLFlBQUksS0FBS25DLE1BQUwsQ0FBWVEsWUFBaEIsRUFBOEI7QUFDMUIsY0FBTXVDLE1BQU0sR0FBRyxDQUFDLEtBQUtBLE1BQU4sSUFBZ0IsQ0FBL0I7QUFDQSxjQUFNWCxZQUFZLEdBQUcsQ0FBQyxLQUFLcEMsTUFBTCxDQUFZb0MsWUFBYixJQUE2QixDQUFsRDtBQUNBLGNBQU1zSCxhQUFhLEdBQUcsS0FBSyxDQUFDLEtBQUsxSixNQUFMLENBQVlzQyxvQkFBYixJQUFxQyxDQUExQyxLQUFnRCxDQUFDLEtBQUt0QyxNQUFMLENBQVlxQyxzQkFBYixJQUF1QyxDQUF2RixDQUF0QjtBQUNBLGNBQU1zSCxhQUFhLEdBQUk1RyxNQUFNLEdBQUdYLFlBQVYsR0FBMkIsQ0FBQ1csTUFBTSxHQUFHLENBQVYsSUFBZTJHLGFBQWhFO0FBQ0EsZUFBSzlJLE1BQUwsQ0FBWVUsaUJBQVosQ0FBOEJxSSxhQUE5Qjs7QUFDQSxjQUFJRixXQUFXLElBQUksS0FBSzdJLE1BQUwsQ0FBWXdELE1BQS9CLEVBQXVDO0FBQ25DLGlCQUFLeEQsTUFBTCxDQUFZd0QsTUFBWixDQUFtQndGLElBQW5CO0FBQ0EsaUJBQUtoSixNQUFMLENBQVlaLE1BQVosQ0FBbUI2SixJQUFuQixDQUF3QkosV0FBeEIsSUFBdUM7QUFDbkNYLG9CQUFNLEVBQUUsSUFEMkI7QUFFbkNnQixtQkFBSyxFQUFFLEVBRjRCO0FBR25DQyxtQkFBSyxFQUFFO0FBQ0hsSyxxQkFBSyxFQUFHOEosYUFBYSxHQUFJLEtBQUszSixNQUFMLENBQVlvQyxZQUFaLEdBQTJCLENBRGpEO0FBRUh4QyxtQkFBRyxFQUFHLEtBQUtJLE1BQUwsQ0FBWW9DLFlBQVosR0FBMkI7QUFGOUI7QUFINEIsYUFBdkMsQ0FGbUMsQ0FVbkM7QUFDQTtBQUNBOztBQUNBLGlCQUFLcEMsTUFBTCxDQUFZb0UsTUFBWixDQUFtQm1CLE9BQW5CLENBQTJCLFVBQUNyQyxPQUFELEVBQWE7QUFDcEMsa0JBQU1rRSxHQUFHLEdBQUdsRSxPQUFPLENBQUMsTUFBSSxDQUFDbEQsTUFBTCxDQUFZaUMsaUJBQWIsQ0FBbkI7QUFDQSxrQkFBSW9FLEtBQUssR0FBRyxNQUFJLENBQUNmLHVCQUFMLENBQTZCOEIsR0FBN0IsQ0FBWjs7QUFDQSxrQkFBSWYsS0FBSixFQUFXO0FBQ1Asb0JBQUksTUFBSSxDQUFDckcsTUFBTCxDQUFZa0MsaUJBQVosS0FBa0MsTUFBdEMsRUFBOEM7QUFDMUNtRSx1QkFBSyxHQUFHTCxJQUFJLENBQUNnRSxHQUFMLENBQVMzRCxLQUFLLEdBQUd0RCxNQUFSLEdBQWlCLENBQTFCLENBQVI7QUFDSDs7QUFDRCxzQkFBSSxDQUFDbkMsTUFBTCxDQUFZWixNQUFaLENBQW1CNkosSUFBbkIsQ0FBd0JKLFdBQXhCLEVBQXFDSyxLQUFyQyxDQUEyQ3hELElBQTNDLENBQWdEO0FBQzVDZ0QsbUJBQUMsRUFBRWpELEtBRHlDO0FBRTVDNEQsc0JBQUksRUFBRS9HLE9BQU8sQ0FBQytCO0FBRjhCLGlCQUFoRDtBQUlIO0FBQ0osYUFaRDtBQWFBLGlCQUFLakYsTUFBTCxDQUFZa0ssTUFBWixHQUFxQjtBQUNqQkMsa0JBQUksRUFBRSxLQUFLbkssTUFBTCxDQUFZbUMsNEJBREQ7QUFFakJpSSxtQkFBSyxFQUFFLENBRlU7QUFHakJDLHFCQUFPLEVBQUV0SDtBQUhRLGFBQXJCO0FBS0EsaUJBQUtuQyxNQUFMLENBQVlrSSxNQUFaO0FBQ0g7O0FBQ0QsZUFBS3ZILFdBQUwsQ0FBaUJDLGNBQWpCO0FBQ0gsU0F4Q0QsTUF3Q087QUFDSCxjQUFJaUksV0FBVyxJQUFJLEtBQUs3SSxNQUFMLENBQVl3RCxNQUEvQixFQUF1QztBQUNuQyxnQkFBSSxDQUFDLEtBQUtwRSxNQUFMLENBQVl1QyxrQkFBakIsRUFBcUM7QUFDakMsbUJBQUszQixNQUFMLENBQVl3RCxNQUFaLENBQW1CekQsSUFBbkI7QUFDSDs7QUFDRCxpQkFBS0MsTUFBTCxDQUFZWixNQUFaLENBQW1CNkosSUFBbkIsQ0FBd0JKLFdBQXhCLElBQXVDO0FBQUVYLG9CQUFNLEVBQUU7QUFBVixhQUF2QztBQUNBLGlCQUFLbEksTUFBTCxDQUFZa0ksTUFBWjtBQUNIO0FBQ0o7O0FBQ0QsZUFBTyxJQUFQO0FBQ0gsT0F0ZG9CLENBd2RyQjtBQUNBOztBQXpkcUI7QUFBQTtBQUFBLDBDQTBkRDtBQUdoQixhQUFLOUksTUFBTCxDQUFZUSxZQUFaLEdBQTJCLENBQUMsS0FBS1IsTUFBTCxDQUFZUSxZQUF4Qzs7QUFFQSxZQUFJLEtBQUtJLE1BQUwsQ0FBWXdELE1BQVosSUFBc0IsQ0FBQyxLQUFLcEUsTUFBTCxDQUFZdUMsa0JBQXZDLEVBQTJEO0FBQ3ZELGVBQUszQixNQUFMLENBQVlaLE1BQVosQ0FBbUJzSyxNQUFuQixDQUEwQkMsTUFBMUIsR0FBbUMsS0FBSyxLQUFLdkssTUFBTCxDQUFZUSxZQUFaLEdBQTJCLENBQTNCLEdBQStCLEtBQUtJLE1BQUwsQ0FBWXdELE1BQVosQ0FBbUJwRSxNQUFuQixDQUEwQndKLE1BQTFCLEdBQW1DLENBQXZFLENBQW5DO0FBQ0g7O0FBRUQsYUFBS1YsTUFBTDtBQUNBLGFBQUswQixvQkFBTDs7QUFFQSxZQUFJLENBQUMsS0FBS3hLLE1BQUwsQ0FBWVEsWUFBakIsRUFBK0I7QUFDM0I7QUFDQTtBQUVBLGVBQUtlLFdBQUwsQ0FBaUJ2QixNQUFqQixDQUF3QnlLLFVBQXhCLEdBQXFDLEtBQUtsSixXQUFMLENBQWlCaUMsWUFBakIsQ0FBOEJpSCxVQUFuRTtBQUNBLGVBQUtsSixXQUFMLENBQWlCdkIsTUFBakIsQ0FBd0IwSyxTQUF4QixHQUFvQyxLQUFLbkosV0FBTCxDQUFpQmlDLFlBQWpCLENBQThCa0gsU0FBbEU7QUFDQUMsaUJBQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQUtySixXQUFMLENBQWlCdkIsTUFBN0IsRUFBcUMsS0FBS3VCLFdBQUwsQ0FBaUJpQyxZQUF0RDtBQUNBLGVBQUtqQyxXQUFMLENBQWlCQyxjQUFqQjtBQUNIOztBQUlELGVBQU8sSUFBUDtBQUNILE9BbmZvQixDQXVmckI7QUFDQTs7QUF4ZnFCO0FBQUE7QUFBQSx1Q0F5ZkpxSixhQXpmSSxFQXlmVztBQUM1QjtBQUNBLFlBQU1DLG1CQUFtQixHQUFHRCxhQUFhLENBQUNsSCxJQUFkLENBQW1CLFVBQUNDLElBQUQ7QUFBQSxpQkFBVUEsSUFBSSxDQUFDLENBQUQsQ0FBZDtBQUFBLFNBQW5CLENBQTVCOztBQUNBLFlBQUlrSCxtQkFBSixFQUF5QjtBQUNyQixpQkFBT0QsYUFBYSxDQUFDaEcsR0FBZCxDQUFrQixVQUFDakIsSUFBRDtBQUFBLG1CQUFVQSxJQUFJLENBQUMsQ0FBRCxDQUFkO0FBQUEsV0FBbEIsQ0FBUDtBQUNILFNBTDJCLENBTzVCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxZQUFNbUgsWUFBWSxHQUFHRixhQUFhLENBQUM1RyxNQUFuQzs7QUFDQSxZQUFJOEcsWUFBWSxJQUFJLEVBQXBCLEVBQXdCO0FBQ3BCLGlCQUFPLENBQUMsa0JBQUQsRUFBcUIsa0JBQXJCLEVBQXlDLGtCQUF6QyxFQUE2RCxrQkFBN0QsRUFBaUYsa0JBQWpGLEVBQXFHLGdCQUFyRyxFQUF1SCxrQkFBdkgsRUFBMkksa0JBQTNJLEVBQStKLGdCQUEvSixFQUFpTCxnQkFBakwsRUFBbU0sY0FBbk0sRUFBbU4sY0FBbk4sRUFBbU8sZ0JBQW5PLEVBQXFQLGVBQXJQLEVBQXNRLGNBQXRRLENBQVA7QUFDSCxTQUZELE1BRU8sSUFBSUEsWUFBWSxJQUFJLEVBQXBCLEVBQXdCO0FBQzNCLGlCQUFPLENBQUMsa0JBQUQsRUFBcUIsa0JBQXJCLEVBQXlDLGtCQUF6QyxFQUE2RCxrQkFBN0QsRUFBaUYsZ0JBQWpGLEVBQW1HLGtCQUFuRyxFQUF1SCxrQkFBdkgsRUFBMkksZ0JBQTNJLEVBQTZKLGlCQUE3SixFQUFnTCxpQkFBaEwsRUFBbU0sZ0JBQW5NLEVBQXFOLGdCQUFyTixFQUF1TyxjQUF2TyxFQUF1UCxjQUF2UCxFQUF1USxlQUF2USxFQUF3UixlQUF4UixFQUF5UyxlQUF6UyxFQUEwVCxjQUExVCxDQUFQO0FBQ0gsU0FGTSxNQUVBO0FBQ0g7QUFDQSxpQkFBTyxDQUFDLGtCQUFELEVBQXFCLGtCQUFyQixFQUF5QyxpQkFBekMsRUFBNEQsa0JBQTVELEVBQWdGLGtCQUFoRixFQUFvRyxrQkFBcEcsRUFBd0gsa0JBQXhILEVBQTRJLGdCQUE1SSxFQUE4SixnQkFBOUosRUFBZ0wsZ0JBQWhMLEVBQWtNLGlCQUFsTSxFQUFxTixpQkFBck4sRUFBd08saUJBQXhPLEVBQTJQLGdCQUEzUCxFQUE2USxnQkFBN1EsRUFBK1IsZ0JBQS9SLEVBQWlULGdCQUFqVCxFQUFtVSxjQUFuVSxFQUFtVixjQUFuVixFQUFtVyxjQUFuVyxFQUFtWCxjQUFuWCxFQUFtWSxlQUFuWSxFQUFvWixlQUFwWixFQUFxYSxlQUFyYSxFQUFzYixjQUF0YixDQUFQO0FBQ0g7QUFDSjtBQUVEOzs7Ozs7Ozs7QUEvZ0JxQjtBQUFBO0FBQUEsa0RBdWhCT3JHLElBdmhCUCxFQXVoQmFKLFNBdmhCYixFQXVoQndCO0FBQUE7O0FBQ3pDLFlBQU1oQixJQUFJLEdBQUcsSUFBYixDQUR5QyxDQUV6Qzs7QUFDQSxZQUFNYyxNQUFNLEdBQUcsS0FBS1osWUFBTCxDQUFrQlksTUFBakM7O0FBQ0EsWUFBSUEsTUFBTSxJQUFJQSxNQUFNLENBQUNILE1BQXJCLEVBQTZCO0FBQ3pCLGlCQUFPRyxNQUFNLENBQUNTLEdBQVAsQ0FBVyxVQUFDakIsSUFBRDtBQUFBLG1CQUFVLENBQUNBLElBQUksQ0FBQyxNQUFJLENBQUM1RCxNQUFMLENBQVlpQyxpQkFBYixDQUFMLEVBQXNDMkIsSUFBSSxDQUFDcUIsS0FBM0MsRUFBa0RyQixJQUFJLENBQUM3QyxLQUF2RCxDQUFWO0FBQUEsV0FBWCxDQUFQO0FBQ0gsU0FOd0MsQ0FRekM7OztBQUNBLFlBQU1pSyxVQUFVLEdBQUcsRUFBbkIsQ0FUeUMsQ0FTbEI7O0FBQ3ZCLFlBQU1oSCxVQUFVLEdBQUcsRUFBbkI7QUFFQVUsWUFBSSxDQUFDYSxPQUFMLENBQWEsVUFBQzNCLElBQUQsRUFBVTtBQUNuQixjQUFNb0IsRUFBRSxHQUFHcEIsSUFBSSxDQUFDTixJQUFJLENBQUN0RCxNQUFMLENBQVlpQyxpQkFBYixDQUFmOztBQUNBLGNBQUksQ0FBQ3dELE1BQU0sQ0FBQ3dGLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDdEMsSUFBaEMsQ0FBcUNvQyxVQUFyQyxFQUFpRGhHLEVBQWpELENBQUwsRUFBMkQ7QUFDdkRnRyxzQkFBVSxDQUFDaEcsRUFBRCxDQUFWLEdBQWlCLElBQWpCLENBRHVELENBRXZEOztBQUNBaEIsc0JBQVUsQ0FBQ3NDLElBQVgsQ0FBZ0IsQ0FBQ3RCLEVBQUQsRUFBS3BCLElBQUksQ0FBQyxNQUFJLENBQUM1RCxNQUFMLENBQVlnQyxpQkFBYixDQUFULEVBQTBDNEIsSUFBSSxDQUFDVSxTQUFELENBQTlDLENBQWhCO0FBQ0g7QUFDSixTQVBEO0FBUUEsZUFBT04sVUFBUDtBQUNIO0FBNWlCb0I7O0FBQUE7QUFBQSxJQW1HTXRCLFNBbkdOOztBQStpQnpCLE1BQU15SSx3QkFBd0IsR0FBRztBQUM3QkMsYUFBUyxFQUFFO0FBQUUsbUJBQWE7QUFBZixLQURrQjtBQUU3QkMsWUFBUSxFQUFFLEtBRm1CO0FBRzdCMUssUUFBSSxFQUFFO0FBQUUySyxRQUFFLEVBQUUsQ0FBQyxhQUFELEVBQWdCLFVBQWhCO0FBQU4sS0FIdUI7QUFJN0IxQixRQUFJLEVBQUU7QUFBRTJCLFNBQUcsRUFBRSxDQUFDLGVBQUQsRUFBa0IsWUFBbEI7QUFBUCxLQUp1QjtBQUs3QmhMLFFBQUksRUFBRTtBQUx1QixHQUFqQztBQVFBLE1BQU1pTCxzQkFBc0IsR0FBSTtBQUM1QkosYUFBUyxFQUFFO0FBQUUsbUJBQWE7QUFBZixLQURpQjtBQUU1QnBHLE1BQUUsRUFBRSxXQUZ3QjtBQUc1QnlHLFFBQUksRUFBRSxXQUhzQjtBQUk1QnBNLFVBQU0sRUFBRSxDQUFDLCtCQUFELEVBQWtDLDZCQUFsQyxFQUFpRSxrQ0FBakUsRUFBcUcsb0NBQXJHLEVBQTJJLGlDQUEzSSxDQUpvQjtBQUs1QndJLFlBQVEsRUFBRSwrQkFMa0I7QUFNNUIvRixlQUFXLEVBQUUsK0JBTmU7QUFPNUJDLGFBQVMsRUFBRSw2QkFQaUI7QUFRNUJFLHFCQUFpQixFQUFFLG9DQVJTO0FBUzVCRCxxQkFBaUIsRUFBRSxvQ0FUUztBQVU1QnhCLGdCQUFZLEVBQUUsS0FWYztBQVc1QitCLHNCQUFrQixFQUFFLElBWFE7QUFZNUJ4QixTQUFLLEVBQUUsQ0FDSDtBQUNJO0FBQ0F3RCxXQUFLLEVBQUUsaUNBRlg7QUFHSVYsb0JBQWMsRUFBRTtBQUhwQixLQURHLEVBTUg7QUFDSVUsV0FBSyxFQUFFLG9DQURYO0FBRUlWLG9CQUFjLEVBQUUsaUJBRnBCO0FBR0lsQyxnQkFBVSxFQUFFO0FBQ1I7QUFDQXFDLGtCQUFVLEVBQUUsRUFGSjtBQUdSRSxjQUFNLEVBQUUsRUFIQTtBQUlSd0gsa0JBQVUsRUFBRTtBQUpKO0FBSGhCLEtBTkcsQ0FacUI7QUE2QjVCdEgsVUFBTSxFQUFFLEVBN0JvQjtBQTZCaEI7QUFDWnVILGFBQVMsRUFBRTtBQUNQQyxpQkFBVyxFQUFFLENBQ1Q7QUFBRUMsY0FBTSxFQUFFLEtBQVY7QUFBaUJDLGNBQU0sRUFBRTtBQUF6QixPQURTLENBRE47QUFJUEMsZ0JBQVUsRUFBRSxDQUNSO0FBQUVGLGNBQU0sRUFBRSxPQUFWO0FBQW1CQyxjQUFNLEVBQUU7QUFBM0IsT0FEUSxDQUpMO0FBT1BFLGFBQU8sRUFBRSxDQUNMO0FBQUVILGNBQU0sRUFBRSxRQUFWO0FBQW9CQyxjQUFNLEVBQUUsVUFBNUI7QUFBd0NHLGlCQUFTLEVBQUU7QUFBbkQsT0FESyxDQVBGO0FBVVBDLGtCQUFZLEVBQUUsQ0FDVjtBQUFFTCxjQUFNLEVBQUUsUUFBVjtBQUFvQkMsY0FBTSxFQUFFO0FBQTVCLE9BRFU7QUFWUCxLQTlCaUI7QUE0QzVCL0MsV0FBTyxFQUFFb0M7QUE1Q21CLEdBQWhDO0FBK0NBLE1BQU1nQixzQkFBc0IsR0FBRztBQUMzQm5ILE1BQUUsRUFBRSxXQUR1QjtBQUUzQkksU0FBSyxFQUFFLElBRm9CO0FBRzNCb0UsVUFBTSxFQUFFLEVBSG1CO0FBSTNCa0IsYUFBUyxFQUFFLEdBSmdCO0FBSzNCRCxjQUFVLEVBQUUsRUFMZTtBQU0zQkgsVUFBTSxFQUFFO0FBQUU4QixTQUFHLEVBQUUsRUFBUDtBQUFXQyxXQUFLLEVBQUUsR0FBbEI7QUFBdUI5QixZQUFNLEVBQUUsQ0FBL0I7QUFBa0MrQixVQUFJLEVBQUU7QUFBeEMsS0FObUI7QUFPM0JDLFdBQU8sRUFBRyxZQUFZO0FBQ2xCLFVBQU1DLENBQUMsR0FBRzdOLFNBQVMsQ0FBQ2tFLE9BQVYsQ0FBa0IvRCxHQUFsQixDQUFzQixTQUF0QixFQUFpQyxnQkFBakMsRUFBbUQ7QUFBRTJOLG9CQUFZLEVBQUU7QUFBaEIsT0FBbkQsQ0FBVjtBQUNBRCxPQUFDLENBQUNFLE9BQUYsQ0FBVXBHLElBQVYsQ0FBZTtBQUNYbUYsWUFBSSxFQUFFLHFCQURLO0FBRVh2TCxxQkFBYSxFQUFFLFdBRko7QUFHWFcsZ0JBQVEsRUFBRTtBQUhDLE9BQWY7QUFLQSxhQUFPMkwsQ0FBUDtBQUNILEtBUlEsRUFQa0I7QUFnQjNCM0MsUUFBSSxFQUFFLEVBaEJxQjtBQWlCM0I4QyxlQUFXLEVBQUU7QUFDVEMsNEJBQXNCLEVBQUUsSUFEZjtBQUVUQyxvQkFBYyxFQUFFLElBRlA7QUFHVEMsY0FBUSxFQUFFO0FBSEQsS0FqQmM7QUFzQjNCMUksVUFBTSxFQUFFO0FBQ0oySSxZQUFNLEVBQUUsSUFESjtBQUVKQyxpQkFBVyxFQUFFLFlBRlQ7QUFHSkMsWUFBTSxFQUFFO0FBQUVDLFNBQUMsRUFBRSxFQUFMO0FBQVM1RCxTQUFDLEVBQUU7QUFBWixPQUhKO0FBSUo2RCxxQkFBZSxFQUFFO0FBSmIsS0F0Qm1CO0FBNEIzQi9NLGVBQVcsRUFBRSxDQUFDb0wsc0JBQUQ7QUE1QmMsR0FBL0I7QUErQkEsTUFBTTRCLHFCQUFxQixHQUFHO0FBQzFCak8sU0FBSyxFQUFFLEVBRG1CO0FBRTFCaUcsU0FBSyxFQUFFLEdBRm1CO0FBRzFCb0UsVUFBTSxFQUFFLEdBSGtCO0FBSTFCNkQscUJBQWlCLEVBQUUsSUFKTztBQUsxQkMsb0JBQWdCLEVBQUUsS0FMUTtBQU0xQkMsb0JBQWdCLEVBQUUsT0FOUTtBQU8xQmhCLFdBQU8sRUFBRTVOLFNBQVMsQ0FBQ2tFLE9BQVYsQ0FBa0IvRCxHQUFsQixDQUFzQixTQUF0QixFQUFpQyxzQkFBakMsRUFBeUQ7QUFBRTJOLGtCQUFZLEVBQUU7QUFBaEIsS0FBekQsQ0FQaUI7QUFRMUJlLFVBQU0sRUFBRSxDQUNKN08sU0FBUyxDQUFDa0UsT0FBVixDQUFrQi9ELEdBQWxCLENBQXNCLE9BQXRCLEVBQStCLGFBQS9CLEVBQThDO0FBQzFDMk4sa0JBQVksRUFBRSxJQUQ0QjtBQUUxQ3JILFdBQUssRUFBRSxHQUZtQztBQUcxQ3FJLHlCQUFtQixFQUFHLE1BQU07QUFIYyxLQUE5QyxDQURJLEVBTUpoSSxNQUFNLENBQUNpSSxNQUFQLENBQ0k7QUFBRWpCLGtCQUFZLEVBQUUsSUFBaEI7QUFBc0JnQix5QkFBbUIsRUFBRyxNQUFNO0FBQWxELEtBREosRUFFSXRCLHNCQUZKLENBTkksRUFVSnhOLFNBQVMsQ0FBQ2tFLE9BQVYsQ0FBa0IvRCxHQUFsQixDQUFzQixPQUF0QixFQUErQixPQUEvQixFQUF3QztBQUFFMk4sa0JBQVksRUFBRSxJQUFoQjtBQUFzQnJILFdBQUssRUFBRSxHQUE3QjtBQUFrQ3FJLHlCQUFtQixFQUFHLE1BQU07QUFBOUQsS0FBeEMsQ0FWSTtBQVJrQixHQUE5QjtBQXNCQTlPLFdBQVMsQ0FBQ0UsUUFBVixDQUFtQjhPLEdBQW5CLENBQXVCLFlBQXZCLEVBQXFDek8sVUFBckM7QUFDQVAsV0FBUyxDQUFDZ0UsVUFBVixDQUFxQmdMLEdBQXJCLENBQXlCLFdBQXpCLEVBQXNDL0ssZ0JBQXRDO0FBRUFqRSxXQUFTLENBQUNrRSxPQUFWLENBQWtCOEssR0FBbEIsQ0FBc0IsU0FBdEIsRUFBaUMsb0JBQWpDLEVBQXVEeEMsd0JBQXZEO0FBQ0F4TSxXQUFTLENBQUNrRSxPQUFWLENBQWtCOEssR0FBbEIsQ0FBc0IsWUFBdEIsRUFBb0MsV0FBcEMsRUFBaURuQyxzQkFBakQ7QUFDQTdNLFdBQVMsQ0FBQ2tFLE9BQVYsQ0FBa0I4SyxHQUFsQixDQUFzQixPQUF0QixFQUErQixXQUEvQixFQUE0Q3hCLHNCQUE1QztBQUNBeE4sV0FBUyxDQUFDa0UsT0FBVixDQUFrQjhLLEdBQWxCLENBQXNCLE1BQXRCLEVBQThCLHNCQUE5QixFQUFzRFAscUJBQXREO0FBRUF6TyxXQUFTLENBQUNpUCxjQUFWLENBQXlCRCxHQUF6QixDQUE2QixRQUE3QixFQUF1Q2pNLE1BQXZDO0FBRUEvQyxXQUFTLENBQUNLLE9BQVYsQ0FBa0IyTyxHQUFsQixDQUFzQixxQkFBdEIsRUFBNkM1TixpQkFBN0M7QUFDSDs7QUFFRCxJQUFJLE9BQU9wQixTQUFQLEtBQXFCLFdBQXpCLEVBQXNDO0FBQ2xDO0FBQ0E7QUFDQUEsV0FBUyxDQUFDa1AsR0FBVixDQUFjblAsT0FBZDtBQUNIOztBQUdjQSxzRUFBZixFOzs7Ozs7Ozs7OztBQzVyQkEsb0IiLCJmaWxlIjoiZXh0L2x6LWludGVydmFscy10cmFjay5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2VzbS9leHQvbHotaW50ZXJ2YWxzLXRyYWNrLmpzXCIpO1xuIiwiLyoqXG5JbnRlcnZhbCBhbm5vdGF0aW9uIHRyYWNrIChmb3IgY2hyb21hdGluIHN0YXRlLCBldGMpLiBVc2VmdWwgZm9yIEJFRCBmaWxlIGRhdGEgd2l0aCBub24tb3ZlcmxhcHBpbmcgaW50ZXJ2YWxzLlxuVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgY29yZSBMb2N1c1pvb20gbGlicmFyeSwgYnV0IGNhbiBiZSBpbmNsdWRlZCBhcyBhIHN0YW5kYWxvbmUgZmlsZS5cblxuVGhlIHBhZ2UgbXVzdCBpbmNvcnBvcmF0ZSBhbmQgbG9hZCBhbGwgbGlicmFyaWVzIGJlZm9yZSB0aGlzIGZpbGUgY2FuIGJlIHVzZWQsIGluY2x1ZGluZzpcbiAtIFZlbmRvciBhc3NldHNcbiAtIExvY3VzWm9vbVxuIEBtb2R1bGVcbiovXG5cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuXG5mdW5jdGlvbiBpbnN0YWxsIChMb2N1c1pvb20pIHtcbiAgICBjb25zdCBCYXNlQXBpQWRhcHRlciA9IExvY3VzWm9vbS5BZGFwdGVycy5nZXQoJ0Jhc2VBcGlBZGFwdGVyJyk7XG4gICAgY29uc3QgX0J1dHRvbiA9IExvY3VzWm9vbS5XaWRnZXRzLmdldCgnX0J1dHRvbicpO1xuICAgIGNvbnN0IF9CYXNlV2lkZ2V0ID0gTG9jdXNab29tLldpZGdldHMuZ2V0KCdCYXNlV2lkZ2V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIFNvdXJjZSBmb3IgSW50ZXJ2YWwgQW5ub3RhdGlvbiBEYXRhIChlLmcuIEJFRCBUcmFja3MpLCBhcyBmZXRjaGVkIGZyb20gdGhlIExvY3VzWm9vbSBBUEkgc2VydmVyIChvciBjb21wYXRpYmxlKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBJbnRlcnZhbExaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgICAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGNoYWluLmhlYWRlci5iZWR0cmFja3NvdXJjZSB8fCB0aGlzLnBhcmFtcy5zb3VyY2U7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGA/ZmlsdGVyPWlkIGluICR7c291cmNlfSBhbmQgY2hyb21vc29tZSBlcSAnJHtzdGF0ZS5jaHJ9JyBhbmQgc3RhcnQgbGUgJHtzdGF0ZS5lbmR9IGFuZCBlbmQgZ2UgJHtzdGF0ZS5zdGFydH1gO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMudXJsfSR7cXVlcnl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1dHRvbiB0byB0b2dnbGUgc3BsaXQgdHJhY2tzXG4gICAgICovXG4gICAgY2xhc3MgVG9nZ2xlU3BsaXRUcmFja3MgZXh0ZW5kcyBfQmFzZVdpZGdldCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICghbGF5b3V0LmRhdGFfbGF5ZXJfaWQpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQuZGF0YV9sYXllcl9pZCA9ICdpbnRlcnZhbHMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudF9wYW5lbC5kYXRhX2xheWVyc1tsYXlvdXQuZGF0YV9sYXllcl9pZF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvZ2dsZSBzcGxpdCB0cmFja3Mgd2lkZ2V0IHNwZWNpZmllcyBhbiBpbnZhbGlkIGRhdGEgbGF5ZXIgSUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFfbGF5ZXIgPSB0aGlzLnBhcmVudF9wYW5lbC5kYXRhX2xheWVyc1t0aGlzLmxheW91dC5kYXRhX2xheWVyX2lkXTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBkYXRhX2xheWVyLmxheW91dC5zcGxpdF90cmFja3MgPyAnTWVyZ2UgVHJhY2tzJyA6ICdTcGxpdCBUcmFja3MnO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2V0SHRtbChodG1sKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgX0J1dHRvbih0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRIdG1sKGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUaXRsZSgnVG9nZ2xlIHdoZXRoZXIgdHJhY2tzIGFyZSBzcGxpdCBhcGFydCBvciBtZXJnZWQgdG9nZXRoZXInKVxuICAgICAgICAgICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyLnRvZ2dsZVNwbGl0VHJhY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FsZV90aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2NhbGVfdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wYW5lbC5zY2FsZUhlaWdodFRvRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QucG9zaXRpb25QYW5lbHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB2YWx1ZSBcIlwicnIsZ2csYmJcIiAoaWYgZ2l2ZW4pIHRvIGEgY3NzLWZyaWVuZGx5IGNvbG9yIHN0cmluZzogXCJyZ2IocnIsZ2csYmIpXCIuXG4gICAgICogVGhpcyBpcyB0YWlsb3JlZCBzcGVjaWZpY2FsbHkgdG8gdGhlIGNvbG9yIHNwZWNpZmljYXRpb24gZm9ybWF0IGVtYnJhY2VkIGJ5IHRoZSBCRUQgZmlsZSBzdGFuZGFyZC5cbiAgICAgKiBAZnVuY3Rpb24gdG9fcmdiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgVGhpcyBmdW5jdGlvbiBoYXMgbm8gZGVmaW5lZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydCB0byByZ2JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b19yZ2IocGFyYW1ldGVycywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gYHJnYigke3ZhbHVlfSlgIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0X2xheW91dCA9IHtcbiAgICAgICAgc3RhcnRfZmllbGQ6ICdzdGFydCcsXG4gICAgICAgIGVuZF9maWVsZDogJ2VuZCcsXG4gICAgICAgIHRyYWNrX2xhYmVsX2ZpZWxkOiAnc3RhdGVfbmFtZScsIC8vIFVzZWQgdG8gbGFiZWwgaXRlbXMgb24gdGhlIHktYXhpc1xuICAgICAgICAvLyBVc2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRyYWNrcyBmb3IgY29sb3JpbmcuIFRoaXMgdGVuZHMgdG8gbGVhZCB0byBtb3JlIHN0YWJsZSBjb2xvcmluZy9zb3J0aW5nXG4gICAgICAgIC8vICB0aGFuIHVzaW5nIHRoZSBsYWJlbCBmaWVsZC0gZWcsIHN0YXRlX2lkcyBhbGxvdyB1cyB0byBzZXQgZ2xvYmFsIGNvbG9ycyBhY3Jvc3MgdGhlIGVudGlyZSBkYXRhc2V0LFxuICAgICAgICAvLyAgbm90IGp1c3QgY2hvb3NlIHVuaXF1ZSBjb2xvcnMgd2l0aGluIGEgcGFydGljdWxhciBuYXJyb3cgcmVnaW9uLiAod2hlcmUgY2hhbmdpbmcgcmVnaW9uIG1pZ2h0IGxlYWQgdG8gbW9yZVxuICAgICAgICAvLyAgY2F0ZWdvcmllcyBhbmQgZGlmZmVyZW50IGNvbG9ycylcbiAgICAgICAgdHJhY2tfc3BsaXRfZmllbGQ6ICdzdGF0ZV9pZCcsXG4gICAgICAgIHRyYWNrX3NwbGl0X29yZGVyOiAnREVTQycsXG4gICAgICAgIHRyYWNrX3NwbGl0X2xlZ2VuZF90b195X2F4aXM6IDIsXG4gICAgICAgIHNwbGl0X3RyYWNrczogdHJ1ZSxcbiAgICAgICAgdHJhY2tfaGVpZ2h0OiAxNSxcbiAgICAgICAgdHJhY2tfdmVydGljYWxfc3BhY2luZzogMyxcbiAgICAgICAgYm91bmRpbmdfYm94X3BhZGRpbmc6IDIsXG4gICAgICAgIGFsd2F5c19oaWRlX2xlZ2VuZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiAnI0I4QjhCOCcsXG4gICAgICAgIGZpbGxfb3BhY2l0eTogMSxcbiAgICAgICAgdG9vbHRpcF9wb3NpdGlvbmluZzogJ3ZlcnRpY2FsJyxcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnZhbHMgRGF0YSBMYXllclxuICAgICAqIEltcGxlbWVudHMgYSBkYXRhIGxheWVyIHRoYXQgd2lsbCByZW5kZXIgaW50ZXJ2YWwgYW5ub3RhdGlvbiB0cmFja3MgKGludGVydmFscyBtdXN0IHByb3ZpZGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMpXG4gICAgICovXG4gICAgY29uc3QgQmFzZUxheWVyID0gTG9jdXNab29tLkRhdGFMYXllcnMuZ2V0KCdCYXNlRGF0YUxheWVyJyk7XG4gICAgY2xhc3MgTHpJbnRlcnZhbHNUcmFjayBleHRlbmRzIEJhc2VMYXllciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICAgICAgTG9jdXNab29tLkxheW91dHMubWVyZ2UobGF5b3V0LCBkZWZhdWx0X2xheW91dCk7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy50cmFja3MgPSAxO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c190cmFja3MgPSAxO1xuXG4gICAgICAgICAgICAvLyB0cmFjay1udW1iZXItaW5kZXhlZCBvYmplY3Qgd2l0aCBhcnJheXMgb2YgaW50ZXJ2YWwgaW5kZXhlcyBpbiB0aGUgZGF0YXNldFxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleCA9IHsgMTogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUbyBkZWZpbmUgc2hhcmVkIGhpZ2hsaWdodGluZyBvbiB0aGUgdHJhY2sgc3BsaXQgZmllbGQgZGVmaW5lIHRoZSBzdGF0dXMgbm9kZSBpZCBvdmVycmlkZVxuICAgICAgICAgKiB0byBnZW5lcmF0ZSBhbiBJRCBjb21tb24gdG8gdGhlIHRyYWNrIHdoZW4gd2UncmUgYWN0aXZlbHkgc3BsaXR0aW5nIGRhdGEgb3V0IHRvIHNlcGFyYXRlIHRyYWNrc1xuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEVsZW1lbnRTdGF0dXNOb2RlSWQoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYCR7dGhpcy5nZXRCYXNlSWQoKX0tc3RhdHVzbm9kZS0ke2VsZW1lbnRbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdfWApLnJlcGxhY2UoL1teXFx3XS9nLCAnXycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0RWxlbWVudElkKGVsZW1lbnQpfS1zdGF0dXNub2RlYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzdW0gbGF5b3V0IHZhbHVlcyB0byBkZXJpdmUgdG90YWwgaGVpZ2h0IGZvciBhIHNpbmdsZSBpbnRlcnZhbCB0cmFja1xuICAgICAgICBnZXRUcmFja0hlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC50cmFja19oZWlnaHRcbiAgICAgICAgICAgICAgICArIHRoaXMubGF5b3V0LnRyYWNrX3ZlcnRpY2FsX3NwYWNpbmdcbiAgICAgICAgICAgICAgICArICgyICogdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9kaWZ5IHRoZSBsYXlvdXQgYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IGFwcHJvcHJpYXRlIGNvbG9yLCBsYWJlbCwgYW5kIGxlZ2VuZCBvcHRpb25zIGFyZSBhdmFpbGFibGVcbiAgICAgICAgLy8gRXZlbiB3aGVuIG5vdCBkaXNwbGF5ZWQsIHRoZSBsZWdlbmQgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgeS1heGlzIHRpY2tzXG4gICAgICAgIF9hcHBseUxheW91dE9wdGlvbnMoKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGJhc2VfbGF5b3V0ID0gdGhpcy5fYmFzZV9sYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJfbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCBiYXNlX2NvbG9yX3NjYWxlID0gYmFzZV9sYXlvdXQuY29sb3IuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNjYWxlX2Z1bmN0aW9uICYmIGl0ZW0uc2NhbGVfZnVuY3Rpb24gPT09ICdjYXRlZ29yaWNhbF9iaW4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb2xvcl9zY2FsZSA9IHJlbmRlcl9sYXlvdXQuY29sb3IuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNjYWxlX2Z1bmN0aW9uICYmIGl0ZW0uc2NhbGVfZnVuY3Rpb24gPT09ICdjYXRlZ29yaWNhbF9iaW4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWJhc2VfY29sb3Jfc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBhIHBsYWNlaG9sZGVyIChlbXB0eSBjYXRlZ29yaWVzICYgdmFsdWVzKSwgYnV0IGl0IG5lZWRzIHRvIGJlIHRoZXJlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcnZhbCB0cmFja3MgbXVzdCBkZWZpbmUgYSBgY2F0ZWdvcmljYWxfYmluYCBjb2xvciBzY2FsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoYXNfY29sb3JzID0gYmFzZV9jb2xvcl9zY2FsZS5wYXJhbWV0ZXJzLmNhdGVnb3JpZXMubGVuZ3RoICYmIGJhc2VfY29sb3Jfc2NhbGUucGFyYW1ldGVycy52YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGFzX2xlZ2VuZCA9IGJhc2VfbGF5b3V0LmxlZ2VuZCAmJiBiYXNlX2xheW91dC5sZWdlbmQubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISFoYXNfY29sb3JzIF4gISFoYXNfbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgY29sb3IgT1IgbGVnZW5kIHRvIGJlIHNldCBtYW51YWxseS4gSXQgbXVzdCBiZSBib3RoLCBvciBuZWl0aGVyLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gdXNlIGEgbWFudWFsbHkgc3BlY2lmaWVkIGNvbG9yIHNjaGVtZSwgYm90aCBjb2xvciBhbmQgbGVnZW5kIG9wdGlvbnMgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhcnZlc3QgYW55IGluZm9ybWF0aW9uIGFib3V0IGFuIGV4cGxpY2l0IGNvbG9yIGZpZWxkIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgd2hlbiBnZW5lcmF0aW5nIGNvbG9yc1xuICAgICAgICAgICAgY29uc3QgcmdiX29wdGlvbiA9IGJhc2VfbGF5b3V0LmNvbG9yLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zY2FsZV9mdW5jdGlvbiAmJiBpdGVtLnNjYWxlX2Z1bmN0aW9uID09PSAndG9fcmdiJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmdiX2ZpZWxkID0gcmdiX29wdGlvbiAmJiByZ2Jfb3B0aW9uLmZpZWxkO1xuXG4gICAgICAgICAgICAvLyBBdXRvLWdlbmVyYXRlIGxlZ2VuZCBiYXNlZCBvbiBkYXRhXG4gICAgICAgICAgICBjb25zdCBrbm93bl9jYXRlZ29yaWVzID0gdGhpcy5fZ2VuZXJhdGVDYXRlZ29yaWVzRnJvbURhdGEodGhpcy5kYXRhLCByZ2JfZmllbGQpOyAvLyBbaWQsIGxhYmVsLCBpdGVtUmdiXSBpdGVtc1xuXG4gICAgICAgICAgICBpZiAoIWhhc19jb2xvcnMgJiYgIWhhc19sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBjb2xvciBzY2hlbWUgcHJlLWRlZmluZWQsIHRoZW4gbWFrZSBhIGNvbG9yIHNjaGVtZSB0aGF0IGlzIGFwcHJvcHJpYXRlIGFuZCBhcHBseSB0byB0aGUgcGxvdFxuICAgICAgICAgICAgICAgIC8vIFRoZSBsZWdlbmQgbXVzdCBtYXRjaCB0aGUgY29sb3Igc2NoZW1lLiBJZiB3ZSBnZW5lcmF0ZSBvbmUsIHRoZW4gd2UgbXVzdCBnZW5lcmF0ZSBib3RoLlxuXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5fbWFrZUNvbG9yU2NoZW1lKGtub3duX2NhdGVnb3JpZXMpO1xuICAgICAgICAgICAgICAgIGNvbG9yX3NjYWxlLnBhcmFtZXRlcnMuY2F0ZWdvcmllcyA9IGtub3duX2NhdGVnb3JpZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbG9yX3NjYWxlLnBhcmFtZXRlcnMudmFsdWVzID0gY29sb3JzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQubGVnZW5kID0ga25vd25fY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24gKHBhaXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gcGFpclswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBwYWlyWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtX2NvbG9yID0gY29sb3Jfc2NhbGUucGFyYW1ldGVycy52YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0geyBzaGFwZTogJ3JlY3QnLCB3aWR0aDogOSwgbGFiZWw6IGxhYmVsLCBjb2xvcjogaXRlbV9jb2xvciB9O1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3NlbGYubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFmdGVyIHdlJ3ZlIGxvYWRlZCBpbnRlcnZhbCBkYXRhIGludGVycHJldCBpdCB0byBhc3NpZ25cbiAgICAgICAgLy8gZWFjaCB0byBhIHRyYWNrIHNvIHRoYXQgdGhleSBkbyBub3Qgb3ZlcmxhcCBpbiB0aGUgdmlld1xuICAgICAgICBhc3NpZ25UcmFja3MoKSB7XG4gICAgICAgICAgICAvLyBBdXRvZ2VuZXJhdGUgbGF5b3V0IG9wdGlvbnMgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dE9wdGlvbnMoKTtcblxuICAgICAgICAgICAgLy8gUmVpbml0aWFsaXplIHNvbWUgbWV0YWRhdGFcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNfdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICAgICAgICB0aGlzLnRyYWNrcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4ID0geyAxOiBbXSB9O1xuICAgICAgICAgICAgLy8gVGhpcyBtYXBzIHVuaXF1ZSB2YWx1ZXMgb2YgdHJhY2tfc3BsaXRfZmllbGQgdG8gdW5pcXVlIHkgaW5kaWNlcy4gSXQgY29udHJvbHMgdGhlIG9yZGVyaW5nIG9mIHNlcGFyYXRlIHRyYWNrcy5cbiAgICAgICAgICAgIHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXggPSB7fTtcblxuICAgICAgICAgICAgLy8gSWYgc3BsaXR0aW5nIHRyYWNrcyBieSBhIGZpZWxkJ3MgdmFsdWUgdGhlbiBkZXRlcm1pbmUgaG93IHRvIG9yZGVyIHRoZW0uIFRoZXJlIGFyZSB0d28gb3B0aW9ucyBoZXJlOlxuICAgICAgICAgICAgLy8gYSkgbnVtZXJpYyBJRHMgZ2V0IHNvcnRlZCBpbiBudW1lcmljIG9yZGVyIChKUyBxdWlyazogaW50IG9iamVjdCBrZXlzIGFjdCBsaWtlIGFycmF5IGluZGljZXMpLCBvclxuICAgICAgICAgICAgLy8gYikgdGV4dCBsYWJlbHMgZ2V0IHNvcnRlZCBiYXNlZCBvbiBvcmRlciBpbiB0aGUgc291cmNlIGRhdGEgKGhhc2ggcHJlc2VydmVzIGluc2VydGlvbiBvcmRlcilcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZCAmJiB0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4W2RbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfb3JkZXIgPT09ICdERVNDJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4LmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrX3NwbGl0X2ZpZWxkX2luZGV4W3ZhbF0gPSB0aGlzLnRyYWNrcyArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxfdHJhY2tfaW5kZXhbdGhpcy50cmFja3MgKyAxXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcysrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGFzaCBhIHBhcmVudCByZWZlcmVuY2Ugb24gdGhlIGludGVydmFsXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZGlzcGxheSByYW5nZSBzdGFydCBhbmQgZW5kLCBiYXNlZCBvbiBtaW5pbXVtIGFsbG93YWJsZSBpbnRlcnZhbCBkaXNwbGF5IHdpZHRoLFxuICAgICAgICAgICAgICAgIC8vIGJvdW5kZWQgYnkgd2hhdCB3ZSBjYW4gc2VlIChyYW5nZTogdmFsdWVzIGluIHRlcm1zIG9mIHBpeGVscyBvbiB0aGUgc2NyZWVuKVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJlbnQueF9zY2FsZShNYXRoLm1heChkW3RoaXMubGF5b3V0LnN0YXJ0X2ZpZWxkXSwgdGhpcy5zdGF0ZS5zdGFydCkpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6ICAgdGhpcy5wYXJlbnQueF9zY2FsZShNYXRoLm1pbihkW3RoaXMubGF5b3V0LmVuZF9maWVsZF0sIHRoaXMuc3RhdGUuZW5kKSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0uZGlzcGxheV9yYW5nZS53aWR0aCA9IHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlLmVuZCAtIHRoaXMuZGF0YVtpXS5kaXNwbGF5X3JhbmdlLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhbmQgc3Rhc2ggZGlzcGxheSByYW5nZSB2YWx1ZXMgaW50byBkb21haW4gdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gKGRvbWFpbjogdmFsdWVzIGluIHRlcm1zIG9mIHRoZSBkYXRhIHNldCwgZS5nLiBtZWdhYmFzZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLmRpc3BsYXlfZG9tYWluID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJlbnQueF9zY2FsZS5pbnZlcnQodGhpcy5kYXRhW2ldLmRpc3BsYXlfcmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6ICAgdGhpcy5wYXJlbnQueF9zY2FsZS5pbnZlcnQodGhpcy5kYXRhW2ldLmRpc3BsYXlfcmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS5kaXNwbGF5X2RvbWFpbi53aWR0aCA9IHRoaXMuZGF0YVtpXS5kaXNwbGF5X2RvbWFpbi5lbmQgLSB0aGlzLmRhdGFbaV0uZGlzcGxheV9kb21haW4uc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzcGxpdHRpbmcgdG8gdHJhY2tzIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgZGVzaWduYXRlZCB0cmFjayBzcGxpdCBmaWVsZFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYm90aGVyIHdpdGggY29sbGlzaW9uIGRldGVjdGlvbiAoaW50ZXJ2YWxzIHdpbGwgYmUgZ3JvdXBlZCBvbiB0cmFja3NcbiAgICAgICAgICAgICAgICAvLyBzb2xlbHkgYnkgdGhlIHZhbHVlIG9mIHRyYWNrX3NwbGl0X2ZpZWxkKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC50cmFja19zcGxpdF9maWVsZCAmJiB0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5kYXRhW2ldW3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldLnRyYWNrID0gdGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFt2YWxdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4W3RoaXMuZGF0YVtpXS50cmFja10ucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3Qgc3BsaXR0aW5nIHRvIHRyYWNrcyBiYXNlZCBvbiBhIGZpZWxkIHZhbHVlIHRoZW4gZG8gc28gYmFzZWQgb24gY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdGlvbiAoYXMgaG93IGl0J3MgZG9uZSBmb3IgZ2VuZXMpLiBVc2UgZGlzcGxheSByYW5nZS9kb21haW4gZGF0YSBnZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvdmUgYW5kIGNhc3QgZWFjaCBpbnRlcnZhbCB0byB0cmFja3Mgc3VjaCB0aGF0IG5vbmUgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXS50cmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3RlbnRpYWxfdHJhY2sgPSAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5kYXRhW2ldLnRyYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlzaW9uX29uX3BvdGVudGlhbF90cmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleFtwb3RlbnRpYWxfdHJhY2tdLm1hcChmdW5jdGlvbihwbGFjZWRfaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluX3N0YXJ0ID0gTWF0aC5taW4ocGxhY2VkX2ludGVydmFsLmRpc3BsYXlfcmFuZ2Uuc3RhcnQsIHRoaXMuZGlzcGxheV9yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heF9lbmQgPSBNYXRoLm1heChwbGFjZWRfaW50ZXJ2YWwuZGlzcGxheV9yYW5nZS5lbmQsIHRoaXMuZGlzcGxheV9yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1heF9lbmQgLSBtaW5fc3RhcnQpIDwgKHBsYWNlZF9pbnRlcnZhbC5kaXNwbGF5X3JhbmdlLndpZHRoICsgdGhpcy5kaXNwbGF5X3JhbmdlLndpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uX29uX3BvdGVudGlhbF90cmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcy5kYXRhW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0udHJhY2sgPSBwb3RlbnRpYWxfdHJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbF90cmFja19pbmRleFtwb3RlbnRpYWxfdHJhY2tdLnB1c2godGhpcy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsX3RyYWNrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbF90cmFjayA+IHRoaXMudHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzID0gcG90ZW50aWFsX3RyYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsX3RyYWNrX2luZGV4W3BvdGVudGlhbF90cmFja10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbXBsZW1lbnQgdGhlIG1haW4gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8vIExheSBvdXQgc3BhY2UgZmlyc3RcbiAgICAgICAgICAgIHRoaXMuYXNzaWduVHJhY2tzKCk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGZpbHRlcnMgdG8gb25seSByZW5kZXIgYSBzcGVjaWZpZWQgc2V0IG9mIHBvaW50cy4gSGlkZGVuIGZpZWxkcyB3aWxsIHN0aWxsIGJlIGdpdmVuIHNwYWNlIHRvIHJlbmRlciwgYnV0IG5vdCBzaG93bi5cbiAgICAgICAgICAgIGNvbnN0IHRyYWNrX2RhdGEgPSB0aGlzLl9hcHBseUZpbHRlcnMoKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBzaGFyZWQgaGlnaGxpZ2h0IG5vZGVzIGFuZCByZS1yZW5kZXIgdGhlbSBpZiB3ZSdyZSBzcGxpdHRpbmcgb24gdHJhY2tzXG4gICAgICAgICAgICAvLyBBdCBtb3N0IHRoZXJlIHdpbGwgb25seSBiZSBkb3plbiBvciBzbyBub2RlcyBoZXJlIChvbmUgcGVyIHRyYWNrKSBhbmQgZWFjaCB0aW1lXG4gICAgICAgICAgICAvLyB3ZSByZW5kZXIgZGF0YSB3ZSBtYXkgaGF2ZSBuZXcgdHJhY2tzLCBzbyB3aXBpbmcvcmVkcmF3aW5nIGFsbCBpcyByZWFzb25hYmxlLlxuICAgICAgICAgICAgdGhpcy5zdmcuZ3JvdXAuc2VsZWN0QWxsKCcubHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZS5sei1kYXRhX2xheWVyLWludGVydmFscy1zaGFyZWQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMudHJhY2tfc3BsaXRfZmllbGRfaW5kZXgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBwc3VlZG8tZWxlbWVudCBzbyB0aGF0IHdlIGNhbiBnZW5lcmF0ZSBhbiBpZCBmb3IgdGhlIHNoYXJlZCBub2RlXG4gICAgICAgICAgICAgICAgY29uc3QgcHNldWRvRWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgICAgIHBzZXVkb0VsZW1lbnRbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdID0ga2V5O1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgc2hhcmVkIG5vZGVcbiAgICAgICAgICAgICAgICB0aGlzLnN2Zy5ncm91cC5pbnNlcnQoJ3JlY3QnLCAnOmZpcnN0LWNoaWxkJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgdGhpcy5nZXRFbGVtZW50U3RhdHVzTm9kZUlkKHBzZXVkb0VsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1pbnRlcnZhbHMgbHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZSBsei1kYXRhX2xheWVyLWludGVydmFscy1zaGFyZWQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncngnLCB0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J5JywgdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMucGFyZW50LmxheW91dC5jbGlwYXJlYS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuZ2V0VHJhY2tIZWlnaHQoKSAtIHRoaXMubGF5b3V0LnRyYWNrX3ZlcnRpY2FsX3NwYWNpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAodGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFtrZXldIC0gMSkgKiB0aGlzLmdldFRyYWNrSGVpZ2h0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MgPyBudWxsIDogJ25vbmUnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIGludGVydmFsIGdyb3Vwc1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zdmcuZ3JvdXAuc2VsZWN0QWxsKCdnLmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzJylcbiAgICAgICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFt0aGlzLmxheW91dC5pZF9maWVsZF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzJylcbiAgICAgICAgICAgICAgICAubWVyZ2Uoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiB0aGlzLmdldEVsZW1lbnRJZChkKSlcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gaW50ZXJ2YWwucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgaW50ZXJ2YWwgc3RhdHVzIG5vZGVzIChkaXNwbGF5ZWQgYmVoaW5kIGludGVydmFscyB0byBzaG93IGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRob3V0IG5lZWRpbmcgdG8gbW9kaWZ5IGludGVydmFsIGRpc3BsYXkgZWxlbWVudChzKSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzbm9kZXMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdyZWN0Lmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLmx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUubHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZS1kaXNjcmV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbaW50ZXJ2YWxdLCAoZCkgPT4gYCR7ZGF0YV9sYXllci5nZXRFbGVtZW50SWQoZCl9LXN0YXR1c25vZGVgKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzbm9kZXMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydCgncmVjdCcsICc6Zmlyc3QtY2hpbGQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzIGx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUgbHotZGF0YV9sYXllci1pbnRlcnZhbHMtc3RhdHVzbm9kZS1kaXNjcmV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWVyZ2Uoc3RhdHVzbm9kZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gYCR7ZGF0YV9sYXllci5nZXRFbGVtZW50SWQoZCl9LXN0YXR1c25vZGVgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncnknLCBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGRhdGFfbGF5ZXIubGF5b3V0LnNwbGl0X3RyYWNrcyA/ICdub25lJyA6IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLndpZHRoICsgKDIgKiBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpIC0gZGF0YV9sYXllci5sYXlvdXQudHJhY2tfdmVydGljYWxfc3BhY2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS5zdGFydCAtIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNub2Rlcy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgcHJpbWFyeSBpbnRlcnZhbCByZWN0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0cyA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3JlY3QubHotZGF0YV9sYXllci1pbnRlcnZhbHMubHotaW50ZXJ2YWxfcmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbaW50ZXJ2YWxdLCAoZCkgPT4gYCR7ZFtkYXRhX2xheWVyLmxheW91dC5pZF9maWVsZF19X2ludGVydmFsX3JlY3RgKTtcblxuICAgICAgICAgICAgICAgICAgICByZWN0cy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscyBsei1pbnRlcnZhbF9yZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tZXJnZShyZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2Uud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZGF0YV9sYXllci5sYXlvdXQudHJhY2tfaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpICsgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBkYXRhX2xheWVyLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcihkYXRhX2xheWVyLmxheW91dC5jb2xvciwgZCwgaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgKGQsIGkpID0+IGRhdGFfbGF5ZXIucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKGRhdGFfbGF5ZXIubGF5b3V0LmZpbGxfb3BhY2l0eSwgZCwgaSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlY3RzLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciBpbnRlcnZhbCBjbGljayBhcmVhc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2FyZWFzID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgncmVjdC5sei1kYXRhX2xheWVyLWludGVydmFscy5sei1jbGlja2FyZWEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2ludGVydmFsXSwgKGQpID0+IGAke2QuaW50ZXJ2YWxfbmFtZX1fY2xpY2thcmVhYCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpY2thcmVhcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscyBsei1jbGlja2FyZWEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGNsaWNrYXJlYXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gYCR7ZGF0YV9sYXllci5nZXRFbGVtZW50SWQoZCl9X2NsaWNrYXJlYWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncngnLCBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeScsIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkgLSBkYXRhX2xheWVyLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgZGVmYXVsdCBldmVudCBlbWl0dGVycyB0byBjbGlja2FyZWFzXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgKGVsZW1lbnRfZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRfZGF0YS5wYXJlbnQucGFyZW50LmVtaXQoJ2VsZW1lbnRfY2xpY2tlZCcsIGVsZW1lbnRfZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgbW91c2UgYmVoYXZpb3JzIHRvIGNsaWNrYXJlYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGRhdGFfbGF5ZXIuYXBwbHlCZWhhdmlvcnMuYmluZChkYXRhX2xheWVyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBjbGlja2FyZWFzIGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBjbGlja2FyZWFzLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyAvLyBSZW1vdmUgb2xkIGVsZW1lbnRzIGFzIG5lZWRlZFxuICAgICAgICAgICAgc2VsZWN0aW9uLmV4aXQoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gLy8gVXBkYXRlIHRoZSBsZWdlbmQgYXhpcyBpZiB0aGUgbnVtYmVyIG9mIHRpY2tzIGNoYW5nZWRcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnByZXZpb3VzX3RyYWNrcyAhPT0gdGhpcy50cmFja3MpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnVwZGF0ZVNwbGl0VHJhY2tBeGlzKCk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIC8vIFRoZSBpbnRlcnZhbHMgdHJhY2sgYWxsb3dzIGxlZ2VuZHMgdG8gYmUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkLCBpbiB3aGljaCBjYXNlIHNwYWNlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAvLyAvLyAgYWxsb2NhdGVkIGFmdGVyIHRoZSBwYW5lbCBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWdlbmQucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dldFRvb2x0aXBQb3NpdGlvbih0b29sdGlwKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbF9iYm94ID0gZDMuc2VsZWN0KGAjJHt0aGlzLmdldEVsZW1lbnRTdGF0dXNOb2RlSWQodG9vbHRpcC5kYXRhKX1gKS5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4X21pbjogdG9vbHRpcC5kYXRhLmRpc3BsYXlfcmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgeF9tYXg6IHRvb2x0aXAuZGF0YS5kaXNwbGF5X3JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICB5X21pbjogaW50ZXJ2YWxfYmJveC55LFxuICAgICAgICAgICAgICAgIHlfbWF4OiBpbnRlcnZhbF9iYm94LnkgKyBpbnRlcnZhbF9iYm94LmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWRyYXcgc3BsaXQgdHJhY2sgYXhpcyBvciBoaWRlIGl0LCBhbmQgc2hvdy9oaWRlIHRoZSBsZWdlbmQsIGFzIGRldGVybWluZWRcbiAgICAgICAgLy8gYnkgY3VycmVudCBsYXlvdXQgcGFyYW1ldGVycyBhbmQgZGF0YVxuICAgICAgICB1cGRhdGVTcGxpdFRyYWNrQXhpcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZF9heGlzID0gdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfbGVnZW5kX3RvX3lfYXhpcyA/IGB5JHt0aGlzLmxheW91dC50cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzfWAgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja3MgPSArdGhpcy50cmFja3MgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja19oZWlnaHQgPSArdGhpcy5sYXlvdXQudHJhY2tfaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tfc3BhY2luZyA9IDIgKiAoK3RoaXMubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nIHx8IDApICsgKCt0aGlzLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nIHx8IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldF9oZWlnaHQgPSAodHJhY2tzICogdHJhY2tfaGVpZ2h0KSArICgodHJhY2tzIC0gMSkgKiB0cmFja19zcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY2FsZUhlaWdodFRvRGF0YSh0YXJnZXRfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kX2F4aXMgJiYgdGhpcy5wYXJlbnQubGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlZ2VuZC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dC5heGVzW2xlZ2VuZF9heGlzXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICh0YXJnZXRfaGVpZ2h0IC0gKHRoaXMubGF5b3V0LnRyYWNrX2hlaWdodCAvIDIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6ICh0aGlzLmxheW91dC50cmFja19oZWlnaHQgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgdmVyeSB0aWdodCBjb3VwbGluZyBiZXR3ZWVuIHRoZSBkaXNwbGF5IGRpcmVjdGl2ZXM6IGVhY2ggbGVnZW5kIGl0ZW0gbXVzdCBpZGVudGlmeSBhIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyAgZmllbGQgZm9yIHVuaXF1ZSB0cmFja3MuIChUeXBpY2FsbHkgdGhpcyBpcyBgc3RhdGVfaWRgLCB0aGUgc2FtZSBrZXkgZmllbGQgdXNlZCB0byBhc3NpZ24gdW5pcXVlIGNvbG9ycylcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxpc3Qgb2YgdW5pcXVlIGtleXMgY29ycmVzcG9uZHMgdG8gdGhlIG9yZGVyIGFsb25nIHRoZSB5LWF4aXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQubGVnZW5kLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGVsZW1lbnRbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy50cmFja19zcGxpdF9maWVsZF9pbmRleFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X29yZGVyID09PSAnREVTQycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sgPSBNYXRoLmFicyh0cmFjayAtIHRyYWNrcyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQuYXhlc1tsZWdlbmRfYXhpc10udGlja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBlbGVtZW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQueV9heGlzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpczogdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfbGVnZW5kX3RvX3lfYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb29yOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VpbGluZzogdHJhY2tzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kX2F4aXMgJiYgdGhpcy5wYXJlbnQubGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQuYWx3YXlzX2hpZGVfbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWdlbmQuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dC5heGVzW2xlZ2VuZF9heGlzXSA9IHsgcmVuZGVyOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ldGhvZCB0byBub3Qgb25seSB0b2dnbGUgdGhlIHNwbGl0IHRyYWNrcyBib29sZWFuIGJ1dCBhbHNvIHVwZGF0ZVxuICAgICAgICAvLyBuZWNlc3NhcnkgZGlzcGxheSB2YWx1ZXMgdG8gYW5pbWF0ZSBhIGNvbXBsZXRlIG1lcmdlL3NwbGl0XG4gICAgICAgIHRvZ2dsZVNwbGl0VHJhY2tzKCkge1xuXG5cbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcyA9ICF0aGlzLmxheW91dC5zcGxpdF90cmFja3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5sZWdlbmQgJiYgIXRoaXMubGF5b3V0LmFsd2F5c19oaWRlX2xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dC5tYXJnaW4uYm90dG9tID0gNSArICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MgPyAwIDogdGhpcy5wYXJlbnQubGVnZW5kLmxheW91dC5oZWlnaHQgKyA1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTsgICAgIFxuICAgICAgICAgICAgdGhpcy51cGRhdGVTcGxpdFRyYWNrQXhpcygpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQud2lkdGgsIHRoaXMucGFyZW50X3Bsb3QubGF5b3V0LmhlaWdodClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QubGF5b3V0Lm1pbl9oZWlnaHQgPSB0aGlzLnBhcmVudF9wbG90Ll9iYXNlX2xheW91dC5taW5faGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QubGF5b3V0Lm1pbl93aWR0aCA9IHRoaXMucGFyZW50X3Bsb3QuX2Jhc2VfbGF5b3V0Lm1pbl93aWR0aDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBhcmVudF9wbG90LmxheW91dCwgdGhpcy5wYXJlbnRfcGxvdC5fYmFzZV9sYXlvdXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLy8gQ2hvb3NlIGFuIGFwcHJvcHJpYXRlIGNvbG9yIHNjaGVtZSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0cmFjaywgYW5kIHdoZXRoZXIgb3Igbm90IHdlIGFyZVxuICAgICAgICAvLyAgdXNpbmcgZXhwbGljaXRseSBwcm92aWRlZCBpdGVtUmdiIGluZm9ybWF0aW9uXG4gICAgICAgIF9tYWtlQ29sb3JTY2hlbWUoY2F0ZWdvcnlfaW5mbykge1xuICAgICAgICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IGl0ZW1SZ2IsIGFzc3VtZSB0aGUgZW50aXJlIGRhdGFzZXQgaGFzIGNvbG9yc1xuICAgICAgICAgICAgY29uc3QgaGFzX2V4cGxpY2l0X2NvbG9ycyA9IGNhdGVnb3J5X2luZm8uZmluZCgoaXRlbSkgPT4gaXRlbVsyXSk7XG4gICAgICAgICAgICBpZiAoaGFzX2V4cGxpY2l0X2NvbG9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeV9pbmZvLm1hcCgoaXRlbSkgPT4gaXRlbVsyXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHNldCBvZiBjb2xvciBzY2hlbWVzIGZvciBjb21tb24gMTUsIDE4LCBvciAyNSBzdGF0ZSBtb2RlbHMsIGFzIHNwZWNpZmllZCBmcm9tOlxuICAgICAgICAgICAgLy8gIGh0dHBzOi8vZWdnMi53dXN0bC5lZHUvcm9hZG1hcC93ZWJfcG9ydGFsL2Nocl9zdGF0ZV9sZWFybmluZy5odG1sXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgYWN0dWFsbHkgcmV2ZXJzZWQgc28gdGhhdCBkaW0gY29sb3JzIGNvbWUgZmlyc3QsIG9uIHRoZSBwcmVtaXNlIHRoYXQgdXN1YWxseSB0aGVzZSBhcmUgdGhlXG4gICAgICAgICAgICAvLyAgbW9zdCBjb21tb24gc3RhdGVzXG4gICAgICAgICAgICBjb25zdCBuX2NhdGVnb3JpZXMgPSBjYXRlZ29yeV9pbmZvLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuX2NhdGVnb3JpZXMgPD0gMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydyZ2IoMjEyLDIxMiwyMTIpJywgJ3JnYigxOTIsMTkyLDE5MiknLCAncmdiKDEyOCwxMjgsMTI4KScsICdyZ2IoMTg5LDE4MywxMDcpJywgJ3JnYigyMzMsMTUwLDEyMiknLCAncmdiKDIwNSw5Miw5MiknLCAncmdiKDEzOCwxNDUsMjA4KScsICdyZ2IoMTAyLDIwNSwxNzApJywgJ3JnYigyNTUsMjU1LDApJywgJ3JnYigxOTQsMjI1LDUpJywgJ3JnYigwLDEwMCwwKScsICdyZ2IoMCwxMjgsMCknLCAncmdiKDUwLDIwNSw1MCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDAsMCknXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobl9jYXRlZ29yaWVzIDw9IDE4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsncmdiKDIxMiwyMTIsMjEyKScsICdyZ2IoMTkyLDE5MiwxOTIpJywgJ3JnYigxMjgsMTI4LDEyOCknLCAncmdiKDE4OSwxODMsMTA3KScsICdyZ2IoMjA1LDkyLDkyKScsICdyZ2IoMTM4LDE0NSwyMDgpJywgJ3JnYigxMDIsMjA1LDE3MCknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwxOTUsNzcpJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMCwxMDAsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsMCwwKSddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDI1IGNhdGVnb3JpZXMsIHRoZSBpbnRlcnZhbCBsYXllciB3aWxsIGZhbGwgYmFjayB0byB0aGUgJ251bGwgdmFsdWUnIG9wdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBbJ3JnYigyMTIsMjEyLDIxMiknLCAncmdiKDEyOCwxMjgsMTI4KScsICdyZ2IoMTEyLDQ4LDE2MCknLCAncmdiKDIzMCwxODQsMTgzKScsICdyZ2IoMTM4LDE0NSwyMDgpJywgJ3JnYigxMDIsMjA1LDE3MCknLCAncmdiKDI1NSwyNTUsMTAyKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMjU1LDE5NSw3NyknLCAncmdiKDI1NSwxOTUsNzcpJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMCwxNTAsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYigwLDEyOCwwKScsICdyZ2IoMCwxMjgsMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSwwLDApJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBhbGwgb2YgdGhlIHVuaXF1ZSB0cmFja3MgKGEgY29tYmluYXRpb24gb2YgbmFtZSBhbmQgSUQgaW5mb3JtYXRpb24pXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmdiX2ZpZWxkXSBBIGZpZWxkIHRoYXQgY29udGFpbnMgYW4gUkdCIHZhbHVlLiBBaW1lZCBhdCBCRUQgZmlsZXMgd2l0aCBhbiBpdGVtUmdiIGNvbHVtblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFsbCBbdW5pcXVlX2lkLCBsYWJlbCwgY29sb3JdIHBhaXJzIGluIGRhdGEuIFRoZSB1bmlxdWVfaWQgaXMgdGhlIHRoaW5nIHVzZWQgdG8gZGVmaW5lIGdyb3VwaW5nc1xuICAgICAgICAgKiAgbW9zdCB1bmFtYmlndW91c2x5LlxuICAgICAgICAgKi9cbiAgICAgICAgX2dlbmVyYXRlQ2F0ZWdvcmllc0Zyb21EYXRhKGRhdGEsIHJnYl9maWVsZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGhhcmQtY29kZWQgbGVnZW5kIGlmIGF2YWlsYWJsZSAoaWdub3JpbmcgYW55IG1vZHMgb24gcmUtcmVuZGVyKVxuICAgICAgICAgICAgY29uc3QgbGVnZW5kID0gdGhpcy5fYmFzZV9sYXlvdXQubGVnZW5kO1xuICAgICAgICAgICAgaWYgKGxlZ2VuZCAmJiBsZWdlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZ2VuZC5tYXAoKGl0ZW0pID0+IFtpdGVtW3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXSwgaXRlbS5sYWJlbCwgaXRlbS5jb2xvcl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBvcHRpb25zIGZyb20gZGF0YSwgaWYgbm8gcHJlc2V0IGxlZ2VuZCBleGlzdHNcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZV9pZHMgPSB7fTsgLy8gbWFrZSBjYXRlZ29yaWVzIHVuaXF1ZVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFtdO1xuXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGl0ZW1bc2VsZi5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdO1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVuaXF1ZV9pZHMsIGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVfaWRzW2lkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHJnYmZpZWxkIGlzIG51bGwsIHRoZW4gdGhlIGxhc3QgZW50cnkgaXMgdW5kZWZpbmVkL251bGwgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goW2lkLCBpdGVtW3RoaXMubGF5b3V0LnRyYWNrX2xhYmVsX2ZpZWxkXSwgaXRlbVtyZ2JfZmllbGRdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2F0ZWdvcmllcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludGVydmFsc190b29sdGlwX2xheW91dCA9IHtcbiAgICAgICAgbmFtZXNwYWNlOiB7ICdpbnRlcnZhbHMnOiAnaW50ZXJ2YWxzJyB9LFxuICAgICAgICBjbG9zYWJsZTogZmFsc2UsXG4gICAgICAgIHNob3c6IHsgb3I6IFsnaGlnaGxpZ2h0ZWQnLCAnc2VsZWN0ZWQnXSB9LFxuICAgICAgICBoaWRlOiB7IGFuZDogWyd1bmhpZ2hsaWdodGVkJywgJ3Vuc2VsZWN0ZWQnXSB9LFxuICAgICAgICBodG1sOiAne3t7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9uYW1lfGh0bWxlc2NhcGV9fTxicj57e3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXJ0fGh0bWxlc2NhcGV9fS17e3t7bmFtZXNwYWNlW2ludGVydmFsc119fWVuZHxodG1sZXNjYXBlfX0nLFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfbGF5ZXJfbGF5b3V0ID0gIHtcbiAgICAgICAgbmFtZXNwYWNlOiB7ICdpbnRlcnZhbHMnOiAnaW50ZXJ2YWxzJyB9LFxuICAgICAgICBpZDogJ2ludGVydmFscycsXG4gICAgICAgIHR5cGU6ICdpbnRlcnZhbHMnLFxuICAgICAgICBmaWVsZHM6IFsne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhcnQnLCAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19ZW5kJywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX2lkJywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLCAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19aXRlbVJnYiddLFxuICAgICAgICBpZF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXJ0JyxcbiAgICAgICAgc3RhcnRfZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGFydCcsXG4gICAgICAgIGVuZF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWVuZCcsXG4gICAgICAgIHRyYWNrX3NwbGl0X2ZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhdGVfbmFtZScsXG4gICAgICAgIHRyYWNrX2xhYmVsX2ZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhdGVfbmFtZScsXG4gICAgICAgIHNwbGl0X3RyYWNrczogZmFsc2UsXG4gICAgICAgIGFsd2F5c19oaWRlX2xlZ2VuZDogdHJ1ZSxcbiAgICAgICAgY29sb3I6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwcmVzZW50LCBhbiBleHBsaWNpdCBjb2xvciBmaWVsZCB3aWxsIG92ZXJyaWRlIGFueSBvdGhlciBvcHRpb24gKGFuZCBiZSB1c2VkIHRvIGF1dG8tZ2VuZXJhdGUgbGVnZW5kKVxuICAgICAgICAgICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19aXRlbVJnYicsXG4gICAgICAgICAgICAgICAgc2NhbGVfZnVuY3Rpb246ICd0b19yZ2InLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnY2F0ZWdvcmljYWxfYmluJyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyLiBFbXB0eSBjYXRlZ29yaWVzIGFuZCB2YWx1ZXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGZpbGxlZCBpbiB3aGVuIG5ldyBkYXRhIGxvYWRzLlxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbF92YWx1ZTogJyNCOEI4QjgnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBsZWdlbmQ6IFtdLCAvLyBQbGFjZWhvbGRlcjsgYXV0by1maWxsZWQgd2hlbiBkYXRhIGxvYWRzLlxuICAgICAgICBiZWhhdmlvcnM6IHtcbiAgICAgICAgICAgIG9ubW91c2VvdmVyOiBbXG4gICAgICAgICAgICAgICAgeyBhY3Rpb246ICdzZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbm1vdXNlb3V0OiBbXG4gICAgICAgICAgICAgICAgeyBhY3Rpb246ICd1bnNldCcsIHN0YXR1czogJ2hpZ2hsaWdodGVkJyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uY2xpY2s6IFtcbiAgICAgICAgICAgICAgICB7IGFjdGlvbjogJ3RvZ2dsZScsIHN0YXR1czogJ3NlbGVjdGVkJywgZXhjbHVzaXZlOiB0cnVlIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25zaGlmdGNsaWNrOiBbXG4gICAgICAgICAgICAgICAgeyBhY3Rpb246ICd0b2dnbGUnLCBzdGF0dXM6ICdzZWxlY3RlZCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IGludGVydmFsc190b29sdGlwX2xheW91dCxcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJ2YWxzX3BhbmVsX2xheW91dCA9IHtcbiAgICAgICAgaWQ6ICdpbnRlcnZhbHMnLFxuICAgICAgICB3aWR0aDogMTAwMCxcbiAgICAgICAgaGVpZ2h0OiA1MCxcbiAgICAgICAgbWluX3dpZHRoOiA1MDAsXG4gICAgICAgIG1pbl9oZWlnaHQ6IDUwLFxuICAgICAgICBtYXJnaW46IHsgdG9wOiAyNSwgcmlnaHQ6IDE1MCwgYm90dG9tOiA1LCBsZWZ0OiA1MCB9LFxuICAgICAgICB0b29sYmFyOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbGJhcicsICdzdGFuZGFyZF9wYW5lbCcsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pO1xuICAgICAgICAgICAgbC53aWRnZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b2dnbGVfc3BsaXRfdHJhY2tzJyxcbiAgICAgICAgICAgICAgICBkYXRhX2xheWVyX2lkOiAnaW50ZXJ2YWxzJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0pKCksXG4gICAgICAgIGF4ZXM6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgZHJhZ19iYWNrZ3JvdW5kX3RvX3BhbjogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbF90b196b29tOiB0cnVlLFxuICAgICAgICAgICAgeF9saW5rZWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9yaWdpbjogeyB4OiA1MCwgeTogMCB9LFxuICAgICAgICAgICAgcGFkX2Zyb21fYm90dG9tOiA1LFxuICAgICAgICB9LFxuICAgICAgICBkYXRhX2xheWVyczogW2ludGVydmFsc19sYXllcl9sYXlvdXRdLFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfcGxvdF9sYXlvdXQgPSB7XG4gICAgICAgIHN0YXRlOiB7fSxcbiAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgaGVpZ2h0OiA1NTAsXG4gICAgICAgIHJlc3BvbnNpdmVfcmVzaXplOiB0cnVlLFxuICAgICAgICBtaW5fcmVnaW9uX3NjYWxlOiAyMDAwMCxcbiAgICAgICAgbWF4X3JlZ2lvbl9zY2FsZTogMTAwMDAwMCxcbiAgICAgICAgdG9vbGJhcjogTG9jdXNab29tLkxheW91dHMuZ2V0KCd0b29sYmFyJywgJ3N0YW5kYXJkX2Fzc29jaWF0aW9uJywgeyB1bm5hbWVzcGFjZWQ6IHRydWUgfSksXG4gICAgICAgIHBhbmVsczogW1xuICAgICAgICAgICAgTG9jdXNab29tLkxheW91dHMuZ2V0KCdwYW5lbCcsICdhc3NvY2lhdGlvbicsIHtcbiAgICAgICAgICAgICAgICB1bm5hbWVzcGFjZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgICAgICAgICBwcm9wb3J0aW9uYWxfaGVpZ2h0OiAoMjI1IC8gNTcwKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICB7IHVubmFtZXNwYWNlZDogdHJ1ZSwgcHJvcG9ydGlvbmFsX2hlaWdodDogKDEyMCAvIDU3MCkgfSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbHNfcGFuZWxfbGF5b3V0XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgTG9jdXNab29tLkxheW91dHMuZ2V0KCdwYW5lbCcsICdnZW5lcycsIHsgdW5uYW1lc3BhY2VkOiB0cnVlLCB3aWR0aDogODAwLCBwcm9wb3J0aW9uYWxfaGVpZ2h0OiAoMjI1IC8gNTcwKSB9KSxcbiAgICAgICAgXSxcbiAgICB9O1xuXG4gICAgTG9jdXNab29tLkFkYXB0ZXJzLmFkZCgnSW50ZXJ2YWxMWicsIEludGVydmFsTFopO1xuICAgIExvY3VzWm9vbS5EYXRhTGF5ZXJzLmFkZCgnaW50ZXJ2YWxzJywgTHpJbnRlcnZhbHNUcmFjayk7XG5cbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ3Rvb2x0aXAnLCAnc3RhbmRhcmRfaW50ZXJ2YWxzJywgaW50ZXJ2YWxzX3Rvb2x0aXBfbGF5b3V0KTtcbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ2RhdGFfbGF5ZXInLCAnaW50ZXJ2YWxzJywgaW50ZXJ2YWxzX2xheWVyX2xheW91dCk7XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdwYW5lbCcsICdpbnRlcnZhbHMnLCBpbnRlcnZhbHNfcGFuZWxfbGF5b3V0KTtcbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ3Bsb3QnLCAnaW50ZXJ2YWxfYXNzb2NpYXRpb24nLCBpbnRlcnZhbHNfcGxvdF9sYXlvdXQpO1xuXG4gICAgTG9jdXNab29tLlNjYWxlRnVuY3Rpb25zLmFkZCgndG9fcmdiJywgdG9fcmdiKTtcblxuICAgIExvY3VzWm9vbS5XaWRnZXRzLmFkZCgndG9nZ2xlX3NwbGl0X3RyYWNrcycsIFRvZ2dsZVNwbGl0VHJhY2tzKTtcbn1cblxuaWYgKHR5cGVvZiBMb2N1c1pvb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXV0by1yZWdpc3RlciB0aGUgcGx1Z2luIHdoZW4gaW5jbHVkZWQgYXMgYSBzY3JpcHQgdGFnLiBFUzYgbW9kdWxlIHVzZXJzIG11c3QgcmVnaXN0ZXIgdmlhIExvY3VzWm9vbS51c2UoKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIExvY3VzWm9vbS51c2UoaW5zdGFsbCk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFsbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZDM7Il0sInNvdXJjZVJvb3QiOiIifQ==