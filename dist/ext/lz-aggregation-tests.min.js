/*! Locuszoom 0.13.0-beta.2 */
var LzAggregationTests =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-aggregation-tests.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/data/adapters.js":
/*!******************************!*\
  !*** ./esm/data/adapters.js ***!
  \******************************/
/*! exports provided: BaseAdapter, BaseApiAdapter, AssociationLZ, ConnectorSource, GeneConstraintLZ, GeneLZ, GwasCatalogLZ, LDServer, PheWASLZ, RecombLZ, StaticSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseAdapter", function() { return BaseAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseApiAdapter", function() { return BaseApiAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssociationLZ", function() { return AssociationLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectorSource", function() { return ConnectorSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneConstraintLZ", function() { return GeneConstraintLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneLZ", function() { return GeneLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GwasCatalogLZ", function() { return GwasCatalogLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDServer", function() { return LDServer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PheWASLZ", function() { return PheWASLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RecombLZ", function() { return RecombLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticSource", function() { return StaticSource; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Define standard data adapters used to retrieve data (usually from REST APIs)
 * @module
 */
function validateBuildSource(class_name, build, source) {
  // Build OR Source, not both
  if (build && source || !(build || source)) {
    throw new Error("".concat(class_name, " must provide a parameter specifying either \"build\" or \"source\". It should not specify both."));
  } // If the build isn't recognized, our APIs can't transparently select a source to match


  if (build && !['GRCh37', 'GRCh38'].includes(build)) {
    throw new Error("".concat(class_name, " must specify a valid genome build number"));
  }
}
/**
 * Base class for LocusZoom data sources (any). See also: BaseApiAdapter
 * @public
 */


var BaseAdapter = /*#__PURE__*/function () {
  function BaseAdapter(config) {
    _classCallCheck(this, BaseAdapter);

    /**
     * Whether this source should enable caching
     * @member {Boolean}
     */
    this._enableCache = true;
    this._cachedKey = null;
    /**
     * Whether this data source type is dependent on previous requests- for example, the LD source cannot annotate
     *  association data if no data was found for that region.
     * @member {boolean}
     */

    this.__dependentSource = false; // Parse configuration options

    this.parseInit(config);
  }
  /**
   * Parse configuration used to create the data source. Many custom sources will override this method to suit their
   *  needs (eg specific config options, or for sources that do not retrieve data from a URL)
   * @protected
   * @param {String|Object} config Basic configuration- either a url, or a config object
   * @param {String} [config.url] The datasource URL
   * @param {String} [config.params] Initial config params for the datasource
   */


  _createClass(BaseAdapter, [{
    key: "parseInit",
    value: function parseInit(config) {
      /** @member {Object} */
      this.params = config.params || {};
    }
    /**
     * A unique identifier that indicates whether cached data is valid for this request. For most sources using GET
     *  requests to a REST API, this is usually the URL.
     * @protected
     * @param {Object} state Information available in plot.state (chr, start, end). Sometimes used to inject globally
     *  available information that influences the request being made.
     * @param {Object} chain The data chain from previous requests made in a sequence.
     * @param fields
     * @returns {String|undefined}
     */

  }, {
    key: "getCacheKey",
    value: function getCacheKey(state, chain, fields) {
      return this.getURL(state, chain, fields);
    }
    /**
     * Stub: build the URL for any requests made by this source.
     * @protected
     */

  }, {
    key: "getURL",
    value: function getURL(state, chain, fields) {
      return this.url;
    }
    /**
     * Perform a network request to fetch data for this source. This is usually the method that is used to override
     *  when defining how to retrieve data.
     * @protected
     * @param {Object} state The state of the parent plot
     * @param chain
     * @param fields
     * @returns {Promise}
     */

  }, {
    key: "fetchRequest",
    value: function fetchRequest(state, chain, fields) {
      var url = this.getURL(state, chain, fields);
      return fetch(url).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return response.text();
      });
    }
    /**
     * Gets the data for just this source, typically via a network request (but using cache where possible)
     *
     * For most use cases, it is better to override `fetchRequest` instead, to avoid bypassing the cache mechanism
     * by accident.
     * @protected
     */

  }, {
    key: "getRequest",
    value: function getRequest(state, chain, fields) {
      var req;
      var cacheKey = this.getCacheKey(state, chain, fields);

      if (this._enableCache && typeof cacheKey !== 'undefined' && cacheKey === this._cachedKey) {
        req = Promise.resolve(this._cachedResponse); // Resolve to the value of the current promise
      } else {
        req = this.fetchRequest(state, chain, fields);

        if (this._enableCache) {
          this._cachedKey = cacheKey;
          this._cachedResponse = req;
        }
      }

      return req;
    }
    /**
     * Ensure the server response is in a canonical form, an array of one object per record. [ {field: oneval} ].
     * If the server response contains columns, reformats the response from {column1: [], column2: []} to the above.
     *
     * Does not apply namespacing, transformations, or field extraction.
     *
     * May be overridden by data sources that inherently return more complex payloads, or that exist to annotate other
     *  sources (eg, if the payload provides extra data rather than a series of records).
     * @protected
     * @param {Object[]|Object} data The original parsed server response
     */

  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      if (Array.isArray(data)) {
        // Already in the desired form
        return data;
      } // Otherwise, assume the server response is an object representing columns of data.
      // Each array should have the same length (verify), and a given array index corresponds to a single row.


      var keys = Object.keys(data);
      var N = data[keys[0]].length;
      var sameLength = keys.every(function (key) {
        var item = data[key];
        return item.length === N;
      });

      if (!sameLength) {
        throw new Error("".concat(this.constructor.name, " expects a response in which all arrays of data are the same length"));
      } // Go down the rows, and create an object for each record


      var records = [];
      var fields = Object.keys(data);

      for (var i = 0; i < N; i++) {
        var record = {};

        for (var j = 0; j < fields.length; j++) {
          record[fields[j]] = data[fields[j]][i];
        }

        records.push(record);
      }

      return records;
    }
    /**
     * Hook to post-process the data returned by this source with new, additional behavior.
     *   (eg cleaning up API values or performing complex calculations on the returned data)
     *
     * @protected
     * @param {Object[]} records The parsed data from the source (eg standardized api response)
     * @param {Object} chain The data chain object. For example, chain.headers may provide useful annotation metadata
     * @returns {Object[]|Promise} The modified set of records
     */

  }, {
    key: "annotateData",
    value: function annotateData(records, chain) {
      // Default behavior: no transformations
      return records;
    }
    /**
     * Clean up the server records for use by datalayers: extract only certain fields, with the specified names.
     *   Apply per-field transformations as appropriate.
     *
     * This hook can be overridden, eg to create a source that always returns all records and ignores the "fields" array.
     *  This is particularly common for sources at the end of a chain- many "dependent" sources do not allow
     *  cherry-picking individual fields, in which case by **convention** the fields array specifies "last_source_name:all"
     *
     * @protected
     * @param {Object[]} data One record object per element
     * @param {String[]} fields The names of fields to extract (as named in the source data). Eg "afield"
     * @param {String[]} outnames How to represent the source fields in the output. Eg "namespace:afield|atransform"
     * @param {function[]} trans An array of transformation functions (if any). One function per data element, or null.
     * @protected
     */

  }, {
    key: "extractFields",
    value: function extractFields(data, fields, outnames, trans) {
      //intended for an array of objects
      //  [ {"id":1, "val":5}, {"id":2, "val":10}]
      // Since a number of sources exist that do not obey this format, we will provide a convenient pass-through
      if (!Array.isArray(data)) {
        return data;
      }

      if (!data.length) {
        // Sometimes there are regions that just don't have data- this should not trigger a missing field error message!
        return data;
      }

      var fieldFound = [];

      for (var k = 0; k < fields.length; k++) {
        fieldFound[k] = 0;
      }

      var records = data.map(function (item) {
        var output_record = {};

        for (var j = 0; j < fields.length; j++) {
          var val = item[fields[j]];

          if (typeof val != 'undefined') {
            fieldFound[j] = 1;
          }

          if (trans && trans[j]) {
            val = trans[j](val);
          }

          output_record[outnames[j]] = val;
        }

        return output_record;
      });
      fieldFound.forEach(function (v, i) {
        if (!v) {
          throw new Error("field ".concat(fields[i], " not found in response for ").concat(outnames[i]));
        }
      });
      return records;
    }
    /**
     * Combine records from this source with others in the chain to yield final chain body.
     *   Handles merging this data with other sources (if applicable).
     *
     * @protected
     * @param {Object[]} data The data That would be returned from this source alone
     * @param {Object} chain The data chain built up during previous requests
     * @param {String[]} fields
     * @param {String[]} outnames
     * @param {String[]} trans
     * @return {Promise|Object[]} The new chain body
     */

  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      return data;
    }
    /**
     * Coordinates the work of parsing a response and returning records. This is broken into 4 steps, which may be
     *  overridden separately for fine-grained control. Each step can return either raw data or a promise.
     *
     * @protected
     *
     * @param {String|Object} resp The raw data associated with the response
     * @param {Object} chain The combined parsed response data from this and all other requests made in the chain
     * @param {String[]} fields Array of requested field names (as they would appear in the response payload)
     * @param {String[]} outnames  Array of field names as they will be represented in the data returned by this source,
     *  including the namespace. This must be an array with the same length as `fields`
     * @param {Function[]} trans The collection of transformation functions to be run on selected fields.
     *     This must be an array with the same length as `fields`
     * @returns {Promise} A promise that resolves to an object containing
     *   request metadata (`headers: {}`), the consolidated data for plotting (`body: []`), and the individual responses that would be
     *   returned by each source in the chain in isolation (`discrete: {}`)
     */

  }, {
    key: "parseResponse",
    value: function parseResponse(resp, chain, fields, outnames, trans) {
      var _this = this;

      var source_id = this.source_id || this.constructor.name;

      if (!chain.discrete) {
        chain.discrete = {};
      }

      var json = typeof resp == 'string' ? JSON.parse(resp) : resp; // Perform the 4 steps of parsing the payload and return a combined chain object

      return Promise.resolve(this.normalizeResponse(json.data || json)).then(function (standardized) {
        // Perform calculations on the data from just this source
        return Promise.resolve(_this.annotateData(standardized, chain));
      }).then(function (data) {
        return Promise.resolve(_this.extractFields(data, fields, outnames, trans));
      }).then(function (one_source_body) {
        // Store a copy of the data that would be returned by parsing this source in isolation (and taking the
        //   fields array into account). This is useful when we want to re-use the source output in many ways.
        chain.discrete[source_id] = one_source_body;
        return Promise.resolve(_this.combineChainBody(one_source_body, chain, fields, outnames, trans));
      }).then(function (new_body) {
        return {
          header: chain.header || {},
          discrete: chain.discrete,
          body: new_body
        };
      });
    }
    /**
     * Fetch the data from the specified data source, and apply transformations requested by an external consumer.
     * This is the public-facing datasource method that will most be called by the plot, but custom data sources will
     *  almost never want to override this method directly- more specific hooks are provided to control individual pieces
     *  of the request lifecycle.
     *
     * @private
     * @param {Object} state The current "state" of the plot, such as chromosome and start/end positions
     * @param {String[]} fields Array of field names that the plot has requested from this data source. (without the "namespace" prefix)
     * @param {String[]} outnames  Array describing how the output data should refer to this field. This represents the
     *     originally requested field name, including the namespace. This must be an array with the same length as `fields`
     * @param {Function[]} trans The collection of transformation functions to be run on selected fields.
     *     This must be an array with the same length as `fields`
     * @returns {function} A callable operation that can be used as part of the data chain
     */

  }, {
    key: "getData",
    value: function getData(state, fields, outnames, trans) {
      var _this2 = this;

      if (this.preGetData) {
        // TODO try to remove this method if at all possible
        var pre = this.preGetData(state, fields, outnames, trans);

        if (this.pre) {
          state = pre.state || state;
          fields = pre.fields || fields;
          outnames = pre.outnames || outnames;
          trans = pre.trans || trans;
        }
      }

      return function (chain) {
        if (_this2.__dependentSource && chain && chain.body && !chain.body.length) {
          // A "dependent" source should not attempt to fire a request if there is no data for it to act on.
          // Therefore, it should simply return the previous data chain.
          return Promise.resolve(chain);
        }

        return _this2.getRequest(state, chain, fields).then(function (resp) {
          return _this2.parseResponse(resp, chain, fields, outnames, trans);
        });
      };
    }
  }]);

  return BaseAdapter;
}();
/**
 * Base source for LocusZoom data sources that receive their data over the web. Adds default config parameters
 *  (and potentially other behavior) that are relevant to URL-based requests.
 */


var BaseApiAdapter = /*#__PURE__*/function (_BaseAdapter) {
  _inherits(BaseApiAdapter, _BaseAdapter);

  var _super = _createSuper(BaseApiAdapter);

  function BaseApiAdapter() {
    _classCallCheck(this, BaseApiAdapter);

    return _super.apply(this, arguments);
  }

  _createClass(BaseApiAdapter, [{
    key: "parseInit",
    value: function parseInit(config) {
      _get(_getPrototypeOf(BaseApiAdapter.prototype), "parseInit", this).call(this, config);
      /** @member {String} */


      this.url = config.url;

      if (!this.url) {
        throw new Error('Source not initialized with required URL');
      }
    }
  }]);

  return BaseApiAdapter;
}(BaseAdapter);
/**
 * Data Source for Association Data from the LocusZoom/ Portaldev API (or compatible). Defines how to make a requesr
 * @public
 */


var AssociationLZ = /*#__PURE__*/function (_BaseApiAdapter) {
  _inherits(AssociationLZ, _BaseApiAdapter);

  var _super2 = _createSuper(AssociationLZ);

  function AssociationLZ() {
    _classCallCheck(this, AssociationLZ);

    return _super2.apply(this, arguments);
  }

  _createClass(AssociationLZ, [{
    key: "preGetData",
    value: function preGetData(state, fields, outnames, trans) {
      // TODO: Modify internals to see if we can go without this method
      var id_field = this.params.id_field || 'id';
      [id_field, 'position'].forEach(function (x) {
        if (!fields.includes(x)) {
          fields.unshift(x);
          outnames.unshift(x);
          trans.unshift(null);
        }
      });
      return {
        fields: fields,
        outnames: outnames,
        trans: trans
      };
    }
  }, {
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var analysis = chain.header.analysis || this.params.source || this.params.analysis; // Old usages called this param "analysis"

      if (typeof analysis == 'undefined') {
        throw new Error('Association source must specify an analysis ID to plot');
      }

      return "".concat(this.url, "results/?filter=analysis in ").concat(analysis, " and chromosome in  '").concat(state.chr, "' and position ge ").concat(state.start, " and position le ").concat(state.end);
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      // Some association sources do not sort their data in a predictable order, which makes it hard to reliably
      //  align with other sources (such as LD). For performance reasons, sorting is an opt-in argument.
      // TODO: Consider more fine grained sorting control in the future. This was added as a very specific
      //   workaround for the original T2D portal.
      data = _get(_getPrototypeOf(AssociationLZ.prototype), "normalizeResponse", this).call(this, data);

      if (this.params && this.params.sort && data.length && data[0]['position']) {
        data.sort(function (a, b) {
          return a['position'] - b['position'];
        });
      }

      return data;
    }
  }]);

  return AssociationLZ;
}(BaseApiAdapter);
/**
 * Fetch linkage disequilibrium information from a UMich LDServer-compatible API
 *
 * This source is designed to connect its results to association data, and therefore depends on association data having
 *  been loaded by a previous request in the data chain.
 *
 * In older versions of LocusZoom, this was known as "LDServer". A prior source (targeted at older APIs) has been removed.
 */


var LDServer = /*#__PURE__*/function (_BaseApiAdapter2) {
  _inherits(LDServer, _BaseApiAdapter2);

  var _super3 = _createSuper(LDServer);

  function LDServer(config) {
    var _this3;

    _classCallCheck(this, LDServer);

    _this3 = _super3.call(this, config);
    _this3.__dependentSource = true;
    return _this3;
  }

  _createClass(LDServer, [{
    key: "preGetData",
    value: function preGetData(state, fields) {
      if (fields.length > 1) {
        if (fields.length !== 2 || !fields.includes('isrefvar')) {
          throw new Error("LD does not know how to get all fields: ".concat(fields.join(', ')));
        }
      }
    }
  }, {
    key: "findMergeFields",
    value: function findMergeFields(chain) {
      // Find the fields (as provided by a previous step in the chain, like an association source) that will be needed to
      //  combine LD data with existing information
      // Since LD information may be shared across multiple assoc sources with different namespaces,
      //   we use regex to find columns to join on, rather than requiring exact matches
      var exactMatch = function exactMatch(arr) {
        return function () {
          var regexes = arguments;

          var _loop = function _loop(i) {
            var regex = regexes[i];
            var m = arr.filter(function (x) {
              return x.match(regex);
            });

            if (m.length) {
              return {
                v: m[0]
              };
            }
          };

          for (var i = 0; i < regexes.length; i++) {
            var _ret = _loop(i);

            if (_typeof(_ret) === "object") return _ret.v;
          }

          return null;
        };
      };

      var dataFields = {
        id: this.params.id_field,
        position: this.params.position_field,
        pvalue: this.params.pvalue_field,
        _names_: null
      };

      if (chain && chain.body && chain.body.length > 0) {
        var names = Object.keys(chain.body[0]);
        var nameMatch = exactMatch(names); // Internally, fields are generally prefixed with the name of the source they come from.
        // If the user provides an id_field (like `variant`), it should work across data sources( `assoc1:variant`,
        //  assoc2:variant), but not match fragments of other field names (assoc1:variant_thing)
        // Note: these lookups hard-code a couple of common fields that will work based on known APIs in the wild

        var id_match = dataFields.id && nameMatch(new RegExp("".concat(dataFields.id, "\\b")));
        dataFields.id = id_match || nameMatch(/\bvariant\b/) || nameMatch(/\bid\b/);
        dataFields.position = dataFields.position || nameMatch(/\bposition\b/i, /\bpos\b/i);
        dataFields.pvalue = dataFields.pvalue || nameMatch(/\bpvalue\b/i, /\blog_pvalue\b/i);
        dataFields._names_ = names;
      }

      return dataFields;
    }
  }, {
    key: "findRequestedFields",
    value: function findRequestedFields(fields, outnames) {
      // Assumption: all usages of this source will only ever ask for "isrefvar" or "state". This maps to output names.
      var obj = {};

      for (var i = 0; i < fields.length; i++) {
        if (fields[i] === 'isrefvar') {
          obj.isrefvarin = fields[i];
          obj.isrefvarout = outnames && outnames[i];
        } else {
          obj.ldin = fields[i];
          obj.ldout = outnames && outnames[i];
        }
      }

      return obj;
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      // The LD API payload does not obey standard format conventions; do not try to transform it.
      return data;
    }
    /**
     * Get the LD reference variant, which by default will be the most significant hit in the assoc results
     *   This will be used in making the original query to the LD server for pairwise LD information
     * @returns {*|string} The marker id (expected to be in `chr:pos_ref/alt` format) of the reference variant
     */

  }, {
    key: "getRefvar",
    value: function getRefvar(state, chain, fields) {
      var findExtremeValue = function findExtremeValue(records, pval_field) {
        // Finds the most significant hit (smallest pvalue, or largest -log10p). Will try to auto-detect the appropriate comparison.
        pval_field = pval_field || 'log_pvalue'; // The official LZ API returns log_pvalue

        var is_log = /log/.test(pval_field);
        var cmp;

        if (is_log) {
          cmp = function cmp(a, b) {
            return a > b;
          };
        } else {
          cmp = function cmp(a, b) {
            return a < b;
          };
        }

        var extremeVal = records[0][pval_field],
            extremeIdx = 0;

        for (var i = 1; i < records.length; i++) {
          if (cmp(records[i][pval_field], extremeVal)) {
            extremeVal = records[i][pval_field];
            extremeIdx = i;
          }
        }

        return extremeIdx;
      };

      var reqFields = this.findRequestedFields(fields);
      var refVar = reqFields.ldin;

      if (refVar === 'state') {
        refVar = state.ldrefvar || chain.header.ldrefvar || 'best';
      }

      if (refVar === 'best') {
        if (!chain.body) {
          throw new Error('No association data found to find best pvalue');
        }

        var keys = this.findMergeFields(chain);

        if (!keys.pvalue || !keys.id) {
          var columns = '';

          if (!keys.id) {
            columns += "".concat(columns.length ? ', ' : '', "id");
          }

          if (!keys.pvalue) {
            columns += "".concat(columns.length ? ', ' : '', "pvalue");
          }

          throw new Error("Unable to find necessary column(s) for merge: ".concat(columns, " (available: ").concat(keys._names_, ")"));
        }

        refVar = chain.body[findExtremeValue(chain.body, keys.pvalue)][keys.id];
      }

      return refVar;
    }
  }, {
    key: "getURL",
    value: function getURL(state, chain, fields) {
      // Accept the following params in this.params:
      // - method (r, rsquare, cov)
      // - source (aka panel)
      // - population (ALL, AFR, EUR, etc)
      // - build
      // The LD source/pop can be overridden from plot.state for dynamic layouts
      var build = state.genome_build || this.params.build || 'GRCh37';
      var source = state.ld_source || this.params.source || '1000G';
      var population = state.ld_pop || this.params.population || 'ALL'; // LDServer panels will always have an ALL

      var method = this.params.method || 'rsquare';

      if (source === '1000G' && build === 'GRCh38') {
        // For build 38 (only), there is a newer/improved 1000G LD panel available that uses WGS data. Auto upgrade by default.
        source = '1000G-FRZ09';
      }

      validateBuildSource(this.constructor.name, build, null); // LD doesn't need to validate `source` option

      var refVar = this.getRefvar(state, chain, fields); // Some datasets, notably the Portal, use a different marker format.
      //  Coerce it into one that will work with the LDServer API. (CHROM:POS_REF/ALT)

      var REGEX_MARKER = /^(?:chr)?([a-zA-Z0-9]+?)[_:-](\d+)[_:|-]?(\w+)?[/_:|-]?([^_]+)?_?(.*)?/;
      var match = refVar && refVar.match(REGEX_MARKER);

      if (!match) {
        throw new Error('Could not request LD for a missing or incomplete marker format');
      }

      var _match = _slicedToArray(match, 5),
          original = _match[0],
          chrom = _match[1],
          pos = _match[2],
          ref = _match[3],
          alt = _match[4]; // Currently, the LD server only accepts full variant specs; it won't return LD w/o ref+alt. Allowing
      //  a partial match at most leaves room for potential future features.


      refVar = "".concat(chrom, ":").concat(pos);

      if (ref && alt) {
        refVar += "_".concat(ref, "/").concat(alt);
      } // Preserve the user-provided variant spec for use when matching to assoc data


      chain.header.ldrefvar = original;
      return [this.url, 'genome_builds/', build, '/references/', source, '/populations/', population, '/variants', '?correlation=', method, '&variant=', encodeURIComponent(refVar), '&chrom=', encodeURIComponent(state.chr), '&start=', encodeURIComponent(state.start), '&stop=', encodeURIComponent(state.end)].join('');
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      var keys = this.findMergeFields(chain);
      var reqFields = this.findRequestedFields(fields, outnames);

      if (!keys.position) {
        throw new Error("Unable to find position field for merge: ".concat(keys._names_));
      }

      var leftJoin = function leftJoin(left, right, lfield, rfield) {
        var i = 0,
            j = 0;

        while (i < left.length && j < right.position2.length) {
          if (left[i][keys.position] === right.position2[j]) {
            left[i][lfield] = right[rfield][j];
            i++;
            j++;
          } else if (left[i][keys.position] < right.position2[j]) {
            i++;
          } else {
            j++;
          }
        }
      };

      var tagRefVariant = function tagRefVariant(data, refvar, idfield, outrefname, outldname) {
        for (var i = 0; i < data.length; i++) {
          if (data[i][idfield] && data[i][idfield] === refvar) {
            data[i][outrefname] = 1;
            data[i][outldname] = 1; // For label/filter purposes, implicitly mark the ref var as LD=1 to itself
          } else {
            data[i][outrefname] = 0;
          }
        }
      }; // LD servers vary slightly. Some report corr as "rsquare", others as "correlation"


      var corrField = data.rsquare ? 'rsquare' : 'correlation';
      leftJoin(chain.body, data, reqFields.ldout, corrField);

      if (reqFields.isrefvarin && chain.header.ldrefvar) {
        tagRefVariant(chain.body, chain.header.ldrefvar, keys.id, reqFields.isrefvarout, reqFields.ldout);
      }

      return chain.body;
    }
  }, {
    key: "fetchRequest",
    value: function fetchRequest(state, chain, fields) {
      // The API is paginated, but we need all of the data to render a plot. Depaginate and combine where appropriate.
      var url = this.getURL(state, chain, fields);
      var combined = {
        data: {}
      };

      var chainRequests = function chainRequests(url) {
        return fetch(url).then().then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return response.text();
        }).then(function (payload) {
          payload = JSON.parse(payload);
          Object.keys(payload.data).forEach(function (key) {
            combined.data[key] = (combined.data[key] || []).concat(payload.data[key]);
          });

          if (payload.next) {
            return chainRequests(payload.next);
          }

          return combined;
        });
      };

      return chainRequests(url);
    }
  }]);

  return LDServer;
}(BaseApiAdapter);
/**
 * Data source for GWAS catalogs of known variants
 * @public
 * @class
 * @param {Object|String} init Configuration (URL or object)
 * @param {Object} [init.params] Optional configuration parameters
 * @param {Number} [init.params.source=2] The ID of the chosen catalog. Defaults to EBI GWAS catalog, GRCh37
 * @param {('strict'|'loose')} [init.params.match_type='strict'] Whether to match on exact variant, or just position.
 */


var GwasCatalogLZ = /*#__PURE__*/function (_BaseApiAdapter3) {
  _inherits(GwasCatalogLZ, _BaseApiAdapter3);

  var _super4 = _createSuper(GwasCatalogLZ);

  function GwasCatalogLZ(config) {
    var _this4;

    _classCallCheck(this, GwasCatalogLZ);

    _this4 = _super4.call(this, config);
    _this4.__dependentSource = true;
    return _this4;
  }

  _createClass(GwasCatalogLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      // This is intended to be aligned with another source- we will assume they are always ordered by position, asc
      //  (regardless of the actual match field)
      var build_option = state.genome_build || this.params.build;
      validateBuildSource(this.constructor.name, build_option, null); // Source can override build- not mutually exclusive
      // Most of our annotations will respect genome build before any other option.
      //   But there can be more than one GWAS catalog version available in the same API, for the same build- an
      //   explicit config option will always take
      //   precedence.
      // See: http://portaldev.sph.umich.edu/api/v1/annotation/gwascatalog/?format=objects

      var default_source = build_option === 'GRCh38' ? 5 : 6; // EBI GWAS catalog

      var source = this.params.source || default_source;
      return "".concat(this.url, "?format=objects&sort=pos&filter=id eq ").concat(source, " and chrom eq '").concat(state.chr, "' and pos ge ").concat(state.start, " and pos le ").concat(state.end);
    }
  }, {
    key: "findMergeFields",
    value: function findMergeFields(records) {
      // Data from previous sources is already namespaced. Find the alignment field by matching.
      var knownFields = Object.keys(records); // Note: All API endoints involved only give results for 1 chromosome at a time; match is implied

      var posMatch = knownFields.find(function (item) {
        return item.match(/\b(position|pos)\b/i);
      });

      if (!posMatch) {
        throw new Error('Could not find data to align with GWAS catalog results');
      }

      return {
        'pos': posMatch
      };
    }
  }, {
    key: "extractFields",
    value: function extractFields(data, fields, outnames, trans) {
      // Skip the "individual field extraction" step; extraction will be handled when building chain body instead
      return data;
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      if (!data.length) {
        return chain.body;
      } //  TODO: Better reuse options in the future. This source is very specifically tied to the PortalDev API, where
      //   the field name is always "log_pvalue". Relatively few sites will write their own gwas-catalog endpoint.


      var decider = 'log_pvalue';
      var decider_out = outnames[fields.indexOf(decider)];

      function leftJoin(left, right, fields, outnames, trans) {
        // Add `fields` from `right` to `left`
        // Add a synthetic, un-namespaced field to all matching records
        var n_matches = left['n_catalog_matches'] || 0;
        left['n_catalog_matches'] = n_matches + 1;

        if (decider && left[decider_out] && left[decider_out] > right[decider]) {
          // There may be more than one GWAS catalog entry for the same SNP. This source is intended for a 1:1
          //  annotation scenario, so for now it only joins the catalog entry that has the best -log10 pvalue
          return;
        }

        for (var _j = 0; _j < fields.length; _j++) {
          var fn = fields[_j];
          var outn = outnames[_j];
          var val = right[fn];

          if (trans && trans[_j]) {
            val = trans[_j](val);
          }

          left[outn] = val;
        }
      }

      var chainNames = this.findMergeFields(chain.body[0]);
      var catNames = this.findMergeFields(data[0]);
      var i = 0,
          j = 0;

      while (i < chain.body.length && j < data.length) {
        var left = chain.body[i];
        var right = data[j];

        if (left[chainNames.pos] === right[catNames.pos]) {
          // There may be multiple catalog entries for each matching SNP; evaluate match one at a time
          leftJoin(left, right, fields, outnames, trans);
          j += 1;
        } else if (left[chainNames.pos] < right[catNames.pos]) {
          i += 1;
        } else {
          j += 1;
        }
      }

      return chain.body;
    }
  }]);

  return GwasCatalogLZ;
}(BaseApiAdapter);
/**
 * Data Source for Gene Data, as fetched from the LocusZoom/Portaldev API server (or compatible format)
 * @public
 */


var GeneLZ = /*#__PURE__*/function (_BaseApiAdapter4) {
  _inherits(GeneLZ, _BaseApiAdapter4);

  var _super5 = _createSuper(GeneLZ);

  function GeneLZ() {
    _classCallCheck(this, GeneLZ);

    return _super5.apply(this, arguments);
  }

  _createClass(GeneLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var build = state.genome_build || this.params.build;
      var source = this.params.source;
      validateBuildSource(this.constructor.name, build, source);

      if (build) {
        // If build specified, we auto-select the best current portaldev API dataset for that build
        // If build is not specified, we use the exact source ID provided by the user.
        // See: https://portaldev.sph.umich.edu/api/v1/annotation/genes/sources/?format=objects
        source = build === 'GRCh38' ? 4 : 5;
      }

      return "".concat(this.url, "?filter=source in ").concat(source, " and chrom eq '").concat(state.chr, "' and start le ").concat(state.end, " and end ge ").concat(state.start);
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      // Genes have a very complex internal data format. Bypass any record parsing, and provide the data layer with
      // the exact information returned by the API. (ignoring the fields array in the layout)
      return data;
    }
  }, {
    key: "extractFields",
    value: function extractFields(data, fields, outnames, trans) {
      return data;
    }
  }]);

  return GeneLZ;
}(BaseApiAdapter);
/**
 * Data Source for Gene Constraint Data, as fetched from the gnomAD server (or compatible)
 *
 * This is intended to be the second request in a chain, with special logic that connects it to Genes data
 *  already fetched.
 *
 * @public
*/


var GeneConstraintLZ = /*#__PURE__*/function (_BaseApiAdapter5) {
  _inherits(GeneConstraintLZ, _BaseApiAdapter5);

  var _super6 = _createSuper(GeneConstraintLZ);

  function GeneConstraintLZ(config) {
    var _this5;

    _classCallCheck(this, GeneConstraintLZ);

    _this5 = _super6.call(this, config);
    _this5.__dependentSource = true;
    return _this5;
  }

  _createClass(GeneConstraintLZ, [{
    key: "getURL",
    value: function getURL() {
      // GraphQL API: request details are encoded in the body, not the URL
      return this.url;
    }
  }, {
    key: "getCacheKey",
    value: function getCacheKey(state, chain, fields) {
      var build = state.genome_build || this.params.build; // GraphQL API: request not defined solely by the URL
      // Gather the state params that govern constraint query for a given region.

      return "".concat(this.url, " ").concat(state.chr, " ").concat(state.start, " ").concat(state.end, " ").concat(build);
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      return data;
    }
  }, {
    key: "fetchRequest",
    value: function fetchRequest(state, chain, fields) {
      var build = state.genome_build || this.params.build;

      if (!build) {
        throw new Error("Data source ".concat(this.constructor.name, " must specify a 'genome_build' option"));
      }

      var unique_gene_names = chain.body.reduce( // In rare cases, the same gene symbol may appear at multiple positions. (issue #179) We de-duplicate the
      //  gene names to avoid issuing a malformed GraphQL query.
      function (acc, gene) {
        acc[gene.gene_name] = null;
        return acc;
      }, {});
      var query = Object.keys(unique_gene_names).map(function (gene_name) {
        // GraphQL alias names must match a specific set of allowed characters: https://stackoverflow.com/a/45757065/1422268
        var alias = "_".concat(gene_name.replace(/[^A-Za-z0-9_]/g, '_')); // Each gene symbol is a separate graphQL query, grouped into one request using aliases

        return "".concat(alias, ": gene(gene_symbol: \"").concat(gene_name, "\", reference_genome: ").concat(build, ") { gnomad_constraint { exp_syn obs_syn syn_z oe_syn oe_syn_lower oe_syn_upper exp_mis obs_mis mis_z oe_mis oe_mis_lower oe_mis_upper exp_lof obs_lof pLI oe_lof oe_lof_lower oe_lof_upper } } ");
      });

      if (!query.length) {
        // If there are no genes, skip the network request
        return Promise.resolve({
          data: null
        });
      }

      query = "{".concat(query.join(' '), " }"); // GraphQL isn't quite JSON; items are separated by spaces but not commas

      var url = this.getURL(state, chain, fields); // See: https://graphql.org/learn/serving-over-http/

      var body = JSON.stringify({
        query: query
      });
      var headers = {
        'Content-Type': 'application/json'
      }; // FIXME: The gnomAD API sometimes has temporary CORS changes that temporarily break the genes track
      // If request blocked, return  a fake "no data" signal so the genes track can still render w/o constraint info

      return fetch(url, {
        method: 'POST',
        body: body,
        headers: headers
      }).then(function (response) {
        if (!response.ok) {
          return [];
        }

        return response.text();
      })["catch"](function (err) {
        return [];
      });
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      if (!data) {
        return chain;
      }

      chain.body.forEach(function (gene) {
        // Find payload keys that match gene names in this response
        var alias = "_".concat(gene.gene_name.replace(/[^A-Za-z0-9_]/g, '_')); // aliases are modified gene names

        var constraint = data[alias] && data[alias]['gnomad_constraint']; // gnomad API has two ways of specifying missing data for a requested gene

        if (constraint) {
          // Add all fields from constraint data- do not override fields present in the gene source
          Object.keys(constraint).forEach(function (key) {
            var val = constraint[key];

            if (typeof gene[key] === 'undefined') {
              if (typeof val == 'number' && val.toString().includes('.')) {
                val = parseFloat(val.toFixed(2));
              }

              gene[key] = val; // These two sources are both designed to bypass namespacing
            }
          });
        }
      });
      return chain.body;
    }
  }]);

  return GeneConstraintLZ;
}(BaseApiAdapter);
/**
 * Data Source for Recombination Rate Data, as fetched from the LocusZoom API server (or compatible)
 * @public
 */


var RecombLZ = /*#__PURE__*/function (_BaseApiAdapter6) {
  _inherits(RecombLZ, _BaseApiAdapter6);

  var _super7 = _createSuper(RecombLZ);

  function RecombLZ() {
    _classCallCheck(this, RecombLZ);

    return _super7.apply(this, arguments);
  }

  _createClass(RecombLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var build = state.genome_build || this.params.build;
      var source = this.params.source;
      validateBuildSource(this.constructor.SOURCE_NAME, build, source);

      if (build) {
        // If build specified, choose a known Portal API dataset IDs (build 37/38)
        source = build === 'GRCh38' ? 16 : 15;
      }

      return "".concat(this.url, "?filter=id in ").concat(source, " and chromosome eq '").concat(state.chr, "' and position le ").concat(state.end, " and position ge ").concat(state.start);
    }
  }]);

  return RecombLZ;
}(BaseApiAdapter);
/**
 * Data Source for static blobs of data as raw JS objects. This does not perform additional parsing, and it bypasses
 * namespaces. Therefore it is the responsibility of the user to pass information in a format that can be read and
 * understood by the chosen plot- a StaticJSON source is rarely a drop-in replacement.
 *
 * This source is largely here for legacy reasons. More often, a convenient way to serve static data is as separate
 *  JSON files to an existing source (with the JSON url in place of an API).
 * @public
 */


var StaticSource = /*#__PURE__*/function (_BaseAdapter2) {
  _inherits(StaticSource, _BaseAdapter2);

  var _super8 = _createSuper(StaticSource);

  function StaticSource() {
    _classCallCheck(this, StaticSource);

    return _super8.apply(this, arguments);
  }

  _createClass(StaticSource, [{
    key: "parseInit",
    value: function parseInit(data) {
      // Does not receive any config; the only argument is the raw data, embedded when source is created
      this._data = data;
    }
  }, {
    key: "getRequest",
    value: function getRequest(state, chain, fields) {
      return Promise.resolve(this._data);
    }
  }]);

  return StaticSource;
}(BaseAdapter);
/**
 * Data source for PheWAS data retrieved from a LocusZoom/PortalDev compatible API
 * @public
 * @param {String[]} init.params.build This datasource expects to be provided the name of the genome build that will
 *   be used to provide pheWAS results for this position. Note positions may not translate between builds.
 */


var PheWASLZ = /*#__PURE__*/function (_BaseApiAdapter7) {
  _inherits(PheWASLZ, _BaseApiAdapter7);

  var _super9 = _createSuper(PheWASLZ);

  function PheWASLZ() {
    _classCallCheck(this, PheWASLZ);

    return _super9.apply(this, arguments);
  }

  _createClass(PheWASLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var build = (state.genome_build ? [state.genome_build] : null) || this.params.build;

      if (!build || !Array.isArray(build) || !build.length) {
        throw new Error(['Data source', this.constructor.SOURCE_NAME, 'requires that you specify array of one or more desired genome build names'].join(' '));
      }

      var url = [this.url, "?filter=variant eq '", encodeURIComponent(state.variant), "'&format=objects&", build.map(function (item) {
        return "build=".concat(encodeURIComponent(item));
      }).join('&')];
      return url.join('');
    }
  }]);

  return PheWASLZ;
}(BaseApiAdapter);
/**
 * Base class for "connectors"- this is meant to be subclassed, rather than used directly.
 *
 * A connector is a source that makes no server requests and caches no data of its own. Instead, it decides how to
 *  combine data from other sources in the chain. Connectors are useful when we want to request (or calculate) some
 *  useful piece of information once, but apply it to many different kinds of record types.
 *
 * Typically, a subclass will implement the field merging logic in `combineChainBody`.
 *
 * @public
 * @param {Object} init Configuration for this source
 * @param {Object} init.sources Specify how the hard-coded logic should find the data it relies on in the chain,
 *  as {internal_name: chain_source_id} pairs. This allows writing a reusable connector that does not need to make
 *  assumptions about what namespaces a source is using.
 * @type {*|Function}
 */


var ConnectorSource = /*#__PURE__*/function (_BaseAdapter3) {
  _inherits(ConnectorSource, _BaseAdapter3);

  var _super10 = _createSuper(ConnectorSource);

  function ConnectorSource(config) {
    var _this6;

    _classCallCheck(this, ConnectorSource);

    _this6 = _super10.call(this, config);

    if (!config || !config.sources) {
      throw new Error('Connectors must specify the data they require as init.sources = {internal_name: chain_source_id}} pairs');
    }
    /**
     * Tells the connector how to find the data it relies on
     *
     * For example, a connector that applies burden test information to the genes layer might specify:
     *  {gene_ns: "gene", aggregation_ns: "aggregation"}
     *
     * @member {Object}
     */


    _this6._source_name_mapping = config.sources; // Validate that this source has been told how to find the required information

    var specified_ids = Object.keys(config.sources);
    /** @property {String[]} Specifies the sources that must be provided in the original config object */

    _this6._getRequiredSources().forEach(function (k) {
      if (!specified_ids.includes(k)) {
        // TODO: Fix constructor.name usage in minified bundles
        throw new Error("Configuration for ".concat(_this6.constructor.name, " must specify a source ID corresponding to ").concat(k));
      }
    });

    return _this6;
  } // Stub- connectors don't have their own url or data, so the defaults don't make sense


  _createClass(ConnectorSource, [{
    key: "parseInit",
    value: function parseInit() {}
  }, {
    key: "getRequest",
    value: function getRequest(state, chain, fields) {
      var _this7 = this;

      // Connectors do not request their own data by definition, but they *do* depend on other sources having been loaded
      //  first. This method performs basic validation, and preserves the accumulated body from the chain so far.
      Object.keys(this._source_name_mapping).forEach(function (ns) {
        var chain_source_id = _this7._source_name_mapping[ns];

        if (chain.discrete && !chain.discrete[chain_source_id]) {
          throw new Error("".concat(_this7.constructor.name, " cannot be used before loading required data for: ").concat(chain_source_id));
        }
      });
      return Promise.resolve(chain.body || []);
    }
  }, {
    key: "parseResponse",
    value: function parseResponse(data, chain, fields, outnames, trans) {
      // A connector source does not update chain.discrete, but it may use it. It bypasses data formatting
      //  and field selection (both are assumed to have been done already, by the previous sources this draws from)
      // Because of how the chain works, connectors are not very good at applying new transformations or namespacing.
      // Typically connectors are called with `connector_name:all` in the fields array.
      return Promise.resolve(this.combineChainBody(data, chain, fields, outnames, trans)).then(function (new_body) {
        return {
          header: chain.header || {},
          discrete: chain.discrete || {},
          body: new_body
        };
      });
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(records, chain) {
      // Stub method: specifies how to combine the data
      throw new Error('This method must be implemented in a subclass');
    }
    /**
     * Helper method since ES6 doesn't support class fields
     * @private
     */

  }, {
    key: "_getRequiredSources",
    value: function _getRequiredSources() {
      throw new Error('Must specify an array that identifes the kind of data required by this source');
    }
  }]);

  return ConnectorSource;
}(BaseAdapter);




/***/ }),

/***/ "./esm/ext/lz-aggregation-tests.js":
/*!*****************************************!*\
  !*** ./esm/ext/lz-aggregation-tests.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var raremetal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raremetal.js */ "raremetal.js");
/* harmony import */ var raremetal_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(raremetal_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_adapters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/adapters */ "./esm/data/adapters.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */

/*
 * LocusZoom extensions used to calculate and render aggregation test results. Because these calculations depend on an
 *   external library, the special data sources are defined here, rather than in LocusZoom core code.
 *
 *     The page must incorporate and load all libraries before this file can be used, including:
 *    - Vendor assets
 *    - LocusZoom
 *    - raremetal.js (available via NPM or a related CDN)
 */
// This is defined as a UMD module, to work with multiple different module systems / bundlers
// Arcane build note: everything defined here gets registered globally. This is not a "pure" module, and some build
//  systems may require being told that this file has side effects.



function install(LocusZoom) {
  /**
   * Data Source that calculates gene or region-based tests based on provided data
   *   It will rarely be used by itself, but rather using a connector that attaches the results to data from
   *   another source (like genes). Using a separate connector allows us to add caching and run this front-end
   *   calculation only once, while using it in many different places
   * @public
   */
  var BaseAdapter = LocusZoom.Adapters.get('BaseAdapter');
  var ConnectorSource = LocusZoom.Adapters.get('ConnectorSource');

  var AggregationTestSource = /*#__PURE__*/function (_BaseApiAdapter) {
    _inherits(AggregationTestSource, _BaseApiAdapter);

    var _super = _createSuper(AggregationTestSource);

    function AggregationTestSource() {
      _classCallCheck(this, AggregationTestSource);

      return _super.apply(this, arguments);
    }

    _createClass(AggregationTestSource, [{
      key: "getURL",
      value: function getURL(state, chain, fields) {
        // Unlike most sources, calculations may require access to plot state data even after the initial request
        // This example source REQUIRES that the external UI widget would store the needed test definitions in a plot state
        //  field called `aggregation_tests` (an object {masks: [], calcs: {})
        var required_info = state.aggregation_tests || {};

        if (!chain.header) {
          chain.header = {};
        } // All of these fields are required in order to use this datasource. TODO: Add validation?


        chain.header.aggregation_genoset_id = required_info.genoset_id || null; // Number

        chain.header.aggregation_genoset_build = required_info.genoset_build || null; // String

        chain.header.aggregation_phenoset_id = required_info.phenoset_id || null; // Number

        chain.header.aggregation_pheno = required_info.pheno || null; // String

        chain.header.aggregation_calcs = required_info.calcs || {}; // String[]

        var mask_data = required_info.masks || [];
        chain.header.aggregation_masks = mask_data; // {name:desc}[]

        chain.header.aggregation_mask_ids = mask_data.map(function (item) {
          return item.name;
        }); // Number[]

        return this.url;
      }
    }, {
      key: "getCacheKey",
      value: function getCacheKey(state, chain, fields) {
        this.getURL(state, chain, fields); // TODO: This just sets the chain.header fields

        return JSON.stringify({
          chrom: state.chr,
          start: state.start,
          stop: state.end,
          genotypeDataset: chain.header.aggregation_genoset_id,
          phenotypeDataset: chain.header.aggregation_phenoset_id,
          phenotype: chain.header.aggregation_pheno,
          samples: 'ALL',
          genomeBuild: chain.header.aggregation_genoset_build,
          masks: chain.header.aggregation_mask_ids
        });
      }
    }, {
      key: "fetchRequest",
      value: function fetchRequest(state, chain, fields) {
        var url = this.getURL(state, chain, fields);
        var body = this.getCacheKey(state, chain, fields);
        var headers = {
          'Content-Type': 'application/json'
        };
        return fetch(url, {
          method: 'POST',
          body: body,
          headers: headers
        }).then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return response.text();
        }).then(function (resp) {
          var json = typeof resp == 'string' ? JSON.parse(resp) : resp;

          if (json.error) {
            // RAREMETAL-server quirk: The API sometimes returns a 200 status code for failed requests,
            //    with a human-readable error description as a key
            // For now, this should be treated strictly as an error
            throw new Error(json.error);
          }

          return json;
        });
      }
    }, {
      key: "annotateData",
      value: function annotateData(records, chain) {
        // Operate on the calculated results. The result of this method will be added to chain.discrete
        // In a page using live API data, the UI would only request the masks it needs from the API.
        // But in our demos, sometimes boilerplate JSON has more masks than the UI asked for. Limit what calcs we run (by
        //  type, and to the set of groups requested by the user)
        // The Raremetal-server API has a quirk: it returns a different payload structure if no groups are defined
        //  for the request region. Detect when that happens and end the calculation immediately in that case
        if (!records.groups) {
          return {
            groups: [],
            variants: []
          };
        }

        records.groups = records.groups.filter(function (item) {
          return item.groupType === 'GENE';
        });
        var parsed = raremetal_js__WEBPACK_IMPORTED_MODULE_0__["helpers"].parsePortalJSON(records);
        var groups = parsed[0];
        var variants = parsed[1]; // Some APIs may return more data than we want (eg simple sites that are just serving up premade scorecov json files).
        //  Filter the response to just what the user has chosen to analyze.

        groups = groups.byMask(chain.header.aggregation_mask_ids); // Determine what calculations to run

        var calcs = chain.header.aggregation_calcs;

        if (!calcs || Object.keys(calcs).length === 0) {
          // If no calcs have been requested, then return a dummy placeholder immediately
          return {
            variants: [],
            groups: [],
            results: []
          };
        }

        var runner = new raremetal_js__WEBPACK_IMPORTED_MODULE_0__["helpers"].PortalTestRunner(groups, variants, calcs);
        return runner.toJSON().then(function (res) {
          // Internally, raremetal helpers track how the calculation is done, but not any display-friendly values
          // We will annotate each mask name (id) with a human-friendly description for later use
          var mask_id_to_desc = chain.header.aggregation_masks.reduce(function (acc, val) {
            acc[val.name] = val.description;
            return acc;
          }, {});
          res.data.groups.forEach(function (group) {
            group.mask_name = mask_id_to_desc[group.mask];
          });
          return res.data;
        })["catch"](function (e) {
          console.error(e);
          throw new Error('Failed to calculate aggregation test results');
        });
      }
    }, {
      key: "normalizeResponse",
      value: function normalizeResponse(data) {
        return data;
      }
    }, {
      key: "combineChainBody",
      value: function combineChainBody(records, chain) {
        // aggregation tests are a bit unique, in that the data is rarely used directly- instead it is used to annotate many
        //  other layers in different ways. The calculated result has been added to `chain.discrete`, but will not be returned
        //  as part of the response body built up by the chain
        return chain.body;
      }
    }]);

    return AggregationTestSource;
  }(_data_adapters__WEBPACK_IMPORTED_MODULE_1__["BaseApiAdapter"]);

  var AssocFromAggregationLZ = /*#__PURE__*/function (_BaseAdapter) {
    _inherits(AssocFromAggregationLZ, _BaseAdapter);

    var _super2 = _createSuper(AssocFromAggregationLZ);

    function AssocFromAggregationLZ(config) {
      _classCallCheck(this, AssocFromAggregationLZ);

      if (!config || !config.from) {
        throw 'Must specify the name of the source that contains association data';
      }

      return _super2.apply(this, arguments);
    }

    _createClass(AssocFromAggregationLZ, [{
      key: "parseInit",
      value: function parseInit(config) {
        _get(_getPrototypeOf(AssocFromAggregationLZ.prototype), "parseInit", this).call(this, config);

        this._from = config.from;
      }
    }, {
      key: "getRequest",
      value: function getRequest(state, chain, fields) {
        // Does not actually make a request. Just pick off the specific bundle of data from a known payload structure.
        if (chain.discrete && !chain.discrete[this._from]) {
          throw "".concat(this.constructor.SOURCE_NAME, " cannot be used before loading required data for: ").concat(this._from);
        } // Copy the data so that mutations (like sorting) don't affect the original


        return Promise.resolve(JSON.parse(JSON.stringify(chain.discrete[this._from]['variants'])));
      }
    }, {
      key: "normalizeResponse",
      value: function normalizeResponse(data) {
        // The payload structure of the association source is slightly different than the one required by association
        //   plots. For example, we need to parse variant names and convert to log_pvalue
        var REGEX_EPACTS = new RegExp('(?:chr)?(.+):(\\d+)_?(\\w+)?/?([^_]+)?_?(.*)?'); // match API variant strings

        return data.map(function (one_variant) {
          var match = one_variant.variant.match(REGEX_EPACTS);
          return {
            variant: one_variant.variant,
            chromosome: match[1],
            position: +match[2],
            ref_allele: match[3],
            ref_allele_freq: 1 - one_variant.altFreq,
            log_pvalue: -Math.log10(one_variant.pvalue)
          };
        }).sort(function (a, b) {
          a = a.variant;
          b = b.variant;

          if (a < b) {
            return -1;
          } else if (a > b) {
            return 1;
          } else {
            // names must be equal
            return 0;
          }
        });
      }
    }]);

    return AssocFromAggregationLZ;
  }(BaseAdapter);
  /**
   * A sample connector that aligns calculated aggregation test data with corresponding gene information. Returns a body
   *   suitable for use with the genes datalayer.
   *
   *  To use this source, one must specify a fields array that calls first the genes source, then a dummy field from
   *      this source. The output will be to transparently add several new fields to the genes data.
   * @public
   */


  var GeneAggregationConnectorLZ = /*#__PURE__*/function (_ConnectorSource) {
    _inherits(GeneAggregationConnectorLZ, _ConnectorSource);

    var _super3 = _createSuper(GeneAggregationConnectorLZ);

    function GeneAggregationConnectorLZ() {
      _classCallCheck(this, GeneAggregationConnectorLZ);

      return _super3.apply(this, arguments);
    }

    _createClass(GeneAggregationConnectorLZ, [{
      key: "_getRequiredSources",
      value: function _getRequiredSources() {
        return ['gene_ns', 'aggregation_ns'];
      }
    }, {
      key: "combineChainBody",
      value: function combineChainBody(data, chain) {
        // The genes layer receives all results, and displays only the best pvalue for each gene
        // Tie the calculated group-test results to genes with a matching name
        var aggregation_source_id = this._source_name_mapping['aggregation_ns'];
        var gene_source_id = this._source_name_mapping['gene_ns']; // This connector assumes that genes are the main body of records from the chain, and that aggregation tests are
        //   a standalone source that has not acted on genes data yet

        var aggregationData = chain.discrete[aggregation_source_id];
        var genesData = chain.discrete[gene_source_id];
        var groupedAggregation = {}; // Group together all tests done on that gene- any mask, any test

        aggregationData.groups.forEach(function (result) {
          if (!Object.prototype.hasOwnProperty.call(groupedAggregation, result.group)) {
            groupedAggregation[result.group] = [];
          }

          groupedAggregation[result.group].push(result.pvalue);
        }); // Annotate any genes that have test results

        genesData.forEach(function (gene) {
          var gene_id = gene.gene_name;
          var tests = groupedAggregation[gene_id];

          if (tests) {
            gene.aggregation_best_pvalue = Math.min.apply(null, tests);
          }
        });
        return genesData;
      }
    }]);

    return GeneAggregationConnectorLZ;
  }(ConnectorSource);

  LocusZoom.Adapters.add('AggregationTestSourceLZ', AggregationTestSource);
  LocusZoom.Adapters.add('AssocFromAggregationLZ', AssocFromAggregationLZ);
  LocusZoom.Adapters.add('GeneAggregationConnectorLZ', GeneAggregationConnectorLZ);
}

if (typeof LocusZoom !== 'undefined') {
  // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
  // eslint-disable-next-line no-undef
  LocusZoom.use(install);
}

/* harmony default export */ __webpack_exports__["default"] = (install);

/***/ }),

/***/ "raremetal.js":
/*!****************************!*\
  !*** external "raremetal" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = raremetal;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2RhdGEvYWRhcHRlcnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1hZ2dyZWdhdGlvbi10ZXN0cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwgXCJyYXJlbWV0YWxcIiJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUJ1aWxkU291cmNlIiwiY2xhc3NfbmFtZSIsImJ1aWxkIiwic291cmNlIiwiRXJyb3IiLCJpbmNsdWRlcyIsIkJhc2VBZGFwdGVyIiwiY29uZmlnIiwiX2VuYWJsZUNhY2hlIiwiX2NhY2hlZEtleSIsIl9fZGVwZW5kZW50U291cmNlIiwicGFyc2VJbml0IiwicGFyYW1zIiwic3RhdGUiLCJjaGFpbiIsImZpZWxkcyIsImdldFVSTCIsInVybCIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwib2siLCJzdGF0dXNUZXh0IiwidGV4dCIsInJlcSIsImNhY2hlS2V5IiwiZ2V0Q2FjaGVLZXkiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9jYWNoZWRSZXNwb25zZSIsImZldGNoUmVxdWVzdCIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiT2JqZWN0IiwiTiIsImxlbmd0aCIsInNhbWVMZW5ndGgiLCJldmVyeSIsImtleSIsIml0ZW0iLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJyZWNvcmRzIiwiaSIsInJlY29yZCIsImoiLCJwdXNoIiwib3V0bmFtZXMiLCJ0cmFucyIsImZpZWxkRm91bmQiLCJrIiwibWFwIiwib3V0cHV0X3JlY29yZCIsInZhbCIsImZvckVhY2giLCJ2IiwicmVzcCIsInNvdXJjZV9pZCIsImRpc2NyZXRlIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIm5vcm1hbGl6ZVJlc3BvbnNlIiwic3RhbmRhcmRpemVkIiwiYW5ub3RhdGVEYXRhIiwiZXh0cmFjdEZpZWxkcyIsIm9uZV9zb3VyY2VfYm9keSIsImNvbWJpbmVDaGFpbkJvZHkiLCJuZXdfYm9keSIsImhlYWRlciIsImJvZHkiLCJwcmVHZXREYXRhIiwicHJlIiwiZ2V0UmVxdWVzdCIsInBhcnNlUmVzcG9uc2UiLCJCYXNlQXBpQWRhcHRlciIsIkFzc29jaWF0aW9uTFoiLCJpZF9maWVsZCIsIngiLCJ1bnNoaWZ0IiwiYW5hbHlzaXMiLCJjaHIiLCJzdGFydCIsImVuZCIsInNvcnQiLCJhIiwiYiIsIkxEU2VydmVyIiwiam9pbiIsImV4YWN0TWF0Y2giLCJhcnIiLCJyZWdleGVzIiwiYXJndW1lbnRzIiwicmVnZXgiLCJtIiwiZmlsdGVyIiwibWF0Y2giLCJkYXRhRmllbGRzIiwiaWQiLCJwb3NpdGlvbiIsInBvc2l0aW9uX2ZpZWxkIiwicHZhbHVlIiwicHZhbHVlX2ZpZWxkIiwiX25hbWVzXyIsIm5hbWVzIiwibmFtZU1hdGNoIiwiaWRfbWF0Y2giLCJSZWdFeHAiLCJvYmoiLCJpc3JlZnZhcmluIiwiaXNyZWZ2YXJvdXQiLCJsZGluIiwibGRvdXQiLCJmaW5kRXh0cmVtZVZhbHVlIiwicHZhbF9maWVsZCIsImlzX2xvZyIsInRlc3QiLCJjbXAiLCJleHRyZW1lVmFsIiwiZXh0cmVtZUlkeCIsInJlcUZpZWxkcyIsImZpbmRSZXF1ZXN0ZWRGaWVsZHMiLCJyZWZWYXIiLCJsZHJlZnZhciIsImZpbmRNZXJnZUZpZWxkcyIsImNvbHVtbnMiLCJnZW5vbWVfYnVpbGQiLCJsZF9zb3VyY2UiLCJwb3B1bGF0aW9uIiwibGRfcG9wIiwibWV0aG9kIiwiZ2V0UmVmdmFyIiwiUkVHRVhfTUFSS0VSIiwib3JpZ2luYWwiLCJjaHJvbSIsInBvcyIsInJlZiIsImFsdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImxlZnRKb2luIiwibGVmdCIsInJpZ2h0IiwibGZpZWxkIiwicmZpZWxkIiwicG9zaXRpb24yIiwidGFnUmVmVmFyaWFudCIsInJlZnZhciIsImlkZmllbGQiLCJvdXRyZWZuYW1lIiwib3V0bGRuYW1lIiwiY29yckZpZWxkIiwicnNxdWFyZSIsImNvbWJpbmVkIiwiY2hhaW5SZXF1ZXN0cyIsInBheWxvYWQiLCJjb25jYXQiLCJuZXh0IiwiR3dhc0NhdGFsb2dMWiIsImJ1aWxkX29wdGlvbiIsImRlZmF1bHRfc291cmNlIiwia25vd25GaWVsZHMiLCJwb3NNYXRjaCIsImZpbmQiLCJkZWNpZGVyIiwiZGVjaWRlcl9vdXQiLCJpbmRleE9mIiwibl9tYXRjaGVzIiwiZm4iLCJvdXRuIiwiY2hhaW5OYW1lcyIsImNhdE5hbWVzIiwiR2VuZUxaIiwiR2VuZUNvbnN0cmFpbnRMWiIsInVuaXF1ZV9nZW5lX25hbWVzIiwicmVkdWNlIiwiYWNjIiwiZ2VuZSIsImdlbmVfbmFtZSIsInF1ZXJ5IiwiYWxpYXMiLCJyZXBsYWNlIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsImVyciIsImNvbnN0cmFpbnQiLCJ0b1N0cmluZyIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiUmVjb21iTFoiLCJTT1VSQ0VfTkFNRSIsIlN0YXRpY1NvdXJjZSIsIl9kYXRhIiwiUGhlV0FTTFoiLCJ2YXJpYW50IiwiQ29ubmVjdG9yU291cmNlIiwic291cmNlcyIsIl9zb3VyY2VfbmFtZV9tYXBwaW5nIiwic3BlY2lmaWVkX2lkcyIsIl9nZXRSZXF1aXJlZFNvdXJjZXMiLCJucyIsImNoYWluX3NvdXJjZV9pZCIsImluc3RhbGwiLCJMb2N1c1pvb20iLCJBZGFwdGVycyIsImdldCIsIkFnZ3JlZ2F0aW9uVGVzdFNvdXJjZSIsInJlcXVpcmVkX2luZm8iLCJhZ2dyZWdhdGlvbl90ZXN0cyIsImFnZ3JlZ2F0aW9uX2dlbm9zZXRfaWQiLCJnZW5vc2V0X2lkIiwiYWdncmVnYXRpb25fZ2Vub3NldF9idWlsZCIsImdlbm9zZXRfYnVpbGQiLCJhZ2dyZWdhdGlvbl9waGVub3NldF9pZCIsInBoZW5vc2V0X2lkIiwiYWdncmVnYXRpb25fcGhlbm8iLCJwaGVubyIsImFnZ3JlZ2F0aW9uX2NhbGNzIiwiY2FsY3MiLCJtYXNrX2RhdGEiLCJtYXNrcyIsImFnZ3JlZ2F0aW9uX21hc2tzIiwiYWdncmVnYXRpb25fbWFza19pZHMiLCJzdG9wIiwiZ2Vub3R5cGVEYXRhc2V0IiwicGhlbm90eXBlRGF0YXNldCIsInBoZW5vdHlwZSIsInNhbXBsZXMiLCJnZW5vbWVCdWlsZCIsImVycm9yIiwiZ3JvdXBzIiwidmFyaWFudHMiLCJncm91cFR5cGUiLCJwYXJzZWQiLCJoZWxwZXJzIiwicGFyc2VQb3J0YWxKU09OIiwiYnlNYXNrIiwicmVzdWx0cyIsInJ1bm5lciIsIlBvcnRhbFRlc3RSdW5uZXIiLCJ0b0pTT04iLCJyZXMiLCJtYXNrX2lkX3RvX2Rlc2MiLCJkZXNjcmlwdGlvbiIsImdyb3VwIiwibWFza19uYW1lIiwibWFzayIsImUiLCJjb25zb2xlIiwiQXNzb2NGcm9tQWdncmVnYXRpb25MWiIsImZyb20iLCJfZnJvbSIsIlJFR0VYX0VQQUNUUyIsIm9uZV92YXJpYW50IiwiY2hyb21vc29tZSIsInJlZl9hbGxlbGUiLCJyZWZfYWxsZWxlX2ZyZXEiLCJhbHRGcmVxIiwibG9nX3B2YWx1ZSIsIk1hdGgiLCJsb2cxMCIsIkdlbmVBZ2dyZWdhdGlvbkNvbm5lY3RvckxaIiwiYWdncmVnYXRpb25fc291cmNlX2lkIiwiZ2VuZV9zb3VyY2VfaWQiLCJhZ2dyZWdhdGlvbkRhdGEiLCJnZW5lc0RhdGEiLCJncm91cGVkQWdncmVnYXRpb24iLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJnZW5lX2lkIiwidGVzdHMiLCJhZ2dyZWdhdGlvbl9iZXN0X3B2YWx1ZSIsIm1pbiIsImFwcGx5IiwiYWRkIiwidXNlIl0sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtR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RDtBQUNIOztBQUdELElBQUksT0FBTzFELFNBQVAsS0FBcUIsV0FBekIsRUFBc0M7QUFDbEM7QUFDQTtBQUNBQSxXQUFTLENBQUMwRSxHQUFWLENBQWMzRSxPQUFkO0FBQ0g7O0FBR2NBLHNFQUFmLEU7Ozs7Ozs7Ozs7O0FDelFBLDJCIiwiZmlsZSI6ImV4dC9sei1hZ2dyZWdhdGlvbi10ZXN0cy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2VzbS9leHQvbHotYWdncmVnYXRpb24tdGVzdHMuanNcIik7XG4iLCIvKipcbiAqIERlZmluZSBzdGFuZGFyZCBkYXRhIGFkYXB0ZXJzIHVzZWQgdG8gcmV0cmlldmUgZGF0YSAodXN1YWxseSBmcm9tIFJFU1QgQVBJcylcbiAqIEBtb2R1bGVcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUJ1aWxkU291cmNlKGNsYXNzX25hbWUsIGJ1aWxkLCBzb3VyY2UpIHtcbiAgICAvLyBCdWlsZCBPUiBTb3VyY2UsIG5vdCBib3RoXG4gICAgaWYgKChidWlsZCAmJiBzb3VyY2UpIHx8ICEoYnVpbGQgfHwgc291cmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2xhc3NfbmFtZX0gbXVzdCBwcm92aWRlIGEgcGFyYW1ldGVyIHNwZWNpZnlpbmcgZWl0aGVyIFwiYnVpbGRcIiBvciBcInNvdXJjZVwiLiBJdCBzaG91bGQgbm90IHNwZWNpZnkgYm90aC5gKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGJ1aWxkIGlzbid0IHJlY29nbml6ZWQsIG91ciBBUElzIGNhbid0IHRyYW5zcGFyZW50bHkgc2VsZWN0IGEgc291cmNlIHRvIG1hdGNoXG4gICAgaWYgKGJ1aWxkICYmICFbJ0dSQ2gzNycsICdHUkNoMzgnXS5pbmNsdWRlcyhidWlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NsYXNzX25hbWV9IG11c3Qgc3BlY2lmeSBhIHZhbGlkIGdlbm9tZSBidWlsZCBudW1iZXJgKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBMb2N1c1pvb20gZGF0YSBzb3VyY2VzIChhbnkpLiBTZWUgYWxzbzogQmFzZUFwaUFkYXB0ZXJcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQmFzZUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHNvdXJjZSBzaG91bGQgZW5hYmxlIGNhY2hpbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VuYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkS2V5ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGRhdGEgc291cmNlIHR5cGUgaXMgZGVwZW5kZW50IG9uIHByZXZpb3VzIHJlcXVlc3RzLSBmb3IgZXhhbXBsZSwgdGhlIExEIHNvdXJjZSBjYW5ub3QgYW5ub3RhdGVcbiAgICAgICAgICogIGFzc29jaWF0aW9uIGRhdGEgaWYgbm8gZGF0YSB3YXMgZm91bmQgZm9yIHRoYXQgcmVnaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2RlcGVuZGVudFNvdXJjZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFBhcnNlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAgICB0aGlzLnBhcnNlSW5pdChjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGNvbmZpZ3VyYXRpb24gdXNlZCB0byBjcmVhdGUgdGhlIGRhdGEgc291cmNlLiBNYW55IGN1c3RvbSBzb3VyY2VzIHdpbGwgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gc3VpdCB0aGVpclxuICAgICAqICBuZWVkcyAoZWcgc3BlY2lmaWMgY29uZmlnIG9wdGlvbnMsIG9yIGZvciBzb3VyY2VzIHRoYXQgZG8gbm90IHJldHJpZXZlIGRhdGEgZnJvbSBhIFVSTClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcgQmFzaWMgY29uZmlndXJhdGlvbi0gZWl0aGVyIGEgdXJsLCBvciBhIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy51cmxdIFRoZSBkYXRhc291cmNlIFVSTFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnBhcmFtc10gSW5pdGlhbCBjb25maWcgcGFyYW1zIGZvciB0aGUgZGF0YXNvdXJjZVxuICAgICAqL1xuICAgIHBhcnNlSW5pdChjb25maWcpIHtcbiAgICAgICAgLyoqIEBtZW1iZXIge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5wYXJhbXMgPSBjb25maWcucGFyYW1zIHx8IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBjYWNoZWQgZGF0YSBpcyB2YWxpZCBmb3IgdGhpcyByZXF1ZXN0LiBGb3IgbW9zdCBzb3VyY2VzIHVzaW5nIEdFVFxuICAgICAqICByZXF1ZXN0cyB0byBhIFJFU1QgQVBJLCB0aGlzIGlzIHVzdWFsbHkgdGhlIFVSTC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIEluZm9ybWF0aW9uIGF2YWlsYWJsZSBpbiBwbG90LnN0YXRlIChjaHIsIHN0YXJ0LCBlbmQpLiBTb21ldGltZXMgdXNlZCB0byBpbmplY3QgZ2xvYmFsbHlcbiAgICAgKiAgYXZhaWxhYmxlIGluZm9ybWF0aW9uIHRoYXQgaW5mbHVlbmNlcyB0aGUgcmVxdWVzdCBiZWluZyBtYWRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFpbiBUaGUgZGF0YSBjaGFpbiBmcm9tIHByZXZpb3VzIHJlcXVlc3RzIG1hZGUgaW4gYSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0Q2FjaGVLZXkoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHViOiBidWlsZCB0aGUgVVJMIGZvciBhbnkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHNvdXJjZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgbmV0d29yayByZXF1ZXN0IHRvIGZldGNoIGRhdGEgZm9yIHRoaXMgc291cmNlLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gb3ZlcnJpZGVcbiAgICAgKiAgd2hlbiBkZWZpbmluZyBob3cgdG8gcmV0cmlldmUgZGF0YS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgcGFyZW50IHBsb3RcbiAgICAgKiBAcGFyYW0gY2hhaW5cbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBqdXN0IHRoaXMgc291cmNlLCB0eXBpY2FsbHkgdmlhIGEgbmV0d29yayByZXF1ZXN0IChidXQgdXNpbmcgY2FjaGUgd2hlcmUgcG9zc2libGUpXG4gICAgICpcbiAgICAgKiBGb3IgbW9zdCB1c2UgY2FzZXMsIGl0IGlzIGJldHRlciB0byBvdmVycmlkZSBgZmV0Y2hSZXF1ZXN0YCBpbnN0ZWFkLCB0byBhdm9pZCBieXBhc3NpbmcgdGhlIGNhY2hlIG1lY2hhbmlzbVxuICAgICAqIGJ5IGFjY2lkZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGxldCByZXE7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleShzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVDYWNoZSAmJiB0eXBlb2YoY2FjaGVLZXkpICE9PSAndW5kZWZpbmVkJyAmJiBjYWNoZUtleSA9PT0gdGhpcy5fY2FjaGVkS2V5KSB7XG4gICAgICAgICAgICByZXEgPSBQcm9taXNlLnJlc29sdmUodGhpcy5fY2FjaGVkUmVzcG9uc2UpOyAgLy8gUmVzb2x2ZSB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgcHJvbWlzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxID0gdGhpcy5mZXRjaFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkS2V5ID0gY2FjaGVLZXk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUmVzcG9uc2UgPSByZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIHNlcnZlciByZXNwb25zZSBpcyBpbiBhIGNhbm9uaWNhbCBmb3JtLCBhbiBhcnJheSBvZiBvbmUgb2JqZWN0IHBlciByZWNvcmQuIFsge2ZpZWxkOiBvbmV2YWx9IF0uXG4gICAgICogSWYgdGhlIHNlcnZlciByZXNwb25zZSBjb250YWlucyBjb2x1bW5zLCByZWZvcm1hdHMgdGhlIHJlc3BvbnNlIGZyb20ge2NvbHVtbjE6IFtdLCBjb2x1bW4yOiBbXX0gdG8gdGhlIGFib3ZlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgYXBwbHkgbmFtZXNwYWNpbmcsIHRyYW5zZm9ybWF0aW9ucywgb3IgZmllbGQgZXh0cmFjdGlvbi5cbiAgICAgKlxuICAgICAqIE1heSBiZSBvdmVycmlkZGVuIGJ5IGRhdGEgc291cmNlcyB0aGF0IGluaGVyZW50bHkgcmV0dXJuIG1vcmUgY29tcGxleCBwYXlsb2Fkcywgb3IgdGhhdCBleGlzdCB0byBhbm5vdGF0ZSBvdGhlclxuICAgICAqICBzb3VyY2VzIChlZywgaWYgdGhlIHBheWxvYWQgcHJvdmlkZXMgZXh0cmEgZGF0YSByYXRoZXIgdGhhbiBhIHNlcmllcyBvZiByZWNvcmRzKS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxPYmplY3R9IGRhdGEgVGhlIG9yaWdpbmFsIHBhcnNlZCBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBub3JtYWxpemVSZXNwb25zZShkYXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGluIHRoZSBkZXNpcmVkIGZvcm1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBjb2x1bW5zIG9mIGRhdGEuXG4gICAgICAgIC8vIEVhY2ggYXJyYXkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoICh2ZXJpZnkpLCBhbmQgYSBnaXZlbiBhcnJheSBpbmRleCBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSByb3cuXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgY29uc3QgTiA9IGRhdGFba2V5c1swXV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBzYW1lTGVuZ3RoID0ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGVuZ3RoID09PSBOO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzYW1lTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBleHBlY3RzIGEgcmVzcG9uc2UgaW4gd2hpY2ggYWxsIGFycmF5cyBvZiBkYXRhIGFyZSB0aGUgc2FtZSBsZW5ndGhgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdvIGRvd24gdGhlIHJvd3MsIGFuZCBjcmVhdGUgYW4gb2JqZWN0IGZvciBlYWNoIHJlY29yZFxuICAgICAgICBjb25zdCByZWNvcmRzID0gW107XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlY29yZFtmaWVsZHNbal1dID0gZGF0YVtmaWVsZHNbal1dW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byBwb3N0LXByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhpcyBzb3VyY2Ugd2l0aCBuZXcsIGFkZGl0aW9uYWwgYmVoYXZpb3IuXG4gICAgICogICAoZWcgY2xlYW5pbmcgdXAgQVBJIHZhbHVlcyBvciBwZXJmb3JtaW5nIGNvbXBsZXggY2FsY3VsYXRpb25zIG9uIHRoZSByZXR1cm5lZCBkYXRhKVxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY29yZHMgVGhlIHBhcnNlZCBkYXRhIGZyb20gdGhlIHNvdXJjZSAoZWcgc3RhbmRhcmRpemVkIGFwaSByZXNwb25zZSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGRhdGEgY2hhaW4gb2JqZWN0LiBGb3IgZXhhbXBsZSwgY2hhaW4uaGVhZGVycyBtYXkgcHJvdmlkZSB1c2VmdWwgYW5ub3RhdGlvbiBtZXRhZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXXxQcm9taXNlfSBUaGUgbW9kaWZpZWQgc2V0IG9mIHJlY29yZHNcbiAgICAgKi9cbiAgICBhbm5vdGF0ZURhdGEocmVjb3JkcywgY2hhaW4pIHtcbiAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvcjogbm8gdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIHRoZSBzZXJ2ZXIgcmVjb3JkcyBmb3IgdXNlIGJ5IGRhdGFsYXllcnM6IGV4dHJhY3Qgb25seSBjZXJ0YWluIGZpZWxkcywgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzLlxuICAgICAqICAgQXBwbHkgcGVyLWZpZWxkIHRyYW5zZm9ybWF0aW9ucyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaG9vayBjYW4gYmUgb3ZlcnJpZGRlbiwgZWcgdG8gY3JlYXRlIGEgc291cmNlIHRoYXQgYWx3YXlzIHJldHVybnMgYWxsIHJlY29yZHMgYW5kIGlnbm9yZXMgdGhlIFwiZmllbGRzXCIgYXJyYXkuXG4gICAgICogIFRoaXMgaXMgcGFydGljdWxhcmx5IGNvbW1vbiBmb3Igc291cmNlcyBhdCB0aGUgZW5kIG9mIGEgY2hhaW4tIG1hbnkgXCJkZXBlbmRlbnRcIiBzb3VyY2VzIGRvIG5vdCBhbGxvd1xuICAgICAqICBjaGVycnktcGlja2luZyBpbmRpdmlkdWFsIGZpZWxkcywgaW4gd2hpY2ggY2FzZSBieSAqKmNvbnZlbnRpb24qKiB0aGUgZmllbGRzIGFycmF5IHNwZWNpZmllcyBcImxhc3Rfc291cmNlX25hbWU6YWxsXCJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhIE9uZSByZWNvcmQgb2JqZWN0IHBlciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIFRoZSBuYW1lcyBvZiBmaWVsZHMgdG8gZXh0cmFjdCAoYXMgbmFtZWQgaW4gdGhlIHNvdXJjZSBkYXRhKS4gRWcgXCJhZmllbGRcIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG91dG5hbWVzIEhvdyB0byByZXByZXNlbnQgdGhlIHNvdXJjZSBmaWVsZHMgaW4gdGhlIG91dHB1dC4gRWcgXCJuYW1lc3BhY2U6YWZpZWxkfGF0cmFuc2Zvcm1cIlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gdHJhbnMgQW4gYXJyYXkgb2YgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIChpZiBhbnkpLiBPbmUgZnVuY3Rpb24gcGVyIGRhdGEgZWxlbWVudCwgb3IgbnVsbC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZXh0cmFjdEZpZWxkcyAoZGF0YSwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgLy9pbnRlbmRlZCBmb3IgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAvLyAgWyB7XCJpZFwiOjEsIFwidmFsXCI6NX0sIHtcImlkXCI6MiwgXCJ2YWxcIjoxMH1dXG4gICAgICAgIC8vIFNpbmNlIGEgbnVtYmVyIG9mIHNvdXJjZXMgZXhpc3QgdGhhdCBkbyBub3Qgb2JleSB0aGlzIGZvcm1hdCwgd2Ugd2lsbCBwcm92aWRlIGEgY29udmVuaWVudCBwYXNzLXRocm91Z2hcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGVyZSBhcmUgcmVnaW9ucyB0aGF0IGp1c3QgZG9uJ3QgaGF2ZSBkYXRhLSB0aGlzIHNob3VsZCBub3QgdHJpZ2dlciBhIG1pc3NpbmcgZmllbGQgZXJyb3IgbWVzc2FnZSFcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRGb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZmllbGRGb3VuZFtrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWNvcmRzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dF9yZWNvcmQgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IGl0ZW1bZmllbGRzW2pdXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEZvdW5kW2pdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICYmIHRyYW5zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRyYW5zW2pdKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dF9yZWNvcmRbb3V0bmFtZXNbal1dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dF9yZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWVsZEZvdW5kLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWVsZCAke2ZpZWxkc1tpXX0gbm90IGZvdW5kIGluIHJlc3BvbnNlIGZvciAke291dG5hbWVzW2ldfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tYmluZSByZWNvcmRzIGZyb20gdGhpcyBzb3VyY2Ugd2l0aCBvdGhlcnMgaW4gdGhlIGNoYWluIHRvIHlpZWxkIGZpbmFsIGNoYWluIGJvZHkuXG4gICAgICogICBIYW5kbGVzIG1lcmdpbmcgdGhpcyBkYXRhIHdpdGggb3RoZXIgc291cmNlcyAoaWYgYXBwbGljYWJsZSkuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YSBUaGUgZGF0YSBUaGF0IHdvdWxkIGJlIHJldHVybmVkIGZyb20gdGhpcyBzb3VyY2UgYWxvbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGRhdGEgY2hhaW4gYnVpbHQgdXAgZHVyaW5nIHByZXZpb3VzIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3V0bmFtZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB0cmFuc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V8T2JqZWN0W119IFRoZSBuZXcgY2hhaW4gYm9keVxuICAgICAqL1xuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvb3JkaW5hdGVzIHRoZSB3b3JrIG9mIHBhcnNpbmcgYSByZXNwb25zZSBhbmQgcmV0dXJuaW5nIHJlY29yZHMuIFRoaXMgaXMgYnJva2VuIGludG8gNCBzdGVwcywgd2hpY2ggbWF5IGJlXG4gICAgICogIG92ZXJyaWRkZW4gc2VwYXJhdGVseSBmb3IgZmluZS1ncmFpbmVkIGNvbnRyb2wuIEVhY2ggc3RlcCBjYW4gcmV0dXJuIGVpdGhlciByYXcgZGF0YSBvciBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHJlc3AgVGhlIHJhdyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGNvbWJpbmVkIHBhcnNlZCByZXNwb25zZSBkYXRhIGZyb20gdGhpcyBhbmQgYWxsIG90aGVyIHJlcXVlc3RzIG1hZGUgaW4gdGhlIGNoYWluXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIEFycmF5IG9mIHJlcXVlc3RlZCBmaWVsZCBuYW1lcyAoYXMgdGhleSB3b3VsZCBhcHBlYXIgaW4gdGhlIHJlc3BvbnNlIHBheWxvYWQpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3V0bmFtZXMgIEFycmF5IG9mIGZpZWxkIG5hbWVzIGFzIHRoZXkgd2lsbCBiZSByZXByZXNlbnRlZCBpbiB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGlzIHNvdXJjZSxcbiAgICAgKiAgaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2UuIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyBgZmllbGRzYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gdHJhbnMgVGhlIGNvbGxlY3Rpb24gb2YgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGJlIHJ1biBvbiBzZWxlY3RlZCBmaWVsZHMuXG4gICAgICogICAgIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyBgZmllbGRzYFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAqICAgcmVxdWVzdCBtZXRhZGF0YSAoYGhlYWRlcnM6IHt9YCksIHRoZSBjb25zb2xpZGF0ZWQgZGF0YSBmb3IgcGxvdHRpbmcgKGBib2R5OiBbXWApLCBhbmQgdGhlIGluZGl2aWR1YWwgcmVzcG9uc2VzIHRoYXQgd291bGQgYmVcbiAgICAgKiAgIHJldHVybmVkIGJ5IGVhY2ggc291cmNlIGluIHRoZSBjaGFpbiBpbiBpc29sYXRpb24gKGBkaXNjcmV0ZToge31gKVxuICAgICAqL1xuICAgIHBhcnNlUmVzcG9uc2UgKHJlc3AsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICBjb25zdCBzb3VyY2VfaWQgPSB0aGlzLnNvdXJjZV9pZCB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmICghY2hhaW4uZGlzY3JldGUpIHtcbiAgICAgICAgICAgIGNoYWluLmRpc2NyZXRlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBqc29uID0gdHlwZW9mIHJlc3AgPT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHJlc3ApIDogcmVzcDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSA0IHN0ZXBzIG9mIHBhcnNpbmcgdGhlIHBheWxvYWQgYW5kIHJldHVybiBhIGNvbWJpbmVkIGNoYWluIG9iamVjdFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMubm9ybWFsaXplUmVzcG9uc2UoanNvbi5kYXRhIHx8IGpzb24pKVxuICAgICAgICAgICAgLnRoZW4oKHN0YW5kYXJkaXplZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY2FsY3VsYXRpb25zIG9uIHRoZSBkYXRhIGZyb20ganVzdCB0aGlzIHNvdXJjZVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hbm5vdGF0ZURhdGEoc3RhbmRhcmRpemVkLCBjaGFpbikpO1xuICAgICAgICAgICAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5leHRyYWN0RmllbGRzKGRhdGEsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSk7XG4gICAgICAgICAgICB9KS50aGVuKChvbmVfc291cmNlX2JvZHkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBhIGNvcHkgb2YgdGhlIGRhdGEgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBieSBwYXJzaW5nIHRoaXMgc291cmNlIGluIGlzb2xhdGlvbiAoYW5kIHRha2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGZpZWxkcyBhcnJheSBpbnRvIGFjY291bnQpLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8gcmUtdXNlIHRoZSBzb3VyY2Ugb3V0cHV0IGluIG1hbnkgd2F5cy5cbiAgICAgICAgICAgICAgICBjaGFpbi5kaXNjcmV0ZVtzb3VyY2VfaWRdID0gb25lX3NvdXJjZV9ib2R5O1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jb21iaW5lQ2hhaW5Cb2R5KG9uZV9zb3VyY2VfYm9keSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSk7XG4gICAgICAgICAgICB9KS50aGVuKChuZXdfYm9keSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcjogY2hhaW4uaGVhZGVyIHx8IHt9LCBkaXNjcmV0ZTogY2hhaW4uZGlzY3JldGUsIGJvZHk6IG5ld19ib2R5IH07XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgZGF0YSBzb3VyY2UsIGFuZCBhcHBseSB0cmFuc2Zvcm1hdGlvbnMgcmVxdWVzdGVkIGJ5IGFuIGV4dGVybmFsIGNvbnN1bWVyLlxuICAgICAqIFRoaXMgaXMgdGhlIHB1YmxpYy1mYWNpbmcgZGF0YXNvdXJjZSBtZXRob2QgdGhhdCB3aWxsIG1vc3QgYmUgY2FsbGVkIGJ5IHRoZSBwbG90LCBidXQgY3VzdG9tIGRhdGEgc291cmNlcyB3aWxsXG4gICAgICogIGFsbW9zdCBuZXZlciB3YW50IHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LSBtb3JlIHNwZWNpZmljIGhvb2tzIGFyZSBwcm92aWRlZCB0byBjb250cm9sIGluZGl2aWR1YWwgcGllY2VzXG4gICAgICogIG9mIHRoZSByZXF1ZXN0IGxpZmVjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBjdXJyZW50IFwic3RhdGVcIiBvZiB0aGUgcGxvdCwgc3VjaCBhcyBjaHJvbW9zb21lIGFuZCBzdGFydC9lbmQgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIEFycmF5IG9mIGZpZWxkIG5hbWVzIHRoYXQgdGhlIHBsb3QgaGFzIHJlcXVlc3RlZCBmcm9tIHRoaXMgZGF0YSBzb3VyY2UuICh3aXRob3V0IHRoZSBcIm5hbWVzcGFjZVwiIHByZWZpeClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvdXRuYW1lcyAgQXJyYXkgZGVzY3JpYmluZyBob3cgdGhlIG91dHB1dCBkYXRhIHNob3VsZCByZWZlciB0byB0aGlzIGZpZWxkLiBUaGlzIHJlcHJlc2VudHMgdGhlXG4gICAgICogICAgIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGZpZWxkIG5hbWUsIGluY2x1ZGluZyB0aGUgbmFtZXNwYWNlLiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgYGZpZWxkc2BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IHRyYW5zIFRoZSBjb2xsZWN0aW9uIG9mIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBydW4gb24gc2VsZWN0ZWQgZmllbGRzLlxuICAgICAqICAgICBUaGlzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgYGZpZWxkc2BcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IEEgY2FsbGFibGUgb3BlcmF0aW9uIHRoYXQgY2FuIGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgZGF0YSBjaGFpblxuICAgICAqL1xuICAgIGdldERhdGEoc3RhdGUsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGlmICh0aGlzLnByZUdldERhdGEpIHsgLy8gVE9ETyB0cnkgdG8gcmVtb3ZlIHRoaXMgbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAgICAgICAgY29uc3QgcHJlID0gdGhpcy5wcmVHZXREYXRhKHN0YXRlLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHByZS5zdGF0ZSB8fCBzdGF0ZTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBwcmUuZmllbGRzIHx8IGZpZWxkcztcbiAgICAgICAgICAgICAgICBvdXRuYW1lcyA9IHByZS5vdXRuYW1lcyB8fCBvdXRuYW1lcztcbiAgICAgICAgICAgICAgICB0cmFucyA9IHByZS50cmFucyB8fCB0cmFucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoY2hhaW4pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGVwZW5kZW50U291cmNlICYmIGNoYWluICYmIGNoYWluLmJvZHkgJiYgIWNoYWluLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBcImRlcGVuZGVudFwiIHNvdXJjZSBzaG91bGQgbm90IGF0dGVtcHQgdG8gZmlyZSBhIHJlcXVlc3QgaWYgdGhlcmUgaXMgbm8gZGF0YSBmb3IgaXQgdG8gYWN0IG9uLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgaXQgc2hvdWxkIHNpbXBseSByZXR1cm4gdGhlIHByZXZpb3VzIGRhdGEgY2hhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGFpbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3BvbnNlKHJlc3AsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBzb3VyY2UgZm9yIExvY3VzWm9vbSBkYXRhIHNvdXJjZXMgdGhhdCByZWNlaXZlIHRoZWlyIGRhdGEgb3ZlciB0aGUgd2ViLiBBZGRzIGRlZmF1bHQgY29uZmlnIHBhcmFtZXRlcnNcbiAqICAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGJlaGF2aW9yKSB0aGF0IGFyZSByZWxldmFudCB0byBVUkwtYmFzZWQgcmVxdWVzdHMuXG4gKi9cbmNsYXNzIEJhc2VBcGlBZGFwdGVyIGV4dGVuZHMgQmFzZUFkYXB0ZXIge1xuICAgIHBhcnNlSW5pdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIucGFyc2VJbml0KGNvbmZpZyk7XG5cbiAgICAgICAgLyoqIEBtZW1iZXIge1N0cmluZ30gKi9cbiAgICAgICAgdGhpcy51cmwgPSBjb25maWcudXJsO1xuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBub3QgaW5pdGlhbGl6ZWQgd2l0aCByZXF1aXJlZCBVUkwnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgQXNzb2NpYXRpb24gRGF0YSBmcm9tIHRoZSBMb2N1c1pvb20vIFBvcnRhbGRldiBBUEkgKG9yIGNvbXBhdGlibGUpLiBEZWZpbmVzIGhvdyB0byBtYWtlIGEgcmVxdWVzclxuICogQHB1YmxpY1xuICovXG5jbGFzcyBBc3NvY2lhdGlvbkxaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIHByZUdldERhdGEgKHN0YXRlLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICAvLyBUT0RPOiBNb2RpZnkgaW50ZXJuYWxzIHRvIHNlZSBpZiB3ZSBjYW4gZ28gd2l0aG91dCB0aGlzIG1ldGhvZFxuICAgICAgICBjb25zdCBpZF9maWVsZCA9IHRoaXMucGFyYW1zLmlkX2ZpZWxkIHx8ICdpZCc7XG4gICAgICAgIFtpZF9maWVsZCwgJ3Bvc2l0aW9uJ10uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkcy5pbmNsdWRlcyh4KSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy51bnNoaWZ0KHgpO1xuICAgICAgICAgICAgICAgIG91dG5hbWVzLnVuc2hpZnQoeCk7XG4gICAgICAgICAgICAgICAgdHJhbnMudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ZmllbGRzOiBmaWVsZHMsIG91dG5hbWVzOm91dG5hbWVzLCB0cmFuczp0cmFuc307XG4gICAgfVxuXG4gICAgZ2V0VVJMIChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCBhbmFseXNpcyA9IGNoYWluLmhlYWRlci5hbmFseXNpcyB8fCB0aGlzLnBhcmFtcy5zb3VyY2UgfHwgdGhpcy5wYXJhbXMuYW5hbHlzaXM7ICAvLyBPbGQgdXNhZ2VzIGNhbGxlZCB0aGlzIHBhcmFtIFwiYW5hbHlzaXNcIlxuICAgICAgICBpZiAodHlwZW9mIGFuYWx5c2lzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc29jaWF0aW9uIHNvdXJjZSBtdXN0IHNwZWNpZnkgYW4gYW5hbHlzaXMgSUQgdG8gcGxvdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybH1yZXN1bHRzLz9maWx0ZXI9YW5hbHlzaXMgaW4gJHthbmFseXNpc30gYW5kIGNocm9tb3NvbWUgaW4gICcke3N0YXRlLmNocn0nIGFuZCBwb3NpdGlvbiBnZSAke3N0YXRlLnN0YXJ0fSBhbmQgcG9zaXRpb24gbGUgJHtzdGF0ZS5lbmR9YDtcbiAgICB9XG5cbiAgICBub3JtYWxpemVSZXNwb25zZSAoZGF0YSkge1xuICAgICAgICAvLyBTb21lIGFzc29jaWF0aW9uIHNvdXJjZXMgZG8gbm90IHNvcnQgdGhlaXIgZGF0YSBpbiBhIHByZWRpY3RhYmxlIG9yZGVyLCB3aGljaCBtYWtlcyBpdCBoYXJkIHRvIHJlbGlhYmx5XG4gICAgICAgIC8vICBhbGlnbiB3aXRoIG90aGVyIHNvdXJjZXMgKHN1Y2ggYXMgTEQpLiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgc29ydGluZyBpcyBhbiBvcHQtaW4gYXJndW1lbnQuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vcmUgZmluZSBncmFpbmVkIHNvcnRpbmcgY29udHJvbCBpbiB0aGUgZnV0dXJlLiBUaGlzIHdhcyBhZGRlZCBhcyBhIHZlcnkgc3BlY2lmaWNcbiAgICAgICAgLy8gICB3b3JrYXJvdW5kIGZvciB0aGUgb3JpZ2luYWwgVDJEIHBvcnRhbC5cbiAgICAgICAgZGF0YSA9IHN1cGVyLm5vcm1hbGl6ZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMgJiYgdGhpcy5wYXJhbXMuc29ydCAmJiBkYXRhLmxlbmd0aCAmJiBkYXRhWzBdWydwb3NpdGlvbiddKSB7XG4gICAgICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVsncG9zaXRpb24nXSAtIGJbJ3Bvc2l0aW9uJ107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbi8qKlxuICogRmV0Y2ggbGlua2FnZSBkaXNlcXVpbGlicml1bSBpbmZvcm1hdGlvbiBmcm9tIGEgVU1pY2ggTERTZXJ2ZXItY29tcGF0aWJsZSBBUElcbiAqXG4gKiBUaGlzIHNvdXJjZSBpcyBkZXNpZ25lZCB0byBjb25uZWN0IGl0cyByZXN1bHRzIHRvIGFzc29jaWF0aW9uIGRhdGEsIGFuZCB0aGVyZWZvcmUgZGVwZW5kcyBvbiBhc3NvY2lhdGlvbiBkYXRhIGhhdmluZ1xuICogIGJlZW4gbG9hZGVkIGJ5IGEgcHJldmlvdXMgcmVxdWVzdCBpbiB0aGUgZGF0YSBjaGFpbi5cbiAqXG4gKiBJbiBvbGRlciB2ZXJzaW9ucyBvZiBMb2N1c1pvb20sIHRoaXMgd2FzIGtub3duIGFzIFwiTERTZXJ2ZXJcIi4gQSBwcmlvciBzb3VyY2UgKHRhcmdldGVkIGF0IG9sZGVyIEFQSXMpIGhhcyBiZWVuIHJlbW92ZWQuXG4gKi9cbmNsYXNzIExEU2VydmVyIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLl9fZGVwZW5kZW50U291cmNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcmVHZXREYXRhKHN0YXRlLCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCAhPT0gMiB8fCAhZmllbGRzLmluY2x1ZGVzKCdpc3JlZnZhcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMRCBkb2VzIG5vdCBrbm93IGhvdyB0byBnZXQgYWxsIGZpZWxkczogJHtmaWVsZHMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbmRNZXJnZUZpZWxkcyhjaGFpbikge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaWVsZHMgKGFzIHByb3ZpZGVkIGJ5IGEgcHJldmlvdXMgc3RlcCBpbiB0aGUgY2hhaW4sIGxpa2UgYW4gYXNzb2NpYXRpb24gc291cmNlKSB0aGF0IHdpbGwgYmUgbmVlZGVkIHRvXG4gICAgICAgIC8vICBjb21iaW5lIExEIGRhdGEgd2l0aCBleGlzdGluZyBpbmZvcm1hdGlvblxuXG4gICAgICAgIC8vIFNpbmNlIExEIGluZm9ybWF0aW9uIG1heSBiZSBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIGFzc29jIHNvdXJjZXMgd2l0aCBkaWZmZXJlbnQgbmFtZXNwYWNlcyxcbiAgICAgICAgLy8gICB3ZSB1c2UgcmVnZXggdG8gZmluZCBjb2x1bW5zIHRvIGpvaW4gb24sIHJhdGhlciB0aGFuIHJlcXVpcmluZyBleGFjdCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IGV4YWN0TWF0Y2ggPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ZXMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gcmVnZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IGFyci5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4Lm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZGF0YUZpZWxkcyA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLnBhcmFtcy5pZF9maWVsZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBhcmFtcy5wb3NpdGlvbl9maWVsZCxcbiAgICAgICAgICAgIHB2YWx1ZTogdGhpcy5wYXJhbXMucHZhbHVlX2ZpZWxkLFxuICAgICAgICAgICAgX25hbWVzXzpudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hhaW4gJiYgY2hhaW4uYm9keSAmJiBjaGFpbi5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoY2hhaW4uYm9keVswXSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lTWF0Y2ggPSBleGFjdE1hdGNoKG5hbWVzKTtcbiAgICAgICAgICAgIC8vIEludGVybmFsbHksIGZpZWxkcyBhcmUgZ2VuZXJhbGx5IHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNvdXJjZSB0aGV5IGNvbWUgZnJvbS5cbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVzIGFuIGlkX2ZpZWxkIChsaWtlIGB2YXJpYW50YCksIGl0IHNob3VsZCB3b3JrIGFjcm9zcyBkYXRhIHNvdXJjZXMoIGBhc3NvYzE6dmFyaWFudGAsXG4gICAgICAgICAgICAvLyAgYXNzb2MyOnZhcmlhbnQpLCBidXQgbm90IG1hdGNoIGZyYWdtZW50cyBvZiBvdGhlciBmaWVsZCBuYW1lcyAoYXNzb2MxOnZhcmlhbnRfdGhpbmcpXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVzZSBsb29rdXBzIGhhcmQtY29kZSBhIGNvdXBsZSBvZiBjb21tb24gZmllbGRzIHRoYXQgd2lsbCB3b3JrIGJhc2VkIG9uIGtub3duIEFQSXMgaW4gdGhlIHdpbGRcbiAgICAgICAgICAgIGNvbnN0IGlkX21hdGNoID0gZGF0YUZpZWxkcy5pZCAmJiBuYW1lTWF0Y2gobmV3IFJlZ0V4cChgJHtkYXRhRmllbGRzLmlkfVxcXFxiYCkpO1xuICAgICAgICAgICAgZGF0YUZpZWxkcy5pZCA9IGlkX21hdGNoIHx8IG5hbWVNYXRjaCgvXFxidmFyaWFudFxcYi8pIHx8IG5hbWVNYXRjaCgvXFxiaWRcXGIvKTtcbiAgICAgICAgICAgIGRhdGFGaWVsZHMucG9zaXRpb24gPSBkYXRhRmllbGRzLnBvc2l0aW9uIHx8IG5hbWVNYXRjaCgvXFxicG9zaXRpb25cXGIvaSwgL1xcYnBvc1xcYi9pKTtcbiAgICAgICAgICAgIGRhdGFGaWVsZHMucHZhbHVlID0gZGF0YUZpZWxkcy5wdmFsdWUgfHwgbmFtZU1hdGNoKC9cXGJwdmFsdWVcXGIvaSwgL1xcYmxvZ19wdmFsdWVcXGIvaSk7XG4gICAgICAgICAgICBkYXRhRmllbGRzLl9uYW1lc18gPSBuYW1lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUZpZWxkcztcbiAgICB9XG5cbiAgICBmaW5kUmVxdWVzdGVkRmllbGRzIChmaWVsZHMsIG91dG5hbWVzKSB7XG4gICAgICAgIC8vIEFzc3VtcHRpb246IGFsbCB1c2FnZXMgb2YgdGhpcyBzb3VyY2Ugd2lsbCBvbmx5IGV2ZXIgYXNrIGZvciBcImlzcmVmdmFyXCIgb3IgXCJzdGF0ZVwiLiBUaGlzIG1hcHMgdG8gb3V0cHV0IG5hbWVzLlxuICAgICAgICBsZXQgb2JqID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRzW2ldID09PSAnaXNyZWZ2YXInKSB7XG4gICAgICAgICAgICAgICAgb2JqLmlzcmVmdmFyaW4gPSBmaWVsZHNbaV07XG4gICAgICAgICAgICAgICAgb2JqLmlzcmVmdmFyb3V0ID0gb3V0bmFtZXMgJiYgb3V0bmFtZXNbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5sZGluID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgIG9iai5sZG91dCA9IG91dG5hbWVzICYmIG91dG5hbWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UgKGRhdGEpIHtcbiAgICAgICAgLy8gVGhlIExEIEFQSSBwYXlsb2FkIGRvZXMgbm90IG9iZXkgc3RhbmRhcmQgZm9ybWF0IGNvbnZlbnRpb25zOyBkbyBub3QgdHJ5IHRvIHRyYW5zZm9ybSBpdC5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBMRCByZWZlcmVuY2UgdmFyaWFudCwgd2hpY2ggYnkgZGVmYXVsdCB3aWxsIGJlIHRoZSBtb3N0IHNpZ25pZmljYW50IGhpdCBpbiB0aGUgYXNzb2MgcmVzdWx0c1xuICAgICAqICAgVGhpcyB3aWxsIGJlIHVzZWQgaW4gbWFraW5nIHRoZSBvcmlnaW5hbCBxdWVyeSB0byB0aGUgTEQgc2VydmVyIGZvciBwYWlyd2lzZSBMRCBpbmZvcm1hdGlvblxuICAgICAqIEByZXR1cm5zIHsqfHN0cmluZ30gVGhlIG1hcmtlciBpZCAoZXhwZWN0ZWQgdG8gYmUgaW4gYGNocjpwb3NfcmVmL2FsdGAgZm9ybWF0KSBvZiB0aGUgcmVmZXJlbmNlIHZhcmlhbnRcbiAgICAgKi9cbiAgICBnZXRSZWZ2YXIoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgbGV0IGZpbmRFeHRyZW1lVmFsdWUgPSBmdW5jdGlvbihyZWNvcmRzLCBwdmFsX2ZpZWxkKSB7XG4gICAgICAgICAgICAvLyBGaW5kcyB0aGUgbW9zdCBzaWduaWZpY2FudCBoaXQgKHNtYWxsZXN0IHB2YWx1ZSwgb3IgbGFyZ2VzdCAtbG9nMTBwKS4gV2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGFwcHJvcHJpYXRlIGNvbXBhcmlzb24uXG4gICAgICAgICAgICBwdmFsX2ZpZWxkID0gcHZhbF9maWVsZCB8fCAnbG9nX3B2YWx1ZSc7ICAvLyBUaGUgb2ZmaWNpYWwgTFogQVBJIHJldHVybnMgbG9nX3B2YWx1ZVxuICAgICAgICAgICAgY29uc3QgaXNfbG9nID0gL2xvZy8udGVzdChwdmFsX2ZpZWxkKTtcbiAgICAgICAgICAgIGxldCBjbXA7XG4gICAgICAgICAgICBpZiAoaXNfbG9nKSB7XG4gICAgICAgICAgICAgICAgY21wID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21wID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRyZW1lVmFsID0gcmVjb3Jkc1swXVtwdmFsX2ZpZWxkXSwgZXh0cmVtZUlkeCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY21wKHJlY29yZHNbaV1bcHZhbF9maWVsZF0sIGV4dHJlbWVWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWVWYWwgPSByZWNvcmRzW2ldW3B2YWxfZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1lSWR4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0cmVtZUlkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgcmVxRmllbGRzID0gdGhpcy5maW5kUmVxdWVzdGVkRmllbGRzKGZpZWxkcyk7XG4gICAgICAgIGxldCByZWZWYXIgPSByZXFGaWVsZHMubGRpbjtcbiAgICAgICAgaWYgKHJlZlZhciA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgcmVmVmFyID0gc3RhdGUubGRyZWZ2YXIgfHwgY2hhaW4uaGVhZGVyLmxkcmVmdmFyIHx8ICdiZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmVmFyID09PSAnYmVzdCcpIHtcbiAgICAgICAgICAgIGlmICghY2hhaW4uYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXNzb2NpYXRpb24gZGF0YSBmb3VuZCB0byBmaW5kIGJlc3QgcHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQga2V5cyA9IHRoaXMuZmluZE1lcmdlRmllbGRzKGNoYWluKTtcbiAgICAgICAgICAgIGlmICgha2V5cy5wdmFsdWUgfHwgIWtleXMuaWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1ucyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICgha2V5cy5pZCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zICs9IGAke2NvbHVtbnMubGVuZ3RoID8gJywgJyA6ICcnfWlkYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlzLnB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zICs9IGAke2NvbHVtbnMubGVuZ3RoID8gJywgJyA6ICcnfXB2YWx1ZWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgbmVjZXNzYXJ5IGNvbHVtbihzKSBmb3IgbWVyZ2U6ICR7Y29sdW1uc30gKGF2YWlsYWJsZTogJHtrZXlzLl9uYW1lc199KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmVmFyID0gY2hhaW4uYm9keVtmaW5kRXh0cmVtZVZhbHVlKGNoYWluLmJvZHksIGtleXMucHZhbHVlKV1ba2V5cy5pZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZlZhcjtcbiAgICB9XG5cbiAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgLy8gQWNjZXB0IHRoZSBmb2xsb3dpbmcgcGFyYW1zIGluIHRoaXMucGFyYW1zOlxuICAgICAgICAvLyAtIG1ldGhvZCAociwgcnNxdWFyZSwgY292KVxuICAgICAgICAvLyAtIHNvdXJjZSAoYWthIHBhbmVsKVxuICAgICAgICAvLyAtIHBvcHVsYXRpb24gKEFMTCwgQUZSLCBFVVIsIGV0YylcbiAgICAgICAgLy8gLSBidWlsZFxuICAgICAgICAvLyBUaGUgTEQgc291cmNlL3BvcCBjYW4gYmUgb3ZlcnJpZGRlbiBmcm9tIHBsb3Quc3RhdGUgZm9yIGR5bmFtaWMgbGF5b3V0c1xuICAgICAgICBjb25zdCBidWlsZCA9IHN0YXRlLmdlbm9tZV9idWlsZCB8fCB0aGlzLnBhcmFtcy5idWlsZCB8fCAnR1JDaDM3JztcbiAgICAgICAgbGV0IHNvdXJjZSA9IHN0YXRlLmxkX3NvdXJjZSB8fCB0aGlzLnBhcmFtcy5zb3VyY2UgfHwgJzEwMDBHJztcbiAgICAgICAgY29uc3QgcG9wdWxhdGlvbiA9IHN0YXRlLmxkX3BvcCB8fCB0aGlzLnBhcmFtcy5wb3B1bGF0aW9uIHx8ICdBTEwnOyAgLy8gTERTZXJ2ZXIgcGFuZWxzIHdpbGwgYWx3YXlzIGhhdmUgYW4gQUxMXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMucGFyYW1zLm1ldGhvZCB8fCAncnNxdWFyZSc7XG5cbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJzEwMDBHJyAmJiBidWlsZCA9PT0gJ0dSQ2gzOCcpIHtcbiAgICAgICAgICAgIC8vIEZvciBidWlsZCAzOCAob25seSksIHRoZXJlIGlzIGEgbmV3ZXIvaW1wcm92ZWQgMTAwMEcgTEQgcGFuZWwgYXZhaWxhYmxlIHRoYXQgdXNlcyBXR1MgZGF0YS4gQXV0byB1cGdyYWRlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBzb3VyY2UgPSAnMTAwMEctRlJaMDknO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdGVCdWlsZFNvdXJjZSh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGJ1aWxkLCBudWxsKTsgIC8vIExEIGRvZXNuJ3QgbmVlZCB0byB2YWxpZGF0ZSBgc291cmNlYCBvcHRpb25cblxuICAgICAgICBsZXQgcmVmVmFyID0gdGhpcy5nZXRSZWZ2YXIoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICAvLyBTb21lIGRhdGFzZXRzLCBub3RhYmx5IHRoZSBQb3J0YWwsIHVzZSBhIGRpZmZlcmVudCBtYXJrZXIgZm9ybWF0LlxuICAgICAgICAvLyAgQ29lcmNlIGl0IGludG8gb25lIHRoYXQgd2lsbCB3b3JrIHdpdGggdGhlIExEU2VydmVyIEFQSS4gKENIUk9NOlBPU19SRUYvQUxUKVxuICAgICAgICBjb25zdCBSRUdFWF9NQVJLRVIgPSAvXig/OmNocik/KFthLXpBLVowLTldKz8pW186LV0oXFxkKylbXzp8LV0/KFxcdyspP1svXzp8LV0/KFteX10rKT9fPyguKik/LztcbiAgICAgICAgY29uc3QgbWF0Y2ggPSByZWZWYXIgJiYgcmVmVmFyLm1hdGNoKFJFR0VYX01BUktFUik7XG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVxdWVzdCBMRCBmb3IgYSBtaXNzaW5nIG9yIGluY29tcGxldGUgbWFya2VyIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvcmlnaW5hbCwgY2hyb20sIHBvcywgcmVmLCBhbHRdID0gbWF0Y2g7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgdGhlIExEIHNlcnZlciBvbmx5IGFjY2VwdHMgZnVsbCB2YXJpYW50IHNwZWNzOyBpdCB3b24ndCByZXR1cm4gTEQgdy9vIHJlZithbHQuIEFsbG93aW5nXG4gICAgICAgIC8vICBhIHBhcnRpYWwgbWF0Y2ggYXQgbW9zdCBsZWF2ZXMgcm9vbSBmb3IgcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlcy5cbiAgICAgICAgcmVmVmFyID0gYCR7Y2hyb219OiR7cG9zfWA7XG4gICAgICAgIGlmIChyZWYgJiYgYWx0KSB7XG4gICAgICAgICAgICByZWZWYXIgKz0gYF8ke3JlZn0vJHthbHR9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgdXNlci1wcm92aWRlZCB2YXJpYW50IHNwZWMgZm9yIHVzZSB3aGVuIG1hdGNoaW5nIHRvIGFzc29jIGRhdGFcbiAgICAgICAgY2hhaW4uaGVhZGVyLmxkcmVmdmFyID0gb3JpZ2luYWw7XG5cbiAgICAgICAgcmV0dXJuICBbXG4gICAgICAgICAgICB0aGlzLnVybCwgJ2dlbm9tZV9idWlsZHMvJywgYnVpbGQsICcvcmVmZXJlbmNlcy8nLCBzb3VyY2UsICcvcG9wdWxhdGlvbnMvJywgcG9wdWxhdGlvbiwgJy92YXJpYW50cycsXG4gICAgICAgICAgICAnP2NvcnJlbGF0aW9uPScsIG1ldGhvZCxcbiAgICAgICAgICAgICcmdmFyaWFudD0nLCBlbmNvZGVVUklDb21wb25lbnQocmVmVmFyKSxcbiAgICAgICAgICAgICcmY2hyb209JywgZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlLmNociksXG4gICAgICAgICAgICAnJnN0YXJ0PScsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS5zdGFydCksXG4gICAgICAgICAgICAnJnN0b3A9JywgZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlLmVuZCksXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgfVxuXG4gICAgY29tYmluZUNoYWluQm9keShkYXRhLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgbGV0IGtleXMgPSB0aGlzLmZpbmRNZXJnZUZpZWxkcyhjaGFpbik7XG4gICAgICAgIGxldCByZXFGaWVsZHMgPSB0aGlzLmZpbmRSZXF1ZXN0ZWRGaWVsZHMoZmllbGRzLCBvdXRuYW1lcyk7XG4gICAgICAgIGlmICgha2V5cy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBwb3NpdGlvbiBmaWVsZCBmb3IgbWVyZ2U6ICR7a2V5cy5fbmFtZXNffWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRKb2luID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBsZmllbGQsIHJmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwLCBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVmdC5sZW5ndGggJiYgaiA8IHJpZ2h0LnBvc2l0aW9uMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdFtpXVtrZXlzLnBvc2l0aW9uXSA9PT0gcmlnaHQucG9zaXRpb24yW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRbaV1bbGZpZWxkXSA9IHJpZ2h0W3JmaWVsZF1bal07XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdFtpXVtrZXlzLnBvc2l0aW9uXSA8IHJpZ2h0LnBvc2l0aW9uMltqXSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGFnUmVmVmFyaWFudCA9IGZ1bmN0aW9uIChkYXRhLCByZWZ2YXIsIGlkZmllbGQsIG91dHJlZm5hbWUsIG91dGxkbmFtZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV1baWRmaWVsZF0gJiYgZGF0YVtpXVtpZGZpZWxkXSA9PT0gcmVmdmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bb3V0cmVmbmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW291dGxkbmFtZV0gPSAxOyAvLyBGb3IgbGFiZWwvZmlsdGVyIHB1cnBvc2VzLCBpbXBsaWNpdGx5IG1hcmsgdGhlIHJlZiB2YXIgYXMgTEQ9MSB0byBpdHNlbGZcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW291dHJlZm5hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTEQgc2VydmVycyB2YXJ5IHNsaWdodGx5LiBTb21lIHJlcG9ydCBjb3JyIGFzIFwicnNxdWFyZVwiLCBvdGhlcnMgYXMgXCJjb3JyZWxhdGlvblwiXG4gICAgICAgIGxldCBjb3JyRmllbGQgPSBkYXRhLnJzcXVhcmUgPyAncnNxdWFyZScgOiAnY29ycmVsYXRpb24nO1xuICAgICAgICBsZWZ0Sm9pbihjaGFpbi5ib2R5LCBkYXRhLCByZXFGaWVsZHMubGRvdXQsIGNvcnJGaWVsZCk7XG4gICAgICAgIGlmIChyZXFGaWVsZHMuaXNyZWZ2YXJpbiAmJiBjaGFpbi5oZWFkZXIubGRyZWZ2YXIpIHtcbiAgICAgICAgICAgIHRhZ1JlZlZhcmlhbnQoY2hhaW4uYm9keSwgY2hhaW4uaGVhZGVyLmxkcmVmdmFyLCBrZXlzLmlkLCByZXFGaWVsZHMuaXNyZWZ2YXJvdXQsIHJlcUZpZWxkcy5sZG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWluLmJvZHk7XG4gICAgfVxuXG4gICAgZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIFRoZSBBUEkgaXMgcGFnaW5hdGVkLCBidXQgd2UgbmVlZCBhbGwgb2YgdGhlIGRhdGEgdG8gcmVuZGVyIGEgcGxvdC4gRGVwYWdpbmF0ZSBhbmQgY29tYmluZSB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICAgICAgbGV0IHVybCA9IHRoaXMuZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgbGV0IGNvbWJpbmVkID0geyBkYXRhOiB7fSB9O1xuICAgICAgICBsZXQgY2hhaW5SZXF1ZXN0cyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGF5bG9hZC5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQuZGF0YVtrZXldID0gKGNvbWJpbmVkLmRhdGFba2V5XSB8fCBbXSkuY29uY2F0KHBheWxvYWQuZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpblJlcXVlc3RzKHBheWxvYWQubmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2hhaW5SZXF1ZXN0cyh1cmwpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIHNvdXJjZSBmb3IgR1dBUyBjYXRhbG9ncyBvZiBrbm93biB2YXJpYW50c1xuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGluaXQgQ29uZmlndXJhdGlvbiAoVVJMIG9yIG9iamVjdClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5pdC5wYXJhbXNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtpbml0LnBhcmFtcy5zb3VyY2U9Ml0gVGhlIElEIG9mIHRoZSBjaG9zZW4gY2F0YWxvZy4gRGVmYXVsdHMgdG8gRUJJIEdXQVMgY2F0YWxvZywgR1JDaDM3XG4gKiBAcGFyYW0geygnc3RyaWN0J3wnbG9vc2UnKX0gW2luaXQucGFyYW1zLm1hdGNoX3R5cGU9J3N0cmljdCddIFdoZXRoZXIgdG8gbWF0Y2ggb24gZXhhY3QgdmFyaWFudCwgb3IganVzdCBwb3NpdGlvbi5cbiAqL1xuY2xhc3MgR3dhc0NhdGFsb2dMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fX2RlcGVuZGVudFNvdXJjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWxpZ25lZCB3aXRoIGFub3RoZXIgc291cmNlLSB3ZSB3aWxsIGFzc3VtZSB0aGV5IGFyZSBhbHdheXMgb3JkZXJlZCBieSBwb3NpdGlvbiwgYXNjXG4gICAgICAgIC8vICAocmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIG1hdGNoIGZpZWxkKVxuICAgICAgICBjb25zdCBidWlsZF9vcHRpb24gPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIHZhbGlkYXRlQnVpbGRTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBidWlsZF9vcHRpb24sIG51bGwpOyAvLyBTb3VyY2UgY2FuIG92ZXJyaWRlIGJ1aWxkLSBub3QgbXV0dWFsbHkgZXhjbHVzaXZlXG5cbiAgICAgICAgLy8gTW9zdCBvZiBvdXIgYW5ub3RhdGlvbnMgd2lsbCByZXNwZWN0IGdlbm9tZSBidWlsZCBiZWZvcmUgYW55IG90aGVyIG9wdGlvbi5cbiAgICAgICAgLy8gICBCdXQgdGhlcmUgY2FuIGJlIG1vcmUgdGhhbiBvbmUgR1dBUyBjYXRhbG9nIHZlcnNpb24gYXZhaWxhYmxlIGluIHRoZSBzYW1lIEFQSSwgZm9yIHRoZSBzYW1lIGJ1aWxkLSBhblxuICAgICAgICAvLyAgIGV4cGxpY2l0IGNvbmZpZyBvcHRpb24gd2lsbCBhbHdheXMgdGFrZVxuICAgICAgICAvLyAgIHByZWNlZGVuY2UuXG4gICAgICAgIC8vIFNlZTogaHR0cDovL3BvcnRhbGRldi5zcGgudW1pY2guZWR1L2FwaS92MS9hbm5vdGF0aW9uL2d3YXNjYXRhbG9nLz9mb3JtYXQ9b2JqZWN0c1xuICAgICAgICBjb25zdCBkZWZhdWx0X3NvdXJjZSA9IChidWlsZF9vcHRpb24gPT09ICdHUkNoMzgnKSA/IDUgOiA2OyAgLy8gRUJJIEdXQVMgY2F0YWxvZ1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnBhcmFtcy5zb3VyY2UgfHwgZGVmYXVsdF9zb3VyY2U7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybCAgfT9mb3JtYXQ9b2JqZWN0cyZzb3J0PXBvcyZmaWx0ZXI9aWQgZXEgJHtzb3VyY2V9IGFuZCBjaHJvbSBlcSAnJHtzdGF0ZS5jaHJ9JyBhbmQgcG9zIGdlICR7c3RhdGUuc3RhcnR9IGFuZCBwb3MgbGUgJHtzdGF0ZS5lbmR9YDtcbiAgICB9XG5cbiAgICBmaW5kTWVyZ2VGaWVsZHMocmVjb3Jkcykge1xuICAgICAgICAvLyBEYXRhIGZyb20gcHJldmlvdXMgc291cmNlcyBpcyBhbHJlYWR5IG5hbWVzcGFjZWQuIEZpbmQgdGhlIGFsaWdubWVudCBmaWVsZCBieSBtYXRjaGluZy5cbiAgICAgICAgY29uc3Qga25vd25GaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmRzKTtcbiAgICAgICAgLy8gTm90ZTogQWxsIEFQSSBlbmRvaW50cyBpbnZvbHZlZCBvbmx5IGdpdmUgcmVzdWx0cyBmb3IgMSBjaHJvbW9zb21lIGF0IGEgdGltZTsgbWF0Y2ggaXMgaW1wbGllZFxuICAgICAgICBjb25zdCBwb3NNYXRjaCA9IGtub3duRmllbGRzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm1hdGNoKC9cXGIocG9zaXRpb258cG9zKVxcYi9pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwb3NNYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBkYXRhIHRvIGFsaWduIHdpdGggR1dBUyBjYXRhbG9nIHJlc3VsdHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAncG9zJzogcG9zTWF0Y2ggfTtcbiAgICB9XG5cbiAgICBleHRyYWN0RmllbGRzIChkYXRhLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICAvLyBTa2lwIHRoZSBcImluZGl2aWR1YWwgZmllbGQgZXh0cmFjdGlvblwiIHN0ZXA7IGV4dHJhY3Rpb24gd2lsbCBiZSBoYW5kbGVkIHdoZW4gYnVpbGRpbmcgY2hhaW4gYm9keSBpbnN0ZWFkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFRPRE86IEJldHRlciByZXVzZSBvcHRpb25zIGluIHRoZSBmdXR1cmUuIFRoaXMgc291cmNlIGlzIHZlcnkgc3BlY2lmaWNhbGx5IHRpZWQgdG8gdGhlIFBvcnRhbERldiBBUEksIHdoZXJlXG4gICAgICAgIC8vICAgdGhlIGZpZWxkIG5hbWUgaXMgYWx3YXlzIFwibG9nX3B2YWx1ZVwiLiBSZWxhdGl2ZWx5IGZldyBzaXRlcyB3aWxsIHdyaXRlIHRoZWlyIG93biBnd2FzLWNhdGFsb2cgZW5kcG9pbnQuXG4gICAgICAgIGNvbnN0IGRlY2lkZXIgPSAnbG9nX3B2YWx1ZSc7XG4gICAgICAgIGNvbnN0IGRlY2lkZXJfb3V0ID0gb3V0bmFtZXNbZmllbGRzLmluZGV4T2YoZGVjaWRlcildO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxlZnRKb2luKGxlZnQsIHJpZ2h0LCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykgeyAvLyBBZGQgYGZpZWxkc2AgZnJvbSBgcmlnaHRgIHRvIGBsZWZ0YFxuICAgICAgICAgICAgLy8gQWRkIGEgc3ludGhldGljLCB1bi1uYW1lc3BhY2VkIGZpZWxkIHRvIGFsbCBtYXRjaGluZyByZWNvcmRzXG4gICAgICAgICAgICBjb25zdCBuX21hdGNoZXMgPSBsZWZ0WyduX2NhdGFsb2dfbWF0Y2hlcyddIHx8IDA7XG4gICAgICAgICAgICBsZWZ0WyduX2NhdGFsb2dfbWF0Y2hlcyddID0gbl9tYXRjaGVzICsgMTtcbiAgICAgICAgICAgIGlmIChkZWNpZGVyICYmIGxlZnRbZGVjaWRlcl9vdXRdICYmIGxlZnRbZGVjaWRlcl9vdXRdID4gcmlnaHRbZGVjaWRlcl0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBHV0FTIGNhdGFsb2cgZW50cnkgZm9yIHRoZSBzYW1lIFNOUC4gVGhpcyBzb3VyY2UgaXMgaW50ZW5kZWQgZm9yIGEgMToxXG4gICAgICAgICAgICAgICAgLy8gIGFubm90YXRpb24gc2NlbmFyaW8sIHNvIGZvciBub3cgaXQgb25seSBqb2lucyB0aGUgY2F0YWxvZyBlbnRyeSB0aGF0IGhhcyB0aGUgYmVzdCAtbG9nMTAgcHZhbHVlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dG4gPSBvdXRuYW1lc1tqXTtcblxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSByaWdodFtmbl07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICYmIHRyYW5zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRyYW5zW2pdKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnRbb3V0bl0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGFpbk5hbWVzID0gdGhpcy5maW5kTWVyZ2VGaWVsZHMoY2hhaW4uYm9keVswXSk7XG4gICAgICAgIGNvbnN0IGNhdE5hbWVzID0gdGhpcy5maW5kTWVyZ2VGaWVsZHMoZGF0YVswXSk7XG5cbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBjaGFpbi5ib2R5Lmxlbmd0aCAmJiBqIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gY2hhaW4uYm9keVtpXTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGRhdGFbal07XG5cbiAgICAgICAgICAgIGlmIChsZWZ0W2NoYWluTmFtZXMucG9zXSA9PT0gcmlnaHRbY2F0TmFtZXMucG9zXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBtdWx0aXBsZSBjYXRhbG9nIGVudHJpZXMgZm9yIGVhY2ggbWF0Y2hpbmcgU05QOyBldmFsdWF0ZSBtYXRjaCBvbmUgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgbGVmdEpvaW4obGVmdCwgcmlnaHQsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnRbY2hhaW5OYW1lcy5wb3NdIDwgcmlnaHRbY2F0TmFtZXMucG9zXSkge1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgR2VuZSBEYXRhLCBhcyBmZXRjaGVkIGZyb20gdGhlIExvY3VzWm9vbS9Qb3J0YWxkZXYgQVBJIHNlcnZlciAob3IgY29tcGF0aWJsZSBmb3JtYXQpXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEdlbmVMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYnVpbGQgPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnBhcmFtcy5zb3VyY2U7XG4gICAgICAgIHZhbGlkYXRlQnVpbGRTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBidWlsZCwgc291cmNlKTtcblxuICAgICAgICBpZiAoYnVpbGQpIHtcbiAgICAgICAgICAgIC8vIElmIGJ1aWxkIHNwZWNpZmllZCwgd2UgYXV0by1zZWxlY3QgdGhlIGJlc3QgY3VycmVudCBwb3J0YWxkZXYgQVBJIGRhdGFzZXQgZm9yIHRoYXQgYnVpbGRcbiAgICAgICAgICAgIC8vIElmIGJ1aWxkIGlzIG5vdCBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZXhhY3Qgc291cmNlIElEIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL3BvcnRhbGRldi5zcGgudW1pY2guZWR1L2FwaS92MS9hbm5vdGF0aW9uL2dlbmVzL3NvdXJjZXMvP2Zvcm1hdD1vYmplY3RzXG4gICAgICAgICAgICBzb3VyY2UgPSAoYnVpbGQgPT09ICdHUkNoMzgnKSA/IDQgOiA1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybH0/ZmlsdGVyPXNvdXJjZSBpbiAke3NvdXJjZX0gYW5kIGNocm9tIGVxICcke3N0YXRlLmNocn0nIGFuZCBzdGFydCBsZSAke3N0YXRlLmVuZH0gYW5kIGVuZCBnZSAke3N0YXRlLnN0YXJ0fWA7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICAvLyBHZW5lcyBoYXZlIGEgdmVyeSBjb21wbGV4IGludGVybmFsIGRhdGEgZm9ybWF0LiBCeXBhc3MgYW55IHJlY29yZCBwYXJzaW5nLCBhbmQgcHJvdmlkZSB0aGUgZGF0YSBsYXllciB3aXRoXG4gICAgICAgIC8vIHRoZSBleGFjdCBpbmZvcm1hdGlvbiByZXR1cm5lZCBieSB0aGUgQVBJLiAoaWdub3JpbmcgdGhlIGZpZWxkcyBhcnJheSBpbiB0aGUgbGF5b3V0KVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBleHRyYWN0RmllbGRzKGRhdGEsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgR2VuZSBDb25zdHJhaW50IERhdGEsIGFzIGZldGNoZWQgZnJvbSB0aGUgZ25vbUFEIHNlcnZlciAob3IgY29tcGF0aWJsZSlcbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHRoZSBzZWNvbmQgcmVxdWVzdCBpbiBhIGNoYWluLCB3aXRoIHNwZWNpYWwgbG9naWMgdGhhdCBjb25uZWN0cyBpdCB0byBHZW5lcyBkYXRhXG4gKiAgYWxyZWFkeSBmZXRjaGVkLlxuICpcbiAqIEBwdWJsaWNcbiovXG5jbGFzcyBHZW5lQ29uc3RyYWludExaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLl9fZGVwZW5kZW50U291cmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0VVJMKCkge1xuICAgICAgICAvLyBHcmFwaFFMIEFQSTogcmVxdWVzdCBkZXRhaWxzIGFyZSBlbmNvZGVkIGluIHRoZSBib2R5LCBub3QgdGhlIFVSTFxuICAgICAgICByZXR1cm4gdGhpcy51cmw7XG4gICAgfVxuICAgIGdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkID0gc3RhdGUuZ2Vub21lX2J1aWxkIHx8IHRoaXMucGFyYW1zLmJ1aWxkO1xuICAgICAgICAvLyBHcmFwaFFMIEFQSTogcmVxdWVzdCBub3QgZGVmaW5lZCBzb2xlbHkgYnkgdGhlIFVSTFxuICAgICAgICAvLyBHYXRoZXIgdGhlIHN0YXRlIHBhcmFtcyB0aGF0IGdvdmVybiBjb25zdHJhaW50IHF1ZXJ5IGZvciBhIGdpdmVuIHJlZ2lvbi5cbiAgICAgICAgcmV0dXJuIGAke3RoaXMudXJsfSAke3N0YXRlLmNocn0gJHtzdGF0ZS5zdGFydH0gJHtzdGF0ZS5lbmR9ICR7YnVpbGR9YDtcbiAgICB9XG5cbiAgICBub3JtYWxpemVSZXNwb25zZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZldGNoUmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCBidWlsZCA9IHN0YXRlLmdlbm9tZV9idWlsZCB8fCB0aGlzLnBhcmFtcy5idWlsZDtcbiAgICAgICAgaWYgKCFidWlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIHNvdXJjZSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gbXVzdCBzcGVjaWZ5IGEgJ2dlbm9tZV9idWlsZCcgb3B0aW9uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1bmlxdWVfZ2VuZV9uYW1lcyA9IGNoYWluLmJvZHkucmVkdWNlKFxuICAgICAgICAgICAgLy8gSW4gcmFyZSBjYXNlcywgdGhlIHNhbWUgZ2VuZSBzeW1ib2wgbWF5IGFwcGVhciBhdCBtdWx0aXBsZSBwb3NpdGlvbnMuIChpc3N1ZSAjMTc5KSBXZSBkZS1kdXBsaWNhdGUgdGhlXG4gICAgICAgICAgICAvLyAgZ2VuZSBuYW1lcyB0byBhdm9pZCBpc3N1aW5nIGEgbWFsZm9ybWVkIEdyYXBoUUwgcXVlcnkuXG4gICAgICAgICAgICBmdW5jdGlvbiAoYWNjLCBnZW5lKSB7XG4gICAgICAgICAgICAgICAgYWNjW2dlbmUuZ2VuZV9uYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7fVxuICAgICAgICApO1xuICAgICAgICBsZXQgcXVlcnkgPSBPYmplY3Qua2V5cyh1bmlxdWVfZ2VuZV9uYW1lcykubWFwKGZ1bmN0aW9uIChnZW5lX25hbWUpIHtcbiAgICAgICAgICAgIC8vIEdyYXBoUUwgYWxpYXMgbmFtZXMgbXVzdCBtYXRjaCBhIHNwZWNpZmljIHNldCBvZiBhbGxvd2VkIGNoYXJhY3RlcnM6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc1NzA2NS8xNDIyMjY4XG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IGBfJHtnZW5lX25hbWUucmVwbGFjZSgvW15BLVphLXowLTlfXS9nLCAnXycpfWA7XG4gICAgICAgICAgICAvLyBFYWNoIGdlbmUgc3ltYm9sIGlzIGEgc2VwYXJhdGUgZ3JhcGhRTCBxdWVyeSwgZ3JvdXBlZCBpbnRvIG9uZSByZXF1ZXN0IHVzaW5nIGFsaWFzZXNcbiAgICAgICAgICAgIHJldHVybiBgJHthbGlhc306IGdlbmUoZ2VuZV9zeW1ib2w6IFwiJHtnZW5lX25hbWV9XCIsIHJlZmVyZW5jZV9nZW5vbWU6ICR7YnVpbGR9KSB7IGdub21hZF9jb25zdHJhaW50IHsgZXhwX3N5biBvYnNfc3luIHN5bl96IG9lX3N5biBvZV9zeW5fbG93ZXIgb2Vfc3luX3VwcGVyIGV4cF9taXMgb2JzX21pcyBtaXNfeiBvZV9taXMgb2VfbWlzX2xvd2VyIG9lX21pc191cHBlciBleHBfbG9mIG9ic19sb2YgcExJIG9lX2xvZiBvZV9sb2ZfbG93ZXIgb2VfbG9mX3VwcGVyIH0gfSBgO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGdlbmVzLCBza2lwIHRoZSBuZXR3b3JrIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBudWxsIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVlcnkgPSBgeyR7cXVlcnkuam9pbignICcpfSB9YDsgLy8gR3JhcGhRTCBpc24ndCBxdWl0ZSBKU09OOyBpdGVtcyBhcmUgc2VwYXJhdGVkIGJ5IHNwYWNlcyBidXQgbm90IGNvbW1hc1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9ncmFwaHFsLm9yZy9sZWFybi9zZXJ2aW5nLW92ZXItaHR0cC9cbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgcXVlcnk6IHF1ZXJ5IH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG5cbiAgICAgICAgLy8gRklYTUU6IFRoZSBnbm9tQUQgQVBJIHNvbWV0aW1lcyBoYXMgdGVtcG9yYXJ5IENPUlMgY2hhbmdlcyB0aGF0IHRlbXBvcmFyaWx5IGJyZWFrIHRoZSBnZW5lcyB0cmFja1xuICAgICAgICAvLyBJZiByZXF1ZXN0IGJsb2NrZWQsIHJldHVybiAgYSBmYWtlIFwibm8gZGF0YVwiIHNpZ25hbCBzbyB0aGUgZ2VuZXMgdHJhY2sgY2FuIHN0aWxsIHJlbmRlciB3L28gY29uc3RyYWludCBpbmZvXG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHksIGhlYWRlcnMgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiBbXSk7XG4gICAgfVxuXG4gICAgY29tYmluZUNoYWluQm9keShkYXRhLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgIH1cblxuICAgICAgICBjaGFpbi5ib2R5LmZvckVhY2goZnVuY3Rpb24oZ2VuZSkge1xuICAgICAgICAgICAgLy8gRmluZCBwYXlsb2FkIGtleXMgdGhhdCBtYXRjaCBnZW5lIG5hbWVzIGluIHRoaXMgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gYF8ke2dlbmUuZ2VuZV9uYW1lLnJlcGxhY2UoL1teQS1aYS16MC05X10vZywgJ18nKX1gOyAgLy8gYWxpYXNlcyBhcmUgbW9kaWZpZWQgZ2VuZSBuYW1lc1xuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludCA9IGRhdGFbYWxpYXNdICYmIGRhdGFbYWxpYXNdWydnbm9tYWRfY29uc3RyYWludCddOyAvLyBnbm9tYWQgQVBJIGhhcyB0d28gd2F5cyBvZiBzcGVjaWZ5aW5nIG1pc3NpbmcgZGF0YSBmb3IgYSByZXF1ZXN0ZWQgZ2VuZVxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIGZpZWxkcyBmcm9tIGNvbnN0cmFpbnQgZGF0YS0gZG8gbm90IG92ZXJyaWRlIGZpZWxkcyBwcmVzZW50IGluIHRoZSBnZW5lIHNvdXJjZVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnN0cmFpbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gY29uc3RyYWludFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdlbmVba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09ICdudW1iZXInICYmIHZhbC50b1N0cmluZygpLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbC50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVba2V5XSA9IHZhbDsgICAvLyBUaGVzZSB0d28gc291cmNlcyBhcmUgYm90aCBkZXNpZ25lZCB0byBieXBhc3MgbmFtZXNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYWluLmJvZHk7XG4gICAgfVxufVxuXG4vKipcbiAqIERhdGEgU291cmNlIGZvciBSZWNvbWJpbmF0aW9uIFJhdGUgRGF0YSwgYXMgZmV0Y2hlZCBmcm9tIHRoZSBMb2N1c1pvb20gQVBJIHNlcnZlciAob3IgY29tcGF0aWJsZSlcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUmVjb21iTFogZXh0ZW5kcyBCYXNlQXBpQWRhcHRlciB7XG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkID0gc3RhdGUuZ2Vub21lX2J1aWxkIHx8IHRoaXMucGFyYW1zLmJ1aWxkO1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5wYXJhbXMuc291cmNlO1xuICAgICAgICB2YWxpZGF0ZUJ1aWxkU291cmNlKHRoaXMuY29uc3RydWN0b3IuU09VUkNFX05BTUUsIGJ1aWxkLCBzb3VyY2UpO1xuXG4gICAgICAgIGlmIChidWlsZCkgeyAvLyBJZiBidWlsZCBzcGVjaWZpZWQsIGNob29zZSBhIGtub3duIFBvcnRhbCBBUEkgZGF0YXNldCBJRHMgKGJ1aWxkIDM3LzM4KVxuICAgICAgICAgICAgc291cmNlID0gKGJ1aWxkID09PSAnR1JDaDM4JykgPyAxNiA6IDE1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybH0/ZmlsdGVyPWlkIGluICR7c291cmNlfSBhbmQgY2hyb21vc29tZSBlcSAnJHtzdGF0ZS5jaHJ9JyBhbmQgcG9zaXRpb24gbGUgJHtzdGF0ZS5lbmR9IGFuZCBwb3NpdGlvbiBnZSAke3N0YXRlLnN0YXJ0fWA7XG4gICAgfVxufVxuXG4vKipcbiAqIERhdGEgU291cmNlIGZvciBzdGF0aWMgYmxvYnMgb2YgZGF0YSBhcyByYXcgSlMgb2JqZWN0cy4gVGhpcyBkb2VzIG5vdCBwZXJmb3JtIGFkZGl0aW9uYWwgcGFyc2luZywgYW5kIGl0IGJ5cGFzc2VzXG4gKiBuYW1lc3BhY2VzLiBUaGVyZWZvcmUgaXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyIHRvIHBhc3MgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgdGhhdCBjYW4gYmUgcmVhZCBhbmRcbiAqIHVuZGVyc3Rvb2QgYnkgdGhlIGNob3NlbiBwbG90LSBhIFN0YXRpY0pTT04gc291cmNlIGlzIHJhcmVseSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQuXG4gKlxuICogVGhpcyBzb3VyY2UgaXMgbGFyZ2VseSBoZXJlIGZvciBsZWdhY3kgcmVhc29ucy4gTW9yZSBvZnRlbiwgYSBjb252ZW5pZW50IHdheSB0byBzZXJ2ZSBzdGF0aWMgZGF0YSBpcyBhcyBzZXBhcmF0ZVxuICogIEpTT04gZmlsZXMgdG8gYW4gZXhpc3Rpbmcgc291cmNlICh3aXRoIHRoZSBKU09OIHVybCBpbiBwbGFjZSBvZiBhbiBBUEkpLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTdGF0aWNTb3VyY2UgZXh0ZW5kcyBCYXNlQWRhcHRlciB7XG4gICAgcGFyc2VJbml0KGRhdGEpIHtcbiAgICAgICAgLy8gRG9lcyBub3QgcmVjZWl2ZSBhbnkgY29uZmlnOyB0aGUgb25seSBhcmd1bWVudCBpcyB0aGUgcmF3IGRhdGEsIGVtYmVkZGVkIHdoZW4gc291cmNlIGlzIGNyZWF0ZWRcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGdldFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9kYXRhKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBEYXRhIHNvdXJjZSBmb3IgUGhlV0FTIGRhdGEgcmV0cmlldmVkIGZyb20gYSBMb2N1c1pvb20vUG9ydGFsRGV2IGNvbXBhdGlibGUgQVBJXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBpbml0LnBhcmFtcy5idWlsZCBUaGlzIGRhdGFzb3VyY2UgZXhwZWN0cyB0byBiZSBwcm92aWRlZCB0aGUgbmFtZSBvZiB0aGUgZ2Vub21lIGJ1aWxkIHRoYXQgd2lsbFxuICogICBiZSB1c2VkIHRvIHByb3ZpZGUgcGhlV0FTIHJlc3VsdHMgZm9yIHRoaXMgcG9zaXRpb24uIE5vdGUgcG9zaXRpb25zIG1heSBub3QgdHJhbnNsYXRlIGJldHdlZW4gYnVpbGRzLlxuICovXG5jbGFzcyBQaGVXQVNMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYnVpbGQgPSAoc3RhdGUuZ2Vub21lX2J1aWxkID8gW3N0YXRlLmdlbm9tZV9idWlsZF0gOiBudWxsKSB8fCB0aGlzLnBhcmFtcy5idWlsZDtcbiAgICAgICAgaWYgKCFidWlsZCB8fCAhQXJyYXkuaXNBcnJheShidWlsZCkgfHwgIWJ1aWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFsnRGF0YSBzb3VyY2UnLCB0aGlzLmNvbnN0cnVjdG9yLlNPVVJDRV9OQU1FLCAncmVxdWlyZXMgdGhhdCB5b3Ugc3BlY2lmeSBhcnJheSBvZiBvbmUgb3IgbW9yZSBkZXNpcmVkIGdlbm9tZSBidWlsZCBuYW1lcyddLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gW1xuICAgICAgICAgICAgdGhpcy51cmwsXG4gICAgICAgICAgICBcIj9maWx0ZXI9dmFyaWFudCBlcSAnXCIsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS52YXJpYW50KSwgXCInJmZvcm1hdD1vYmplY3RzJlwiLFxuICAgICAgICAgICAgYnVpbGQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBidWlsZD0ke2VuY29kZVVSSUNvbXBvbmVudChpdGVtKX1gO1xuICAgICAgICAgICAgfSkuam9pbignJicpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdXJsLmpvaW4oJycpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFwiY29ubmVjdG9yc1wiLSB0aGlzIGlzIG1lYW50IHRvIGJlIHN1YmNsYXNzZWQsIHJhdGhlciB0aGFuIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQSBjb25uZWN0b3IgaXMgYSBzb3VyY2UgdGhhdCBtYWtlcyBubyBzZXJ2ZXIgcmVxdWVzdHMgYW5kIGNhY2hlcyBubyBkYXRhIG9mIGl0cyBvd24uIEluc3RlYWQsIGl0IGRlY2lkZXMgaG93IHRvXG4gKiAgY29tYmluZSBkYXRhIGZyb20gb3RoZXIgc291cmNlcyBpbiB0aGUgY2hhaW4uIENvbm5lY3RvcnMgYXJlIHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8gcmVxdWVzdCAob3IgY2FsY3VsYXRlKSBzb21lXG4gKiAgdXNlZnVsIHBpZWNlIG9mIGluZm9ybWF0aW9uIG9uY2UsIGJ1dCBhcHBseSBpdCB0byBtYW55IGRpZmZlcmVudCBraW5kcyBvZiByZWNvcmQgdHlwZXMuXG4gKlxuICogVHlwaWNhbGx5LCBhIHN1YmNsYXNzIHdpbGwgaW1wbGVtZW50IHRoZSBmaWVsZCBtZXJnaW5nIGxvZ2ljIGluIGBjb21iaW5lQ2hhaW5Cb2R5YC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gaW5pdCBDb25maWd1cmF0aW9uIGZvciB0aGlzIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IGluaXQuc291cmNlcyBTcGVjaWZ5IGhvdyB0aGUgaGFyZC1jb2RlZCBsb2dpYyBzaG91bGQgZmluZCB0aGUgZGF0YSBpdCByZWxpZXMgb24gaW4gdGhlIGNoYWluLFxuICogIGFzIHtpbnRlcm5hbF9uYW1lOiBjaGFpbl9zb3VyY2VfaWR9IHBhaXJzLiBUaGlzIGFsbG93cyB3cml0aW5nIGEgcmV1c2FibGUgY29ubmVjdG9yIHRoYXQgZG9lcyBub3QgbmVlZCB0byBtYWtlXG4gKiAgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCBuYW1lc3BhY2VzIGEgc291cmNlIGlzIHVzaW5nLlxuICogQHR5cGUgeyp8RnVuY3Rpb259XG4gKi9cbmNsYXNzIENvbm5lY3RvclNvdXJjZSBleHRlbmRzIEJhc2VBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29ubmVjdG9ycyBtdXN0IHNwZWNpZnkgdGhlIGRhdGEgdGhleSByZXF1aXJlIGFzIGluaXQuc291cmNlcyA9IHtpbnRlcm5hbF9uYW1lOiBjaGFpbl9zb3VyY2VfaWR9fSBwYWlycycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbGxzIHRoZSBjb25uZWN0b3IgaG93IHRvIGZpbmQgdGhlIGRhdGEgaXQgcmVsaWVzIG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBhIGNvbm5lY3RvciB0aGF0IGFwcGxpZXMgYnVyZGVuIHRlc3QgaW5mb3JtYXRpb24gdG8gdGhlIGdlbmVzIGxheWVyIG1pZ2h0IHNwZWNpZnk6XG4gICAgICAgICAqICB7Z2VuZV9uczogXCJnZW5lXCIsIGFnZ3JlZ2F0aW9uX25zOiBcImFnZ3JlZ2F0aW9uXCJ9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NvdXJjZV9uYW1lX21hcHBpbmcgPSBjb25maWcuc291cmNlcztcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoaXMgc291cmNlIGhhcyBiZWVuIHRvbGQgaG93IHRvIGZpbmQgdGhlIHJlcXVpcmVkIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IHNwZWNpZmllZF9pZHMgPSBPYmplY3Qua2V5cyhjb25maWcuc291cmNlcyk7XG4gICAgICAgIC8qKiBAcHJvcGVydHkge1N0cmluZ1tdfSBTcGVjaWZpZXMgdGhlIHNvdXJjZXMgdGhhdCBtdXN0IGJlIHByb3ZpZGVkIGluIHRoZSBvcmlnaW5hbCBjb25maWcgb2JqZWN0ICovXG5cbiAgICAgICAgdGhpcy5fZ2V0UmVxdWlyZWRTb3VyY2VzKCkuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzcGVjaWZpZWRfaWRzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRml4IGNvbnN0cnVjdG9yLm5hbWUgdXNhZ2UgaW4gbWluaWZpZWQgYnVuZGxlc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uZmlndXJhdGlvbiBmb3IgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IG11c3Qgc3BlY2lmeSBhIHNvdXJjZSBJRCBjb3JyZXNwb25kaW5nIHRvICR7a31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3R1Yi0gY29ubmVjdG9ycyBkb24ndCBoYXZlIHRoZWlyIG93biB1cmwgb3IgZGF0YSwgc28gdGhlIGRlZmF1bHRzIGRvbid0IG1ha2Ugc2Vuc2VcbiAgICBwYXJzZUluaXQoKSB7fVxuXG4gICAgZ2V0UmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAvLyBDb25uZWN0b3JzIGRvIG5vdCByZXF1ZXN0IHRoZWlyIG93biBkYXRhIGJ5IGRlZmluaXRpb24sIGJ1dCB0aGV5ICpkbyogZGVwZW5kIG9uIG90aGVyIHNvdXJjZXMgaGF2aW5nIGJlZW4gbG9hZGVkXG4gICAgICAgIC8vICBmaXJzdC4gVGhpcyBtZXRob2QgcGVyZm9ybXMgYmFzaWMgdmFsaWRhdGlvbiwgYW5kIHByZXNlcnZlcyB0aGUgYWNjdW11bGF0ZWQgYm9keSBmcm9tIHRoZSBjaGFpbiBzbyBmYXIuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZV9uYW1lX21hcHBpbmcpLmZvckVhY2goKG5zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbl9zb3VyY2VfaWQgPSB0aGlzLl9zb3VyY2VfbmFtZV9tYXBwaW5nW25zXTtcbiAgICAgICAgICAgIGlmIChjaGFpbi5kaXNjcmV0ZSAmJiAhY2hhaW4uZGlzY3JldGVbY2hhaW5fc291cmNlX2lkXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNhbm5vdCBiZSB1c2VkIGJlZm9yZSBsb2FkaW5nIHJlcXVpcmVkIGRhdGEgZm9yOiAke2NoYWluX3NvdXJjZV9pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hhaW4uYm9keSB8fCBbXSk7XG4gICAgfVxuXG4gICAgcGFyc2VSZXNwb25zZShkYXRhLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgLy8gQSBjb25uZWN0b3Igc291cmNlIGRvZXMgbm90IHVwZGF0ZSBjaGFpbi5kaXNjcmV0ZSwgYnV0IGl0IG1heSB1c2UgaXQuIEl0IGJ5cGFzc2VzIGRhdGEgZm9ybWF0dGluZ1xuICAgICAgICAvLyAgYW5kIGZpZWxkIHNlbGVjdGlvbiAoYm90aCBhcmUgYXNzdW1lZCB0byBoYXZlIGJlZW4gZG9uZSBhbHJlYWR5LCBieSB0aGUgcHJldmlvdXMgc291cmNlcyB0aGlzIGRyYXdzIGZyb20pXG5cbiAgICAgICAgLy8gQmVjYXVzZSBvZiBob3cgdGhlIGNoYWluIHdvcmtzLCBjb25uZWN0b3JzIGFyZSBub3QgdmVyeSBnb29kIGF0IGFwcGx5aW5nIG5ldyB0cmFuc2Zvcm1hdGlvbnMgb3IgbmFtZXNwYWNpbmcuXG4gICAgICAgIC8vIFR5cGljYWxseSBjb25uZWN0b3JzIGFyZSBjYWxsZWQgd2l0aCBgY29ubmVjdG9yX25hbWU6YWxsYCBpbiB0aGUgZmllbGRzIGFycmF5LlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tYmluZUNoYWluQm9keShkYXRhLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24obmV3X2JvZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2hlYWRlcjogY2hhaW4uaGVhZGVyIHx8IHt9LCBkaXNjcmV0ZTogY2hhaW4uZGlzY3JldGUgfHwge30sIGJvZHk6IG5ld19ib2R5fTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbWJpbmVDaGFpbkJvZHkocmVjb3JkcywgY2hhaW4pIHtcbiAgICAgICAgLy8gU3R1YiBtZXRob2Q6IHNwZWNpZmllcyBob3cgdG8gY29tYmluZSB0aGUgZGF0YVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBzdWJjbGFzcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2Qgc2luY2UgRVM2IGRvZXNuJ3Qgc3VwcG9ydCBjbGFzcyBmaWVsZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZXF1aXJlZFNvdXJjZXMoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IGFuIGFycmF5IHRoYXQgaWRlbnRpZmVzIHRoZSBraW5kIG9mIGRhdGEgcmVxdWlyZWQgYnkgdGhpcyBzb3VyY2UnKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJhc2VBZGFwdGVyLCBCYXNlQXBpQWRhcHRlciB9O1xuXG5leHBvcnQge1xuICAgIEFzc29jaWF0aW9uTFosXG4gICAgQ29ubmVjdG9yU291cmNlLFxuICAgIEdlbmVDb25zdHJhaW50TFosXG4gICAgR2VuZUxaLFxuICAgIEd3YXNDYXRhbG9nTFosXG4gICAgTERTZXJ2ZXIsXG4gICAgUGhlV0FTTFosXG4gICAgUmVjb21iTFosXG4gICAgU3RhdGljU291cmNlLFxufTtcbiIsIi8qKiBAbW9kdWxlICovXG4vKlxuICogTG9jdXNab29tIGV4dGVuc2lvbnMgdXNlZCB0byBjYWxjdWxhdGUgYW5kIHJlbmRlciBhZ2dyZWdhdGlvbiB0ZXN0IHJlc3VsdHMuIEJlY2F1c2UgdGhlc2UgY2FsY3VsYXRpb25zIGRlcGVuZCBvbiBhblxuICogICBleHRlcm5hbCBsaWJyYXJ5LCB0aGUgc3BlY2lhbCBkYXRhIHNvdXJjZXMgYXJlIGRlZmluZWQgaGVyZSwgcmF0aGVyIHRoYW4gaW4gTG9jdXNab29tIGNvcmUgY29kZS5cbiAqXG4gKiAgICAgVGhlIHBhZ2UgbXVzdCBpbmNvcnBvcmF0ZSBhbmQgbG9hZCBhbGwgbGlicmFyaWVzIGJlZm9yZSB0aGlzIGZpbGUgY2FuIGJlIHVzZWQsIGluY2x1ZGluZzpcbiAqICAgIC0gVmVuZG9yIGFzc2V0c1xuICogICAgLSBMb2N1c1pvb21cbiAqICAgIC0gcmFyZW1ldGFsLmpzIChhdmFpbGFibGUgdmlhIE5QTSBvciBhIHJlbGF0ZWQgQ0ROKVxuICovXG4vLyBUaGlzIGlzIGRlZmluZWQgYXMgYSBVTUQgbW9kdWxlLCB0byB3b3JrIHdpdGggbXVsdGlwbGUgZGlmZmVyZW50IG1vZHVsZSBzeXN0ZW1zIC8gYnVuZGxlcnNcbi8vIEFyY2FuZSBidWlsZCBub3RlOiBldmVyeXRoaW5nIGRlZmluZWQgaGVyZSBnZXRzIHJlZ2lzdGVyZWQgZ2xvYmFsbHkuIFRoaXMgaXMgbm90IGEgXCJwdXJlXCIgbW9kdWxlLCBhbmQgc29tZSBidWlsZFxuLy8gIHN5c3RlbXMgbWF5IHJlcXVpcmUgYmVpbmcgdG9sZCB0aGF0IHRoaXMgZmlsZSBoYXMgc2lkZSBlZmZlY3RzLlxuXG5pbXBvcnQge2hlbHBlcnN9IGZyb20gJ3JhcmVtZXRhbC5qcyc7XG5pbXBvcnQge0Jhc2VBcGlBZGFwdGVyfSBmcm9tICcuLi9kYXRhL2FkYXB0ZXJzJztcblxuXG5mdW5jdGlvbiBpbnN0YWxsIChMb2N1c1pvb20pIHtcbiAgICAvKipcbiAgICAgKiBEYXRhIFNvdXJjZSB0aGF0IGNhbGN1bGF0ZXMgZ2VuZSBvciByZWdpb24tYmFzZWQgdGVzdHMgYmFzZWQgb24gcHJvdmlkZWQgZGF0YVxuICAgICAqICAgSXQgd2lsbCByYXJlbHkgYmUgdXNlZCBieSBpdHNlbGYsIGJ1dCByYXRoZXIgdXNpbmcgYSBjb25uZWN0b3IgdGhhdCBhdHRhY2hlcyB0aGUgcmVzdWx0cyB0byBkYXRhIGZyb21cbiAgICAgKiAgIGFub3RoZXIgc291cmNlIChsaWtlIGdlbmVzKS4gVXNpbmcgYSBzZXBhcmF0ZSBjb25uZWN0b3IgYWxsb3dzIHVzIHRvIGFkZCBjYWNoaW5nIGFuZCBydW4gdGhpcyBmcm9udC1lbmRcbiAgICAgKiAgIGNhbGN1bGF0aW9uIG9ubHkgb25jZSwgd2hpbGUgdXNpbmcgaXQgaW4gbWFueSBkaWZmZXJlbnQgcGxhY2VzXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNvbnN0IEJhc2VBZGFwdGVyID0gTG9jdXNab29tLkFkYXB0ZXJzLmdldCgnQmFzZUFkYXB0ZXInKTtcbiAgICBjb25zdCBDb25uZWN0b3JTb3VyY2UgPSBMb2N1c1pvb20uQWRhcHRlcnMuZ2V0KCdDb25uZWN0b3JTb3VyY2UnKTtcblxuICAgIGNsYXNzIEFnZ3JlZ2F0aW9uVGVzdFNvdXJjZSBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICAgICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgICAgICAvLyBVbmxpa2UgbW9zdCBzb3VyY2VzLCBjYWxjdWxhdGlvbnMgbWF5IHJlcXVpcmUgYWNjZXNzIHRvIHBsb3Qgc3RhdGUgZGF0YSBldmVuIGFmdGVyIHRoZSBpbml0aWFsIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIFRoaXMgZXhhbXBsZSBzb3VyY2UgUkVRVUlSRVMgdGhhdCB0aGUgZXh0ZXJuYWwgVUkgd2lkZ2V0IHdvdWxkIHN0b3JlIHRoZSBuZWVkZWQgdGVzdCBkZWZpbml0aW9ucyBpbiBhIHBsb3Qgc3RhdGVcbiAgICAgICAgICAgIC8vICBmaWVsZCBjYWxsZWQgYGFnZ3JlZ2F0aW9uX3Rlc3RzYCAoYW4gb2JqZWN0IHttYXNrczogW10sIGNhbGNzOiB7fSlcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkX2luZm8gPSBzdGF0ZS5hZ2dyZWdhdGlvbl90ZXN0cyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCFjaGFpbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5oZWFkZXIgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsbCBvZiB0aGVzZSBmaWVsZHMgYXJlIHJlcXVpcmVkIGluIG9yZGVyIHRvIHVzZSB0aGlzIGRhdGFzb3VyY2UuIFRPRE86IEFkZCB2YWxpZGF0aW9uP1xuICAgICAgICAgICAgY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX2dlbm9zZXRfaWQgPSByZXF1aXJlZF9pbmZvLmdlbm9zZXRfaWQgfHwgbnVsbDsgLy8gTnVtYmVyXG4gICAgICAgICAgICBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fZ2Vub3NldF9idWlsZCA9IHJlcXVpcmVkX2luZm8uZ2Vub3NldF9idWlsZCB8fCBudWxsOyAvLyBTdHJpbmdcbiAgICAgICAgICAgIGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9waGVub3NldF9pZCA9IHJlcXVpcmVkX2luZm8ucGhlbm9zZXRfaWQgfHwgbnVsbDsgIC8vIE51bWJlclxuICAgICAgICAgICAgY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX3BoZW5vID0gcmVxdWlyZWRfaW5mby5waGVubyB8fCBudWxsOyAvLyBTdHJpbmdcbiAgICAgICAgICAgIGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9jYWxjcyA9IHJlcXVpcmVkX2luZm8uY2FsY3MgfHwge307ICAvLyBTdHJpbmdbXVxuICAgICAgICAgICAgY29uc3QgbWFza19kYXRhID0gcmVxdWlyZWRfaW5mby5tYXNrcyB8fCBbXTtcbiAgICAgICAgICAgIGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9tYXNrcyA9IG1hc2tfZGF0YTsgIC8vIHtuYW1lOmRlc2N9W11cbiAgICAgICAgICAgIGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9tYXNrX2lkcyA9IG1hc2tfZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfSk7IC8vIE51bWJlcltdXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cmw7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDYWNoZUtleShzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5nZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpOyAgLy8gVE9ETzogVGhpcyBqdXN0IHNldHMgdGhlIGNoYWluLmhlYWRlciBmaWVsZHNcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgY2hyb206IHN0YXRlLmNocixcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhdGUuc3RhcnQsXG4gICAgICAgICAgICAgICAgc3RvcDogc3RhdGUuZW5kLFxuICAgICAgICAgICAgICAgIGdlbm90eXBlRGF0YXNldDogY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX2dlbm9zZXRfaWQsXG4gICAgICAgICAgICAgICAgcGhlbm90eXBlRGF0YXNldDogY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX3BoZW5vc2V0X2lkLFxuICAgICAgICAgICAgICAgIHBoZW5vdHlwZTogY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX3BoZW5vLFxuICAgICAgICAgICAgICAgIHNhbXBsZXM6ICdBTEwnLFxuICAgICAgICAgICAgICAgIGdlbm9tZUJ1aWxkOiBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fZ2Vub3NldF9idWlsZCxcbiAgICAgICAgICAgICAgICBtYXNrczogY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX21hc2tfaWRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZXRjaFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHttZXRob2Q6ICdQT1NUJywgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVyc30pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IHR5cGVvZiByZXNwID09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShyZXNwKSA6IHJlc3A7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUkFSRU1FVEFMLXNlcnZlciBxdWlyazogVGhlIEFQSSBzb21ldGltZXMgcmV0dXJucyBhIDIwMCBzdGF0dXMgY29kZSBmb3IgZmFpbGVkIHJlcXVlc3RzLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICB3aXRoIGEgaHVtYW4tcmVhZGFibGUgZXJyb3IgZGVzY3JpcHRpb24gYXMgYSBrZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgdGhpcyBzaG91bGQgYmUgdHJlYXRlZCBzdHJpY3RseSBhcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoanNvbi5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbm5vdGF0ZURhdGEocmVjb3JkcywgY2hhaW4pIHtcbiAgICAgICAgICAgIC8vIE9wZXJhdGUgb24gdGhlIGNhbGN1bGF0ZWQgcmVzdWx0cy4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCB3aWxsIGJlIGFkZGVkIHRvIGNoYWluLmRpc2NyZXRlXG5cbiAgICAgICAgICAgIC8vIEluIGEgcGFnZSB1c2luZyBsaXZlIEFQSSBkYXRhLCB0aGUgVUkgd291bGQgb25seSByZXF1ZXN0IHRoZSBtYXNrcyBpdCBuZWVkcyBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAgICAvLyBCdXQgaW4gb3VyIGRlbW9zLCBzb21ldGltZXMgYm9pbGVycGxhdGUgSlNPTiBoYXMgbW9yZSBtYXNrcyB0aGFuIHRoZSBVSSBhc2tlZCBmb3IuIExpbWl0IHdoYXQgY2FsY3Mgd2UgcnVuIChieVxuICAgICAgICAgICAgLy8gIHR5cGUsIGFuZCB0byB0aGUgc2V0IG9mIGdyb3VwcyByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIpXG5cbiAgICAgICAgICAgIC8vIFRoZSBSYXJlbWV0YWwtc2VydmVyIEFQSSBoYXMgYSBxdWlyazogaXQgcmV0dXJucyBhIGRpZmZlcmVudCBwYXlsb2FkIHN0cnVjdHVyZSBpZiBubyBncm91cHMgYXJlIGRlZmluZWRcbiAgICAgICAgICAgIC8vICBmb3IgdGhlIHJlcXVlc3QgcmVnaW9uLiBEZXRlY3Qgd2hlbiB0aGF0IGhhcHBlbnMgYW5kIGVuZCB0aGUgY2FsY3VsYXRpb24gaW1tZWRpYXRlbHkgaW4gdGhhdCBjYXNlXG4gICAgICAgICAgICBpZiAoIXJlY29yZHMuZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZ3JvdXBzOiBbXSwgdmFyaWFudHM6IFtdIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY29yZHMuZ3JvdXBzID0gcmVjb3Jkcy5ncm91cHMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ3JvdXBUeXBlID09PSAnR0VORSc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gaGVscGVycy5wYXJzZVBvcnRhbEpTT04ocmVjb3Jkcyk7XG4gICAgICAgICAgICBsZXQgZ3JvdXBzID0gcGFyc2VkWzBdO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudHMgPSBwYXJzZWRbMV07XG4gICAgICAgICAgICAvLyBTb21lIEFQSXMgbWF5IHJldHVybiBtb3JlIGRhdGEgdGhhbiB3ZSB3YW50IChlZyBzaW1wbGUgc2l0ZXMgdGhhdCBhcmUganVzdCBzZXJ2aW5nIHVwIHByZW1hZGUgc2NvcmVjb3YganNvbiBmaWxlcykuXG4gICAgICAgICAgICAvLyAgRmlsdGVyIHRoZSByZXNwb25zZSB0byBqdXN0IHdoYXQgdGhlIHVzZXIgaGFzIGNob3NlbiB0byBhbmFseXplLlxuICAgICAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmJ5TWFzayhjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fbWFza19pZHMpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hhdCBjYWxjdWxhdGlvbnMgdG8gcnVuXG4gICAgICAgICAgICBjb25zdCBjYWxjcyA9IGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9jYWxjcztcbiAgICAgICAgICAgIGlmICghY2FsY3MgfHwgT2JqZWN0LmtleXMoY2FsY3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhbGNzIGhhdmUgYmVlbiByZXF1ZXN0ZWQsIHRoZW4gcmV0dXJuIGEgZHVtbXkgcGxhY2Vob2xkZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YXJpYW50czogW10sIGdyb3VwczogW10sIHJlc3VsdHM6IFtdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgaGVscGVycy5Qb3J0YWxUZXN0UnVubmVyKGdyb3VwcywgdmFyaWFudHMsIGNhbGNzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5lci50b0pTT04oKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuYWxseSwgcmFyZW1ldGFsIGhlbHBlcnMgdHJhY2sgaG93IHRoZSBjYWxjdWxhdGlvbiBpcyBkb25lLCBidXQgbm90IGFueSBkaXNwbGF5LWZyaWVuZGx5IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGFubm90YXRlIGVhY2ggbWFzayBuYW1lIChpZCkgd2l0aCBhIGh1bWFuLWZyaWVuZGx5IGRlc2NyaXB0aW9uIGZvciBsYXRlciB1c2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFza19pZF90b19kZXNjID0gY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX21hc2tzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1t2YWwubmFtZV0gPSB2YWwuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5kYXRhLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAubWFza19uYW1lID0gbWFza19pZF90b19kZXNjW2dyb3VwLm1hc2tdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNhbGN1bGF0ZSBhZ2dyZWdhdGlvbiB0ZXN0IHJlc3VsdHMnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tYmluZUNoYWluQm9keShyZWNvcmRzLCBjaGFpbikge1xuICAgICAgICAgICAgLy8gYWdncmVnYXRpb24gdGVzdHMgYXJlIGEgYml0IHVuaXF1ZSwgaW4gdGhhdCB0aGUgZGF0YSBpcyByYXJlbHkgdXNlZCBkaXJlY3RseS0gaW5zdGVhZCBpdCBpcyB1c2VkIHRvIGFubm90YXRlIG1hbnlcbiAgICAgICAgICAgIC8vICBvdGhlciBsYXllcnMgaW4gZGlmZmVyZW50IHdheXMuIFRoZSBjYWxjdWxhdGVkIHJlc3VsdCBoYXMgYmVlbiBhZGRlZCB0byBgY2hhaW4uZGlzY3JldGVgLCBidXQgd2lsbCBub3QgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgIC8vICBhcyBwYXJ0IG9mIHRoZSByZXNwb25zZSBib2R5IGJ1aWx0IHVwIGJ5IHRoZSBjaGFpblxuICAgICAgICAgICAgcmV0dXJuIGNoYWluLmJvZHk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGNsYXNzIEFzc29jRnJvbUFnZ3JlZ2F0aW9uTFogZXh0ZW5kcyBCYXNlQWRhcHRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ011c3Qgc3BlY2lmeSB0aGUgbmFtZSBvZiB0aGUgc291cmNlIHRoYXQgY29udGFpbnMgYXNzb2NpYXRpb24gZGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5pdChjb25maWcpIHtcbiAgICAgICAgICAgIHN1cGVyLnBhcnNlSW5pdChjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fZnJvbSA9IGNvbmZpZy5mcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAgICAgLy8gRG9lcyBub3QgYWN0dWFsbHkgbWFrZSBhIHJlcXVlc3QuIEp1c3QgcGljayBvZmYgdGhlIHNwZWNpZmljIGJ1bmRsZSBvZiBkYXRhIGZyb20gYSBrbm93biBwYXlsb2FkIHN0cnVjdHVyZS5cbiAgICAgICAgICAgIGlmIChjaGFpbi5kaXNjcmV0ZSAmJiAhY2hhaW4uZGlzY3JldGVbdGhpcy5fZnJvbV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgJHt0aGlzLmNvbnN0cnVjdG9yLlNPVVJDRV9OQU1FfSBjYW5ub3QgYmUgdXNlZCBiZWZvcmUgbG9hZGluZyByZXF1aXJlZCBkYXRhIGZvcjogJHt0aGlzLl9mcm9tfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBkYXRhIHNvIHRoYXQgbXV0YXRpb25zIChsaWtlIHNvcnRpbmcpIGRvbid0IGFmZmVjdCB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGFpbi5kaXNjcmV0ZVt0aGlzLl9mcm9tXVsndmFyaWFudHMnXSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwYXlsb2FkIHN0cnVjdHVyZSBvZiB0aGUgYXNzb2NpYXRpb24gc291cmNlIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIHRoZSBvbmUgcmVxdWlyZWQgYnkgYXNzb2NpYXRpb25cbiAgICAgICAgICAgIC8vICAgcGxvdHMuIEZvciBleGFtcGxlLCB3ZSBuZWVkIHRvIHBhcnNlIHZhcmlhbnQgbmFtZXMgYW5kIGNvbnZlcnQgdG8gbG9nX3B2YWx1ZVxuICAgICAgICAgICAgY29uc3QgUkVHRVhfRVBBQ1RTID0gbmV3IFJlZ0V4cCgnKD86Y2hyKT8oLispOihcXFxcZCspXz8oXFxcXHcrKT8vPyhbXl9dKyk/Xz8oLiopPycpOyAgLy8gbWF0Y2ggQVBJIHZhcmlhbnQgc3RyaW5nc1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKChvbmVfdmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gb25lX3ZhcmlhbnQudmFyaWFudC5tYXRjaChSRUdFWF9FUEFDVFMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ6IG9uZV92YXJpYW50LnZhcmlhbnQsXG4gICAgICAgICAgICAgICAgICAgIGNocm9tb3NvbWU6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogK21hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICByZWZfYWxsZWxlOiBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICAgICAgcmVmX2FsbGVsZV9mcmVxOiAxIC0gb25lX3ZhcmlhbnQuYWx0RnJlcSxcbiAgICAgICAgICAgICAgICAgICAgbG9nX3B2YWx1ZTogLU1hdGgubG9nMTAob25lX3ZhcmlhbnQucHZhbHVlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGEgPSBhLnZhcmlhbnQ7XG4gICAgICAgICAgICAgICAgYiA9IGIudmFyaWFudDtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmFtZXMgbXVzdCBiZSBlcXVhbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2FtcGxlIGNvbm5lY3RvciB0aGF0IGFsaWducyBjYWxjdWxhdGVkIGFnZ3JlZ2F0aW9uIHRlc3QgZGF0YSB3aXRoIGNvcnJlc3BvbmRpbmcgZ2VuZSBpbmZvcm1hdGlvbi4gUmV0dXJucyBhIGJvZHlcbiAgICAgKiAgIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCB0aGUgZ2VuZXMgZGF0YWxheWVyLlxuICAgICAqXG4gICAgICogIFRvIHVzZSB0aGlzIHNvdXJjZSwgb25lIG11c3Qgc3BlY2lmeSBhIGZpZWxkcyBhcnJheSB0aGF0IGNhbGxzIGZpcnN0IHRoZSBnZW5lcyBzb3VyY2UsIHRoZW4gYSBkdW1teSBmaWVsZCBmcm9tXG4gICAgICogICAgICB0aGlzIHNvdXJjZS4gVGhlIG91dHB1dCB3aWxsIGJlIHRvIHRyYW5zcGFyZW50bHkgYWRkIHNldmVyYWwgbmV3IGZpZWxkcyB0byB0aGUgZ2VuZXMgZGF0YS5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgR2VuZUFnZ3JlZ2F0aW9uQ29ubmVjdG9yTFogZXh0ZW5kcyBDb25uZWN0b3JTb3VyY2Uge1xuICAgICAgICBfZ2V0UmVxdWlyZWRTb3VyY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnZ2VuZV9ucycsICdhZ2dyZWdhdGlvbl9ucyddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tYmluZUNoYWluQm9keShkYXRhLCBjaGFpbikge1xuICAgICAgICAgICAgLy8gVGhlIGdlbmVzIGxheWVyIHJlY2VpdmVzIGFsbCByZXN1bHRzLCBhbmQgZGlzcGxheXMgb25seSB0aGUgYmVzdCBwdmFsdWUgZm9yIGVhY2ggZ2VuZVxuXG4gICAgICAgICAgICAvLyBUaWUgdGhlIGNhbGN1bGF0ZWQgZ3JvdXAtdGVzdCByZXN1bHRzIHRvIGdlbmVzIHdpdGggYSBtYXRjaGluZyBuYW1lXG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGlvbl9zb3VyY2VfaWQgPSB0aGlzLl9zb3VyY2VfbmFtZV9tYXBwaW5nWydhZ2dyZWdhdGlvbl9ucyddO1xuICAgICAgICAgICAgY29uc3QgZ2VuZV9zb3VyY2VfaWQgPSB0aGlzLl9zb3VyY2VfbmFtZV9tYXBwaW5nWydnZW5lX25zJ107XG4gICAgICAgICAgICAvLyBUaGlzIGNvbm5lY3RvciBhc3N1bWVzIHRoYXQgZ2VuZXMgYXJlIHRoZSBtYWluIGJvZHkgb2YgcmVjb3JkcyBmcm9tIHRoZSBjaGFpbiwgYW5kIHRoYXQgYWdncmVnYXRpb24gdGVzdHMgYXJlXG4gICAgICAgICAgICAvLyAgIGEgc3RhbmRhbG9uZSBzb3VyY2UgdGhhdCBoYXMgbm90IGFjdGVkIG9uIGdlbmVzIGRhdGEgeWV0XG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGlvbkRhdGEgPSBjaGFpbi5kaXNjcmV0ZVthZ2dyZWdhdGlvbl9zb3VyY2VfaWRdO1xuICAgICAgICAgICAgY29uc3QgZ2VuZXNEYXRhID0gY2hhaW4uZGlzY3JldGVbZ2VuZV9zb3VyY2VfaWRdO1xuXG4gICAgICAgICAgICBjb25zdCBncm91cGVkQWdncmVnYXRpb24gPSB7fTsgIC8vIEdyb3VwIHRvZ2V0aGVyIGFsbCB0ZXN0cyBkb25lIG9uIHRoYXQgZ2VuZS0gYW55IG1hc2ssIGFueSB0ZXN0XG5cbiAgICAgICAgICAgIGFnZ3JlZ2F0aW9uRGF0YS5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZ3JvdXBlZEFnZ3JlZ2F0aW9uLCByZXN1bHQuZ3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZWRBZ2dyZWdhdGlvbltyZXN1bHQuZ3JvdXBdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyb3VwZWRBZ2dyZWdhdGlvbltyZXN1bHQuZ3JvdXBdLnB1c2gocmVzdWx0LnB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQW5ub3RhdGUgYW55IGdlbmVzIHRoYXQgaGF2ZSB0ZXN0IHJlc3VsdHNcbiAgICAgICAgICAgIGdlbmVzRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChnZW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZV9pZCA9IGdlbmUuZ2VuZV9uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gZ3JvdXBlZEFnZ3JlZ2F0aW9uW2dlbmVfaWRdO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0cykge1xuICAgICAgICAgICAgICAgICAgICBnZW5lLmFnZ3JlZ2F0aW9uX2Jlc3RfcHZhbHVlID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdGVzdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVzRGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgTG9jdXNab29tLkFkYXB0ZXJzLmFkZCgnQWdncmVnYXRpb25UZXN0U291cmNlTFonLCBBZ2dyZWdhdGlvblRlc3RTb3VyY2UpO1xuICAgIExvY3VzWm9vbS5BZGFwdGVycy5hZGQoJ0Fzc29jRnJvbUFnZ3JlZ2F0aW9uTFonLCBBc3NvY0Zyb21BZ2dyZWdhdGlvbkxaKTtcbiAgICBMb2N1c1pvb20uQWRhcHRlcnMuYWRkKCdHZW5lQWdncmVnYXRpb25Db25uZWN0b3JMWicsIEdlbmVBZ2dyZWdhdGlvbkNvbm5lY3RvckxaKTtcbn1cblxuXG5pZiAodHlwZW9mIExvY3VzWm9vbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBBdXRvLXJlZ2lzdGVyIHRoZSBwbHVnaW4gd2hlbiBpbmNsdWRlZCBhcyBhIHNjcmlwdCB0YWcuIEVTNiBtb2R1bGUgdXNlcnMgbXVzdCByZWdpc3RlciB2aWEgTG9jdXNab29tLnVzZSgpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgTG9jdXNab29tLnVzZShpbnN0YWxsKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBpbnN0YWxsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByYXJlbWV0YWw7Il0sInNvdXJjZVJvb3QiOiIifQ==