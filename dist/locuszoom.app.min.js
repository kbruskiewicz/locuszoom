/*! Locuszoom 0.13.0-beta.2 */
var LocusZoom =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/components/constants.js":
/*!*************************************!*\
  !*** ./esm/components/constants.js ***!
  \*************************************/
/*! exports provided: STATUSES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATUSES", function() { return STATUSES; });
/**
 * Available statuses that individual elements can have. Each status is described by
 *   a verb and an adjective. Verbs are used to generate data layer
 *   methods for updating the status on one or more elements. Adjectives are used in class
 *   names and applied or removed from elements to have a visual representation of the status,
 *   as well as used as keys in the state for tracking which elements are in which status(es)
 * @static
 * @type {{verbs: String[], adjectives: String[]}}
 * @private
 */
var STATUSES = {
  verbs: ['highlight', 'select', 'fade', 'hide'],
  adjectives: ['highlighted', 'selected', 'faded', 'hidden']
};

/***/ }),

/***/ "./esm/components/data_layer/annotation_track.js":
/*!*******************************************************!*\
  !*** ./esm/components/data_layer/annotation_track.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnnotationTrack; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */


var default_layout = {
  color: '#000000',
  filters: null,
  tooltip_positioning: 'vertical',
  // Allowed values: top, middle, bottom
  hitarea_width: 8
};
/**
 * Create a single continuous 2D track that provides information about each datapoint
 *
 * For example, this can be used to color by membership in a group, alongside information in other panels
 *
 */

var AnnotationTrack = /*#__PURE__*/function (_BaseDataLayer) {
  _inherits(AnnotationTrack, _BaseDataLayer);

  var _super = _createSuper(AnnotationTrack);

  /*
   * @param {Object} layout
   * @param {Object|String} [layout.color]
   * @param {Object[]} layout.filters An array of filter entries specifying which points to draw annotations for.
   */
  function AnnotationTrack(layout) {
    _classCallCheck(this, AnnotationTrack);

    if (!Array.isArray(layout.filters)) {
      throw new Error('Annotation track must specify array of filters for selecting points to annotate');
    }

    Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])(layout, default_layout);
    return _super.apply(this, arguments);
  }

  _createClass(AnnotationTrack, [{
    key: "render",
    value: function render() {
      var _this = this;

      // Apply filters to only render a specified set of points
      var track_data = this._applyFilters(); // Put the <g> containing visible lines before the one containing hit areas, so that the hit areas will be on top.


      var visible_lines_group = this.svg.group.select("g.lz-data_layer-".concat(this.layout.type, "-visible_lines"));

      if (visible_lines_group.size() === 0) {
        visible_lines_group = this.svg.group.append('g').attr('class', "lz-data_layer-".concat(this.layout.type, "-visible_lines"));
      }

      var selection = visible_lines_group.selectAll("rect.lz-data_layer-".concat(this.layout.type)).data(track_data, function (d) {
        return d[_this.layout.id_field];
      });
      var width = 1; // Draw rectangles (visual and tooltip positioning)

      selection.enter().append('rect').attr('class', "lz-data_layer-".concat(this.layout.type)).attr('id', function (d) {
        return _this.getElementId(d);
      }).merge(selection).attr('x', function (d) {
        return _this.parent['x_scale'](d[_this.layout.x_axis.field]) - width / 2;
      }).attr('width', width).attr('height', this.parent.layout.height).attr('fill', function (d, i) {
        return _this.resolveScalableParameter(_this.layout.color, d, i);
      }); // Remove unused elements

      selection.exit().remove();
      var hit_areas_group = this.svg.group.select("g.lz-data_layer-".concat(this.layout.type, "-hit_areas"));

      if (hit_areas_group.size() === 0) {
        hit_areas_group = this.svg.group.append('g').attr('class', "lz-data_layer-".concat(this.layout.type, "-hit_areas"));
      }

      var hit_areas_selection = hit_areas_group.selectAll("rect.lz-data_layer-".concat(this.layout.type)).data(track_data, function (d) {
        return d[_this.layout.id_field];
      });

      var _getX = function _getX(d, i) {
        // Helper for position calcs below
        var x_center = _this.parent['x_scale'](d[_this.layout.x_axis.field]);

        var x_left = x_center - _this.layout.hitarea_width / 2;

        if (i >= 1) {
          // This assumes that the data are in sorted order.
          var left_node = track_data[i - 1];

          var left_node_x_center = _this.parent['x_scale'](left_node[_this.layout.x_axis.field]);

          x_left = Math.max(x_left, (x_center + left_node_x_center) / 2);
        }

        return [x_left, x_center];
      }; // Add new elements as needed


      hit_areas_selection.enter().append('rect').attr('class', "lz-data_layer-".concat(this.layout.type)).attr('id', function (d) {
        return _this.getElementId(d);
      }) // Update the set of elements to reflect new data
      .merge(hit_areas_selection).attr('height', this.parent.layout.height).attr('opacity', 0).attr('x', function (d, i) {
        var crds = _getX(d, i);

        return crds[0];
      }).attr('width', function (d, i) {
        var crds = _getX(d, i);

        return crds[1] - crds[0] + _this.layout.hitarea_width / 2;
      }); // Set up tooltips and mouse interaction

      this.svg.group.call(this.applyBehaviors.bind(this)); // Remove unused elements

      hit_areas_selection.exit().remove();
    }
  }, {
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      var panel = this.parent;
      var data_layer_height = panel.layout.height - (panel.layout.margin.top + panel.layout.margin.bottom);
      var stroke_width = 1; // as defined in the default stylesheet

      var x_center = panel.x_scale(tooltip.data[this.layout.x_axis.field]);
      var y_center = data_layer_height / 2;
      return {
        x_min: x_center - stroke_width,
        x_max: x_center + stroke_width,
        y_min: y_center - panel.layout.margin.top,
        y_max: y_center + panel.layout.margin.bottom
      };
    }
  }]);

  return AnnotationTrack;
}(_base__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./esm/components/data_layer/arcs.js":
/*!*******************************************!*\
  !*** ./esm/components/data_layer/arcs.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arcs; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/common */ "./esm/helpers/common.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Arc Data Layer
 * Implements a data layer that will render chromatin accessibility tracks.
 * This layer draws arcs (one per datapoint) that connect two endpoints (x.field1 and x.field2) by means of an arc,
 *  with a height determined by y.field.
 * @module
 */




var default_layout = {
  color: 'seagreen',
  hitarea_width: '10px',
  style: {
    fill: 'none',
    'stroke-width': '1px',
    'stroke-opacity': '100%'
  },
  tooltip_positioning: 'top'
};

var Arcs = /*#__PURE__*/function (_BaseDataLayer) {
  _inherits(Arcs, _BaseDataLayer);

  var _super = _createSuper(Arcs);

  function Arcs(layout) {
    _classCallCheck(this, Arcs);

    layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_2__["merge"])(layout, default_layout);
    return _super.apply(this, arguments);
  } // Implement the main render function


  _createClass(Arcs, [{
    key: "render",
    value: function render() {
      var _this = this;

      var self = this;
      var layout = self.layout;
      var x_scale = self.parent['x_scale'];
      var y_scale = self.parent["y".concat(layout.y_axis.axis, "_scale")]; // Apply filters to only render a specified set of points

      var track_data = this._applyFilters(); // Helper: Each individual data point describes a path composed of 3 points, with a spline to smooth the line


      function _make_line(d) {
        var x1 = d[layout.x_axis.field1];
        var x2 = d[layout.x_axis.field2];
        var xmid = (x1 + x2) / 2;
        var coords = [[x_scale(x1), y_scale(0)], [x_scale(xmid), y_scale(d[layout.y_axis.field])], [x_scale(x2), y_scale(0)]]; // Smoothing options: https://bl.ocks.org/emmasaunders/f7178ed715a601c5b2c458a2c7093f78

        var line = d3__WEBPACK_IMPORTED_MODULE_0__["line"]().x(function (d) {
          return d[0];
        }).y(function (d) {
          return d[1];
        }).curve(d3__WEBPACK_IMPORTED_MODULE_0__["curveNatural"]);
        return line(coords);
      } // Draw real lines, and also invisible hitareas for easier mouse events


      var selection = this.svg.group.selectAll('path.lz-data_layer-arcs').data(track_data, function (d) {
        return _this.getElementId(d);
      });
      var hitareas = this.svg.group.selectAll('path.lz-data_layer-arcs-hitarea').data(track_data, function (d) {
        return _this.getElementId(d);
      });
      this.svg.group.call(_helpers_common__WEBPACK_IMPORTED_MODULE_3__["applyStyles"], layout.style); // Add new points as necessary

      selection.enter().append('path').attr('class', 'lz-data_layer-arcs').attr('id', function (d) {
        return _this.getElementId(d);
      }).merge(selection).attr('stroke', function (d, i) {
        return _this.resolveScalableParameter(_this.layout.color, d, i);
      }).attr('d', function (d, i) {
        return _make_line(d);
      });
      hitareas.enter().append('path').attr('class', 'lz-data_layer-arcs-hitarea').attr('id', function (d) {
        return _this.getElementId(d);
      }).merge(hitareas).style('fill', 'none').style('stroke-width', layout.hitarea_width).style('stroke-opacity', 0).style('stroke', 'transparent').attr('d', function (d) {
        return _make_line(d);
      }); // Remove old elements as needed

      selection.exit().remove();
      hitareas.exit().remove(); // Apply mouse behaviors to arcs

      this.svg.group.call(this.applyBehaviors.bind(this));
      return this;
    }
  }, {
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      // Center the tooltip arrow at the apex of the arc. Sometimes, only part of an arc shows on the screen, so we
      //  clean up these values to ensure that the tooltip will appear within the window.
      var panel = this.parent;
      var layout = this.layout;
      var x1 = tooltip.data[layout.x_axis.field1];
      var x2 = tooltip.data[layout.x_axis.field2];
      var y_scale = panel["y".concat(layout.y_axis.axis, "_scale")];
      return {
        x_min: panel.x_scale(Math.min(x1, x2)),
        x_max: panel.x_scale(Math.max(x1, x2)),
        y_min: y_scale(tooltip.data[layout.y_axis.field]),
        y_max: y_scale(0)
      };
    }
  }]);

  return Arcs;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./esm/components/data_layer/base.js":
/*!*******************************************!*\
  !*** ./esm/components/data_layer/base.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseDataLayer; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./esm/components/constants.js");
/* harmony import */ var _data_field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/field */ "./esm/data/field.js");
/* harmony import */ var _helpers_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/display */ "./esm/helpers/display.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _registry_scalable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../registry/scalable */ "./esm/registry/scalable.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */






/**
 * A basic description of keys expected in a layout. Not intended to be directly used or modified by an end user.
 * @protected
 * @type {{type: string, fields: Array, x_axis: {}, y_axis: {}}}
 */

var default_layout = {
  type: '',
  filters: null,
  // Can be an array of {field, operator, value} entries
  fields: [],
  // A list of fields required for this data layer; determines output of `extractFields`
  x_axis: {},
  // Axis options vary based on data layer type
  y_axis: {},
  // Axis options vary based on data layer type
  tooltip_positioning: 'horizontal' // Where to draw tooltips relative to the point. Can be "vertical" or "horizontal"

};
/**
 * A data layer is an abstract class representing a data set and its graphical representation within a panel
 * @public
 * @param {Object} layout A JSON-serializable object describing the layout for this layer
 * @param {Panel|null} parent Where this layout is used
*/

var BaseDataLayer = /*#__PURE__*/function () {
  function BaseDataLayer(layout, parent) {
    _classCallCheck(this, BaseDataLayer);

    /**
     * @private
     * @member {Boolean}
     */
    this.initialized = false;
    /**
     * @private
     * @member {Number}
     */

    this.layout_idx = null;
    /**
     * The unique identifier for this layer. Should be unique within this panel.
     * @public
     * @member {String}
     */

    this.id = null;
    /**
     * The fully qualified identifier for the data layer, prefixed by any parent or container elements.
     * @type {string}
     * @private
     */

    this._base_id = null;
    /**
     * @protected
     * @member {Panel}
     */

    this.parent = parent || null;
    /**
     * @private
     * @member {{group: d3.selection, container: d3.selection, clipRect: d3.selection}}
     */

    this.svg = {};
    /**
     * @protected
     * @member {Plot}
     */

    this.parent_plot = null;

    if (parent) {
      this.parent_plot = parent.parent;
    }
    /**
     * The current layout configuration for this data layer. This reflects any resizing or dynamically generated
     *  config options produced during rendering. Direct layout mutations are a powerful way to dynamically
     *  modify the plot in response to user interactions, but require a deep knowledge of LZ internals to use
     *  effectively.
     * @public
     * @member {Object}
     */


    this.layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_4__["merge"])(layout || {}, default_layout);

    if (this.layout.id) {
      this.id = this.layout.id;
    }
    /**
     * A user-provided function used to filter data for display. If provided, this will override any declarative
     *  options in `layout.filters`
     * @private
     */


    this._filter_func = null; // Ensure any axes defined in the layout have an explicit axis number (default: 1)

    if (this.layout.x_axis !== {} && typeof this.layout.x_axis.axis !== 'number') {
      this.layout.x_axis.axis = 1;
    }

    if (this.layout.y_axis !== {} && typeof this.layout.y_axis.axis !== 'number') {
      this.layout.y_axis.axis = 1;
    }
    /**
     * Values in the layout object may change during rendering etc. Retain a copy of the original data layer state
     * @protected
     * @member {Object}
     */


    this._base_layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_4__["deepCopy"])(this.layout);
    /**
     * @private
     * @member {Object}
     */

    this.state = {};
    /**
     * @private
     * @member {String}
     */

    this.state_id = null;
    /**
     * @private
     * @member {Object}
     * */

    this.layer_state = null; // Create a default state (and set any references to the parent as appropriate)

    this._setDefaultState(); // Initialize parameters for storing data and tool tips

    /**
     * The data retrieved from a region request. This field is useful for debugging, but will be overridden on
     *  re-render; do not modify it directly. The point annotation cache can be used to preserve markings
     *  after re-render.
     * @protected
     * @member {Array}
     */


    this.data = [];

    if (this.layout.tooltip) {
      /**
       * @private
       * @member {Object}
       */
      this.tooltips = {};
    } // Initialize flags for tracking global statuses


    this.global_statuses = {
      'highlighted': false,
      'selected': false,
      'faded': false,
      'hidden': false
    };
  }
  /****** Public interface: methods for external manipulation */

  /**
   * @public
   */


  _createClass(BaseDataLayer, [{
    key: "render",
    value: function render() {
      throw new Error('Method must be implemented');
    }
    /**
     * Move a data layer forward relative to others by z-index
     * @public
     * @returns {BaseDataLayer}
     */

  }, {
    key: "moveForward",
    value: function moveForward() {
      if (this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1]) {
        this.parent.data_layer_ids_by_z_index[this.layout.z_index] = this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1];
        this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1] = this.id;
        this.parent.resortDataLayers();
      }

      return this;
    }
    /**
     * Move a data layer back relative to others by z-index
     * @public
     * @returns {BaseDataLayer}
     */

  }, {
    key: "moveBack",
    value: function moveBack() {
      if (this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1]) {
        this.parent.data_layer_ids_by_z_index[this.layout.z_index] = this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1];
        this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1] = this.id;
        this.parent.resortDataLayers();
      }

      return this;
    }
    /**
     * Set an "annotation": a piece of additional information about a point that is preserved across re-render,
     *  or as the user pans and zooms near this region.
     *
     * Annotations can be referenced as a named pseudo-field in any filters and scalable parameters. (template support
     *  may be added in the future)
     * Sample use case: user clicks a tooltip to "label this specific point". (or change any other display property)
     *
     * @public
     * @param {String|Object} element The data object or ID string for the element
     * @param {String} key The name of the annotation to track
     * @param {*} value The value of the marked field
     */

  }, {
    key: "setElementAnnotation",
    value: function setElementAnnotation(element, key, value) {
      var id = this.getElementId(element);

      if (!this.layer_state.extra_fields[id]) {
        this.layer_state.extra_fields[id] = {};
      }

      this.layer_state.extra_fields[id][key] = value;
      return this;
    }
    /**
     * Select a filter function to be applied to the data
     * @param func
     */

  }, {
    key: "setFilter",
    value: function setFilter(func) {
      this._filter_func = func;
    }
    /********** Protected methods: useful in subclasses to manipulate data layer behaviors */

    /**
     * Implementation hook for fetching the min and max values of available data. Used to determine axis range, if no other
     *   explicit axis settings override. Useful for data layers where the data extent depends on more than one field.
     *   (eg confidence intervals in a forest plot)
     *
     * @protected
     * @param data
     * @param axis_config The configuration object for the specified axis.
     * @returns {Array} [min, max] without any padding applied
     */

  }, {
    key: "_getDataExtent",
    value: function _getDataExtent(data, axis_config) {
      data = data || this.data; // By default this depends only on a single field.

      return d3__WEBPACK_IMPORTED_MODULE_0__["extent"](data, function (d) {
        var f = new _data_field__WEBPACK_IMPORTED_MODULE_2__["default"](axis_config.field);
        return +f.resolve(d);
      });
    }
    /**
     * Fetch the fully qualified ID to be associated with a specific visual element, based on the data to which that
     *   element is bound. In general this element ID will be unique, allowing it to be addressed directly via selectors.
     * @protected
     * @param {Object} element
     * @returns {String}
     */

  }, {
    key: "getElementId",
    value: function getElementId(element) {
      // Use a cached value if possible
      var id_key = Symbol["for"]('lzID');

      if (element[id_key]) {
        return element[id_key];
      }

      var id_field = this.layout.id_field || 'id';

      if (typeof element[id_field] == 'undefined') {
        throw new Error('Unable to generate element ID');
      }

      var element_id = element[id_field].toString().replace(/\W/g, ''); // Cache ID value for future calls

      var key = "".concat(this.getBaseId(), "-").concat(element_id).replace(/([:.[\],])/g, '_');
      element[id_key] = key;
      return key;
    }
    /**
     * Fetch an ID that may bind a data element to a separate visual node for displaying status
     * Examples of this might be seperate visual nodes to show select/highlight statuses, or
     * even a common/shared node to show status across many elements in a set.
     * Abstract method. It should be overridden by data layers that implement seperate status
     * nodes specifically to the use case of the data layer type.
     * @protected
     * @param {String|Object} element
     * @returns {String|null}
     */

  }, {
    key: "getElementStatusNodeId",
    value: function getElementStatusNodeId(element) {
      return null;
    }
    /**
     * Returns a reference to the underlying data associated with a single visual element in the data layer, as
     *   referenced by the unique identifier for the element
     *
     * @protected
     * @param {String} id The unique identifier for the element, as defined by `getElementId`
     * @returns {Object|null} The data bound to that element
     */

  }, {
    key: "getElementById",
    value: function getElementById(id) {
      var selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(id.replace(/([:.[\],])/g, '\\$1'))); // escape special characters

      if (!selector.empty() && selector.data() && selector.data().length) {
        return selector.data()[0];
      } else {
        return null;
      }
    }
    /**
     * Basic method to apply arbitrary methods and properties to data elements.
     *   This is called on all data immediately after being fetched.
     * @protected
     * @returns {BaseDataLayer}
     */

  }, {
    key: "applyDataMethods",
    value: function applyDataMethods() {
      var _this = this;

      var field_to_match = this.layout.match && this.layout.match.receive;
      var broadcast_value = this.parent_plot.state.lz_match_value;
      this.data.forEach(function (item, i) {
        // Basic toHTML() method - return the stringified value in the id_field, if defined.
        // When this layer receives data, mark whether points match (via a synthetic boolean field)
        //   Any field-based layout directives (color, size, shape) can then be used to control display
        if (field_to_match && broadcast_value !== null && broadcast_value !== undefined) {
          item.lz_highlight_match = item[field_to_match] === broadcast_value;
        }

        item.toHTML = function () {
          var id_field = _this.layout.id_field || 'id';
          var html = '';

          if (item[id_field]) {
            html = item[id_field].toString();
          }

          return html;
        }; // Helper methods - return a reference to various plot levels. Useful for interactive tooltips.


        item.getDataLayer = function () {
          return _this;
        };

        item.getPanel = function () {
          return _this.parent || null;
        };

        item.getPlot = function () {
          // For unit testing etc, this layer may be created without a parent.
          var panel = _this.parent;
          return panel ? panel.parent : null;
        }; // deselect() method - shortcut method to deselect the element


        item.deselect = function () {
          var data_layer = _this.getDataLayer();

          data_layer.unselectElement(_this); // dynamically generated method name. It exists, honest.
        };
      });
      this.applyCustomDataMethods();
      return this;
    }
    /**
     * Hook that allows custom datalayers to apply additional methods and properties to data elements as needed
     * @protected
     * @returns {BaseDataLayer}
     */

  }, {
    key: "applyCustomDataMethods",
    value: function applyCustomDataMethods() {
      return this;
    }
    /**
     * Apply scaling functions to an element as needed, based on the layout rules governing display + the element's data
     * If the layout parameter is already a primitive type, simply return the value as given
     *
     * In the future this may be further expanded, so that scaling functions can operate similar to mappers
     *  (item, index, array). Additional arguments would be added as the need arose.
     *
     * @protected
     * @param {Array|Number|String|Object} layout Either a scalar ("color is red") or a configuration object
     *  ("rules for how to choose color based on item value")
     * @param {*} element_data The value to be used with the filter. May be a primitive value, or a data object for a single item
     * @param {Number} data_index The array index for the data element
     * @returns {*} The transformed value
     */

  }, {
    key: "resolveScalableParameter",
    value: function resolveScalableParameter(layout, element_data, data_index) {
      var ret = null;

      if (Array.isArray(layout)) {
        var idx = 0;

        while (ret === null && idx < layout.length) {
          ret = this.resolveScalableParameter(layout[idx], element_data, data_index);
          idx++;
        }
      } else {
        switch (_typeof(layout)) {
          case 'number':
          case 'string':
            ret = layout;
            break;

          case 'object':
            if (layout.scale_function) {
              var func = _registry_scalable__WEBPACK_IMPORTED_MODULE_5__["default"].get(layout.scale_function);

              if (layout.field) {
                var f = new _data_field__WEBPACK_IMPORTED_MODULE_2__["default"](layout.field);
                var extra;

                try {
                  extra = this.layer_state && this.layer_state.extra_fields[this.getElementId(element_data)];
                } catch (e) {
                  extra = null;
                }

                ret = func(layout.parameters || {}, f.resolve(element_data, extra), data_index);
              } else {
                ret = func(layout.parameters || {}, element_data, data_index);
              }
            }

            break;
        }
      }

      return ret;
    }
    /**
     * Generate dimension extent function based on layout parameters
     * @protected
     * @param {('x'|'y')} dimension
     */

  }, {
    key: "getAxisExtent",
    value: function getAxisExtent(dimension) {
      if (!['x', 'y'].includes(dimension)) {
        throw new Error('Invalid dimension identifier');
      }

      var axis_name = "".concat(dimension, "_axis");
      var axis_layout = this.layout[axis_name]; // If a floor AND a ceiling are explicitly defined then just return that extent and be done

      if (!isNaN(axis_layout.floor) && !isNaN(axis_layout.ceiling)) {
        return [+axis_layout.floor, +axis_layout.ceiling];
      } // If a field is defined for the axis and the data layer has data then generate the extent from the data set


      var data_extent = [];

      if (axis_layout.field && this.data) {
        if (!this.data.length) {
          // If data has been fetched (but no points in region), enforce the min_extent (with no buffers,
          //  because we don't need padding around an empty screen)
          data_extent = axis_layout.min_extent || [];
          return data_extent;
        } else {
          data_extent = this._getDataExtent(this.data, axis_layout); // Apply upper/lower buffers, if applicable

          var original_extent_span = data_extent[1] - data_extent[0];

          if (!isNaN(axis_layout.lower_buffer)) {
            data_extent[0] -= original_extent_span * axis_layout.lower_buffer;
          }

          if (!isNaN(axis_layout.upper_buffer)) {
            data_extent[1] += original_extent_span * axis_layout.upper_buffer;
          }

          if (_typeof(axis_layout.min_extent) == 'object') {
            // The data should span at least the range specified by min_extent, an array with [low, high]
            var range_min = axis_layout.min_extent[0];
            var range_max = axis_layout.min_extent[1];

            if (!isNaN(range_min) && !isNaN(range_max)) {
              data_extent[0] = Math.min(data_extent[0], range_min);
            }

            if (!isNaN(range_max)) {
              data_extent[1] = Math.max(data_extent[1], range_max);
            }
          } // If specified, floor and ceiling will override the actual data range


          return [isNaN(axis_layout.floor) ? data_extent[0] : axis_layout.floor, isNaN(axis_layout.ceiling) ? data_extent[1] : axis_layout.ceiling];
        }
      } // If this is for the x axis and no extent could be generated yet but state has a defined start and end
      // then default to using the state-defined region as the extent


      if (dimension === 'x' && !isNaN(this.state.start) && !isNaN(this.state.end)) {
        return [this.state.start, this.state.end];
      } // No conditions met for generating a valid extent, return an empty array


      return [];
    }
    /**
     * Allow this data layer to tell the panel what axis ticks it thinks it will require. The panel may choose whether
     *   to use some, all, or none of these when rendering, either alone or in conjunction with other data layers.
     *
     *   This method is a stub and should be overridden in data layers that need to specify custom behavior.
     *
     * @protected
     * @param {('x'|'y1'|'y2')} dimension
     * @param {Object} [config] Additional parameters for the panel to specify how it wants ticks to be drawn. The names
     *   and meanings of these parameters may vary between different data layers.
     * @returns {Object[]}
     *   An array of objects: each object must have an 'x' attribute to position the tick.
     *   Other supported object keys:
     *     * text: string to render for a given tick
     *     * style: d3-compatible CSS style object
     *     * transform: SVG transform attribute string
     *     * color: string or LocusZoom scalable parameter object
     */

  }, {
    key: "getTicks",
    value: function getTicks(dimension, config) {
      if (!['x', 'y1', 'y2'].includes(dimension)) {
        throw new Error("Invalid dimension identifier ".concat(dimension));
      }

      return [];
    }
    /**
     * Determine the coordinates for where to point the tooltip at. Typically, this is the center of a datum element (eg,
     *  the middle of a scatter plot point). Also provide an offset if the tooltip should not be at that center (most
     *  elements are not single points, eg a scatter plot point has a radius and a gene is a rectangle).
     *  The default implementation is quite naive: it places the tooltip at the origin for that layer. Individual layers
     *    should override this method to position relative to the chosen data element or mouse event.
     * @protected
     * @param {Object} tooltip A tooltip object (including attribute tooltip.data)
     * @returns {Object} as {x_min, x_max, y_min, y_max} in px, representing bounding box of a rectangle around the data pt
     *  Note that these pixels are in the SVG coordinate system
     */

  }, {
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      var panel = this.parent;
      var y_scale = panel["y".concat(this.layout.y_axis.axis, "_scale")];
      var y_extent = panel["y".concat(this.layout.y_axis.axis, "_extent")];
      var x = panel.x_scale(panel.x_extent[0]);
      var y = y_scale(y_extent[0]);
      return {
        x_min: x,
        x_max: x,
        y_min: y,
        y_max: y
      };
    }
    /**
     * Draw a tooltip on the data layer pointed at the specified coordinates, in the specified orientation.
     *  Tooltip will be drawn on the edge of the major axis, and centered along the minor axis- see diagram.
     *   v
     * > o <
     *   ^
     *
     * @protected
     * @param tooltip {Object} The object representing all data for the tooltip to be drawn
     * @param {'vertical'|'horizontal'|'top'|'bottom'|'left'|'right'} position Where to draw the tooltip relative to
     *  the data
     * @param {Number} x_min The min x-coordinate for the bounding box of the data element
     * @param {Number} x_max The max x-coordinate for the bounding box of the data element
     * @param {Number} y_min The min y-coordinate for the bounding box of the data element
     * @param {Number} y_max The max y-coordinate for the bounding box of the data element
     */

  }, {
    key: "_drawTooltip",
    value: function _drawTooltip(tooltip, position, x_min, x_max, y_min, y_max) {
      var panel_layout = this.parent.layout;
      var layer_layout = this.layout; // Tooltip position params: as defined in the default stylesheet, used in calculations

      var arrow_size = 7;
      var stroke_width = 1;
      var arrow_total = arrow_size + stroke_width; // Tooltip pos should account for how much space the arrow takes up

      var tooltip_padding = 6; // bbox size must account for any internal padding applied between data and border

      var page_origin = this._getPageOrigin();

      var tooltip_box = tooltip.selector.node().getBoundingClientRect();
      var data_layer_height = panel_layout.height - (panel_layout.margin.top + panel_layout.margin.bottom);
      var data_layer_width = panel_layout.width - (panel_layout.margin.left + panel_layout.margin.right); // Clip the edges of the datum to the available plot area

      x_min = Math.max(x_min, 0);
      x_max = Math.min(x_max, data_layer_width);
      y_min = Math.max(y_min, 0);
      y_max = Math.min(y_max, data_layer_height);
      var x_center = (x_min + x_max) / 2;
      var y_center = (y_min + y_max) / 2; // Default offsets are the far edge of the datum bounding box

      var x_offset = x_max - x_center;
      var y_offset = y_max - y_center;
      var placement = layer_layout.tooltip_positioning; // Coordinate system note: the tooltip is positioned relative to the plot/page; the arrow is positioned relative to
      //  the tooltip boundaries

      var tooltip_top, tooltip_left, arrow_type, arrow_top, arrow_left; // The user can specify a generic orientation, and LocusZoom will autoselect whether to place the tooltip above or below

      if (placement === 'vertical') {
        // Auto-select whether to position above the item, or below
        x_offset = 0;

        if (tooltip_box.height + arrow_total > data_layer_height - (y_center + y_offset)) {
          placement = 'top';
        } else {
          placement = 'bottom';
        }
      } else if (placement === 'horizontal') {
        // Auto select whether to position to the left of the item, or to the right
        y_offset = 0;

        if (x_center <= panel_layout.width / 2) {
          placement = 'left';
        } else {
          placement = 'right';
        }
      }

      if (placement === 'top' || placement === 'bottom') {
        // Position horizontally centered above the point
        var offset_right = Math.max(tooltip_box.width / 2 - x_center, 0);
        var offset_left = Math.max(tooltip_box.width / 2 + x_center - data_layer_width, 0);
        tooltip_left = page_origin.x + x_center - tooltip_box.width / 2 - offset_left + offset_right;
        arrow_left = page_origin.x + x_center - tooltip_left - arrow_size; // Arrow should be centered over the data
        // Position vertically above the point unless there's insufficient space, then go below

        if (placement === 'top') {
          tooltip_top = page_origin.y + y_center - (y_offset + tooltip_box.height + arrow_total);
          arrow_type = 'down';
          arrow_top = tooltip_box.height - stroke_width;
        } else {
          tooltip_top = page_origin.y + y_center + y_offset + arrow_total;
          arrow_type = 'up';
          arrow_top = 0 - arrow_total;
        }
      } else if (placement === 'left' || placement === 'right') {
        // Position tooltip horizontally on the left or the right depending on which side of the plot the point is on
        if (placement === 'left') {
          tooltip_left = page_origin.x + x_center + x_offset + arrow_total;
          arrow_type = 'left';
          arrow_left = -1 * (arrow_size + stroke_width);
        } else {
          tooltip_left = page_origin.x + x_center - tooltip_box.width - x_offset - arrow_total;
          arrow_type = 'right';
          arrow_left = tooltip_box.width - stroke_width;
        } // Position with arrow vertically centered along tooltip edge unless we're at the top or bottom of the plot


        if (y_center - tooltip_box.height / 2 <= 0) {
          // Too close to the top, push it down
          tooltip_top = page_origin.y + y_center - 1.5 * arrow_size - tooltip_padding;
          arrow_top = tooltip_padding;
        } else if (y_center + tooltip_box.height / 2 >= data_layer_height) {
          // Too close to the bottom, pull it up
          tooltip_top = page_origin.y + y_center + arrow_size + tooltip_padding - tooltip_box.height;
          arrow_top = tooltip_box.height - 2 * arrow_size - tooltip_padding;
        } else {
          // vertically centered
          tooltip_top = page_origin.y + y_center - tooltip_box.height / 2;
          arrow_top = tooltip_box.height / 2 - arrow_size;
        }
      } else {
        throw new Error('Unrecognized placement value');
      } // Position the div itself, relative to the layer origin


      tooltip.selector.style('left', "".concat(tooltip_left, "px")).style('top', "".concat(tooltip_top, "px")); // Create / update position on arrow connecting tooltip to data

      if (!tooltip.arrow) {
        tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');
      }

      tooltip.arrow.attr('class', "lz-data_layer-tooltip-arrow_".concat(arrow_type)).style('left', "".concat(arrow_left, "px")).style('top', "".concat(arrow_top, "px"));
      return this;
    }
    /**
     * Determine whether a given data element matches set criteria
     *
     * Typically this is used with array.filter (the first argument is curried, `filter.bind(this, options)`
     * @protected
     * @param {Object[]} filters A list of filter entries: {field, value, operator} describing each filter.
     *  Operator must be from a list of built-in operators
     * @param {Object} item
     * @param {Number} index
     * @param {Array} array
     * @returns {Boolean} Whether the specified item is a match
     */

  }, {
    key: "filter",
    value: function filter(filters, item, index, array) {
      var _this2 = this;

      var test = function test(element, filter) {
        var field = filter.field,
            operator = filter.operator,
            target = filter.value;
        var operators = {
          '=': function _(a, b) {
            return a === b;
          },
          // eslint-disable-next-line eqeqeq
          '!=': function _(a, b) {
            return a != b;
          },
          // For absence of a value, deliberately allow weak comparisons (eg undefined/null)
          '<': function _(a, b) {
            return a < b;
          },
          '<=': function _(a, b) {
            return a <= b;
          },
          '>': function _(a, b) {
            return a > b;
          },
          '>=': function _(a, b) {
            return a >= b;
          },
          '%': function _(a, b) {
            return a % b;
          },
          'in': function _in(a, b) {
            return b && b.includes(a);
          },
          // works for strings or arrays
          'match': function match(a, b) {
            return a && a.includes(b);
          }
        };

        var extra = _this2.layer_state.extra_fields[_this2.getElementId(element)];

        var field_value = new _data_field__WEBPACK_IMPORTED_MODULE_2__["default"](field).resolve(element, extra);
        return operators[operator](field_value, target);
      };

      var match = true;
      filters.forEach(function (filter) {
        if (!test(item, filter)) {
          match = false;
        }
      });
      return match;
    }
    /**
     * Get "annotation" metadata associated with a particular point.
     *
     * @protected
     * @param {String|Object} element The data object or ID string for the element
     * @param {String} key The name of the annotation to track
     * @return {*}
     */

  }, {
    key: "getElementAnnotation",
    value: function getElementAnnotation(element, key) {
      var id = this.getElementId(element);
      var extra = this.layer_state.extra_fields[id];
      return extra && extra[key];
    }
    /****** Private methods: rarely overridden or modified by external usages */

    /**
     * Apply filtering options to determine the set of data to render
     *
     * This must be applied on rendering, not fetch, so that the axis limits reflect the true range of the dataset
     *   Otherwise, two stacked panels (same dataset filtered in different ways) might not line up on the x-axis when
     *   filters are applied.
     * @param data
     * @return {*}
     * @private
     */

  }, {
    key: "_applyFilters",
    value: function _applyFilters(data) {
      data = data || this.data;

      if (this._filter_func) {
        data = data.filter(this._filter_func);
      } else if (this.layout.filters) {
        data = data.filter(this.filter.bind(this, this.layout.filters));
      }

      return data;
    }
    /**
     * Define default state that should get tracked during the lifetime of this layer.
     *
     * In some special custom usages, it may be useful to completely reset a panel (eg "click for
     *   genome region" links), plotting new data that invalidates any previously tracked state.  This hook makes it
     *   possible to reset without destroying the panel entirely. It is used by `Plot.clearPanelData`.
     * @private
     */

  }, {
    key: "_setDefaultState",
    value: function _setDefaultState() {
      // Each datalayer tracks two kinds of status: flags for internal state (highlighted, selected, tooltip),
      //  and "extra fields" (annotations like "show a tooltip" that are not determined by the server, but need to
      //  persist across re-render)
      var layer_state = {
        status_flags: {},
        extra_fields: {}
      };
      var status_flags = layer_state.status_flags;
      _constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].adjectives.forEach(function (status) {
        status_flags[status] = status_flags[status] || [];
      }); // Also initialize "internal-only" state fields (things that are tracked, but not set directly by external events)

      status_flags['has_tooltip'] = status_flags['has_tooltip'] || [];

      if (this.parent) {
        // If layer has a parent, store a reference in the overarching plot.state object
        this.state_id = "".concat(this.parent.id, ".").concat(this.id);
        this.state = this.parent.state;
        this.state[this.state_id] = layer_state;
      }

      this.layer_state = layer_state;
    }
    /**
     * Get the fully qualified identifier for the data layer, prefixed by any parent or container elements
     *
     * @private
     * @returns {string} A dot-delimited string of the format <plot>.<panel>.<data_layer>
     */

  }, {
    key: "getBaseId",
    value: function getBaseId() {
      if (this._base_id) {
        return this._base_id;
      }

      if (this.parent) {
        return "".concat(this.parent_plot.id, ".").concat(this.parent.id, ".").concat(this.id);
      } else {
        return (this.id || '').toString();
      }
    }
    /**
     * Determine the pixel height of data-bound objects represented inside this data layer. (excluding elements such as axes)
     *
     * May be used by operations that resize the data layer to fit available data
     *
     * @private
     * @returns {number}
     */

  }, {
    key: "getAbsoluteDataHeight",
    value: function getAbsoluteDataHeight() {
      var dataBCR = this.svg.group.node().getBoundingClientRect();
      return dataBCR.height;
    }
    /**
     * Initialize a data layer
     * @private
     * @returns {BaseDataLayer}
     */

  }, {
    key: "initialize",
    value: function initialize() {
      this._base_id = this.getBaseId(); // Append a container group element to house the main data layer group element and the clip path

      var base_id = this.getBaseId();
      this.svg.container = this.parent.svg.group.append('g').attr('class', 'lz-data_layer-container').attr('id', "".concat(base_id, ".data_layer_container")); // Append clip path to the container element

      this.svg.clipRect = this.svg.container.append('clipPath').attr('id', "".concat(base_id, ".clip")).append('rect'); // Append svg group for rendering all data layer elements, clipped by the clip path

      this.svg.group = this.svg.container.append('g').attr('id', "".concat(base_id, ".data_layer")).attr('clip-path', "url(#".concat(base_id, ".clip)"));
      return this;
    }
    /**
     * Generate a tool tip for a given element
     * @private
     * @param {String|Object} data Data for the element associated with the tooltip
     */

  }, {
    key: "createTooltip",
    value: function createTooltip(data) {
      if (_typeof(this.layout.tooltip) != 'object') {
        throw new Error("DataLayer [".concat(this.id, "] layout does not define a tooltip"));
      }

      var id = this.getElementId(data);

      if (this.tooltips[id]) {
        this.positionTooltip(id);
        return;
      }

      this.tooltips[id] = {
        data: data,
        arrow: null,
        selector: d3__WEBPACK_IMPORTED_MODULE_0__["select"](this.parent_plot.svg.node().parentNode).append('div').attr('class', 'lz-data_layer-tooltip').attr('id', "".concat(id, "-tooltip"))
      };
      this.layer_state.status_flags['has_tooltip'].push(id);
      this.updateTooltip(data);
      return this;
    }
    /**
     * Update a tool tip (generate its inner HTML)
     *
     * @private
     * @param {String|Object} d The element associated with the tooltip
     * @param {String} [id] An identifier to the tooltip
     */

  }, {
    key: "updateTooltip",
    value: function updateTooltip(d, id) {
      var _this3 = this;

      if (typeof id == 'undefined') {
        id = this.getElementId(d);
      } // Empty the tooltip of all HTML (including its arrow!)


      this.tooltips[id].selector.html('');
      this.tooltips[id].arrow = null; // Set the new HTML

      if (this.layout.tooltip.html) {
        this.tooltips[id].selector.html(Object(_helpers_display__WEBPACK_IMPORTED_MODULE_3__["parseFields"])(d, this.layout.tooltip.html));
      } // If the layout allows tool tips on this data layer to be closable then add the close button
      // and add padding to the tooltip to accommodate it


      if (this.layout.tooltip.closable) {
        this.tooltips[id].selector.insert('button', ':first-child').attr('class', 'lz-tooltip-close-button').attr('title', 'Close').text('×').on('click', function () {
          _this3.destroyTooltip(id);
        });
      } // Apply data directly to the tool tip for easier retrieval by custom UI elements inside the tool tip


      this.tooltips[id].selector.data([d]); // Reposition and draw a new arrow

      this.positionTooltip(id);
      return this;
    }
    /**
     * Destroy tool tip - remove the tool tip element from the DOM and delete the tool tip's record on the data layer
     *
     * @private
     * @param {String|Object} element_or_id The element (or id) associated with the tooltip
     * @param {boolean} [temporary=false] Whether this is temporary (not to be tracked in state). Differentiates
     *  "recreate tooltips on re-render" (which is temporary) from "user has closed this tooltip" (permanent)
     * @returns {BaseDataLayer}
     */

  }, {
    key: "destroyTooltip",
    value: function destroyTooltip(element_or_id, temporary) {
      var id;

      if (typeof element_or_id == 'string') {
        id = element_or_id;
      } else {
        id = this.getElementId(element_or_id);
      }

      if (this.tooltips[id]) {
        if (_typeof(this.tooltips[id].selector) == 'object') {
          this.tooltips[id].selector.remove();
        }

        delete this.tooltips[id];
      } // When a tooltip is removed, also remove the reference from the state


      if (!temporary) {
        var state = this.layer_state.status_flags['has_tooltip'];
        var label_mark_position = state.indexOf(id);
        state.splice(label_mark_position, 1);
      }

      return this;
    }
    /**
     * Loop through and destroy all tool tips on this data layer
     *
     * @private
     * @returns {BaseDataLayer}
     */

  }, {
    key: "destroyAllTooltips",
    value: function destroyAllTooltips() {
      for (var id in this.tooltips) {
        this.destroyTooltip(id, true);
      }

      return this;
    }
    /**
     * Position and then redraw tool tip - naïve function to place a tool tip in the data layer. By default, positions wrt
     *   the top-left corner of the data layer.
     *
     * Each layer type may have more specific logic. Consider overriding the provided hooks `_getTooltipPosition` or
     *  `_drawTooltip` as appropriate
     *
     * @private
     * @param {String} id The identifier of the tooltip to position
     * @returns {BaseDataLayer}
     */

  }, {
    key: "positionTooltip",
    value: function positionTooltip(id) {
      if (typeof id != 'string') {
        throw new Error('Unable to position tooltip: id is not a string');
      }

      if (!this.tooltips[id]) {
        throw new Error('Unable to position tooltip: id does not point to a valid tooltip');
      }

      var tooltip = this.tooltips[id];

      var coords = this._getTooltipPosition(tooltip);

      if (!coords) {
        // Special cutout: normally, tooltips are positioned based on the datum element. Some, like lines/curves,
        //  work better if based on a mouse event. Since not every redraw contains a mouse event, we can just skip
        //  calculating position when no position information is available.
        return null;
      }

      this._drawTooltip(tooltip, this.layout.tooltip_positioning, coords.x_min, coords.x_max, coords.y_min, coords.y_max);
    }
    /**
     * Loop through and position all tool tips on this data layer
     *
     * @private
     * @returns {BaseDataLayer}
     */

  }, {
    key: "positionAllTooltips",
    value: function positionAllTooltips() {
      for (var id in this.tooltips) {
        this.positionTooltip(id);
      }

      return this;
    }
    /**
     * Show or hide a tool tip by ID depending on directives in the layout and state values relative to the ID
     *
     * @private
     * @param {String|Object} element The element associated with the tooltip
     * @param {boolean} first_time Because panels can re-render, the rules for showing a tooltip
     *  depend on whether this is the first time a status change affecting display has been applied.
     * @returns {BaseDataLayer}
     */

  }, {
    key: "showOrHideTooltip",
    value: function showOrHideTooltip(element, first_time) {
      if (_typeof(this.layout.tooltip) != 'object') {
        return this;
      }

      var id = this.getElementId(element);
      /**
       * Apply rules and decide whether to show or hide the tooltip
       * @param {Object} statuses All statuses that apply to an element
       * @param {String[]|object} directive A layout directive object
       * @param operator
       * @returns {null|bool}
       */

      var resolveStatus = function resolveStatus(statuses, directive, operator) {
        var status = null;

        if (_typeof(statuses) != 'object' || statuses === null) {
          return null;
        }

        if (Array.isArray(directive)) {
          // This happens when the function is called on the inner part of the directive
          operator = operator || 'and';

          if (directive.length === 1) {
            status = statuses[directive[0]];
          } else {
            status = directive.reduce(function (previousValue, currentValue) {
              if (operator === 'and') {
                return statuses[previousValue] && statuses[currentValue];
              } else if (operator === 'or') {
                return statuses[previousValue] || statuses[currentValue];
              }

              return null;
            });
          }
        } else if (_typeof(directive) == 'object') {
          var sub_status;

          for (var sub_operator in directive) {
            sub_status = resolveStatus(statuses, directive[sub_operator], sub_operator);

            if (status === null) {
              status = sub_status;
            } else if (operator === 'and') {
              status = status && sub_status;
            } else if (operator === 'or') {
              status = status || sub_status;
            }
          }
        } else {
          return false;
        }

        return status;
      };

      var show_directive = {};

      if (typeof this.layout.tooltip.show == 'string') {
        show_directive = {
          and: [this.layout.tooltip.show]
        };
      } else if (_typeof(this.layout.tooltip.show) == 'object') {
        show_directive = this.layout.tooltip.show;
      }

      var hide_directive = {};

      if (typeof this.layout.tooltip.hide == 'string') {
        hide_directive = {
          and: [this.layout.tooltip.hide]
        };
      } else if (_typeof(this.layout.tooltip.hide) == 'object') {
        hide_directive = this.layout.tooltip.hide;
      } // Find all the statuses that apply to just this single element


      var layer_state = this.layer_state;
      var status_flags = {}; // {status_name: bool}

      _constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].adjectives.forEach(function (status) {
        var antistatus = "un".concat(status);
        status_flags[status] = layer_state.status_flags[status].includes(id);
        status_flags[antistatus] = !status_flags[status];
      }); // Decide whether to show/hide the tooltip based solely on the underlying element

      var show_resolved = resolveStatus(status_flags, show_directive);
      var hide_resolved = resolveStatus(status_flags, hide_directive); // Most of the tooltip display logic depends on behavior layouts: was point (un)selected, (un)highlighted, etc.
      // But sometimes, a point is selected, and the user then closes the tooltip. If the panel is re-rendered for
      //  some outside reason (like state change), we must track this in the create/destroy events as tooltip state.

      var has_tooltip = layer_state.status_flags['has_tooltip'].includes(id);
      var tooltip_was_closed = first_time ? false : !has_tooltip;

      if (show_resolved && !tooltip_was_closed && !hide_resolved) {
        this.createTooltip(element);
      } else {
        this.destroyTooltip(element);
      }

      return this;
    }
    /**
     * Toggle a status (e.g. highlighted, selected, identified) on an element
     *
     * @private
     *
     * @param {String} status The name of a recognized status to be added/removed on an appropriate element
     * @param {String|Object} element The data bound to the element of interest
     * @param {Boolean} active True to add the status (and associated CSS styles); false to remove it
     * @param {Boolean} exclusive Whether to only allow a state for a single element at a time
     * @returns {BaseDataLayer}
     */

  }, {
    key: "setElementStatus",
    value: function setElementStatus(status, element, active, exclusive) {
      if (status === 'has_tooltip') {
        // This is a special adjective that exists solely to track tooltip state. It has no CSS and never gets set
        //  directly. It is invisible to the official enums.
        return this;
      }

      if (typeof active == 'undefined') {
        active = true;
      } // Get an ID for the element or return having changed nothing


      var element_id;

      try {
        element_id = this.getElementId(element);
      } catch (get_element_id_error) {
        return this;
      } // Enforce exclusivity (force all elements to have the opposite of toggle first)


      if (exclusive) {
        this.setAllElementStatus(status, !active);
      } // Set/unset the proper status class on the appropriate DOM element(s)


      d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(element_id)).classed("lz-data_layer-".concat(this.layout.type, "-").concat(status), active);
      var element_status_node_id = this.getElementStatusNodeId(element);

      if (element_status_node_id !== null) {
        d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(element_status_node_id)).classed("lz-data_layer-".concat(this.layout.type, "-statusnode-").concat(status), active);
      } // Track element ID in the proper status state array


      var element_status_idx = this.layer_state.status_flags[status].indexOf(element_id);
      var added_status = element_status_idx === -1; // On a re-render, existing statuses will be reapplied.

      if (active && added_status) {
        this.layer_state.status_flags[status].push(element_id);
      }

      if (!active && !added_status) {
        this.layer_state.status_flags[status].splice(element_status_idx, 1);
      } // Trigger tool tip show/hide logic


      this.showOrHideTooltip(element, added_status); // Trigger layout changed event hook

      if (added_status) {
        this.parent.emit('layout_changed', true);
      }

      var is_selected = status === 'selected';

      if (is_selected && (added_status || !active)) {
        // Notify parents that an element has changed selection status (either active, or inactive)
        this.parent.emit('element_selection', {
          element: element,
          active: active
        }, true);
      }

      var value_to_broadcast = this.layout.match && this.layout.match.send;

      if (is_selected && value_to_broadcast && (added_status || !active)) {
        this.parent.emit('match_requested', {
          value: element[value_to_broadcast],
          active: active
        }, true);
      }

      return this;
    }
    /**
     * Toggle a status on all elements in the data layer
     *
     * @private
     * @param {String} status
     * @param {Boolean} toggle
     * @returns {BaseDataLayer}
     */

  }, {
    key: "setAllElementStatus",
    value: function setAllElementStatus(status, toggle) {
      var _this4 = this;

      // Sanity check
      if (typeof status == 'undefined' || !_constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].adjectives.includes(status)) {
        throw new Error('Invalid status');
      }

      if (typeof this.layer_state.status_flags[status] == 'undefined') {
        return this;
      }

      if (typeof toggle == 'undefined') {
        toggle = true;
      } // Apply statuses


      if (toggle) {
        this.data.forEach(function (element) {
          return _this4.setElementStatus(status, element, true);
        });
      } else {
        var status_ids = this.layer_state.status_flags[status].slice();
        status_ids.forEach(function (id) {
          var element = _this4.getElementById(id);

          if (_typeof(element) == 'object' && element !== null) {
            _this4.setElementStatus(status, element, false);
          }
        });
        this.layer_state.status_flags[status] = [];
      } // Update global status flag


      this.global_statuses[status] = toggle;
      return this;
    }
    /**
     * Apply all layout-defined behaviors (DOM event handlers) to a selection of elements
     *
     * @private
     * @param {d3.selection} selection
     */

  }, {
    key: "applyBehaviors",
    value: function applyBehaviors(selection) {
      var _this5 = this;

      if (_typeof(this.layout.behaviors) != 'object') {
        return;
      }

      Object.keys(this.layout.behaviors).forEach(function (directive) {
        var event_match = /(click|mouseover|mouseout)/.exec(directive);

        if (!event_match) {
          return;
        }

        selection.on("".concat(event_match[0], ".").concat(directive), _this5.executeBehaviors(directive, _this5.layout.behaviors[directive]));
      });
    }
    /**
     * Generate a function that executes an arbitrary list of behaviors on an element during an event
     *
     * @private
     * @param {String} directive The name of the event, as described in layout.behaviors for this datalayer
     * @param {Object[]} behaviors An object describing the behavior to attach to this single element
     * @param {string} behaviors.action The name of the action that would trigger this behavior (eg click, mouseover, etc)
     * @param {string} behaviors.status What status to apply to the element when this behavior is triggered (highlighted,
     *  selected, etc)
     * @param {boolean} [behaviors.exclusive] Whether triggering the event for this element should unset the relevant status
     *   for all other elements. Useful for, eg, click events that exclusively highlight one thing.
     * @returns {function(this:BaseDataLayer)} Return a function that handles the event in context with the behavior
     *   and the element- can be attached as an event listener
     */

  }, {
    key: "executeBehaviors",
    value: function executeBehaviors(directive, behaviors) {
      // Determine the required state of control and shift keys during the event
      var requiredKeyStates = {
        'ctrl': directive.includes('ctrl'),
        'shift': directive.includes('shift')
      };
      var self = this;
      return function (element) {
        // This method may be used on two kinds of events: directly attached, or bubbled.
        // D3 doesn't natively support bubbling very well; if no data is bound on the currentTarget, check to see
        //  if there is data available at wherever the event was initiated from
        element = element || d3__WEBPACK_IMPORTED_MODULE_0__["select"](d3__WEBPACK_IMPORTED_MODULE_0__["event"].target).datum(); // Do nothing if the required control and shift key presses (or lack thereof) doesn't match the event

        if (requiredKeyStates.ctrl !== !!d3__WEBPACK_IMPORTED_MODULE_0__["event"].ctrlKey || requiredKeyStates.shift !== !!d3__WEBPACK_IMPORTED_MODULE_0__["event"].shiftKey) {
          return;
        } // Loop through behaviors making each one go in succession


        behaviors.forEach(function (behavior) {
          // Route first by the action, if defined
          if (_typeof(behavior) != 'object' || behavior === null) {
            return;
          }

          var current_status_boolean = self.layer_state.status_flags[behavior.status].includes(self.getElementId(element));
          var exclusive = behavior.exclusive && !current_status_boolean;

          switch (behavior.action) {
            // Set a status (set to true regardless of current status, optionally with exclusivity)
            case 'set':
              self.setElementStatus(behavior.status, element, true, behavior.exclusive);
              break;
            // Unset a status (set to false regardless of current status, optionally with exclusivity)

            case 'unset':
              self.setElementStatus(behavior.status, element, false, behavior.exclusive);
              break;
            // Toggle a status

            case 'toggle':
              self.setElementStatus(behavior.status, element, !current_status_boolean, exclusive);
              break;
            // Link to a dynamic URL

            case 'link':
              if (typeof behavior.href == 'string') {
                var url = Object(_helpers_display__WEBPACK_IMPORTED_MODULE_3__["parseFields"])(element, behavior.href);

                if (typeof behavior.target == 'string') {
                  window.open(url, behavior.target);
                } else {
                  window.location.href = url;
                }
              }

              break;
            // Action not defined, just return

            default:
              break;
          }
        });
      };
    }
    /**
     * Get an object with the x and y coordinates of the panel's origin in terms of the entire page
     *   Necessary for positioning any HTML elements over the panel
     *
     * @private
     * @returns {{x: Number, y: Number}}
     */

  }, {
    key: "_getPageOrigin",
    value: function _getPageOrigin() {
      var panel_origin = this.parent._getPageOrigin();

      return {
        x: panel_origin.x + this.parent.layout.margin.left,
        y: panel_origin.y + this.parent.layout.margin.top
      };
    }
    /**
     * Apply all tracked element statuses. This is primarily intended for re-rendering the plot, in order to preserve
     *  behaviors when items are updated.
     *  @private
     */

  }, {
    key: "applyAllElementStatus",
    value: function applyAllElementStatus() {
      var _this6 = this;

      var status_flags = this.layer_state.status_flags;
      var self = this;

      var _loop = function _loop(property) {
        if (!Object.prototype.hasOwnProperty.call(status_flags, property)) {
          return "continue";
        }

        if (Array.isArray(status_flags[property])) {
          status_flags[property].forEach(function (element_id) {
            try {
              _this6.setElementStatus(property, _this6.getElementById(element_id), true);
            } catch (e) {
              console.warn("Unable to apply state: ".concat(self.state_id, ", ").concat(property));
              console.error(e);
            }
          });
        }
      };

      for (var property in status_flags) {
        var _ret = _loop(property);

        if (_ret === "continue") continue;
      }
    }
    /**
     * Position the datalayer and all tooltips
     * @private
     * @returns {BaseDataLayer}
     */

  }, {
    key: "draw",
    value: function draw() {
      this.svg.container.attr('transform', "translate(".concat(this.parent.layout.cliparea.origin.x, ", ").concat(this.parent.layout.cliparea.origin.y, ")"));
      this.svg.clipRect.attr('width', this.parent.layout.cliparea.width).attr('height', this.parent.layout.cliparea.height);
      this.positionAllTooltips();
      return this;
    }
    /**
     * Re-Map a data layer to reflect changes in the state of a plot (such as viewing region/ chromosome range)
     *
     * Whereas .render draws whatever data is available, this method resets the view and fetches new data if necessary.
     *
     * @private
     * @return {Promise}
     */

  }, {
    key: "reMap",
    value: function reMap() {
      var _this7 = this;

      this.destroyAllTooltips(); // hack - only non-visible tooltips should be destroyed
      // and then recreated if returning to visibility
      // Fetch new data. Datalayers are only given access to the final consolidated data from the chain (not headers or raw payloads)

      return this.parent_plot.lzd.getData(this.state, this.layout.fields).then(function (new_data) {
        _this7.data = new_data.body; // chain.body from datasources

        _this7.applyDataMethods();

        _this7.initialized = true;
      });
    }
  }]);

  return BaseDataLayer;
}();

_constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].verbs.forEach(function (verb, idx) {
  var adjective = _constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].adjectives[idx];
  var antiverb = "un".concat(verb); // Set/unset a single element's status

  /**
   * @private
   * @function highlightElement
   */

  /**
   * @private
   * @function selectElement
   */

  /**
   *  @private
   *  @function fadeElement
   */

  /**
   *  @private
   *  @function hideElement
   */

  BaseDataLayer.prototype["".concat(verb, "Element")] = function (element, exclusive) {
    if (typeof exclusive == 'undefined') {
      exclusive = false;
    } else {
      exclusive = !!exclusive;
    }

    this.setElementStatus(adjective, element, true, exclusive);
    return this;
  };
  /**
   * @private
   * @function unhighlightElement
   */

  /**
   *  @private
   *  @function unselectElement
   */

  /**
   *  @private
   *  @function unfadeElement
   */

  /**
   *  @private
   *  @function unhideElement
   */


  BaseDataLayer.prototype["".concat(antiverb, "Element")] = function (element, exclusive) {
    if (typeof exclusive == 'undefined') {
      exclusive = false;
    } else {
      exclusive = !!exclusive;
    }

    this.setElementStatus(adjective, element, false, exclusive);
    return this;
  };
  /**
   * @private
   * @function highlightAllElements
   */

  /**
   *  @private
   *  @function selectAllElements
   */

  /**
   *  @private
   *  @function fadeAllElements
   */

  /**
   *  @private
   *  @function hideAllElements
   */
  // Set/unset status for all elements


  BaseDataLayer.prototype["".concat(verb, "AllElements")] = function () {
    this.setAllElementStatus(adjective, true);
    return this;
  };
  /**
   * @private
   * @function unhighlightAllElements
   */

  /**
   *  @private
   *  @function unselectAllElements
   */

  /**
   * @private
   * @function unfadeAllElements
   * */

  /**
   * @private
   * @function unhideAllElements
   */


  BaseDataLayer.prototype["".concat(antiverb, "AllElements")] = function () {
    this.setAllElementStatus(adjective, false);
    return this;
  };
});


/***/ }),

/***/ "./esm/components/data_layer/forest.js":
/*!*********************************************!*\
  !*** ./esm/components/data_layer/forest.js ***!
  \*********************************************/
/*! exports provided: forest, category_forest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forest", function() { return Forest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "category_forest", function() { return CategoryForest; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony import */ var _data_field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/field */ "./esm/data/field.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */




var default_layout = {
  point_size: 40,
  point_shape: 'square',
  color: '#888888',
  fill_opacity: 1,
  y_axis: {
    axis: 2
  },
  id_field: 'id',
  confidence_intervals: {
    start_field: 'ci_start',
    end_field: 'ci_end'
  },
  show_no_significance_line: true
};
/**
 * Forest Data Layer
 * Implements a standard forest plot. In order to space out points, any layout using this must specify axis ticks
 *  and extent in advance.
 *
 * If you are using dynamically fetched data, consider using `category_forest` instead.
 *
 */

var Forest = /*#__PURE__*/function (_BaseDataLayer) {
  _inherits(Forest, _BaseDataLayer);

  var _super = _createSuper(Forest);

  function Forest(layout) {
    _classCallCheck(this, Forest);

    layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_3__["merge"])(layout, default_layout);
    return _super.apply(this, arguments);
  }

  _createClass(Forest, [{
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);
      var y_scale = "y".concat(this.layout.y_axis.axis, "_scale");
      var y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);
      var point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);
      var offset = Math.sqrt(point_size / Math.PI);
      return {
        x_min: x_center - offset,
        x_max: x_center + offset,
        y_min: y_center - offset,
        y_max: y_center + offset
      };
    } // Implement the main render function

  }, {
    key: "render",
    value: function render() {
      var _this = this;

      // Apply filters to only render a specified set of points
      var track_data = this._applyFilters();

      var x_scale = 'x_scale';
      var y_scale = "y".concat(this.layout.y_axis.axis, "_scale"); // Generate confidence interval paths if fields are defined

      if (this.layout.confidence_intervals && this.layout.fields.includes(this.layout.confidence_intervals.start_field) && this.layout.fields.includes(this.layout.confidence_intervals.end_field)) {
        // Generate a selection for all forest plot confidence intervals
        var ci_selection = this.svg.group.selectAll('rect.lz-data_layer-forest.lz-data_layer-forest-ci').data(track_data, function (d) {
          return d[_this.layout.id_field];
        });

        var ci_transform = function ci_transform(d) {
          var x = _this.parent[x_scale](d[_this.layout.confidence_intervals.start_field]);

          var y = _this.parent[y_scale](d[_this.layout.y_axis.field]);

          if (isNaN(x)) {
            x = -1000;
          }

          if (isNaN(y)) {
            y = -1000;
          }

          return "translate(".concat(x, ", ").concat(y, ")");
        };

        var ci_width = function ci_width(d) {
          return _this.parent[x_scale](d[_this.layout.confidence_intervals.end_field]) - _this.parent[x_scale](d[_this.layout.confidence_intervals.start_field]);
        };

        var ci_height = 1; // Create confidence interval rect elements

        ci_selection.enter().append('rect').attr('class', 'lz-data_layer-forest lz-data_layer-forest-ci').attr('id', function (d) {
          return "".concat(_this.getElementId(d), "_ci");
        }).attr('transform', "translate(0, ".concat(isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height, ")")).merge(ci_selection).attr('transform', ci_transform).attr('width', ci_width).attr('height', ci_height); // Remove old elements as needed

        ci_selection.exit().remove();
      } // Generate a selection for all forest plot points


      var points_selection = this.svg.group.selectAll('path.lz-data_layer-forest.lz-data_layer-forest-point').data(track_data, function (d) {
        return d[_this.layout.id_field];
      }); // Create elements, apply class, ID, and initial position

      var initial_y = isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height; // Generate new values (or functions for them) for position, color, size, and shape

      var transform = function transform(d) {
        var x = _this.parent[x_scale](d[_this.layout.x_axis.field]);

        var y = _this.parent[y_scale](d[_this.layout.y_axis.field]);

        if (isNaN(x)) {
          x = -1000;
        }

        if (isNaN(y)) {
          y = -1000;
        }

        return "translate(".concat(x, ", ").concat(y, ")");
      };

      var fill = function fill(d, i) {
        return _this.resolveScalableParameter(_this.layout.color, d, i);
      };

      var fill_opacity = function fill_opacity(d, i) {
        return _this.resolveScalableParameter(_this.layout.fill_opacity, d, i);
      };

      var shape = d3__WEBPACK_IMPORTED_MODULE_0__["symbol"]().size(function (d, i) {
        return _this.resolveScalableParameter(_this.layout.point_size, d, i);
      }).type(function (d, i) {
        return Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_3__["nameToSymbol"])(_this.resolveScalableParameter(_this.layout.point_shape, d, i));
      });
      points_selection.enter().append('path').attr('class', 'lz-data_layer-forest lz-data_layer-forest-point').attr('id', function (d) {
        return _this.getElementId(d);
      }).attr('transform', "translate(0, ".concat(initial_y, ")")).merge(points_selection).attr('transform', transform).attr('fill', fill).attr('fill-opacity', fill_opacity).attr('d', shape); // Remove old elements as needed

      points_selection.exit().remove(); // Apply behaviors to points

      this.svg.group.on('click.event_emitter', function (element_data) {
        _this.parent.emit('element_clicked', element_data, true);
      }).call(this.applyBehaviors.bind(this));
    }
  }]);

  return Forest;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * A y-aligned forest plot in which the y-axis represents item labels, which are dynamically chosen when data is loaded.
 *   Each item is assumed to include both data and confidence intervals.
 *   This allows generating forest plots without defining the layout in advance.
 *
 */


var CategoryForest = /*#__PURE__*/function (_Forest) {
  _inherits(CategoryForest, _Forest);

  var _super2 = _createSuper(CategoryForest);

  function CategoryForest() {
    _classCallCheck(this, CategoryForest);

    return _super2.apply(this, arguments);
  }

  _createClass(CategoryForest, [{
    key: "_getDataExtent",
    value: function _getDataExtent(data, axis_config) {
      // In a forest plot, the data range is determined by *three* fields (beta + CI start/end)
      var ci_config = this.layout.confidence_intervals;

      if (ci_config && this.layout.fields.includes(ci_config.start_field) && this.layout.fields.includes(ci_config.end_field)) {
        var min = function min(d) {
          var f = new _data_field__WEBPACK_IMPORTED_MODULE_2__["default"](ci_config.start_field);
          return +f.resolve(d);
        };

        var max = function max(d) {
          var f = new _data_field__WEBPACK_IMPORTED_MODULE_2__["default"](ci_config.end_field);
          return +f.resolve(d);
        };

        return [d3__WEBPACK_IMPORTED_MODULE_0__["min"](data, min), d3__WEBPACK_IMPORTED_MODULE_0__["max"](data, max)];
      } // If there are no confidence intervals set, then range must depend only on a single field


      return _get(_getPrototypeOf(CategoryForest.prototype), "_getDataExtent", this).call(this, data, axis_config);
    }
  }, {
    key: "getTicks",
    value: function getTicks(dimension, config) {
      // Overrides parent method
      if (!['x', 'y1', 'y2'].includes(dimension)) {
        throw new Error("Invalid dimension identifier ".concat(dimension));
      } // Design assumption: one axis (y1 or y2) has the ticks, and the layout says which to use
      // Also assumes that every tick gets assigned a unique matching label


      var axis_num = this.layout.y_axis.axis;

      if (dimension === "y".concat(axis_num)) {
        var category_field = this.layout.y_axis.category_field;

        if (!category_field) {
          throw new Error("Layout for ".concat(this.layout.id, " must specify category_field"));
        }

        return this.data.map(function (item, index) {
          return {
            y: index + 1,
            text: item[category_field]
          };
        });
      } else {
        return [];
      }
    }
  }, {
    key: "applyCustomDataMethods",
    value: function applyCustomDataMethods() {
      // Add a synthetic yaxis field to ensure data is spread out on plot. Then, set axis floor and ceiling to
      //  correct extents.
      var field_to_add = this.layout.y_axis.field;

      if (!field_to_add) {
        throw new Error("Layout for ".concat(this.layout.id, " must specify yaxis.field"));
      }

      this.data = this.data.map(function (item, index) {
        item[field_to_add] = index + 1;
        return item;
      }); // Update axis extents based on one label for every point (with a bit of padding above and below)

      this.layout.y_axis.floor = 0;
      this.layout.y_axis.ceiling = this.data.length + 1;
      return this;
    }
  }]);

  return CategoryForest;
}(Forest);



/***/ }),

/***/ "./esm/components/data_layer/genes.js":
/*!********************************************!*\
  !*** ./esm/components/data_layer/genes.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Genes; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */



var default_layout = {
  // Optionally specify different fill and stroke properties
  stroke: 'rgb(54, 54, 150)',
  color: '#363696',
  label_font_size: 12,
  label_exon_spacing: 3,
  exon_height: 10,
  bounding_box_padding: 3,
  track_vertical_spacing: 5,
  tooltip_positioning: 'top'
};
/*********************
 * Genes Data Layer
 * Implements a data layer that will render gene tracks
*/

var Genes = /*#__PURE__*/function (_BaseDataLayer) {
  _inherits(Genes, _BaseDataLayer);

  var _super = _createSuper(Genes);

  function Genes(layout) {
    var _this;

    _classCallCheck(this, Genes);

    layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_2__["merge"])(layout, default_layout);
    _this = _super.apply(this, arguments);
    /**
     * A gene may have arbitrarily many transcripts, but this data layer isn't set up to render them yet.
     * Stash a transcript_idx to point to the first transcript and use that for all transcript refs.
     * @member {number}
     * @type {number}
     */

    _this.transcript_idx = 0;
    /**
     * An internal counter for the number of tracks in the data layer. Used as an internal counter for looping
     *   over positions / assignments
     * @protected
     * @member {number}
     */

    _this.tracks = 1;
    /**
     * Store information about genes in dataset, in a hash indexed by track number: {track_number: [gene_indices]}
     * @member {Object.<Number, Array>}
     */

    _this.gene_track_index = {
      1: []
    };
    return _this;
  }
  /**
   * Generate a statusnode ID for a given element
   * @override
   * @returns {String}
   */


  _createClass(Genes, [{
    key: "getElementStatusNodeId",
    value: function getElementStatusNodeId(element) {
      return "".concat(this.getElementId(element), "-statusnode");
    }
    /**
     * Helper function to sum layout values to derive total height for a single gene track
     * @returns {number}
     */

  }, {
    key: "getTrackHeight",
    value: function getTrackHeight() {
      return 2 * this.layout.bounding_box_padding + this.layout.label_font_size + this.layout.label_exon_spacing + this.layout.exon_height + this.layout.track_vertical_spacing;
    }
    /**
     * Ensure that genes in overlapping chromosome regions are positioned so that parts of different genes do not
     *   overlap in the view. A track is a row used to vertically separate overlapping genes.
     * @returns {Genes}
     */

  }, {
    key: "assignTracks",
    value: function assignTracks(data) {
      var _this2 = this;

      /**
       * Function to get the width in pixels of a label given the text and layout attributes
       * @param {String} gene_name
       * @param {number|string} font_size
       * @returns {number}
       */
      var _getLabelWidth = function _getLabelWidth(gene_name, font_size) {
        try {
          var temp_text = _this2.svg.group.append('text').attr('x', 0).attr('y', 0).attr('class', 'lz-data_layer-genes lz-label').style('font-size', font_size).text("".concat(gene_name, "\u2192"));

          var label_width = temp_text.node().getBBox().width;
          temp_text.remove();
          return label_width;
        } catch (e) {
          return 0;
        }
      }; // Reinitialize some metadata


      this.tracks = 1;
      this.gene_track_index = {
        1: []
      };
      data.map(function (item) {
        // If necessary, split combined gene id / version fields into discrete fields.
        // NOTE: this may be an issue with CSG's genes data source that may eventually be solved upstream.
        if (item.gene_id && item.gene_id.indexOf('.')) {
          var split = item.gene_id.split('.');
          item.gene_id = split[0];
          item.gene_version = split[1];
        } // Stash the transcript ID on the parent gene


        item.transcript_id = item.transcripts[_this2.transcript_idx].transcript_id; // Determine display range start and end, based on minimum allowable gene display width, bounded by what we can see
        // (range: values in terms of pixels on the screen)

        item.display_range = {
          start: _this2.parent.x_scale(Math.max(item.start, _this2.state.start)),
          end: _this2.parent.x_scale(Math.min(item.end, _this2.state.end))
        };
        item.display_range.label_width = _getLabelWidth(item.gene_name, _this2.layout.label_font_size);
        item.display_range.width = item.display_range.end - item.display_range.start; // Determine label text anchor (default to middle)

        item.display_range.text_anchor = 'middle';

        if (item.display_range.width < item.display_range.label_width) {
          if (item.start < _this2.state.start) {
            item.display_range.end = item.display_range.start + item.display_range.label_width + _this2.layout.label_font_size;
            item.display_range.text_anchor = 'start';
          } else if (item.end > _this2.state.end) {
            item.display_range.start = item.display_range.end - item.display_range.label_width - _this2.layout.label_font_size;
            item.display_range.text_anchor = 'end';
          } else {
            var centered_margin = (item.display_range.label_width - item.display_range.width) / 2 + _this2.layout.label_font_size;

            if (item.display_range.start - centered_margin < _this2.parent.x_scale(_this2.state.start)) {
              item.display_range.start = _this2.parent.x_scale(_this2.state.start);
              item.display_range.end = item.display_range.start + item.display_range.label_width;
              item.display_range.text_anchor = 'start';
            } else if (item.display_range.end + centered_margin > _this2.parent.x_scale(_this2.state.end)) {
              item.display_range.end = _this2.parent.x_scale(_this2.state.end);
              item.display_range.start = item.display_range.end - item.display_range.label_width;
              item.display_range.text_anchor = 'end';
            } else {
              item.display_range.start -= centered_margin;
              item.display_range.end += centered_margin;
            }
          }

          item.display_range.width = item.display_range.end - item.display_range.start;
        } // Add bounding box padding to the calculated display range start, end, and width


        item.display_range.start -= _this2.layout.bounding_box_padding;
        item.display_range.end += _this2.layout.bounding_box_padding;
        item.display_range.width += 2 * _this2.layout.bounding_box_padding; // Convert and stash display range values into domain values
        // (domain: values in terms of the data set, e.g. megabases)

        item.display_domain = {
          start: _this2.parent.x_scale.invert(item.display_range.start),
          end: _this2.parent.x_scale.invert(item.display_range.end)
        };
        item.display_domain.width = item.display_domain.end - item.display_domain.start; // Using display range/domain data generated above cast each gene to tracks such that none overlap

        item.track = null;
        var potential_track = 1;

        var _loop = function _loop() {
          var collision_on_potential_track = false;

          _this2.gene_track_index[potential_track].map(function (placed_gene) {
            if (!collision_on_potential_track) {
              var min_start = Math.min(placed_gene.display_range.start, item.display_range.start);
              var max_end = Math.max(placed_gene.display_range.end, item.display_range.end);

              if (max_end - min_start < placed_gene.display_range.width + item.display_range.width) {
                collision_on_potential_track = true;
              }
            }
          });

          if (!collision_on_potential_track) {
            item.track = potential_track;

            _this2.gene_track_index[potential_track].push(item);
          } else {
            potential_track++;

            if (potential_track > _this2.tracks) {
              _this2.tracks = potential_track;
              _this2.gene_track_index[potential_track] = [];
            }
          }
        };

        while (item.track === null) {
          _loop();
        } // Stash parent references on all genes, transcripts, and exons


        item.parent = _this2;
        item.transcripts.map(function (d, t) {
          item.transcripts[t].parent = item;
          item.transcripts[t].exons.map(function (d, e) {
            return item.transcripts[t].exons[e].parent = item.transcripts[t];
          });
        });
      });
      return this;
    }
    /**
     * Main render function
     */

  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var self = this; // Apply filters to only render a specified set of points

      var track_data = this._applyFilters();

      this.assignTracks(track_data);
      var height; // Render gene groups

      var selection = this.svg.group.selectAll('g.lz-data_layer-genes').data(track_data, function (d) {
        return d.gene_name;
      });
      selection.enter().append('g').attr('class', 'lz-data_layer-genes').merge(selection).attr('id', function (d) {
        return _this3.getElementId(d);
      }).each(function (gene) {
        var data_layer = gene.parent; // Render gene bounding boxes (status nodes to show selected/highlighted)

        var bboxes = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-genes.lz-data_layer-genes-statusnode').data([gene], function (d) {
          return data_layer.getElementStatusNodeId(d);
        });
        height = data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;
        bboxes.enter().append('rect').attr('class', 'lz-data_layer-genes lz-data_layer-genes-statusnode').merge(bboxes).attr('id', function (d) {
          return data_layer.getElementStatusNodeId(d);
        }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).attr('width', function (d) {
          return d.display_range.width;
        }).attr('height', height).attr('x', function (d) {
          return d.display_range.start;
        }).attr('y', function (d) {
          return (d.track - 1) * data_layer.getTrackHeight();
        });
        bboxes.exit().remove(); // Render gene boundaries

        var boundaries = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-genes.lz-boundary').data([gene], function (d) {
          return "".concat(d.gene_name, "_boundary");
        });
        height = 1;
        boundaries.enter().append('rect').attr('class', 'lz-data_layer-genes lz-boundary').merge(boundaries).attr('width', function (d) {
          return data_layer.parent.x_scale(d.end) - data_layer.parent.x_scale(d.start);
        }).attr('height', height).attr('x', function (d) {
          return data_layer.parent.x_scale(d.start);
        }).attr('y', function (d) {
          return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding + data_layer.layout.label_font_size + data_layer.layout.label_exon_spacing + Math.max(data_layer.layout.exon_height, 3) / 2;
        }).style('fill', function (d, i) {
          return self.resolveScalableParameter(self.layout.color, d, i);
        }).style('stroke', function (d, i) {
          return self.resolveScalableParameter(self.layout.stroke, d, i);
        });
        boundaries.exit().remove(); // Render gene labels

        var labels = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('text.lz-data_layer-genes.lz-label').data([gene], function (d) {
          return "".concat(d.gene_name, "_label");
        });
        labels.enter().append('text').attr('class', 'lz-data_layer-genes lz-label').merge(labels).attr('text-anchor', function (d) {
          return d.display_range.text_anchor;
        }).text(function (d) {
          return d.strand === '+' ? "".concat(d.gene_name, "\u2192") : "\u2190".concat(d.gene_name);
        }).style('font-size', gene.parent.layout.label_font_size).attr('x', function (d) {
          if (d.display_range.text_anchor === 'middle') {
            return d.display_range.start + d.display_range.width / 2;
          } else if (d.display_range.text_anchor === 'start') {
            return d.display_range.start + data_layer.layout.bounding_box_padding;
          } else if (d.display_range.text_anchor === 'end') {
            return d.display_range.end - data_layer.layout.bounding_box_padding;
          }
        }).attr('y', function (d) {
          return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding + data_layer.layout.label_font_size;
        });
        labels.exit().remove(); // Render exon rects (first transcript only, for now)
        // Exons: by default color on gene properties for consistency with the gene boundary track- hence color uses d.parent.parent

        var exons = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-genes.lz-exon').data(gene.transcripts[gene.parent.transcript_idx].exons, function (d) {
          return d.exon_id;
        });
        height = data_layer.layout.exon_height;
        exons.enter().append('rect').attr('class', 'lz-data_layer-genes lz-exon').merge(exons).style('fill', function (d, i) {
          return self.resolveScalableParameter(self.layout.color, d.parent.parent, i);
        }).style('stroke', function (d, i) {
          return self.resolveScalableParameter(self.layout.stroke, d.parent.parent, i);
        }).attr('width', function (d) {
          return data_layer.parent.x_scale(d.end) - data_layer.parent.x_scale(d.start);
        }).attr('height', height).attr('x', function (d) {
          return data_layer.parent.x_scale(d.start);
        }).attr('y', function () {
          return (gene.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding + data_layer.layout.label_font_size + data_layer.layout.label_exon_spacing;
        });
        exons.exit().remove(); // Render gene click area

        var clickareas = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).selectAll('rect.lz-data_layer-genes.lz-clickarea').data([gene], function (d) {
          return "".concat(d.gene_name, "_clickarea");
        });
        height = data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;
        clickareas.enter().append('rect').attr('class', 'lz-data_layer-genes lz-clickarea').merge(clickareas).attr('id', function (d) {
          return "".concat(data_layer.getElementId(d), "_clickarea");
        }).attr('rx', data_layer.layout.bounding_box_padding).attr('ry', data_layer.layout.bounding_box_padding).attr('width', function (d) {
          return d.display_range.width;
        }).attr('height', height).attr('x', function (d) {
          return d.display_range.start;
        }).attr('y', function (d) {
          return (d.track - 1) * data_layer.getTrackHeight();
        }); // Remove old clickareas as needed

        clickareas.exit().remove();
      }); // Remove old elements as needed

      selection.exit().remove(); // Apply mouse behaviors & events to clickareas

      this.svg.group.on('click.event_emitter', function (element) {
        return _this3.parent.emit('element_clicked', element, true);
      }).call(this.applyBehaviors.bind(this));
    }
  }, {
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      var gene_bbox_id = this.getElementStatusNodeId(tooltip.data);
      var gene_bbox = d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#".concat(gene_bbox_id)).node().getBBox();
      return {
        x_min: this.parent.x_scale(tooltip.data.start),
        x_max: this.parent.x_scale(tooltip.data.end),
        y_min: gene_bbox.y,
        y_max: gene_bbox.y + gene_bbox.height
      };
    }
  }]);

  return Genes;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./esm/components/data_layer/index.js":
/*!********************************************!*\
  !*** ./esm/components/data_layer/index.js ***!
  \********************************************/
/*! exports provided: BaseDataLayer, annotation_track, arcs, forest, category_forest, genes, line, orthogonal_line, scatter, category_scatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseDataLayer", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _annotation_track__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation_track */ "./esm/components/data_layer/annotation_track.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "annotation_track", function() { return _annotation_track__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _arcs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./arcs */ "./esm/components/data_layer/arcs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arcs", function() { return _arcs__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _forest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./forest */ "./esm/components/data_layer/forest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forest", function() { return _forest__WEBPACK_IMPORTED_MODULE_3__["forest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "category_forest", function() { return _forest__WEBPACK_IMPORTED_MODULE_3__["category_forest"]; });

/* harmony import */ var _genes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./genes */ "./esm/components/data_layer/genes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "genes", function() { return _genes__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line */ "./esm/components/data_layer/line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _line__WEBPACK_IMPORTED_MODULE_5__["line"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "orthogonal_line", function() { return _line__WEBPACK_IMPORTED_MODULE_5__["orthogonal_line"]; });

/* harmony import */ var _scatter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scatter */ "./esm/components/data_layer/scatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scatter", function() { return _scatter__WEBPACK_IMPORTED_MODULE_6__["scatter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "category_scatter", function() { return _scatter__WEBPACK_IMPORTED_MODULE_6__["category_scatter"]; });

/**
 * Rollup module that defines all known datalayers. Used to create the registry.
 * @module
 * @private
 */








/***/ }),

/***/ "./esm/components/data_layer/line.js":
/*!*******************************************!*\
  !*** ./esm/components/data_layer/line.js ***!
  \*******************************************/
/*! exports provided: line, orthogonal_line */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthogonal_line", function() { return OrthogonalLine; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./esm/components/constants.js");
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/common */ "./esm/helpers/common.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */





var default_layout = {
  style: {
    fill: 'none',
    'stroke-width': '2px'
  },
  interpolate: 'curveLinear',
  x_axis: {
    field: 'x'
  },
  y_axis: {
    field: 'y',
    axis: 1
  },
  hitarea_width: 5
};
/*********************
 * Line Data Layer
 * Implements a standard line plot, representing either a trace or a filled curve.
*/

var Line = /*#__PURE__*/function (_BaseDataLayer) {
  _inherits(Line, _BaseDataLayer);

  var _super = _createSuper(Line);

  function Line(layout) {
    _classCallCheck(this, Line);

    layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_2__["merge"])(layout, default_layout);

    if (layout.tooltip) {
      throw new Error('The line / filled curve layer does not support tooltips');
    }

    return _super.apply(this, arguments);
  }
  /**
   * Implement the main render function
   */


  _createClass(Line, [{
    key: "render",
    value: function render() {
      // Several vars needed to be in scope
      var panel = this.parent;
      var x_field = this.layout.x_axis.field;
      var y_field = this.layout.y_axis.field; // Join data to the line selection

      var selection = this.svg.group.selectAll('path.lz-data_layer-line').data([this.data]); // Create path element, apply class

      this.path = selection.enter().append('path').attr('class', 'lz-data_layer-line'); // Generate the line

      var line;
      var x_scale = panel['x_scale'];
      var y_scale = panel["y".concat(this.layout.y_axis.axis, "_scale")];

      if (this.layout.style.fill && this.layout.style.fill !== 'none') {
        // Filled curve: define the line as a filled boundary
        line = d3__WEBPACK_IMPORTED_MODULE_0__["area"]().x(function (d) {
          return +x_scale(d[x_field]);
        }).y0(+y_scale(0)).y1(function (d) {
          return +y_scale(d[y_field]);
        });
      } else {
        // Basic line
        line = d3__WEBPACK_IMPORTED_MODULE_0__["line"]().x(function (d) {
          return +x_scale(d[x_field]);
        }).y(function (d) {
          return +y_scale(d[y_field]);
        }).curve(d3__WEBPACK_IMPORTED_MODULE_0__[this.layout.interpolate]);
      } // Apply line and style


      selection.merge(this.path).attr('d', line).call(_helpers_common__WEBPACK_IMPORTED_MODULE_4__["applyStyles"], this.layout.style); // Remove old elements as needed

      selection.exit().remove();
    }
    /**
     * Redefine setElementStatus family of methods as line data layers will only ever have a single path element
     * @param {String} status A member of `LocusZoom.DataLayer.Statuses.adjectives`
     * @param {String|Object} element
     * @param {Boolean} toggle
     * @returns {Line}
     */

  }, {
    key: "setElementStatus",
    value: function setElementStatus(status, element, toggle) {
      return this.setAllElementStatus(status, toggle);
    }
  }, {
    key: "setAllElementStatus",
    value: function setAllElementStatus(status, toggle) {
      var _this = this;

      // Sanity check
      if (typeof status == 'undefined' || !_constants__WEBPACK_IMPORTED_MODULE_3__["STATUSES"].adjectives.includes(status)) {
        throw new Error('Invalid status');
      }

      if (typeof this.layer_state.status_flags[status] == 'undefined') {
        return this;
      }

      if (typeof toggle == 'undefined') {
        toggle = true;
      } // Update global status flag


      this.global_statuses[status] = toggle; // Apply class to path based on global status flags

      var path_class = 'lz-data_layer-line';
      Object.keys(this.global_statuses).forEach(function (global_status) {
        if (_this.global_statuses[global_status]) {
          path_class += " lz-data_layer-line-".concat(global_status);
        }
      });
      this.path.attr('class', path_class); // Trigger layout changed event hook

      this.parent.emit('layout_changed', true);
      return this;
    }
  }]);

  return Line;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);

var default_orthogonal_layout = {
  style: {
    'stroke': '#D3D3D3',
    'stroke-width': '3px',
    'stroke-dasharray': '10px 10px'
  },
  orientation: 'horizontal',
  x_axis: {
    axis: 1,
    decoupled: true
  },
  y_axis: {
    axis: 1,
    decoupled: true
  },
  tooltip_positioning: 'vertical',
  offset: 0
};
/***************************
 *  Orthogonal Line Data Layer
 *  Implements a horizontal or vertical line given an orientation and an offset in the layout
 *  Does not require a data source
*/

var OrthogonalLine = /*#__PURE__*/function (_BaseDataLayer2) {
  _inherits(OrthogonalLine, _BaseDataLayer2);

  var _super2 = _createSuper(OrthogonalLine);

  function OrthogonalLine(layout) {
    var _this2;

    _classCallCheck(this, OrthogonalLine);

    layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_2__["merge"])(layout, default_orthogonal_layout); // Require that orientation be "horizontal" or "vertical" only

    if (!['horizontal', 'vertical'].includes(layout.orientation)) {
      layout.orientation = 'horizontal';
    }

    _this2 = _super2.apply(this, arguments); // Vars for storing the data generated line

    /** @member {Array} */

    _this2.data = [];
    return _this2;
  }

  _createClass(OrthogonalLine, [{
    key: "getElementId",
    value: function getElementId(element) {
      // There is only one line per datalayer, so this is sufficient.
      return this.getBaseId();
    }
    /**
     * Implement the main render function
     */

  }, {
    key: "render",
    value: function render() {
      // Several vars needed to be in scope
      var panel = this.parent;
      var x_scale = 'x_scale';
      var y_scale = "y".concat(this.layout.y_axis.axis, "_scale");
      var x_extent = 'x_extent';
      var y_extent = "y".concat(this.layout.y_axis.axis, "_extent");
      var x_range = 'x_range'; // Generate data using extents depending on orientation

      if (this.layout.orientation === 'horizontal') {
        this.data = [{
          x: panel[x_extent][0],
          y: this.layout.offset
        }, {
          x: panel[x_extent][1],
          y: this.layout.offset
        }];
      } else if (this.layout.orientation === 'vertical') {
        this.data = [{
          x: this.layout.offset,
          y: panel[y_extent][0]
        }, {
          x: this.layout.offset,
          y: panel[y_extent][1]
        }];
      } else {
        throw new Error('Unrecognized vertical line type. Must be "vertical" or "horizontal"');
      } // Join data to the line selection


      var selection = this.svg.group.selectAll('path.lz-data_layer-line').data([this.data]); // In some cases, a vertical line may overlay a track that has no inherent y-values (extent)
      //  When that happens, provide a default height based on the current panel dimensions (accounting
      //      for any resizing that happened after the panel was created)

      var default_y = [panel.layout.cliparea.height, 0]; // Generate the line

      var line = d3__WEBPACK_IMPORTED_MODULE_0__["line"]().x(function (d, i) {
        var x = +panel[x_scale](d['x']);
        return isNaN(x) ? panel[x_range][i] : x;
      }).y(function (d, i) {
        var y = +panel[y_scale](d['y']);
        return isNaN(y) ? default_y[i] : y;
      }); // Create path element, apply class

      this.path = selection.enter().append('path').attr('class', 'lz-data_layer-line').merge(selection).attr('d', line).call(_helpers_common__WEBPACK_IMPORTED_MODULE_4__["applyStyles"], this.layout.style) // Allow the layer to respond to mouseover events and show a tooltip.
      .call(this.applyBehaviors.bind(this)); // Remove old elements as needed

      selection.exit().remove();
    }
  }, {
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      try {
        var coords = d3__WEBPACK_IMPORTED_MODULE_0__["mouse"](this.svg.container.node());
        var x = coords[0];
        var y = coords[1];
        return {
          x_min: x - 1,
          x_max: x + 1,
          y_min: y - 1,
          y_max: y + 1
        };
      } catch (e) {
        // On redraw, there won't be a mouse event, so skip tooltip repositioning.
        return null;
      }
    }
  }]);

  return OrthogonalLine;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./esm/components/data_layer/scatter.js":
/*!**********************************************!*\
  !*** ./esm/components/data_layer/scatter.js ***!
  \**********************************************/
/*! exports provided: scatter, category_scatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatter", function() { return Scatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "category_scatter", function() { return CategoryScatter; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./esm/components/data_layer/base.js");
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/common */ "./esm/helpers/common.js");
/* harmony import */ var _helpers_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/display */ "./esm/helpers/display.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _helpers_render__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../helpers/render */ "./esm/helpers/render.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */






var default_layout = {
  point_size: 40,
  point_shape: 'circle',
  tooltip_positioning: 'horizontal',
  color: '#888888',
  coalesce: {
    // Options to control whether and how to combine adjacent insignificant ("within region of interest") points
    //  to improve rendering performance?
    active: false,
    max_points: 800,
    // Many plots are 800-2400 px wide, so, more than 1 datum per pixel of average region width
    // Define the "region of interest", like "bottom half of plot"; any points outside this region are taken as is
    //   Values are expressed in terms of data value and will be converted to pixels internally.
    x_min: '-Infinity',
    // JSON doesn't handle some valid JS numbers. Kids, don't get a career in computers.
    x_max: 'Infinity',
    y_min: 0,
    y_max: 3.0,
    // Expressed in units of px apart. For circles, area 40 = radius ~3.5; aim for ~1 diameter distance.
    x_gap: 7,
    y_gap: 7
  },
  fill_opacity: 1,
  y_axis: {
    axis: 1
  },
  id_field: 'id'
};
/**
 * Scatter Data Layer
 * Implements a standard scatter plot
 */

var Scatter = /*#__PURE__*/function (_BaseDataLayer) {
  _inherits(Scatter, _BaseDataLayer);

  var _super = _createSuper(Scatter);

  function Scatter(layout) {
    _classCallCheck(this, Scatter);

    layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_4__["merge"])(layout, default_layout); // Extra default for layout spacing
    // Not in default layout since that would make the label attribute always present

    if (layout.label && isNaN(layout.label.spacing)) {
      layout.label.spacing = 4;
    }

    return _super.apply(this, arguments);
  } // Implement tooltip position to be layer-specific


  _createClass(Scatter, [{
    key: "_getTooltipPosition",
    value: function _getTooltipPosition(tooltip) {
      var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);
      var y_scale = "y".concat(this.layout.y_axis.axis, "_scale");
      var y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);
      var point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);
      var offset = Math.sqrt(point_size / Math.PI);
      return {
        x_min: x_center - offset,
        x_max: x_center + offset,
        y_min: y_center - offset,
        y_max: y_center + offset
      };
    } // Function to flip labels from being anchored at the start of the text to the end
    // Both to keep labels from running outside the data layer and  also as a first
    // pass on recursive separation

  }, {
    key: "flip_labels",
    value: function flip_labels() {
      var data_layer = this; // Base positions on the default point size (which is what resolve scalable param returns if no data provided)

      var point_size = data_layer.resolveScalableParameter(data_layer.layout.point_size, {});
      var spacing = data_layer.layout.label.spacing;
      var handle_lines = Boolean(data_layer.layout.label.lines);
      var min_x = 2 * spacing;
      var max_x = this.parent.layout.width - this.parent.layout.margin.left - this.parent.layout.margin.right - 2 * spacing;

      var flip = function flip(dn, dnl) {
        var dnx = +dn.attr('x');
        var text_swing = 2 * spacing + 2 * Math.sqrt(point_size);
        var dnlx2;
        var line_swing;

        if (handle_lines) {
          dnlx2 = +dnl.attr('x2');
          line_swing = spacing + 2 * Math.sqrt(point_size);
        }

        if (dn.style('text-anchor') === 'start') {
          dn.style('text-anchor', 'end');
          dn.attr('x', dnx - text_swing);

          if (handle_lines) {
            dnl.attr('x2', dnlx2 - line_swing);
          }
        } else {
          dn.style('text-anchor', 'start');
          dn.attr('x', dnx + text_swing);

          if (handle_lines) {
            dnl.attr('x2', dnlx2 + line_swing);
          }
        }
      }; // Flip any going over the right edge from the right side to the left side
      // (all labels start on the right side)


      data_layer.label_texts.each(function (d, i) {
        var a = this;
        var da = d3__WEBPACK_IMPORTED_MODULE_0__["select"](a);
        var dax = +da.attr('x');
        var abound = da.node().getBoundingClientRect();

        if (dax + abound.width + spacing > max_x) {
          var dal = handle_lines ? d3__WEBPACK_IMPORTED_MODULE_0__["select"](data_layer.label_lines.nodes()[i]) : null;
          flip(da, dal);
        }
      }); // Second pass to flip any others that haven't flipped yet if they collide with another label

      data_layer.label_texts.each(function (d, i) {
        var a = this;
        var da = d3__WEBPACK_IMPORTED_MODULE_0__["select"](a);

        if (da.style('text-anchor') === 'end') {
          return;
        }

        var dax = +da.attr('x');
        var abound = da.node().getBoundingClientRect();
        var dal = handle_lines ? d3__WEBPACK_IMPORTED_MODULE_0__["select"](data_layer.label_lines.nodes()[i]) : null;
        data_layer.label_texts.each(function () {
          var b = this;
          var db = d3__WEBPACK_IMPORTED_MODULE_0__["select"](b);
          var bbound = db.node().getBoundingClientRect();
          var collision = abound.left < bbound.left + bbound.width + 2 * spacing && abound.left + abound.width + 2 * spacing > bbound.left && abound.top < bbound.top + bbound.height + 2 * spacing && abound.height + abound.top + 2 * spacing > bbound.top;

          if (collision) {
            flip(da, dal); // Double check that this flip didn't push the label past min_x. If it did, immediately flip back.

            dax = +da.attr('x');

            if (dax - abound.width - spacing < min_x) {
              flip(da, dal);
            }
          }
        });
      });
    } // Recursive function to space labels apart immediately after initial render
    // Adapted from thudfactor's fiddle here: https://jsfiddle.net/thudfactor/HdwTH/
    // TODO: Make labels also aware of data elements

  }, {
    key: "separate_labels",
    value: function separate_labels() {
      var _this = this;

      this.seperate_iterations++;
      var data_layer = this;
      var alpha = 0.5;

      if (!this.layout.label) {
        // Guard against layout changing in the midst of iterative rerender
        return;
      }

      var spacing = this.layout.label.spacing;
      var again = false;
      data_layer.label_texts.each(function () {
        // TODO: O(n2) algorithm; revisit performance?
        var a = this;
        var da = d3__WEBPACK_IMPORTED_MODULE_0__["select"](a);
        var y1 = da.attr('y');
        data_layer.label_texts.each(function () {
          var b = this; // a & b are the same element and don't collide.

          if (a === b) {
            return;
          }

          var db = d3__WEBPACK_IMPORTED_MODULE_0__["select"](b); // a & b are on opposite sides of the chart and
          // don't collide

          if (da.attr('text-anchor') !== db.attr('text-anchor')) {
            return;
          } // Determine if the  bounding rects for the two text elements collide


          var abound = da.node().getBoundingClientRect();
          var bbound = db.node().getBoundingClientRect();
          var collision = abound.left < bbound.left + bbound.width + 2 * spacing && abound.left + abound.width + 2 * spacing > bbound.left && abound.top < bbound.top + bbound.height + 2 * spacing && abound.height + abound.top + 2 * spacing > bbound.top;

          if (!collision) {
            return;
          }

          again = true; // If the labels collide, we'll push each
          // of the two labels up and down a little bit.

          var y2 = db.attr('y');
          var sign = abound.top < bbound.top ? 1 : -1;
          var adjust = sign * alpha;
          var new_a_y = +y1 - adjust;
          var new_b_y = +y2 + adjust; // Keep new values from extending outside the data layer

          var min_y = 2 * spacing;
          var max_y = data_layer.parent.layout.height - data_layer.parent.layout.margin.top - data_layer.parent.layout.margin.bottom - 2 * spacing;
          var delta;

          if (new_a_y - abound.height / 2 < min_y) {
            delta = +y1 - new_a_y;
            new_a_y = +y1;
            new_b_y += delta;
          } else if (new_b_y - bbound.height / 2 < min_y) {
            delta = +y2 - new_b_y;
            new_b_y = +y2;
            new_a_y += delta;
          }

          if (new_a_y + abound.height / 2 > max_y) {
            delta = new_a_y - +y1;
            new_a_y = +y1;
            new_b_y -= delta;
          } else if (new_b_y + bbound.height / 2 > max_y) {
            delta = new_b_y - +y2;
            new_b_y = +y2;
            new_a_y -= delta;
          }

          da.attr('y', new_a_y);
          db.attr('y', new_b_y);
        });
      });

      if (again) {
        // Adjust lines to follow the labels
        if (data_layer.layout.label.lines) {
          var label_elements = data_layer.label_texts.nodes();
          data_layer.label_lines.attr('y2', function (d, i) {
            var label_line = d3__WEBPACK_IMPORTED_MODULE_0__["select"](label_elements[i]);
            return label_line.attr('y');
          });
        } // After ~150 iterations we're probably beyond diminising returns, so stop recursing


        if (this.seperate_iterations < 150) {
          setTimeout(function () {
            _this.separate_labels();
          }, 1);
        }
      }
    } // Implement the main render function

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var data_layer = this;
      var x_scale = this.parent['x_scale'];
      var y_scale = this.parent["y".concat(this.layout.y_axis.axis, "_scale")];
      var xcs = Symbol["for"]('lzX');
      var ycs = Symbol["for"]('lzY'); // Apply filters to only render a specified set of points

      var track_data = this._applyFilters(); // Add coordinates before rendering, so we can coalesce


      track_data.forEach(function (item) {
        var x = x_scale(item[_this2.layout.x_axis.field]);
        var y = y_scale(item[_this2.layout.y_axis.field]);

        if (isNaN(x)) {
          x = -1000;
        }

        if (isNaN(y)) {
          y = -1000;
        }

        item[xcs] = x;
        item[ycs] = y;
      });

      if (this.layout.coalesce.active && track_data.length > this.layout.coalesce.max_points) {
        var _this$layout$coalesce = this.layout.coalesce,
            x_min = _this$layout$coalesce.x_min,
            x_max = _this$layout$coalesce.x_max,
            y_min = _this$layout$coalesce.y_min,
            y_max = _this$layout$coalesce.y_max,
            x_gap = _this$layout$coalesce.x_gap,
            y_gap = _this$layout$coalesce.y_gap; // Convert x and y "significant region" range from data values to pixels

        var x_min_px = isFinite(x_min) ? x_scale(+x_min) : -Infinity;
        var x_max_px = isFinite(x_max) ? x_scale(+x_max) : Infinity; // For y px, we flip the data min/max b/c in SVG coord system +y is down: smaller data y = larger px y

        var y_min_px = isFinite(y_max) ? y_scale(+y_max) : -Infinity;
        var y_max_px = isFinite(y_min) ? y_scale(+y_min) : Infinity;
        track_data = Object(_helpers_render__WEBPACK_IMPORTED_MODULE_5__["coalesce_scatter_points"])(track_data, x_min_px, x_max_px, x_gap, y_min_px, y_max_px, y_gap);
      }

      if (this.layout.label) {
        var label_data;
        var filters = data_layer.layout.label.filters || [];

        if (!filters.length) {
          label_data = track_data;
        } else {
          var func = this.filter.bind(this, filters);
          label_data = track_data.filter(func);
        } // Render label groups


        this.label_groups = this.svg.group.selectAll("g.lz-data_layer-".concat(this.layout.type, "-label")).data(label_data, function (d) {
          return "".concat(d[_this2.layout.id_field], "_label");
        });

        var _style_class = "lz-data_layer-".concat(this.layout.type, "-label");

        var groups_enter = this.label_groups.enter().append('g').attr('class', _style_class);

        if (this.label_texts) {
          this.label_texts.remove();
        }

        this.label_texts = this.label_groups.merge(groups_enter).append('text').text(function (d) {
          return Object(_helpers_display__WEBPACK_IMPORTED_MODULE_3__["parseFields"])(d, data_layer.layout.label.text || '');
        }).attr('x', function (d) {
          return d[xcs] + Math.sqrt(data_layer.resolveScalableParameter(data_layer.layout.point_size, d)) + data_layer.layout.label.spacing;
        }).attr('y', function (d) {
          return d[ycs];
        }).attr('text-anchor', 'start').call(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["applyStyles"], data_layer.layout.label.style || {}); // Render label lines

        if (data_layer.layout.label.lines) {
          if (this.label_lines) {
            this.label_lines.remove();
          }

          this.label_lines = this.label_groups.merge(groups_enter).append('line').attr('x1', function (d) {
            return d[xcs];
          }).attr('y1', function (d) {
            return d[ycs];
          }).attr('x2', function (d) {
            return d[xcs] + Math.sqrt(data_layer.resolveScalableParameter(data_layer.layout.point_size, d)) + data_layer.layout.label.spacing / 2;
          }).attr('y2', function (d) {
            return d[ycs];
          }).call(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["applyStyles"], data_layer.layout.label.lines.style || {});
        } // Remove labels when they're no longer in the filtered data set


        this.label_groups.exit().remove();
      } else {
        // If the layout definition has changed (& no longer specifies labels), strip any previously rendered
        if (this.label_texts) {
          this.label_texts.remove();
        }

        if (this.label_lines) {
          this.label_lines.remove();
        }

        if (this.label_groups) {
          this.label_groups.remove();
        }
      } // Generate main scatter data elements


      var selection = this.svg.group.selectAll("path.lz-data_layer-".concat(this.layout.type)).data(track_data, function (d) {
        return d[_this2.layout.id_field];
      }); // Create elements, apply class, ID, and initial position
      // Generate new values (or functions for them) for position, color, size, and shape

      var transform = function transform(d) {
        return "translate(".concat(d[xcs], ", ").concat(d[ycs], ")");
      };

      var shape = d3__WEBPACK_IMPORTED_MODULE_0__["symbol"]().size(function (d, i) {
        return _this2.resolveScalableParameter(_this2.layout.point_size, d, i);
      }).type(function (d, i) {
        return Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_4__["nameToSymbol"])(_this2.resolveScalableParameter(_this2.layout.point_shape, d, i));
      });
      var style_class = "lz-data_layer-".concat(this.layout.type);
      selection.enter().append('path').attr('class', style_class).attr('id', function (d) {
        return _this2.getElementId(d);
      }).merge(selection).attr('transform', transform).attr('fill', function (d, i) {
        return _this2.resolveScalableParameter(_this2.layout.color, d, i);
      }).attr('fill-opacity', function (d, i) {
        return _this2.resolveScalableParameter(_this2.layout.fill_opacity, d, i);
      }).attr('d', shape); // Remove old elements as needed

      selection.exit().remove(); // Apply method to keep labels from overlapping each other

      if (this.layout.label) {
        this.flip_labels();
        this.seperate_iterations = 0;
        this.separate_labels();
      } // Apply default event emitters & mouse behaviors. Apply to the container, not per element,
      // to reduce number of event listeners. These events will apply to both scatter points and labels.


      this.svg.group.on('click.event_emitter', function () {
        // D3 doesn't natively support bubbling very well; we need to find the data for the bubbled event
        var item_data = d3__WEBPACK_IMPORTED_MODULE_0__["select"](d3__WEBPACK_IMPORTED_MODULE_0__["event"].target).datum();

        _this2.parent.emit('element_clicked', item_data, true);
      }).call(this.applyBehaviors.bind(this));
    } // Method to set a passed element as the LD reference in the plot-level state

  }, {
    key: "makeLDReference",
    value: function makeLDReference(element) {
      var ref = null;

      if (typeof element == 'undefined') {
        throw new Error('makeLDReference requires one argument of any type');
      } else if (_typeof(element) == 'object') {
        if (this.layout.id_field && typeof element[this.layout.id_field] != 'undefined') {
          ref = element[this.layout.id_field].toString();
        } else if (typeof element['id'] != 'undefined') {
          ref = element['id'].toString();
        } else {
          ref = element.toString();
        }
      } else {
        ref = element.toString();
      }

      this.parent_plot.applyState({
        ldrefvar: ref
      });
    }
  }]);

  return Scatter;
}(_base__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * A scatter plot in which the x-axis represents categories, rather than individual positions.
 * For example, this can be used by PheWAS plots to show related groups. This plot allows the categories to be
 *   determined dynamically when data is first loaded.
 *
 */


var CategoryScatter = /*#__PURE__*/function (_Scatter) {
  _inherits(CategoryScatter, _Scatter);

  var _super2 = _createSuper(CategoryScatter);

  function CategoryScatter(layout) {
    var _this3;

    _classCallCheck(this, CategoryScatter);

    _this3 = _super2.apply(this, arguments);
    /**
     * Define category names and extents (boundaries) for plotting.
     * @member {Object.<String, Number[]>} Category names and extents, in the form {category_name: [min_x, max_x]}
     */

    _this3._categories = {};
    return _this3;
  }
  /**
   * This plot layer makes certain assumptions about the data passed in. Transform the raw array of records from
   *   the datasource to prepare it for plotting, as follows:
   * 1. The scatter plot assumes that all records are given in sequence (pre-grouped by `category_field`)
   * 2. It assumes that all records have an x coordinate for individual plotting
   * @private
   */


  _createClass(CategoryScatter, [{
    key: "_prepareData",
    value: function _prepareData() {
      var xField = this.layout.x_axis.field || 'x'; // The (namespaced) field from `this.data` that will be used to assign datapoints to a given category & color

      var category_field = this.layout.x_axis.category_field;

      if (!category_field) {
        throw new Error("Layout for ".concat(this.layout.id, " must specify category_field"));
      } // Sort the data so that things in the same category are adjacent (case-insensitive by specified field)


      var sourceData = this.data.sort(function (a, b) {
        var ak = a[category_field];
        var bk = b[category_field];
        var av = typeof ak === 'string' ? ak.toLowerCase() : ak;
        var bv = typeof bk === 'string' ? bk.toLowerCase() : bk;
        return av === bv ? 0 : av < bv ? -1 : 1;
      });
      sourceData.forEach(function (d, i) {
        // Implementation detail: Scatter plot requires specifying an x-axis value, and most datasources do not
        //   specify plotting positions. If a point is missing this field, fill in a synthetic value.
        d[xField] = d[xField] || i;
      });
      return sourceData;
    }
    /**
     * Identify the unique categories on the plot, and update the layout with an appropriate color scheme.
     * Also identify the min and max x value associated with the category, which will be used to generate ticks
     * @private
     * @returns {Object.<String, Number[]>} Series of entries used to build category name ticks {category_name: [min_x, max_x]}
     */

  }, {
    key: "_generateCategoryBounds",
    value: function _generateCategoryBounds() {
      // TODO: API may return null values in category_field; should we add placeholder category label?
      // The (namespaced) field from `this.data` that will be used to assign datapoints to a given category & color
      var category_field = this.layout.x_axis.category_field;
      var xField = this.layout.x_axis.field || 'x';
      var uniqueCategories = {};
      this.data.forEach(function (item) {
        var category = item[category_field];
        var x = item[xField];
        var bounds = uniqueCategories[category] || [x, x];
        uniqueCategories[category] = [Math.min(bounds[0], x), Math.max(bounds[1], x)];
      });
      var categoryNames = Object.keys(uniqueCategories);

      this._setDynamicColorScheme(categoryNames);

      return uniqueCategories;
    }
    /**
     * This layer relies on defining its own category-based color scheme. Find the correct color config object to
     *  be modified.
     * @param [from_source]
     * @returns {Object} A mutable reference to the layout configuration object
     * @private
     */

  }, {
    key: "_getColorScale",
    value: function _getColorScale(from_source) {
      from_source = from_source || this.layout; // If the layout does not use a supported coloring scheme, or is already complete, this method should do nothing
      // For legacy reasons, layouts can specify color as an object (only one way to set color), as opposed to the
      //  preferred mechanism of array (multiple coloring options)

      var color_params = from_source.color || []; // Object or scalar, no other options allowed

      if (Array.isArray(color_params)) {
        color_params = color_params.find(function (item) {
          return item.scale_function === 'categorical_bin';
        });
      }

      if (!color_params || color_params.scale_function !== 'categorical_bin') {
        throw new Error('This layer requires that color options be provided as a `categorical_bin`');
      }

      return color_params;
    }
    /**
     * Automatically define a color scheme for the layer based on data returned from the server.
     *   If part of the color scheme has been specified, it will fill in remaining missing information.
     *
     * There are three scenarios:
     * 1. The layout does not specify either category names or (color) values. Dynamically build both based on
     *    the data and update the layout.
     * 2. The layout specifies colors, but not categories. Use that exact color information provided, and dynamically
     *     determine what categories are present in the data. (cycle through the available colors, reusing if there
     *     are a lot of categories)
     * 3. The layout specifies exactly what colors and categories to use (and they match the data!). This is useful to
     *    specify an explicit mapping between color scheme and category names, when you want to be sure that the
     *    plot matches a standard color scheme.
     *    (If the layout specifies categories that do not match the data, the user specified categories will be ignored)
     *
     * This method will only act if the layout defines a `categorical_bin` scale function for coloring. It may be
     *   overridden in a subclass to suit other types of coloring methods.
     *
     * @param {String[]} categoryNames
     * @private
     */

  }, {
    key: "_setDynamicColorScheme",
    value: function _setDynamicColorScheme(categoryNames) {
      var colorParams = this._getColorScale(this.layout).parameters;

      var baseParams = this._getColorScale(this._base_layout).parameters;

      if (baseParams.categories.length && baseParams.values.length) {
        // If there are preset category/color combos, make sure that they apply to the actual dataset
        var parameters_categories_hash = {};
        baseParams.categories.forEach(function (category) {
          parameters_categories_hash[category] = 1;
        });

        if (categoryNames.every(function (name) {
          return Object.prototype.hasOwnProperty.call(parameters_categories_hash, name);
        })) {
          // The layout doesn't have to specify categories in order, but make sure they are all there
          colorParams.categories = baseParams.categories;
        } else {
          colorParams.categories = categoryNames;
        }
      } else {
        colorParams.categories = categoryNames;
      } // Prefer user-specified colors if provided. Make sure that there are enough colors for all the categories.


      var colors;

      if (baseParams.values.length) {
        colors = baseParams.values;
      } else {
        // Originally from d3v3 category20
        colors = ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];
      }

      while (colors.length < categoryNames.length) {
        colors = colors.concat(colors);
      }

      colors = colors.slice(0, categoryNames.length); // List of hex values, should be of same length as categories array

      colorParams.values = colors;
    }
    /**
     *
     * @param dimension
     * @param {Object} [config] Parameters that customize how ticks are calculated (not style)
     * @param {('left'|'center'|'right')} [config.position='left'] Align ticks with the center or edge of category
     * @returns {Array}
     */

  }, {
    key: "getTicks",
    value: function getTicks(dimension, config) {
      // Overrides parent method
      if (!['x', 'y1', 'y2'].includes(dimension)) {
        throw new Error('Invalid dimension identifier');
      }

      var position = config.position || 'left';

      if (!['left', 'center', 'right'].includes(position)) {
        throw new Error('Invalid tick position');
      }

      var categoryBounds = this._categories;

      if (!categoryBounds || !Object.keys(categoryBounds).length) {
        return [];
      }

      if (dimension === 'y') {
        return [];
      }

      if (dimension === 'x') {
        // If colors have been defined by this layer, use them to make tick colors match scatterplot point colors
        var colors = this._getColorScale(this.layout);

        var knownCategories = colors.parameters.categories || [];
        var knownColors = colors.parameters.values || [];
        return Object.keys(categoryBounds).map(function (category, index) {
          var bounds = categoryBounds[category];
          var xPos;

          switch (position) {
            case 'left':
              xPos = bounds[0];
              break;

            case 'center':
              // Center tick under one or many elements as appropriate
              // eslint-disable-next-line no-case-declarations
              var diff = bounds[1] - bounds[0];
              xPos = bounds[0] + (diff !== 0 ? diff : bounds[0]) / 2;
              break;

            case 'right':
              xPos = bounds[1];
              break;
          }

          return {
            x: xPos,
            text: category,
            style: {
              'fill': knownColors[knownCategories.indexOf(category)] || '#000000'
            }
          };
        });
      }
    }
  }, {
    key: "applyCustomDataMethods",
    value: function applyCustomDataMethods() {
      this.data = this._prepareData();
      this._categories = this._generateCategoryBounds();
      return this;
    }
  }]);

  return CategoryScatter;
}(Scatter);



/***/ }),

/***/ "./esm/components/legend.js":
/*!**********************************!*\
  !*** ./esm/components/legend.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Legend; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/common */ "./esm/helpers/common.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */



/**
 * The default layout used by legends (used internally)
 * @protected
 * @member {Object}
 */

var default_layout = {
  orientation: 'vertical',
  origin: {
    x: 0,
    y: 0
  },
  width: 10,
  height: 10,
  padding: 5,
  label_size: 12,
  hidden: false
};
/**
 * An SVG object used to display contextual information about a panel.
 * Panel layouts determine basic features of a legend - its position in the panel, orientation, title, etc.
 * Layouts of child data layers of the panel determine the actual content of the legend.
 *
 * @param {Panel} parent
*/

var Legend = /*#__PURE__*/function () {
  function Legend(parent) {
    _classCallCheck(this, Legend);

    // if (!(parent instanceof LocusZoom.Panel)) {
    //     throw new Error('Unable to create legend, parent must be a locuszoom panel');
    // }

    /** @member {Panel} */
    this.parent = parent;
    /** @member {String} */

    this.id = "".concat(this.parent.getBaseId(), ".legend");
    this.parent.layout.legend = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_2__["merge"])(this.parent.layout.legend || {}, default_layout);
    /** @member {Object} */

    this.layout = this.parent.layout.legend;
    /** @member {d3.selection} */

    this.selector = null;
    /** @member {d3.selection} */

    this.background_rect = null;
    /** @member {d3.selection[]} */

    this.elements = [];
    /**
     * SVG selector for the group containing all elements in the legend
     * @protected
     * @member {d3.selection|null}
     */

    this.elements_group = null;
    /**
     * TODO: Not sure if this property is used; the external-facing methods are setting `layout.hidden` instead. Tentatively mark deprecated.
     * @deprecated
     * @protected
     * @member {Boolean}
     */

    this.hidden = false;
    return this.render();
  }
  /**
   * Render the legend in the parent panel
   */


  _createClass(Legend, [{
    key: "render",
    value: function render() {
      var _this = this;

      // Get a legend group selector if not yet defined
      if (!this.selector) {
        this.selector = this.parent.svg.group.append('g').attr('id', "".concat(this.parent.getBaseId(), ".legend")).attr('class', 'lz-legend');
      } // Get a legend background rect selector if not yet defined


      if (!this.background_rect) {
        this.background_rect = this.selector.append('rect').attr('width', 100).attr('height', 100).attr('class', 'lz-legend-background');
      } // Get a legend elements group selector if not yet defined


      if (!this.elements_group) {
        this.elements_group = this.selector.append('g');
      } // Remove all elements from the document and re-render from scratch


      this.elements.forEach(function (element) {
        return element.remove();
      });
      this.elements = []; // Gather all elements from data layers in order (top to bottom) and render them

      var padding = +this.layout.padding || 1;
      var x = padding;
      var y = padding;
      var line_height = 0;
      this.parent.data_layer_ids_by_z_index.slice().reverse().forEach(function (id) {
        if (Array.isArray(_this.parent.data_layers[id].layout.legend)) {
          _this.parent.data_layers[id].layout.legend.forEach(function (element) {
            var selector = _this.elements_group.append('g').attr('transform', "translate(".concat(x, ", ").concat(y, ")"));

            var label_size = +element.label_size || +_this.layout.label_size || 12;
            var label_x = 0;
            var label_y = label_size / 2 + padding / 2;
            line_height = Math.max(line_height, label_size + padding); // Draw the legend element symbol (line, rect, shape, etc)

            var shape = element.shape || '';
            var shape_factory = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_2__["nameToSymbol"])(shape);

            if (shape === 'line') {
              // Line symbol
              var length = +element.length || 16;
              var path_y = label_size / 4 + padding / 2;
              selector.append('path').attr('class', element["class"] || '').attr('d', "M0,".concat(path_y, "L").concat(length, ",").concat(path_y)).call(_helpers_common__WEBPACK_IMPORTED_MODULE_1__["applyStyles"], element.style || {});
              label_x = length + padding;
            } else if (shape === 'rect') {
              // Rect symbol
              var width = +element.width || 16;
              var height = +element.height || width;
              selector.append('rect').attr('class', element["class"] || '').attr('width', width).attr('height', height).attr('fill', element.color || {}).call(_helpers_common__WEBPACK_IMPORTED_MODULE_1__["applyStyles"], element.style || {});
              label_x = width + padding;
              line_height = Math.max(line_height, height + padding);
            } else if (shape_factory) {
              // Shape symbol is a recognized d3 type, so we can draw it in the legend (circle, diamond, etc.)
              var size = +element.size || 40;
              var radius = Math.ceil(Math.sqrt(size / Math.PI));
              selector.append('path').attr('class', element["class"] || '').attr('d', d3__WEBPACK_IMPORTED_MODULE_0__["symbol"]().size(size).type(shape_factory)).attr('transform', "translate(".concat(radius, ", ").concat(radius + padding / 2, ")")).attr('fill', element.color || {}).call(_helpers_common__WEBPACK_IMPORTED_MODULE_1__["applyStyles"], element.style || {});
              label_x = 2 * radius + padding;
              label_y = Math.max(2 * radius + padding / 2, label_y);
              line_height = Math.max(line_height, 2 * radius + padding);
            } // Draw the legend element label


            selector.append('text').attr('text-anchor', 'left').attr('class', 'lz-label').attr('x', label_x).attr('y', label_y).style('font-size', label_size).text(element.label); // Position the legend element group based on legend layout orientation

            var bcr = selector.node().getBoundingClientRect();

            if (_this.layout.orientation === 'vertical') {
              y += bcr.height + padding;
              line_height = 0;
            } else {
              // Ensure this element does not exceed the panel width
              // (E.g. drop to the next line if it does, but only if it's not the only element on this line)
              var right_x = _this.layout.origin.x + x + bcr.width;

              if (x > padding && right_x > _this.parent.layout.width) {
                y += line_height;
                x = padding;
                selector.attr('transform', "translate(".concat(x, ", ").concat(y, ")"));
              }

              x += bcr.width + 3 * padding;
            } // Store the element


            _this.elements.push(selector);
          });
        }
      }); // Scale the background rect to the elements in the legend

      var bcr = this.elements_group.node().getBoundingClientRect();
      this.layout.width = bcr.width + 2 * this.layout.padding;
      this.layout.height = bcr.height + 2 * this.layout.padding;
      this.background_rect.attr('width', this.layout.width).attr('height', this.layout.height); // Set the visibility on the legend from the "hidden" flag
      // TODO: `show()` and `hide()` call a full rerender; might be able to make this more lightweight?

      this.selector.style('visibility', this.layout.hidden ? 'hidden' : 'visible');
      return this.position();
    }
    /**
     * Place the legend in position relative to the panel, as specified in the layout configuration
     * @returns {Legend | null}
     * TODO: should this always be chainable?
     */

  }, {
    key: "position",
    value: function position() {
      if (!this.selector) {
        return this;
      }

      var bcr = this.selector.node().getBoundingClientRect();

      if (!isNaN(+this.layout.pad_from_bottom)) {
        this.layout.origin.y = this.parent.layout.height - bcr.height - +this.layout.pad_from_bottom;
      }

      if (!isNaN(+this.layout.pad_from_right)) {
        this.layout.origin.x = this.parent.layout.width - bcr.width - +this.layout.pad_from_right;
      }

      this.selector.attr('transform', "translate(".concat(this.layout.origin.x, ", ").concat(this.layout.origin.y, ")"));
    }
    /**
     * Hide the legend (triggers a re-render)
     * @public
     */

  }, {
    key: "hide",
    value: function hide() {
      this.layout.hidden = true;
      this.render();
    }
    /**
     * Show the legend (triggers a re-render)
     * @public
     */

  }, {
    key: "show",
    value: function show() {
      this.layout.hidden = false;
      this.render();
    }
  }]);

  return Legend;
}();



/***/ }),

/***/ "./esm/components/panel.js":
/*!*********************************!*\
  !*** ./esm/components/panel.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Panel; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./esm/components/constants.js");
/* harmony import */ var _toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toolbar */ "./esm/components/toolbar/index.js");
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/common */ "./esm/helpers/common.js");
/* harmony import */ var _helpers_display__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/display */ "./esm/helpers/display.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./legend */ "./esm/components/legend.js");
/* harmony import */ var _registry_data_layers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../registry/data_layers */ "./esm/registry/data_layers.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */








/**
 * Default panel layout
 * @static
 * @type {Object}
 */

var default_layout = {
  title: {
    text: '',
    style: {},
    x: 10,
    y: 22
  },
  y_index: null,
  width: 0,
  height: 0,
  origin: {
    x: 0,
    y: null
  },
  min_width: 1,
  min_height: 1,
  proportional_width: null,
  proportional_height: null,
  proportional_origin: {
    x: 0,
    y: null
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background_click: 'clear_selections',
  toolbar: {
    widgets: []
  },
  cliparea: {
    height: 0,
    width: 0,
    origin: {
      x: 0,
      y: 0
    }
  },
  axes: {
    // These are the only axes supported!!
    x: {},
    y1: {},
    y2: {}
  },
  legend: null,
  interaction: {
    drag_background_to_pan: false,
    drag_x_ticks_to_scale: false,
    drag_y1_ticks_to_scale: false,
    drag_y2_ticks_to_scale: false,
    scroll_to_zoom: false,
    x_linked: false,
    y1_linked: false,
    y2_linked: false
  },
  data_layers: []
};
/**
 * A panel is an abstract class representing a subdivision of the LocusZoom stage
 *   to display a distinct data representation as a collection of data layers.
 */

var Panel = /*#__PURE__*/function () {
  /**
   * @param {Object} layout
   * @param {Plot|null} parent
  */
  function Panel(layout, parent) {
    var _this = this;

    _classCallCheck(this, Panel);

    if (_typeof(layout) !== 'object') {
      throw new Error('Unable to create panel, invalid layout');
    }
    /**
     * @protected
     * @member {Plot|null}
     */


    this.parent = parent || null;
    /**
     *  @protected
     *  @member {Plot|null}
     */

    this.parent_plot = parent; // Ensure a valid ID is present. If there is no valid ID then generate one

    if (typeof layout.id !== 'string' || !layout.id.length) {
      if (!this.parent) {
        layout.id = "p".concat(Math.floor(Math.random() * Math.pow(10, 8)));
      } else {
        var generateID = function generateID() {
          var id = "p".concat(Math.floor(Math.random() * Math.pow(10, 8)));

          if (id === null || typeof _this.parent.panels[id] != 'undefined') {
            id = generateID();
          }

          return id;
        };

        layout.id = generateID();
      }
    } else if (this.parent) {
      if (typeof this.parent.panels[layout.id] !== 'undefined') {
        throw new Error("Cannot create panel with id [".concat(layout.id, "]; panel with that id already exists"));
      }
    }
    /**
     * @public
     * @member {String}
     */


    this.id = layout.id;
    /**
     * @private
     * @member {Boolean}
     */

    this.initialized = false;
    /**
     * The index of this panel in the parent plot's `layout.panels`
     * @private
     * @member {number}
     * */

    this.layout_idx = null;
    /**
     * @private
     * @member {Object}
     */

    this.svg = {};
    /**
     * A JSON-serializable object used to describe the composition of the Panel
     * @public
     * @member {Object}
     */

    this.layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_5__["merge"])(layout || {}, default_layout); // Define state parameters specific to this panel

    if (this.parent) {
      /**
       * @private
       * @member {Object}
       */
      this.state = this.parent.state;
      /**
       *  @private
       *  @member {String}
       */

      this.state_id = this.id;
      this.state[this.state_id] = this.state[this.state_id] || {};
    } else {
      this.state = null;
      this.state_id = null;
    }
    /**
     * @protected
     * @member {Object}
     */


    this.data_layers = {};
    /**
     * @private
     * @member {String[]}
     */

    this.data_layer_ids_by_z_index = [];
    /**
     * Track data requests in progress
     * @member {Promise[]}
     * @private
     */

    this.data_promises = [];
    /**
     * @private
     * @member {d3.scale}
     */

    this.x_scale = null;
    /**
     * @private
     * @member {d3.scale}
     */

    this.y1_scale = null;
    /**
     *  @private
     *  @member {d3.scale}
     */

    this.y2_scale = null;
    /**
     * @private
     * @member {d3.extent}
     */

    this.x_extent = null;
    /**
     *  @private
     *  @member {d3.extent}
     */

    this.y1_extent = null;
    /**
     *  @private
     *  @member {d3.extent}
     */

    this.y2_extent = null;
    /**
     * @private
     * @member {Number[]}
     */

    this.x_ticks = [];
    /**
     *  @private
     *  @member {Number[]}
     */

    this.y1_ticks = [];
    /**
     * @private
     * @member {Number[]}
     */

    this.y2_ticks = [];
    /**
     * A timeout ID as returned by setTimeout
     * @private
     * @member {number}
     */

    this.zoom_timeout = null;
    /**
     * Known event hooks that the panel can respond to
     * @protected
     * @member {Object}
     */

    this.event_hooks = {
      'layout_changed': [],
      'data_requested': [],
      'data_rendered': [],
      'element_clicked': [],
      'element_selection': [],
      'match_requested': [] // A data layer is attempting to highlight matching points (internal use only)

    }; // Initialize the layout

    this.initializeLayout();
  }
  /******* Public methods: intended for direct external manipulation of panel internals */

  /**
   * There are several events that a LocusZoom panel can "emit" when appropriate, and LocusZoom supports registering
   *   "hooks" for these events which are essentially custom functions intended to fire at certain times.
   *
   * The following panel-level events are currently supported:
   *   - `layout_changed` - context: panel - Any aspect of the panel's layout (including dimensions or state) has changed.
   *   - `data_requested` - context: panel - A request for new data from any data source used in the panel has been made.
   *   - `data_rendered` - context: panel - Data from a request has been received and rendered in the panel.
   *   - `element_clicked` - context: panel - A data element in any of the panel's data layers has been clicked.
   *   - `element_selection` - context: panel - Triggered when an element changes "selection" status, and identifies
   *        whether the element is being selected or deselected.
   *
   * To register a hook for any of these events use `panel.on('event_name', function() {})`.
   *
   * There can be arbitrarily many functions registered to the same event. They will be executed in the order they
   *   were registered. The this context bound to each event hook function is dependent on the type of event, as
   *   denoted above. For example, when data_requested is emitted the context for this in the event hook will be the
   *   panel itself, but when element_clicked is emitted the context for this in the event hook will be the element
   *   that was clicked.
   *
   * @public
   * @param {String} event The name of the event (as defined in `event_hooks`)
   * @param {function} hook
   * @returns {function} The registered event listener
   */


  _createClass(Panel, [{
    key: "on",
    value: function on(event, hook) {
      // TODO: Dry plot and panel event code into a shared mixin
      if ( false || !Array.isArray(this.event_hooks[event])) {
        throw new Error("Unable to register event hook, invalid event: ".concat(event.toString()));
      }

      if (typeof hook != 'function') {
        throw new Error('Unable to register event hook, invalid hook function passed');
      }

      this.event_hooks[event].push(hook);
      return hook;
    }
    /**
     * Remove one or more previously defined event listeners
     * @public
     * @param {String} event The name of an event (as defined in `event_hooks`)
     * @param {eventCallback} [hook] The callback to deregister
     * @returns {Panel}
     */

  }, {
    key: "off",
    value: function off(event, hook) {
      var theseHooks = this.event_hooks[event];

      if ( false || !Array.isArray(theseHooks)) {
        throw new Error("Unable to remove event hook, invalid event: ".concat(event.toString()));
      }

      if (hook === undefined) {
        // Deregistering all hooks for this event may break basic functionality, and should only be used during
        //  cleanup operations (eg to prevent memory leaks)
        this.event_hooks[event] = [];
      } else {
        var hookMatch = theseHooks.indexOf(hook);

        if (hookMatch !== -1) {
          theseHooks.splice(hookMatch, 1);
        } else {
          throw new Error('The specified event listener is not registered and therefore cannot be removed');
        }
      }

      return this;
    }
    /**
     * Handle running of event hooks when an event is emitted
     *
     * There is a shorter overloaded form of this method: if the event does not have any data, the second
     *   argument can be a boolean to control bubbling
     *
     * @public
     * @param {string} event A known event name
     * @param {*} [eventData] Data or event description that will be passed to the event listener
     * @param {boolean} [bubble=false] Whether to bubble the event to the parent
     * @returns {Panel}
     */

  }, {
    key: "emit",
    value: function emit(event, eventData, bubble) {
      var _this2 = this;

      bubble = bubble || false; // TODO: DRY this with the parent plot implementation. Ensure interfaces remain compatible.
      // TODO: Improve documentation for overloaded method signature (JSDoc may have trouble here)

      if ( false || !Array.isArray(this.event_hooks[event])) {
        throw new Error("LocusZoom attempted to throw an invalid event: ".concat(event.toString()));
      }

      if (typeof eventData === 'boolean' && arguments.length === 2) {
        // Overloaded method signature: emit(event, bubble)
        bubble = eventData;
        eventData = null;
      }

      var sourceID = this.getBaseId();
      var eventContext = {
        sourceID: sourceID,
        target: this,
        data: eventData || null
      };
      this.event_hooks[event].forEach(function (hookToRun) {
        // By default, any handlers fired here will see the panel as the value of `this`. If a bound function is
        // registered as a handler, the previously bound `this` will override anything provided to `call` below.
        hookToRun.call(_this2, eventContext);
      });

      if (bubble && this.parent) {
        this.parent.emit(event, eventContext);
      }

      return this;
    }
    /**
     * Set the title for the panel. If passed an object, will merge the object with the existing layout configuration, so
     *   that all or only some of the title layout object's parameters can be customized. If passed null, false, or an empty
     *   string, the title DOM element will be set to display: none.
     *
     * @public
     * @param {string|object|null} title The title text, or an object with additional configuration
     * @param {string} title.text Text to display. Since titles are rendered as SVG text, HTML and newlines will not be rendered.
     * @param {number} title.x X-offset, in pixels, for the title's text anchor (default left) relative to the top-left corner of the panel.
     * @param {number} title.y Y-offset, in pixels, for the title's text anchor (default left) relative to the top-left corner of the panel.
        NOTE: SVG y values go from the top down, so the SVG origin of (0,0) is in the top left corner.
     * @param {object} title.style CSS styles object to be applied to the title's DOM element.
     * @returns {Panel}
     */

  }, {
    key: "setTitle",
    value: function setTitle(title) {
      if (typeof this.layout.title == 'string') {
        var text = this.layout.title;
        this.layout.title = {
          text: text,
          x: 0,
          y: 0,
          style: {}
        };
      }

      if (typeof title == 'string') {
        this.layout.title.text = title;
      } else if (_typeof(title) == 'object' && title !== null) {
        this.layout.title = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_5__["merge"])(title, this.layout.title);
      }

      if (this.layout.title.text.length) {
        this.title.attr('display', null).attr('x', parseFloat(this.layout.title.x)).attr('y', parseFloat(this.layout.title.y)).text(this.layout.title.text).call(_helpers_common__WEBPACK_IMPORTED_MODULE_3__["applyStyles"], this.layout.title.style);
      } else {
        this.title.attr('display', 'none');
      }

      return this;
    }
    /**
     * Create a new data layer from a provided layout object. Should have the keys specified in `DefaultLayout`
     * Will automatically add at the top (depth/z-index) of the panel unless explicitly directed differently
     *   in the layout provided.
     * @public
     * @param {object} layout
     * @returns {*}
     */

  }, {
    key: "addDataLayer",
    value: function addDataLayer(layout) {
      var _this3 = this;

      // Sanity checks
      if (_typeof(layout) !== 'object' || typeof layout.id !== 'string' || !layout.id.length) {
        throw new Error('Invalid data layer layout');
      }

      if (typeof this.data_layers[layout.id] !== 'undefined') {
        throw new Error("Cannot create data_layer with id [".concat(layout.id, "]; data layer with that id already exists in the panel"));
      }

      if (typeof layout.type !== 'string') {
        throw new Error('Invalid data layer type');
      } // If the layout defines a y axis make sure the axis number is set and is 1 or 2 (default to 1)


      if (_typeof(layout.y_axis) == 'object' && (typeof layout.y_axis.axis == 'undefined' || ![1, 2].includes(layout.y_axis.axis))) {
        layout.y_axis.axis = 1;
      } // Create the Data Layer


      var data_layer = _registry_data_layers__WEBPACK_IMPORTED_MODULE_7__["default"].create(layout.type, layout, this); // Store the Data Layer on the Panel

      this.data_layers[data_layer.id] = data_layer; // If a discrete z_index was set in the layout then adjust other data layer z_index values to accommodate this one

      if (data_layer.layout.z_index !== null && !isNaN(data_layer.layout.z_index) && this.data_layer_ids_by_z_index.length > 0) {
        // Negative z_index values should count backwards from the end, so convert negatives to appropriate values here
        if (data_layer.layout.z_index < 0) {
          data_layer.layout.z_index = Math.max(this.data_layer_ids_by_z_index.length + data_layer.layout.z_index, 0);
        }

        this.data_layer_ids_by_z_index.splice(data_layer.layout.z_index, 0, data_layer.id);
        this.data_layer_ids_by_z_index.forEach(function (dlid, idx) {
          _this3.data_layers[dlid].layout.z_index = idx;
        });
      } else {
        var length = this.data_layer_ids_by_z_index.push(data_layer.id);
        this.data_layers[data_layer.id].layout.z_index = length - 1;
      } // Determine if this data layer was already in the layout.data_layers array.
      // If it wasn't, add it. Either way store the layout.data_layers array index on the data_layer.


      var layout_idx = null;
      this.layout.data_layers.forEach(function (data_layer_layout, idx) {
        if (data_layer_layout.id === data_layer.id) {
          layout_idx = idx;
        }
      });

      if (layout_idx === null) {
        layout_idx = this.layout.data_layers.push(this.data_layers[data_layer.id].layout) - 1;
      }

      this.data_layers[data_layer.id].layout_idx = layout_idx;
      return this.data_layers[data_layer.id];
    }
    /**
     * Remove a data layer by id
     * @public
     * @param {string} id
     * @returns {Panel}
     */

  }, {
    key: "removeDataLayer",
    value: function removeDataLayer(id) {
      var _this4 = this;

      if (!this.data_layers[id]) {
        throw new Error("Unable to remove data layer, ID not found: ".concat(id));
      } // Destroy all tooltips for the data layer


      this.data_layers[id].destroyAllTooltips(); // Remove the svg container for the data layer if it exists

      if (this.data_layers[id].svg.container) {
        this.data_layers[id].svg.container.remove();
      } // Delete the data layer and its presence in the panel layout and state


      this.layout.data_layers.splice(this.data_layers[id].layout_idx, 1);
      delete this.state[this.data_layers[id].state_id];
      delete this.data_layers[id]; // Remove the data_layer id from the z_index array

      this.data_layer_ids_by_z_index.splice(this.data_layer_ids_by_z_index.indexOf(id), 1); // Update layout_idx and layout.z_index values for all remaining data_layers

      this.applyDataLayerZIndexesToDataLayerLayouts();
      this.layout.data_layers.forEach(function (data_layer_layout, idx) {
        _this4.data_layers[data_layer_layout.id].layout_idx = idx;
      });
      return this;
    }
    /**
     * Clear all selections on all data layers
     * @public
     * @returns {Panel}
     */

  }, {
    key: "clearSelections",
    value: function clearSelections() {
      var _this5 = this;

      this.data_layer_ids_by_z_index.forEach(function (id) {
        _this5.data_layers[id].setAllElementStatus('selected', false);
      });
      return this;
    }
    /**
     * Update rendering of this panel whenever an event triggers a redraw. Assumes that the panel has already been
     *   prepared the first time via `initialize`
     * @public
     * @returns {Panel}
     */

  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      // Position the panel container
      this.svg.container.attr('transform', "translate(".concat(this.layout.origin.x, ", ").concat(this.layout.origin.y, ")")); // Set size on the clip rect

      this.svg.clipRect.attr('width', this.layout.width).attr('height', this.layout.height); // Set and position the inner border, style if necessary

      this.inner_border.attr('x', this.layout.margin.left).attr('y', this.layout.margin.top).attr('width', this.layout.width - (this.layout.margin.left + this.layout.margin.right)).attr('height', this.layout.height - (this.layout.margin.top + this.layout.margin.bottom));

      if (this.layout.inner_border) {
        this.inner_border.style('stroke-width', 1).style('stroke', this.layout.inner_border);
      } // Set/update panel title if necessary


      this.setTitle(); // Regenerate all extents

      this.generateExtents(); // Helper function to constrain any procedurally generated vectors (e.g. ranges, extents)
      // Constraints applied here keep vectors from going to infinity or beyond a definable power of ten

      var constrain = function constrain(value, limit_exponent) {
        var neg_min = Math.pow(-10, limit_exponent);
        var neg_max = Math.pow(-10, -limit_exponent);
        var pos_min = Math.pow(10, -limit_exponent);
        var pos_max = Math.pow(10, limit_exponent);

        if (value === Infinity) {
          value = pos_max;
        }

        if (value === -Infinity) {
          value = neg_min;
        }

        if (value === 0) {
          value = pos_min;
        }

        if (value > 0) {
          value = Math.max(Math.min(value, pos_max), pos_min);
        }

        if (value < 0) {
          value = Math.max(Math.min(value, neg_max), neg_min);
        }

        return value;
      }; // Define default and shifted ranges for all axes


      var ranges = {};

      if (this.x_extent) {
        var base_x_range = {
          start: 0,
          end: this.layout.cliparea.width
        };

        if (this.layout.axes.x.range) {
          base_x_range.start = this.layout.axes.x.range.start || base_x_range.start;
          base_x_range.end = this.layout.axes.x.range.end || base_x_range.end;
        }

        ranges.x = [base_x_range.start, base_x_range.end];
        ranges.x_shifted = [base_x_range.start, base_x_range.end];
      }

      if (this.y1_extent) {
        var base_y1_range = {
          start: this.layout.cliparea.height,
          end: 0
        };

        if (this.layout.axes.y1.range) {
          base_y1_range.start = this.layout.axes.y1.range.start || base_y1_range.start;
          base_y1_range.end = this.layout.axes.y1.range.end || base_y1_range.end;
        }

        ranges.y1 = [base_y1_range.start, base_y1_range.end];
        ranges.y1_shifted = [base_y1_range.start, base_y1_range.end];
      }

      if (this.y2_extent) {
        var base_y2_range = {
          start: this.layout.cliparea.height,
          end: 0
        };

        if (this.layout.axes.y2.range) {
          base_y2_range.start = this.layout.axes.y2.range.start || base_y2_range.start;
          base_y2_range.end = this.layout.axes.y2.range.end || base_y2_range.end;
        }

        ranges.y2 = [base_y2_range.start, base_y2_range.end];
        ranges.y2_shifted = [base_y2_range.start, base_y2_range.end];
      } // Shift ranges based on any drag or zoom interactions currently underway


      if (this.parent.interaction.panel_id && (this.parent.interaction.panel_id === this.id || this.parent.interaction.linked_panel_ids.includes(this.id))) {
        var anchor,
            scalar = null;

        if (this.parent.interaction.zooming && typeof this.x_scale == 'function') {
          var current_extent_size = Math.abs(this.x_extent[1] - this.x_extent[0]);
          var current_scaled_extent_size = Math.round(this.x_scale.invert(ranges.x_shifted[1])) - Math.round(this.x_scale.invert(ranges.x_shifted[0]));
          var zoom_factor = this.parent.interaction.zooming.scale;
          var potential_extent_size = Math.floor(current_scaled_extent_size * (1 / zoom_factor));

          if (zoom_factor < 1 && !isNaN(this.parent.layout.max_region_scale)) {
            zoom_factor = 1 / (Math.min(potential_extent_size, this.parent.layout.max_region_scale) / current_scaled_extent_size);
          } else if (zoom_factor > 1 && !isNaN(this.parent.layout.min_region_scale)) {
            zoom_factor = 1 / (Math.max(potential_extent_size, this.parent.layout.min_region_scale) / current_scaled_extent_size);
          }

          var new_extent_size = Math.floor(current_extent_size * zoom_factor);
          anchor = this.parent.interaction.zooming.center - this.layout.margin.left - this.layout.origin.x;
          var offset_ratio = anchor / this.layout.cliparea.width;
          var new_x_extent_start = Math.max(Math.floor(this.x_scale.invert(ranges.x_shifted[0]) - (new_extent_size - current_scaled_extent_size) * offset_ratio), 1);
          ranges.x_shifted = [this.x_scale(new_x_extent_start), this.x_scale(new_x_extent_start + new_extent_size)];
        } else if (this.parent.interaction.dragging) {
          switch (this.parent.interaction.dragging.method) {
            case 'background':
              ranges.x_shifted[0] = +this.parent.interaction.dragging.dragged_x;
              ranges.x_shifted[1] = this.layout.cliparea.width + this.parent.interaction.dragging.dragged_x;
              break;

            case 'x_tick':
              if (d3__WEBPACK_IMPORTED_MODULE_0__["event"] && d3__WEBPACK_IMPORTED_MODULE_0__["event"].shiftKey) {
                ranges.x_shifted[0] = +this.parent.interaction.dragging.dragged_x;
                ranges.x_shifted[1] = this.layout.cliparea.width + this.parent.interaction.dragging.dragged_x;
              } else {
                anchor = this.parent.interaction.dragging.start_x - this.layout.margin.left - this.layout.origin.x;
                scalar = constrain(anchor / (anchor + this.parent.interaction.dragging.dragged_x), 3);
                ranges.x_shifted[0] = 0;
                ranges.x_shifted[1] = Math.max(this.layout.cliparea.width * (1 / scalar), 1);
              }

              break;

            case 'y1_tick':
            case 'y2_tick':
              {
                var y_shifted = "y".concat(this.parent.interaction.dragging.method[1], "_shifted");

                if (d3__WEBPACK_IMPORTED_MODULE_0__["event"] && d3__WEBPACK_IMPORTED_MODULE_0__["event"].shiftKey) {
                  ranges[y_shifted][0] = this.layout.cliparea.height + this.parent.interaction.dragging.dragged_y;
                  ranges[y_shifted][1] = +this.parent.interaction.dragging.dragged_y;
                } else {
                  anchor = this.layout.cliparea.height - (this.parent.interaction.dragging.start_y - this.layout.margin.top - this.layout.origin.y);
                  scalar = constrain(anchor / (anchor - this.parent.interaction.dragging.dragged_y), 3);
                  ranges[y_shifted][0] = this.layout.cliparea.height;
                  ranges[y_shifted][1] = this.layout.cliparea.height - this.layout.cliparea.height * (1 / scalar);
                }
              }
          }
        }
      } // Generate scales and ticks for all axes, then render them


      ['x', 'y1', 'y2'].forEach(function (axis) {
        if (!_this6["".concat(axis, "_extent")]) {
          return;
        } // Base Scale


        _this6["".concat(axis, "_scale")] = d3__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"]().domain(_this6["".concat(axis, "_extent")]).range(ranges["".concat(axis, "_shifted")]); // Shift the extent

        _this6["".concat(axis, "_extent")] = [_this6["".concat(axis, "_scale")].invert(ranges[axis][0]), _this6["".concat(axis, "_scale")].invert(ranges[axis][1])]; // Finalize Scale

        _this6["".concat(axis, "_scale")] = d3__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"]().domain(_this6["".concat(axis, "_extent")]).range(ranges[axis]); // Render axis (and generate ticks as needed)

        _this6.renderAxis(axis);
      }); // Establish mousewheel zoom event handers on the panel (namespacing not passed through by d3, so not used here)

      if (this.layout.interaction.scroll_to_zoom) {
        var zoom_handler = function zoom_handler() {
          // Look for a shift key press while scrolling to execute.
          // If not present, gracefully raise a notification and allow conventional scrolling
          if (!(d3__WEBPACK_IMPORTED_MODULE_0__["event"].shiftKey || d3__WEBPACK_IMPORTED_MODULE_0__["event"].altKey)) {
            if (_this6.parent._canInteract(_this6.id)) {
              _this6.loader.show('Press <tt>[SHIFT]</tt> or <tt>[ALT]</tt> while scrolling to zoom').hide(1000);
            }

            return;
          }

          d3__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();

          if (!_this6.parent._canInteract(_this6.id)) {
            return;
          }

          var coords = d3__WEBPACK_IMPORTED_MODULE_0__["mouse"](_this6.svg.container.node());
          var delta = Math.max(-1, Math.min(1, d3__WEBPACK_IMPORTED_MODULE_0__["event"].wheelDelta || -d3__WEBPACK_IMPORTED_MODULE_0__["event"].detail || -d3__WEBPACK_IMPORTED_MODULE_0__["event"].deltaY));

          if (delta === 0) {
            return;
          }

          _this6.parent.interaction = {
            panel_id: _this6.id,
            linked_panel_ids: _this6.getLinkedPanelIds('x'),
            zooming: {
              scale: delta < 1 ? 0.9 : 1.1,
              center: coords[0]
            }
          };

          _this6.render();

          _this6.parent.interaction.linked_panel_ids.forEach(function (panel_id) {
            _this6.parent.panels[panel_id].render();
          });

          if (_this6.zoom_timeout !== null) {
            clearTimeout(_this6.zoom_timeout);
          }

          _this6.zoom_timeout = setTimeout(function () {
            _this6.parent.interaction = {};

            _this6.parent.applyState({
              start: _this6.x_extent[0],
              end: _this6.x_extent[1]
            });
          }, 500);
        }; // FIXME: Consider moving back to d3.zoom and rewriting drag + zoom to use behaviors.


        this.svg.container.on('wheel.zoom', zoom_handler).on('mousewheel.zoom', zoom_handler).on('DOMMouseScroll.zoom', zoom_handler);
      } // Render data layers in order by z-index


      this.data_layer_ids_by_z_index.forEach(function (data_layer_id) {
        _this6.data_layers[data_layer_id].draw().render();
      });
      return this;
    }
    /**
     * Add a "basic" loader to a panel
     * This method is just a shortcut for adding the most commonly used type of loading indicator, which appears when
     *   data is requested, animates (e.g. shows an infinitely cycling progress bar as opposed to one that loads from
     *   0-100% based on actual load progress), and disappears when new data is loaded and rendered.
     *
     * @public
     * @param {Boolean} show_immediately
     * @returns {Panel}
     */

  }, {
    key: "addBasicLoader",
    value: function addBasicLoader(show_immediately) {
      var _this7 = this;

      if (typeof show_immediately != 'undefined') {
        show_immediately = true;
      }

      if (show_immediately) {
        this.loader.show('Loading...').animate();
      }

      this.on('data_requested', function () {
        _this7.loader.show('Loading...').animate();
      });
      this.on('data_rendered', function () {
        _this7.loader.hide();
      });
      return this;
    }
    /************* Private interface: only used internally */

    /** @private */

  }, {
    key: "applyDataLayerZIndexesToDataLayerLayouts",
    value: function applyDataLayerZIndexesToDataLayerLayouts() {
      var _this8 = this;

      this.data_layer_ids_by_z_index.forEach(function (dlid, idx) {
        _this8.data_layers[dlid].layout.z_index = idx;
      });
    }
    /**
     * @private
     * @returns {string}
     */

  }, {
    key: "getBaseId",
    value: function getBaseId() {
      return "".concat(this.parent.id, ".").concat(this.id);
    }
    /**
     * Get an object with the x and y coordinates of the panel's origin in terms of the entire page
     * Necessary for positioning any HTML elements over the panel
     * @private
     * @returns {{x: Number, y: Number}}
     */

  }, {
    key: "_getPageOrigin",
    value: function _getPageOrigin() {
      var plot_origin = this.parent._getPageOrigin();

      return {
        x: plot_origin.x + this.layout.origin.x,
        y: plot_origin.y + this.layout.origin.y
      };
    }
    /**
     * Prepare the panel for first use by performing parameter validation, creating axes, setting default dimensions,
     *   and preparing / positioning data layers as appropriate.
     * @private
     * @returns {Panel}
     */

  }, {
    key: "initializeLayout",
    value: function initializeLayout() {
      var _this9 = this;

      // If the layout is missing BOTH width and proportional width then set the proportional width to 1.
      // This will default the panel to taking up the full width of the plot.
      if (this.layout.width === 0 && this.layout.proportional_width === null) {
        this.layout.proportional_width = 1;
      } // If the layout is missing BOTH height and proportional height then set the proportional height to
      // an equal share of the plot's current height.


      if (this.layout.height === 0 && this.layout.proportional_height === null) {
        var panel_count = Object.keys(this.parent.panels).length;

        if (panel_count > 0) {
          this.layout.proportional_height = 1 / panel_count;
        } else {
          this.layout.proportional_height = 1;
        }
      } // Set panel dimensions, origin, and margin


      this.setDimensions();
      this.setOrigin();
      this.setMargin(); // Set ranges
      // TODO: Define stub values in constructor

      this.x_range = [0, this.layout.cliparea.width];
      this.y1_range = [this.layout.cliparea.height, 0];
      this.y2_range = [this.layout.cliparea.height, 0]; // Initialize panel axes

      ['x', 'y1', 'y2'].forEach(function (axis) {
        if (!Object.keys(_this9.layout.axes[axis]).length || _this9.layout.axes[axis].render === false) {
          // The default layout sets the axis to an empty object, so set its render boolean here
          _this9.layout.axes[axis].render = false;
        } else {
          _this9.layout.axes[axis].render = true;
          _this9.layout.axes[axis].label = _this9.layout.axes[axis].label || null;
        }
      }); // Add data layers (which define x and y extents)

      this.layout.data_layers.forEach(function (data_layer_layout) {
        _this9.addDataLayer(data_layer_layout);
      });
      return this;
    }
    /**
     * Set the dimensions for the panel. If passed with no arguments will calculate optimal size based on layout
     *   directives and the available area within the plot. If passed discrete width (number) and height (number) will
     *   attempt to resize the panel to them, but may be limited by minimum dimensions defined on the plot or panel.
     *
     * @private
     * @param {number} [width]
     * @param {number} [height]
     * @returns {Panel}
     */

  }, {
    key: "setDimensions",
    value: function setDimensions(width, height) {
      if (typeof width != 'undefined' && typeof height != 'undefined') {
        if (!isNaN(width) && width >= 0 && !isNaN(height) && height >= 0) {
          this.layout.width = Math.max(Math.round(+width), this.layout.min_width);
          this.layout.height = Math.max(Math.round(+height), this.layout.min_height);
        }
      } else {
        if (this.layout.proportional_width !== null) {
          this.layout.width = Math.max(this.layout.proportional_width * this.parent.layout.width, this.layout.min_width);
        }

        if (this.layout.proportional_height !== null) {
          this.layout.height = Math.max(this.layout.proportional_height * this.parent.layout.height, this.layout.min_height);
        }
      }

      this.layout.cliparea.width = Math.max(this.layout.width - (this.layout.margin.left + this.layout.margin.right), 0);
      this.layout.cliparea.height = Math.max(this.layout.height - (this.layout.margin.top + this.layout.margin.bottom), 0);

      if (this.svg.clipRect) {
        this.svg.clipRect.attr('width', this.layout.width).attr('height', this.layout.height);
      }

      if (this.initialized) {
        this.render();
        this.curtain.update();
        this.loader.update();
        this.toolbar.update();

        if (this.legend) {
          this.legend.position();
        }
      }

      return this;
    }
    /**
     * Set panel origin on the plot, and re-render as appropriate
     *
     * @private
     * @param {number} x
     * @param {number} y
     * @returns {Panel}
     */

  }, {
    key: "setOrigin",
    value: function setOrigin(x, y) {
      if (!isNaN(x) && x >= 0) {
        this.layout.origin.x = Math.max(Math.round(+x), 0);
      }

      if (!isNaN(y) && y >= 0) {
        this.layout.origin.y = Math.max(Math.round(+y), 0);
      }

      if (this.initialized) {
        this.render();
      }

      return this;
    }
    /**
     * Set margins around this panel
     * @private
     * @param {number} top
     * @param {number} right
     * @param {number} bottom
     * @param {number} left
     * @returns {Panel}
     */

  }, {
    key: "setMargin",
    value: function setMargin(top, right, bottom, left) {
      var _this10 = this;

      var extra;

      if (!isNaN(top) && top >= 0) {
        this.layout.margin.top = Math.max(Math.round(+top), 0);
      }

      if (!isNaN(right) && right >= 0) {
        this.layout.margin.right = Math.max(Math.round(+right), 0);
      }

      if (!isNaN(bottom) && bottom >= 0) {
        this.layout.margin.bottom = Math.max(Math.round(+bottom), 0);
      }

      if (!isNaN(left) && left >= 0) {
        this.layout.margin.left = Math.max(Math.round(+left), 0);
      }

      if (this.layout.margin.top + this.layout.margin.bottom > this.layout.height) {
        extra = Math.floor((this.layout.margin.top + this.layout.margin.bottom - this.layout.height) / 2);
        this.layout.margin.top -= extra;
        this.layout.margin.bottom -= extra;
      }

      if (this.layout.margin.left + this.layout.margin.right > this.layout.width) {
        extra = Math.floor((this.layout.margin.left + this.layout.margin.right - this.layout.width) / 2);
        this.layout.margin.left -= extra;
        this.layout.margin.right -= extra;
      }

      ['top', 'right', 'bottom', 'left'].forEach(function (m) {
        _this10.layout.margin[m] = Math.max(_this10.layout.margin[m], 0);
      });
      this.layout.cliparea.width = Math.max(this.layout.width - (this.layout.margin.left + this.layout.margin.right), 0);
      this.layout.cliparea.height = Math.max(this.layout.height - (this.layout.margin.top + this.layout.margin.bottom), 0);
      this.layout.cliparea.origin.x = this.layout.margin.left;
      this.layout.cliparea.origin.y = this.layout.margin.top;

      if (this.initialized) {
        this.render();
      }

      return this;
    }
    /**
     * Prepare the first rendering of the panel. This includes drawing the individual data layers, but also creates shared
     *   elements such as axes,  title, and loader/curtain.
     * @private
     * @returns {Panel}
     */

  }, {
    key: "initialize",
    value: function initialize() {
      var _this11 = this;

      // Append a container group element to house the main panel group element and the clip path
      // Position with initial layout parameters
      var base_id = this.getBaseId();
      this.svg.container = this.parent.svg.append('g').attr('id', "".concat(base_id, ".panel_container")).attr('transform', "translate(".concat(this.layout.origin.x || 0, ", ").concat(this.layout.origin.y || 0, ")")); // Append clip path to the parent svg element, size with initial layout parameters

      var clipPath = this.svg.container.append('clipPath').attr('id', "".concat(base_id, ".clip"));
      this.svg.clipRect = clipPath.append('rect').attr('width', this.layout.width).attr('height', this.layout.height); // Append svg group for rendering all panel child elements, clipped by the clip path

      this.svg.group = this.svg.container.append('g').attr('id', "".concat(base_id, ".panel")).attr('clip-path', "url(#".concat(base_id, ".clip)")); // Add curtain and loader prototypes to the panel

      /** @member {Object} */

      this.curtain = _helpers_common__WEBPACK_IMPORTED_MODULE_3__["generateCurtain"].call(this);
      /** @member {Object} */

      this.loader = _helpers_common__WEBPACK_IMPORTED_MODULE_3__["generateLoader"].call(this);
      /**
       * Create the toolbar object and hang widgets on it as defined by panel layout
       * @member {Toolbar}
       */

      this.toolbar = new _toolbar__WEBPACK_IMPORTED_MODULE_2__["default"](this); // Inner border

      this.inner_border = this.svg.group.append('rect').attr('class', 'lz-panel-background').on('click', function () {
        if (_this11.layout.background_click === 'clear_selections') {
          _this11.clearSelections();
        }
      }); // Add the title

      /** @member {Element} */

      this.title = this.svg.group.append('text').attr('class', 'lz-panel-title');

      if (typeof this.layout.title != 'undefined') {
        this.setTitle();
      } // Initialize Axes


      this.svg.x_axis = this.svg.group.append('g').attr('id', "".concat(base_id, ".x_axis")).attr('class', 'lz-x lz-axis');

      if (this.layout.axes.x.render) {
        this.svg.x_axis_label = this.svg.x_axis.append('text').attr('class', 'lz-x lz-axis lz-label').attr('text-anchor', 'middle');
      }

      this.svg.y1_axis = this.svg.group.append('g').attr('id', "".concat(base_id, ".y1_axis")).attr('class', 'lz-y lz-y1 lz-axis');

      if (this.layout.axes.y1.render) {
        this.svg.y1_axis_label = this.svg.y1_axis.append('text').attr('class', 'lz-y1 lz-axis lz-label').attr('text-anchor', 'middle');
      }

      this.svg.y2_axis = this.svg.group.append('g').attr('id', "".concat(base_id, ".y2_axis")).attr('class', 'lz-y lz-y2 lz-axis');

      if (this.layout.axes.y2.render) {
        this.svg.y2_axis_label = this.svg.y2_axis.append('text').attr('class', 'lz-y2 lz-axis lz-label').attr('text-anchor', 'middle');
      } // Initialize child Data Layers


      this.data_layer_ids_by_z_index.forEach(function (id) {
        _this11.data_layers[id].initialize();
      });
      /**
       * Legend object, as defined by panel layout and child data layer layouts
       * @member {Legend}
       * */

      this.legend = null;

      if (this.layout.legend) {
        this.legend = new _legend__WEBPACK_IMPORTED_MODULE_6__["default"](this);
      } // Establish panel background drag interaction mousedown event handler (on the panel background)


      if (this.layout.interaction.drag_background_to_pan) {
        var namespace = ".".concat(this.parent.id, ".").concat(this.id, ".interaction.drag");

        var mousedown = function mousedown() {
          return _this11.parent.startDrag(_this11, 'background');
        };

        this.svg.container.select('.lz-panel-background').on("mousedown".concat(namespace, ".background"), mousedown).on("touchstart".concat(namespace, ".background"), mousedown);
      }

      return this;
    }
    /**
     * Refresh the sort order of all data layers (called by data layer moveForward and moveBack methods)
     * @private
     */

  }, {
    key: "resortDataLayers",
    value: function resortDataLayers() {
      var _this12 = this;

      var sort = [];
      this.data_layer_ids_by_z_index.forEach(function (id) {
        sort.push(_this12.data_layers[id].layout.z_index);
      });
      this.svg.group.selectAll('g.lz-data_layer-container').data(sort).sort(d3__WEBPACK_IMPORTED_MODULE_0__["ascending"]);
      this.applyDataLayerZIndexesToDataLayerLayouts();
    }
    /**
     * Get an array of panel IDs that are axis-linked to this panel
     * @private
     * @param {('x'|'y1'|'y2')} axis
     * @returns {Array}
     */

  }, {
    key: "getLinkedPanelIds",
    value: function getLinkedPanelIds(axis) {
      var _this13 = this;

      axis = axis || null;
      var linked_panel_ids = [];

      if (!['x', 'y1', 'y2'].includes(axis)) {
        return linked_panel_ids;
      }

      if (!this.layout.interaction["".concat(axis, "_linked")]) {
        return linked_panel_ids;
      }

      this.parent.panel_ids_by_y_index.forEach(function (panel_id) {
        if (panel_id !== _this13.id && _this13.parent.panels[panel_id].layout.interaction["".concat(axis, "_linked")]) {
          linked_panel_ids.push(panel_id);
        }
      });
      return linked_panel_ids;
    }
    /**
     * Move a panel up relative to others by y-index
     * @private
     * @returns {Panel}
     */

  }, {
    key: "moveUp",
    value: function moveUp() {
      if (this.parent.panel_ids_by_y_index[this.layout.y_index - 1]) {
        this.parent.panel_ids_by_y_index[this.layout.y_index] = this.parent.panel_ids_by_y_index[this.layout.y_index - 1];
        this.parent.panel_ids_by_y_index[this.layout.y_index - 1] = this.id;
        this.parent.applyPanelYIndexesToPanelLayouts();
        this.parent.positionPanels();
      }

      return this;
    }
    /**
     * Move a panel down (y-axis) relative to others in the plot
     * @private
     * @returns {Panel}
     */

  }, {
    key: "moveDown",
    value: function moveDown() {
      if (this.parent.panel_ids_by_y_index[this.layout.y_index + 1]) {
        this.parent.panel_ids_by_y_index[this.layout.y_index] = this.parent.panel_ids_by_y_index[this.layout.y_index + 1];
        this.parent.panel_ids_by_y_index[this.layout.y_index + 1] = this.id;
        this.parent.applyPanelYIndexesToPanelLayouts();
        this.parent.positionPanels();
      }

      return this;
    }
    /**
     * When the parent plot changes state, adjust the panel accordingly. For example, this may include fetching new data
     *   from the API as the viewing region changes
     * @private
     * @returns {Promise}
     */

  }, {
    key: "reMap",
    value: function reMap() {
      var _this14 = this;

      this.emit('data_requested');
      this.data_promises = []; // Remove any previous error messages before attempting to load new data

      this.curtain.hide(); // Trigger reMap on each Data Layer

      for (var id in this.data_layers) {
        try {
          this.data_promises.push(this.data_layers[id].reMap());
        } catch (error) {
          console.error(error);
          this.curtain.show(error.message || error);
        }
      } // When all finished trigger a render


      return Promise.all(this.data_promises).then(function () {
        _this14.initialized = true;

        _this14.render();

        _this14.emit('layout_changed', true);

        _this14.emit('data_rendered');
      })["catch"](function (error) {
        console.error(error);

        _this14.curtain.show(error.message || error);
      });
    }
    /**
     * Iterate over data layers to generate panel axis extents
     * @private
     * @returns {Panel}
     */

  }, {
    key: "generateExtents",
    value: function generateExtents() {
      var _this15 = this;

      // Reset extents
      ['x', 'y1', 'y2'].forEach(function (axis) {
        _this15["".concat(axis, "_extent")] = null;
      }); // Loop through the data layers

      for (var id in this.data_layers) {
        var data_layer = this.data_layers[id]; // If defined and not decoupled, merge the x extent of the data layer with the panel's x extent

        if (data_layer.layout.x_axis && !data_layer.layout.x_axis.decoupled) {
          this.x_extent = d3__WEBPACK_IMPORTED_MODULE_0__["extent"]((this.x_extent || []).concat(data_layer.getAxisExtent('x')));
        } // If defined and not decoupled, merge the y extent of the data layer with the panel's appropriate y extent


        if (data_layer.layout.y_axis && !data_layer.layout.y_axis.decoupled) {
          var y_axis = "y".concat(data_layer.layout.y_axis.axis);
          this["".concat(y_axis, "_extent")] = d3__WEBPACK_IMPORTED_MODULE_0__["extent"]((this["".concat(y_axis, "_extent")] || []).concat(data_layer.getAxisExtent('y')));
        }
      } // Override x_extent from state if explicitly defined to do so


      if (this.layout.axes.x && this.layout.axes.x.extent === 'state') {
        this.x_extent = [this.state.start, this.state.end];
      }

      return this;
    }
    /**
     * Generate an array of ticks for an axis. These ticks are generated in one of three ways (highest wins):
     *   1. An array of specific tick marks
     *   2. Query each data layer for what ticks are appropriate, and allow a panel-level tick configuration parameter
     *     object to override the layer's default presentation settings
     *   3. Generate generic tick marks based on the extent of the data
     *
     * @private
     * @param {('x'|'y1'|'y2')} axis The string identifier of the axis
     * @returns {Number[]|Object[]}  TODO: number format?
     *   An array of numbers: interpreted as an array of axis value offsets for positioning.
     *   An array of objects: each object must have an 'x' attribute to position the tick.
     *   Other supported object keys:
     *     * text: string to render for a given tick
     *     * style: d3-compatible CSS style object
     *     * transform: SVG transform attribute string
     *     * color: string or LocusZoom scalable parameter object
     */

  }, {
    key: "generateTicks",
    value: function generateTicks(axis) {
      // Parse an explicit 'ticks' attribute in the axis layout
      if (this.layout.axes[axis].ticks) {
        var layout = this.layout.axes[axis];
        var baseTickConfig = layout.ticks;

        if (Array.isArray(baseTickConfig)) {
          // Array of specific ticks hard-coded into a panel will override any ticks that an individual layer might specify
          return baseTickConfig;
        }

        if (_typeof(baseTickConfig) === 'object') {
          // If the layout specifies base configuration for ticks- but without specific positions- then ask each
          //   data layer to report the tick marks that it thinks it needs
          // TODO: Few layers currently need to specify custom ticks (which is ok!). But if it becomes common, consider adding mechanisms to deduplicate ticks across layers
          var self = this; // Pass any layer-specific customizations for how ticks are calculated. (styles are overridden separately)

          var config = {
            position: baseTickConfig.position
          };
          var combinedTicks = this.data_layer_ids_by_z_index.reduce(function (acc, data_layer_id) {
            var nextLayer = self.data_layers[data_layer_id];
            return acc.concat(nextLayer.getTicks(axis, config));
          }, []);
          return combinedTicks.map(function (item) {
            // The layer makes suggestions, but tick configuration params specified on the panel take precedence
            var itemConfig = {};
            itemConfig = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_5__["merge"])(itemConfig, baseTickConfig);
            return Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_5__["merge"])(itemConfig, item);
          });
        }
      } // If no other configuration is provided, attempt to generate ticks from the extent


      if (this["".concat(axis, "_extent")]) {
        return Object(_helpers_display__WEBPACK_IMPORTED_MODULE_4__["prettyTicks"])(this["".concat(axis, "_extent")], 'both');
      }

      return [];
    }
    /**
     * Render ticks for a particular axis
     * @private
     * @param {('x'|'y1'|'y2')} axis The identifier of the axes
     * @returns {Panel}
     */

  }, {
    key: "renderAxis",
    value: function renderAxis(axis) {
      var _this16 = this;

      if (!['x', 'y1', 'y2'].includes(axis)) {
        throw new Error("Unable to render axis; invalid axis identifier: ".concat(axis));
      }

      var canRender = this.layout.axes[axis].render && typeof this["".concat(axis, "_scale")] == 'function' && !isNaN(this["".concat(axis, "_scale")](0)); // If the axis has already been rendered then check if we can/can't render it
      // Make sure the axis element is shown/hidden to suit

      if (this["".concat(axis, "_axis")]) {
        this.svg.container.select("g.lz-axis.lz-".concat(axis)).style('display', canRender ? null : 'none');
      }

      if (!canRender) {
        return this;
      } // Axis-specific values to plug in where needed


      var axis_params = {
        x: {
          position: "translate(".concat(this.layout.margin.left, ", ").concat(this.layout.height - this.layout.margin.bottom, ")"),
          orientation: 'bottom',
          label_x: this.layout.cliparea.width / 2,
          label_y: this.layout.axes[axis].label_offset || 0,
          label_rotate: null
        },
        y1: {
          position: "translate(".concat(this.layout.margin.left, ", ").concat(this.layout.margin.top, ")"),
          orientation: 'left',
          label_x: -1 * (this.layout.axes[axis].label_offset || 0),
          label_y: this.layout.cliparea.height / 2,
          label_rotate: -90
        },
        y2: {
          position: "translate(".concat(this.layout.width - this.layout.margin.right, ", ").concat(this.layout.margin.top, ")"),
          orientation: 'right',
          label_x: this.layout.axes[axis].label_offset || 0,
          label_y: this.layout.cliparea.height / 2,
          label_rotate: -90
        }
      }; // Generate Ticks

      this["".concat(axis, "_ticks")] = this.generateTicks(axis); // Determine if the ticks are all numbers (d3-automated tick rendering) or not (manual tick rendering)

      var ticksAreAllNumbers = function (ticks) {
        for (var i = 0; i < ticks.length; i++) {
          if (isNaN(ticks[i])) {
            return false;
          }
        }

        return true;
      }(this["".concat(axis, "_ticks")]); // Initialize the axis; set scale and orientation


      var axis_factory;

      switch (axis_params[axis].orientation) {
        case 'right':
          axis_factory = d3__WEBPACK_IMPORTED_MODULE_0__["axisRight"];
          break;

        case 'left':
          axis_factory = d3__WEBPACK_IMPORTED_MODULE_0__["axisLeft"];
          break;

        case 'bottom':
          axis_factory = d3__WEBPACK_IMPORTED_MODULE_0__["axisBottom"];
          break;

        default:
          throw new Error('Unrecognized axis orientation');
      }

      this["".concat(axis, "_axis")] = axis_factory(this["".concat(axis, "_scale")]).tickPadding(3); // Set tick values and format

      if (ticksAreAllNumbers) {
        this["".concat(axis, "_axis")].tickValues(this["".concat(axis, "_ticks")]);

        if (this.layout.axes[axis].tick_format === 'region') {
          this["".concat(axis, "_axis")].tickFormat(function (d) {
            return Object(_helpers_display__WEBPACK_IMPORTED_MODULE_4__["positionIntToString"])(d, 6);
          });
        }
      } else {
        var ticks = this["".concat(axis, "_ticks")].map(function (t) {
          return t[axis.substr(0, 1)];
        });
        this["".concat(axis, "_axis")].tickValues(ticks).tickFormat(function (t, i) {
          return _this16["".concat(axis, "_ticks")][i].text;
        });
      } // Position the axis in the SVG and apply the axis construct


      this.svg["".concat(axis, "_axis")].attr('transform', axis_params[axis].position).call(this["".concat(axis, "_axis")]); // If necessary manually apply styles and transforms to ticks as specified by the layout

      if (!ticksAreAllNumbers) {
        var tick_selector = d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"]("g#".concat(this.getBaseId().replace('.', '\\.'), "\\.").concat(axis, "_axis g.tick"));
        var panel = this;
        tick_selector.each(function (d, i) {
          var selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).select('text');

          if (panel["".concat(axis, "_ticks")][i].style) {
            Object(_helpers_common__WEBPACK_IMPORTED_MODULE_3__["applyStyles"])(selector, panel["".concat(axis, "_ticks")][i].style);
          }

          if (panel["".concat(axis, "_ticks")][i].transform) {
            selector.attr('transform', panel["".concat(axis, "_ticks")][i].transform);
          }
        });
      } // Render the axis label if necessary


      var label = this.layout.axes[axis].label || null;

      if (label !== null) {
        this.svg["".concat(axis, "_axis_label")].attr('x', axis_params[axis].label_x).attr('y', axis_params[axis].label_y).text(Object(_helpers_display__WEBPACK_IMPORTED_MODULE_4__["parseFields"])(this.state, label)).attr('fill', 'currentColor');

        if (axis_params[axis].label_rotate !== null) {
          this.svg["".concat(axis, "_axis_label")].attr('transform', "rotate(".concat(axis_params[axis].label_rotate, " ").concat(axis_params[axis].label_x, ", ").concat(axis_params[axis].label_y, ")"));
        }
      } // Attach interactive handlers to ticks as needed


      ['x', 'y1', 'y2'].forEach(function (axis) {
        if (_this16.layout.interaction["drag_".concat(axis, "_ticks_to_scale")]) {
          var namespace = ".".concat(_this16.parent.id, ".").concat(_this16.id, ".interaction.drag");

          var tick_mouseover = function tick_mouseover() {
            if (typeof d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).node().focus == 'function') {
              d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).node().focus();
            }

            var cursor = axis === 'x' ? 'ew-resize' : 'ns-resize';

            if (d3__WEBPACK_IMPORTED_MODULE_0__["event"] && d3__WEBPACK_IMPORTED_MODULE_0__["event"].shiftKey) {
              cursor = 'move';
            }

            d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).style('font-weight', 'bold').style('cursor', cursor).on("keydown".concat(namespace), tick_mouseover).on("keyup".concat(namespace), tick_mouseover);
          };

          _this16.svg.container.selectAll(".lz-axis.lz-".concat(axis, " .tick text")).attr('tabindex', 0) // necessary to make the tick focusable so keypress events can be captured
          .on("mouseover".concat(namespace), tick_mouseover).on("mouseout".concat(namespace), function () {
            d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).style('font-weight', 'normal').on("keydown".concat(namespace), null).on("keyup".concat(namespace), null);
          }).on("mousedown".concat(namespace), function () {
            _this16.parent.startDrag(_this16, "".concat(axis, "_tick"));
          });
        }
      });
      return this;
    }
    /**
     * Force the height of this panel to the largest absolute height of the data in
     *   all child data layers (if not null for any child data layers)
     * @private
     * @param {number|null} [target_height] A target height, which will be used in situations when the expected height can be
     *   pre-calculated (eg when the layers are transitioning)
     */

  }, {
    key: "scaleHeightToData",
    value: function scaleHeightToData(target_height) {
      var _this17 = this;

      target_height = +target_height || null;

      if (target_height === null) {
        this.data_layer_ids_by_z_index.forEach(function (id) {
          var dh = _this17.data_layers[id].getAbsoluteDataHeight();

          if (+dh) {
            if (target_height === null) {
              target_height = +dh;
            } else {
              target_height = Math.max(target_height, +dh);
            }
          }
        });
      }

      if (+target_height) {
        target_height += +this.layout.margin.top + +this.layout.margin.bottom;
        this.setDimensions(this.layout.width, target_height);
        this.parent.setDimensions();
        this.parent.panel_ids_by_y_index.forEach(function (id) {
          _this17.parent.panels[id].layout.proportional_height = null;
        });
        this.parent.positionPanels();
      }
    }
    /**
     * Set/unset element statuses across all data layers
     * @private
     * @param {String} status
     * @param {Boolean} toggle
     */

  }, {
    key: "setAllElementStatus",
    value: function setAllElementStatus(status, toggle) {
      var _this18 = this;

      this.data_layer_ids_by_z_index.forEach(function (id) {
        _this18.data_layers[id].setAllElementStatus(status, toggle);
      });
    }
  }]);

  return Panel;
}();

_constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].verbs.forEach(function (verb, idx) {
  var adjective = _constants__WEBPACK_IMPORTED_MODULE_1__["STATUSES"].adjectives[idx];
  var antiverb = "un".concat(verb); // Set/unset status for all elements

  /**
   * @private
   * @function highlightAllElements
   */

  /**
   *  @private
   *  @function selectAllElements
   */

  /**
   *  @private
   *  @function fadeAllElements
   */

  /**
   *  @private
   *  @function hideAllElements
   */

  Panel.prototype["".concat(verb, "AllElements")] = function () {
    this.setAllElementStatus(adjective, true);
    return this;
  };
  /**
   * @private
   * @function unhighlightAllElements
   */

  /**
   *  @private
   *  @function unselectAllElements
   */

  /**
   * @private
   * @function unfadeAllElements
   */

  /**
   *  @private
   *  @function unhideAllElements
   */


  Panel.prototype["".concat(antiverb, "AllElements")] = function () {
    this.setAllElementStatus(adjective, false);
    return this;
  };
});


/***/ }),

/***/ "./esm/components/plot.js":
/*!********************************!*\
  !*** ./esm/components/plot.js ***!
  \********************************/
/*! exports provided: default, _updateStatePosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Plot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_updateStatePosition", function() { return _updateStatePosition; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _data_requester__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/requester */ "./esm/data/requester.js");
/* harmony import */ var _toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toolbar */ "./esm/components/toolbar/index.js");
/* harmony import */ var _panel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./panel */ "./esm/components/panel.js");
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/common */ "./esm/helpers/common.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */






/**
 * Default/ expected configuration parameters for basic plotting; most plots will override
 *
 * @protected
 * @static
 * @type {Object}
 */

var default_layout = {
  state: {},
  width: 1,
  height: 1,
  min_width: 1,
  min_height: 1,
  responsive_resize: false,
  // Allowed values: false, "width_only" (synonym for true)
  panels: [],
  toolbar: {
    widgets: []
  },
  panel_boundaries: true,
  mouse_guide: true
};
/**
 * Check that position fields (chr, start, end) are provided where appropriate, and ensure that the plot fits within
 *  any constraints specified by the layout
 *
 * This function has side effects; it mutates the proposed state in order to meet certain bounds checks etc.
 * @param {Object} new_state
 * @param {Number} new_state.chr
 * @param {Number} new_state.start
 * @param {Number} new_state.end
 * @param {Object} layout
 * @returns {*|{}}
 */

function _updateStatePosition(new_state, layout) {
  new_state = new_state || {};
  layout = layout || {}; // If a "chr", "start", and "end" are present then resolve start and end
  // to numeric values that are not decimal, negative, or flipped

  var validated_region = false;
  var attempted_midpoint = null;
  var attempted_scale;

  if (typeof new_state.chr != 'undefined' && typeof new_state.start != 'undefined' && typeof new_state.end != 'undefined') {
    // Determine a numeric scale and midpoint for the attempted region,
    new_state.start = Math.max(parseInt(new_state.start), 1);
    new_state.end = Math.max(parseInt(new_state.end), 1);

    if (isNaN(new_state.start) && isNaN(new_state.end)) {
      new_state.start = 1;
      new_state.end = 1;
      attempted_midpoint = 0.5;
      attempted_scale = 0;
    } else if (isNaN(new_state.start) || isNaN(new_state.end)) {
      attempted_midpoint = new_state.start || new_state.end;
      attempted_scale = 0;
      new_state.start = isNaN(new_state.start) ? new_state.end : new_state.start;
      new_state.end = isNaN(new_state.end) ? new_state.start : new_state.end;
    } else {
      attempted_midpoint = Math.round((new_state.start + new_state.end) / 2);
      attempted_scale = new_state.end - new_state.start;

      if (attempted_scale < 0) {
        var temp = new_state.start;
        new_state.end = new_state.start;
        new_state.start = temp;
        attempted_scale = new_state.end - new_state.start;
      }

      if (attempted_midpoint < 0) {
        new_state.start = 1;
        new_state.end = 1;
        attempted_scale = 0;
      }
    }

    validated_region = true;
  } // Constrain w/r/t layout-defined minimum region scale


  if (!isNaN(layout.min_region_scale) && validated_region && attempted_scale < layout.min_region_scale) {
    new_state.start = Math.max(attempted_midpoint - Math.floor(layout.min_region_scale / 2), 1);
    new_state.end = new_state.start + layout.min_region_scale;
  } // Constrain w/r/t layout-defined maximum region scale


  if (!isNaN(layout.max_region_scale) && validated_region && attempted_scale > layout.max_region_scale) {
    new_state.start = Math.max(attempted_midpoint - Math.floor(layout.max_region_scale / 2), 1);
    new_state.end = new_state.start + layout.max_region_scale;
  }

  return new_state;
}

var Plot = /*#__PURE__*/function () {
  /**
   * An independent LocusZoom object that renders a unique set of data and subpanels.
   * Many such LocusZoom objects can exist simultaneously on a single page, each having its own layout.
   *
   * This creates a new plot instance, but does not immediately render it. For practical use, it may be more convenient
   * to use the `LocusZoom.populate` helper method.
   *
   * @param {String} id The ID of the plot. Often corresponds to the ID of the container element on the page
   *   where the plot is rendered..
   * @param {DataSources} datasource Ensemble of data providers used by the plot
   * @param {Object} layout A JSON-serializable object of layout configuration parameters
  */
  function Plot(id, datasource, layout) {
    _classCallCheck(this, Plot);

    /**
     * @private
     * @member Boolean}
     */
    this.initialized = false;
    /**
     *  @private
     *  @member {Plot}
     */

    this.parent_plot = this;
    /**
     *  @public
     *  @member {String}
     */

    this.id = id;
    /**
     * @private
     * @member {Element}
     */

    this.container = null;
    /**
     * Selector for a node that will contain the plot. (set externally by populate methods)
     * @private
     * @member {d3.selection}
     */

    this.svg = null;
    /**
     * Direct access to panel instances, keyed by panel ID. Used primarily for introspection/ development.
     *  @public
     *  @member {Object.<String, Number>}
     */

    this.panels = {};
    /**
     * TODO: This is currently used by external classes that manipulate the parent and may indicate room for a helper method in the api to coordinate boilerplate
     * @private
     * @member {String[]}
     */

    this.panel_ids_by_y_index = [];
    /**
     * Track update operations (reMap) performed on all child panels, and notify the parent plot when complete
     * TODO: Reconsider whether we need to be tracking this as global state outside of context of specific operations
     * @protected
     * @member {Promise[]}
     */

    this.remap_promises = [];
    /**
     * The current layout options for the plot, including the effect of any resizing events or dynamically
     *  generated config produced during rendering options.
     * @public
     * @type {Object}
     */

    this.layout = layout;
    Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])(this.layout, default_layout); // TODO: evaluate how the default layout is applied

    /**
     * Values in the layout object may change during rendering etc. Retain a copy of the original plot options
     * @protected
     * @member {Object}
     */

    this._base_layout = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(this.layout);
    /**
     * Create a shortcut to the state in the layout on the Plot. Tracking in the layout allows the plot to be created
     *   with initial state/setup.
     *
     * Tracks state of the plot, eg start and end position
     * @public
     * @member {Object}
     */

    this.state = this.layout.state;
    /**
     * @private
     * @member {Requester}
     */

    this.lzd = new _data_requester__WEBPACK_IMPORTED_MODULE_2__["default"](datasource);
    /**
     * Track global event listeners that are used by LZ. This allows cleanup of listeners when plot is destroyed.
     * @private
     * @member {Map} A nested hash of entries: { parent: {event_name: [listeners] } }
     */

    this._external_listeners = new Map();
    /**
     * Known event hooks that the panel can respond to
     * @protected
     * @member {Object}
     */

    this.event_hooks = {
      'layout_changed': [],
      // Many rerendering operations, including dimensions changed, element highlighted, or rerender on chanegd data. Caution: Direct layout mutations might not be captured by this event.
      'data_requested': [],
      // A request has been made for new data from any data source used in the plot
      'data_rendered': [],
      // Data from a request has been received and rendered in the plot
      'element_clicked': [],
      // Select or unselect
      'element_selection': [],
      // Element becomes active (only)
      'match_requested': [],
      // A data layer is attempting to highlight matching points (internal use only)
      'panel_removed': [],
      // A panel has been removed (eg via the "x" button in plot)
      'region_changed': [],
      // The viewing region (chr/start/end) has been changed
      'state_changed': [] // Only triggered when a state change causes rerender

    };
    /**
     * @callback eventCallback
     * @param {object} eventData A description of the event
     * @param {String|null} eventData.sourceID The unique identifier (eg plot or parent name) of the element that
     *  triggered the event. Will be automatically filled in if not explicitly provided.
     * @param {Object|null} eventData.context Any additional information to be passed to the callback, eg the data
     *   associated with a clicked plot element
     */

    /**
     * Event information describing interaction (e.g. panning and zooming) is stored on the plot
     * TODO: Add/ document details of interaction structure as we expand
     * @private
     * @member {{panel_id: String, linked_panel_ids: Array, x_linked: *, dragging: *, zooming: *}}
     * @returns {Plot}
     */

    this.interaction = {}; // Initialize the layout

    this.initializeLayout();
  }
  /******* User-facing methods that allow manipulation of the plot instance: the public interface */

  /**
   * There are several events that a LocusZoom plot can "emit" when appropriate, and LocusZoom supports registering
   *   "hooks" for these events which are essentially custom functions intended to fire at certain times.
   *
   * The following plot-level events are currently supported:
   *   - `layout_changed` - context: plot - Any aspect of the plot's layout (including dimensions or state) has changed.
   *   - `data_requested` - context: plot - A request for new data from any data source used in the plot has been made.
   *   - `data_rendered` - context: plot - Data from a request has been received and rendered in the plot.
   *   - `element_clicked` - context: plot - A data element in any of the plot's data layers has been clicked.
   *   - `element_selection` - context: plot - Triggered when an element changes "selection" status, and identifies
   *        whether the element is being selected or deselected.
   *
   * To register a hook for any of these events use `plot.on('event_name', function() {})`.
   *
   * There can be arbitrarily many functions registered to the same event. They will be executed in the order they
   *   were registered. The this context bound to each event hook function is dependent on the type of event, as
   *   denoted above. For example, when data_requested is emitted the context for this in the event hook will be the
   *   plot itself, but when element_clicked is emitted the context for this in the event hook will be the element
   *   that was clicked.
   *
   * @public
   * @param {String} event The name of an event (as defined in `event_hooks`)
   * @param {eventCallback} hook
   * @returns {function} The registered event listener
   */


  _createClass(Plot, [{
    key: "on",
    value: function on(event, hook) {
      if ( false || !Array.isArray(this.event_hooks[event])) {
        throw new Error("Unable to register event hook, invalid event: ".concat(event.toString()));
      }

      if (typeof hook != 'function') {
        throw new Error('Unable to register event hook, invalid hook function passed');
      }

      this.event_hooks[event].push(hook);
      return hook;
    }
    /**
     * Remove one or more previously defined event listeners
     * @public
     * @param {String} event The name of an event (as defined in `event_hooks`)
     * @param {eventCallback} [hook] The callback to deregister
     * @returns {Plot}
     */

  }, {
    key: "off",
    value: function off(event, hook) {
      var theseHooks = this.event_hooks[event];

      if ( false || !Array.isArray(theseHooks)) {
        throw new Error("Unable to remove event hook, invalid event: ".concat(event.toString()));
      }

      if (hook === undefined) {
        // Deregistering all hooks for this event may break basic functionality, and should only be used during
        //  cleanup operations (eg to prevent memory leaks)
        this.event_hooks[event] = [];
      } else {
        var hookMatch = theseHooks.indexOf(hook);

        if (hookMatch !== -1) {
          theseHooks.splice(hookMatch, 1);
        } else {
          throw new Error('The specified event listener is not registered and therefore cannot be removed');
        }
      }

      return this;
    }
    /**
     * Handle running of event hooks when an event is emitted
     * @public
     * @param {string} event A known event name
     * @param {*} eventData Data or event description that will be passed to the event listener
     * @returns {Plot}
     */

  }, {
    key: "emit",
    value: function emit(event, eventData) {
      var _this = this;

      // TODO: there are small differences between the emit implementation between plots and panels. In the future,
      //  DRY this code via mixins, and make sure to keep the interfaces compatible when refactoring.
      if ( false || !Array.isArray(this.event_hooks[event])) {
        throw new Error("LocusZoom attempted to throw an invalid event: ".concat(event.toString()));
      }

      var sourceID = this.getBaseId();
      this.event_hooks[event].forEach(function (hookToRun) {
        var eventContext;

        if (eventData && eventData.sourceID) {
          // If we detect that an event originated elsewhere (via bubbling or externally), preserve the context
          //  when re-emitting the event to plot-level listeners
          eventContext = eventData;
        } else {
          eventContext = {
            sourceID: sourceID,
            target: _this,
            data: eventData || null
          };
        } // By default, any handlers fired here (either directly, or bubbled) will see the plot as the
        //  value of `this`. If a bound function is registered as a handler, the previously bound `this` will
        //  override anything provided to `call` below.


        hookToRun.call(_this, eventContext);
      });
      return this;
    }
    /**
     * Create a new panel from a layout, and handle the work of initializing and placing the panel on the plot
     * @public
     * @param {Object} layout
     * @returns {Panel}
     */

  }, {
    key: "addPanel",
    value: function addPanel(layout) {
      // Sanity checks
      if (_typeof(layout) !== 'object') {
        throw new Error('Invalid panel layout');
      } // Create the Panel and set its parent


      var panel = new _panel__WEBPACK_IMPORTED_MODULE_4__["default"](layout, this); // Store the Panel on the Plot

      this.panels[panel.id] = panel; // If a discrete y_index was set in the layout then adjust other panel y_index values to accommodate this one

      if (panel.layout.y_index !== null && !isNaN(panel.layout.y_index) && this.panel_ids_by_y_index.length > 0) {
        // Negative y_index values should count backwards from the end, so convert negatives to appropriate values here
        if (panel.layout.y_index < 0) {
          panel.layout.y_index = Math.max(this.panel_ids_by_y_index.length + panel.layout.y_index, 0);
        }

        this.panel_ids_by_y_index.splice(panel.layout.y_index, 0, panel.id);
        this.applyPanelYIndexesToPanelLayouts();
      } else {
        var length = this.panel_ids_by_y_index.push(panel.id);
        this.panels[panel.id].layout.y_index = length - 1;
      } // Determine if this panel was already in the layout.panels array.
      // If it wasn't, add it. Either way store the layout.panels array index on the panel.


      var layout_idx = null;
      this.layout.panels.forEach(function (panel_layout, idx) {
        if (panel_layout.id === panel.id) {
          layout_idx = idx;
        }
      });

      if (layout_idx === null) {
        layout_idx = this.layout.panels.push(this.panels[panel.id].layout) - 1;
      }

      this.panels[panel.id].layout_idx = layout_idx; // Call positionPanels() to keep panels from overlapping and ensure filling all available vertical space

      if (this.initialized) {
        this.positionPanels(); // Initialize and load data into the new panel

        this.panels[panel.id].initialize();
        this.panels[panel.id].reMap(); // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip
        // positioning. TODO: make this additional call unnecessary.

        this.setDimensions(this.layout.width, this.layout.height);
      }

      return this.panels[panel.id];
    }
    /**
     * Clear all state, tooltips, and other persisted data associated with one (or all) panel(s) in the plot
     *
     * This is useful when reloading an existing plot with new data, eg "click for genome region" links.
     *   This is a utility method for custom usage. It is not fired automatically during normal rerender of existing panels
     *   @public
     *   @param {String} [panelId] If provided, clear state for only this panel. Otherwise, clear state for all panels.
     *   @param {('wipe'|'reset')} [mode='wipe'] Optionally specify how state should be cleared. `wipe` deletes all data
     *     and is useful for when the panel is being removed; `reset` is best when the panel will be reused in place.
     * @returns {Plot}
     */

  }, {
    key: "clearPanelData",
    value: function clearPanelData(panelId, mode) {
      var _this2 = this;

      mode = mode || 'wipe'; // TODO: Add unit tests for this method

      var panelsList;

      if (panelId) {
        panelsList = [panelId];
      } else {
        panelsList = Object.keys(this.panels);
      }

      panelsList.forEach(function (pid) {
        _this2.panels[pid].data_layer_ids_by_z_index.forEach(function (dlid) {
          var layer = _this2.panels[pid].data_layers[dlid];
          layer.destroyAllTooltips();
          delete layer.layer_state;
          delete _this2.layout.state[layer.state_id];

          if (mode === 'reset') {
            layer._setDefaultState();
          }
        });
      });
      return this;
    }
    /**
     * Remove the panel from the plot, and clear any state, tooltips, or other visual elements belonging to nested content
     * @public
     * @param {String} id
     * @returns {Plot}
     */

  }, {
    key: "removePanel",
    value: function removePanel(id) {
      var _this3 = this;

      if (!this.panels[id]) {
        throw new Error("Unable to remove panel, ID not found: ".concat(id));
      } // Hide all panel boundaries


      this.panel_boundaries.hide(); // Destroy all tooltips and state vars for all data layers on the panel

      this.clearPanelData(id); // Remove all panel-level HTML overlay elements

      this.panels[id].loader.hide();
      this.panels[id].toolbar.destroy(true);
      this.panels[id].curtain.hide(); // Remove the svg container for the panel if it exists

      if (this.panels[id].svg.container) {
        this.panels[id].svg.container.remove();
      } // Delete the panel and its presence in the plot layout and state


      this.layout.panels.splice(this.panels[id].layout_idx, 1);
      delete this.panels[id];
      delete this.layout.state[id]; // Update layout_idx values for all remaining panels

      this.layout.panels.forEach(function (panel_layout, idx) {
        _this3.panels[panel_layout.id].layout_idx = idx;
      }); // Remove the panel id from the y_index array

      this.panel_ids_by_y_index.splice(this.panel_ids_by_y_index.indexOf(id), 1);
      this.applyPanelYIndexesToPanelLayouts(); // Call positionPanels() to keep panels from overlapping and ensure filling all available vertical space

      if (this.initialized) {
        // Allow the plot to shrink when panels are removed, by forcing it to recalculate min dimensions from scratch
        this.layout.min_height = this._base_layout.min_height;
        this.layout.min_width = this._base_layout.min_width;
        this.positionPanels(); // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip
        // positioning. TODO: make this additional call unnecessary.

        this.setDimensions(this.layout.width, this.layout.height);
      }

      this.emit('panel_removed', id);
      return this;
    }
    /**
     * Refresh (or fetch) a plot's data from sources, regardless of whether position or state has changed
     * @public
     * @returns {Promise}
     */

  }, {
    key: "refresh",
    value: function refresh() {
      return this.applyState();
    }
    /**
     * A user-defined callback function that can receive (and potentially act on) new plot data.
     * @callback externalDataCallback
     * @param {Object} new_data The body resulting from a data request. This represents the same information that would be passed to
     *  a data layer making an equivalent request.
     */

    /**
     * A user-defined callback function that can respond to errors received during a previous operation
     * @callback externalErrorCallback
     * @param err A representation of the error that occurred
     */

    /**
     * Allow newly fetched data to be made available outside the LocusZoom plot. For example, a callback could be
     *  registered to draw an HTML table of top GWAS hits, and update that table whenever the plot region changes.
     *
     * This is a convenience method for external hooks. It registers an event listener and returns parsed data,
     *  using the same fields syntax and underlying methods as data layers.
     *
     * @public
     * @param {String[]} fields An array of field names and transforms, in the same syntax used by a data layer.
     *  Different data sources should be prefixed by the source name.
     * @param {externalDataCallback} success_callback Used defined function that is automatically called any time that
     *  new data is received by the plot. Receives two arguments: (data, plot).
     * @param {Object} [opts] Options
     * @param {externalErrorCallback} [opts.onerror] User defined function that is automatically called if a problem
     *  occurs during the data request or subsequent callback operations
     * @param {boolean} [opts.discrete=false] Normally the callback will subscribe to the combined body from the chain,
     *  which may not be in a format that matches what the external callback wants to do. If discrete=true, returns the
     *  uncombined record info
     *  @return {function} The newly created event listener, to allow for later cleanup/removal
     */

  }, {
    key: "subscribeToData",
    value: function subscribeToData(fields, success_callback, opts) {
      var _this4 = this;

      opts = opts || {}; // Register an event listener that is notified whenever new data has been rendered

      var error_callback = opts.onerror || function (err) {
        console.log('An error occurred while acting on an external callback', err);
      };

      var listener = function listener() {
        try {
          _this4.lzd.getData(_this4.state, fields).then(function (new_data) {
            return success_callback(opts.discrete ? new_data.discrete : new_data.body, _this4);
          })["catch"](error_callback);
        } catch (error) {
          // In certain cases, errors are thrown before a promise can be generated, and LZ error display seems to rely on these errors bubbling up
          error_callback(error);
        }
      };

      this.on('data_rendered', listener);
      return listener;
    }
    /**
     * Update state values and trigger a pull for fresh data on all data sources for all data layers
     * @public
     * @param state_changes
     * @returns {Promise} A promise that resolves when all data fetch and update operations are complete
     */

  }, {
    key: "applyState",
    value: function applyState(state_changes) {
      var _this5 = this;

      state_changes = state_changes || {};

      if (_typeof(state_changes) != 'object') {
        throw new Error("applyState only accepts an object; ".concat(_typeof(state_changes), " given"));
      } // Track what parameters will be modified. For bounds checking, we must take some preset values into account.


      var mods = {
        chr: this.state.chr,
        start: this.state.start,
        end: this.state.end
      };

      for (var property in state_changes) {
        mods[property] = state_changes[property];
      }

      mods = _updateStatePosition(mods, this.layout); // Apply new state to the actual state

      for (var _property in mods) {
        this.state[_property] = mods[_property];
      } // Generate requests for all panels given new state


      this.emit('data_requested');
      this.remap_promises = [];
      this.loading_data = true;

      for (var id in this.panels) {
        this.remap_promises.push(this.panels[id].reMap());
      }

      return Promise.all(this.remap_promises)["catch"](function (error) {
        console.error(error);

        _this5.curtain.show(error.message || error);

        _this5.loading_data = false;
      }).then(function () {
        // Update toolbar / widgets
        _this5.toolbar.update(); // Apply panel-level state values


        _this5.panel_ids_by_y_index.forEach(function (panel_id) {
          var panel = _this5.panels[panel_id];
          panel.toolbar.update(); // Apply data-layer-level state values

          panel.data_layer_ids_by_z_index.forEach(function (data_layer_id) {
            panel.data_layers[data_layer_id].applyAllElementStatus();
          });
        }); // Emit events


        _this5.emit('layout_changed');

        _this5.emit('data_rendered');

        _this5.emit('state_changed', state_changes); // An interesting quirk of region changing in LZ: the final region is not always the same as the requested region
        //   (example: zoom out beyond max, or request non-integer position)
        // Echo the actual plot region as the final source of truth


        var _this5$state = _this5.state,
            chr = _this5$state.chr,
            start = _this5$state.start,
            end = _this5$state.end;
        var position_changed = Object.keys(state_changes).some(function (key) {
          return ['chr', 'start', 'end'].includes(key);
        });

        if (position_changed) {
          _this5.emit('region_changed', {
            chr: chr,
            start: start,
            end: end
          });
        }

        _this5.loading_data = false;
      });
    }
    /**
     * Keep a record of event listeners that are defined outside of the LocusZoom boundary (and therefore would not
     *  get cleaned up when the plot was removed from the DOM). For example, window resize or mouse events.
     * This allows safe cleanup of the plot on removal from the page
     * @param {Node} target The node on which the listener has been defined
     * @param {String} event_name
     * @param {function} listener The handle for the event listener to be cleaned up
     */

  }, {
    key: "trackExternalListener",
    value: function trackExternalListener(target, event_name, listener) {
      if (!this._external_listeners.has(target)) {
        this._external_listeners.set(target, new Map());
      }

      var container = this._external_listeners.get(target);

      var tracker = container.get(event_name) || [];

      if (!tracker.includes(listener)) {
        tracker.push(listener);
      }

      container.set(event_name, tracker);
    }
    /**
     * Remove the plot from the page, and clean up any globally registered event listeners
     *
     * Internally, the plot retains references to some nodes via selectors; it may be useful to delete the plot
     *  instance after calling this method
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _iterator = _createForOfIteratorHelper(this._external_listeners.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              target = _step$value[0],
              registered_events = _step$value[1];

          var _iterator2 = _createForOfIteratorHelper(registered_events),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value = _slicedToArray(_step2.value, 2),
                  event_name = _step2$value[0],
                  listeners = _step2$value[1];

              var _iterator3 = _createForOfIteratorHelper(listeners),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var listener = _step3.value;
                  target.removeEventListener(event_name, listener);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } // Clear the SVG, plus other HTML nodes (like toolbar) that live under the same parent

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var parent = this.svg.node().parentNode;

      if (!parent) {
        throw new Error('Plot has already been removed');
      }

      while (parent.lastElementChild) {
        parent.removeChild(parent.lastElementChild);
      } // Clear toolbar event listeners defined on the parent lz-container. As of 2020 this appears to be the
      //  state of the art cross-browser DOM API for this task.
      // eslint-disable-next-line no-self-assign


      parent.outerHTML = parent.outerHTML;
      this.initialized = false;
      this.svg = null;
      this.panels = null;
    }
    /******* The private interface: methods only used by LocusZoom internals */

    /**
     * Track whether the target panel can respond to mouse interaction events
     * @private
     * @param {String} panel_id
     * @returns {boolean}
     */

  }, {
    key: "_canInteract",
    value: function _canInteract(panel_id) {
      panel_id = panel_id || null;

      if (panel_id) {
        return (typeof this.interaction.panel_id == 'undefined' || this.interaction.panel_id === panel_id) && !this.loading_data;
      } else {
        return !(this.interaction.dragging || this.interaction.zooming || this.loading_data);
      }
    }
    /**
     * Get an object with the x and y coordinates of the plot's origin in terms of the entire page
     *  This returns a result with absolute position relative to the page, regardless of current scrolling
     * Necessary for positioning any HTML elements over the plot
     * @private
     * @returns {{x: Number, y: Number, width: Number, height: Number}}
     */

  }, {
    key: "_getPageOrigin",
    value: function _getPageOrigin() {
      var bounding_client_rect = this.svg.node().getBoundingClientRect();
      var x_offset = document.documentElement.scrollLeft || document.body.scrollLeft;
      var y_offset = document.documentElement.scrollTop || document.body.scrollTop;
      var container = this.svg.node();

      while (container.parentNode !== null) {
        // TODO: Recursively seeks offsets for highest non-static parent node. This can lead to incorrect
        //   calculations of, for example, x coordinate relative to the page. Revisit this logic.
        container = container.parentNode;

        if (container !== document && d3__WEBPACK_IMPORTED_MODULE_0__["select"](container).style('position') !== 'static') {
          x_offset = -1 * container.getBoundingClientRect().left;
          y_offset = -1 * container.getBoundingClientRect().top;
          break;
        }
      }

      return {
        x: x_offset + bounding_client_rect.left,
        y: y_offset + bounding_client_rect.top,
        width: bounding_client_rect.width,
        height: bounding_client_rect.height
      };
    }
    /**
     * Get the top and left offset values for the plot's container element (the div that was populated)
     * @private
     * @returns {{top: number, left: number}}
     */

  }, {
    key: "getContainerOffset",
    value: function getContainerOffset() {
      var offset = {
        top: 0,
        left: 0
      };
      var container = this.container.offsetParent || null;

      while (container !== null) {
        offset.top += container.offsetTop;
        offset.left += container.offsetLeft;
        container = container.offsetParent || null;
      }

      return offset;
    }
    /**
     * Notify each child panel of the plot of changes in panel ordering/ arrangement
     * @private
     */

  }, {
    key: "applyPanelYIndexesToPanelLayouts",
    value: function applyPanelYIndexesToPanelLayouts() {
      var _this6 = this;

      this.panel_ids_by_y_index.forEach(function (pid, idx) {
        _this6.panels[pid].layout.y_index = idx;
      });
    }
    /**
     * Get the qualified ID pathname for the plot
     * @private
     * @returns {String}
     */

  }, {
    key: "getBaseId",
    value: function getBaseId() {
      return this.id;
    }
    /**
     * Helper method to sum the proportional dimensions of panels, a value that's checked often as panels are added/removed
     * @private
     * @param {('Height'|'Width')} dimension
     * @returns {number}
     */

  }, {
    key: "sumProportional",
    value: function sumProportional(dimension) {
      if (dimension !== 'height' && dimension !== 'width') {
        throw new Error('Bad dimension value passed to sumProportional');
      }

      var total = 0;

      for (var id in this.panels) {
        // Ensure every panel contributing to the sum has a non-zero proportional dimension
        if (!this.panels[id].layout["proportional_".concat(dimension)]) {
          this.panels[id].layout["proportional_".concat(dimension)] = 1 / Object.keys(this.panels).length;
        }

        total += this.panels[id].layout["proportional_".concat(dimension)];
      }

      return total;
    }
    /**
     * Resize the plot to fit the bounding container
     * @private
     * @returns {Plot}
     */

  }, {
    key: "rescaleSVG",
    value: function rescaleSVG() {
      var clientRect = this.svg.node().getBoundingClientRect();
      this.setDimensions(clientRect.width, clientRect.height);
      return this;
    }
    /**
     * Prepare the plot for first use by performing parameter validation, setting up panels, and calculating dimensions
     * @private
     * @returns {Plot}
     */

  }, {
    key: "initializeLayout",
    value: function initializeLayout() {
      var _this7 = this;

      // Sanity check layout values
      if (isNaN(this.layout.width) || this.layout.width <= 0) {
        throw new Error('Plot layout parameter `width` must be a positive number');
      }

      if (isNaN(this.layout.height) || this.layout.height <= 0) {
        throw new Error('Plot layout parameter `width` must be a positive number');
      } // Backwards compatible check: there was previously a third option. Anything truthy should thus act as "responsive_resize: true"


      this.layout.responsive_resize = !!this.layout.responsive_resize; // If this is a responsive layout then set a namespaced/unique onresize event listener on the window

      if (this.layout.responsive_resize) {
        var resize_listener = function resize_listener() {
          return _this7.rescaleSVG();
        };

        window.addEventListener('resize', resize_listener);
        this.trackExternalListener(window, 'resize', resize_listener); // Forcing one additional setDimensions() call after the page is loaded clears up
        // any disagreements between the initial layout and the loaded responsive container's size

        var load_listener = function load_listener() {
          return _this7.setDimensions();
        };

        window.addEventListener('load', load_listener);
        this.trackExternalListener(window, 'load', load_listener);
      } // Add panels


      this.layout.panels.forEach(function (panel_layout) {
        _this7.addPanel(panel_layout);
      });
      return this;
    }
    /**
     * Set the dimensions for a plot, and ensure that panels are sized and positioned correctly.
     *
     * If dimensions are provided, resizes each panel proportionally to match the new plot dimensions. Otherwise,
     *   calculates the appropriate plot dimensions based on all panels.
     * @private
     * @param {Number} [width] If provided and larger than minimum size, set plot to this width
     * @param {Number} [height] If provided and larger than minimum size, set plot to this height
     * @returns {Plot}
     */

  }, {
    key: "setDimensions",
    value: function setDimensions(width, height) {
      var _this8 = this;

      var id; // Update minimum allowable width and height by aggregating minimums from panels, then apply minimums to containing element.

      var min_width = parseFloat(this.layout.min_width) || 0;
      var min_height = parseFloat(this.layout.min_height) || 0;

      for (id in this.panels) {
        min_width = Math.max(min_width, this.panels[id].layout.min_width);

        if (parseFloat(this.panels[id].layout.min_height) > 0 && parseFloat(this.panels[id].layout.proportional_height) > 0) {
          min_height = Math.max(min_height, this.panels[id].layout.min_height / this.panels[id].layout.proportional_height);
        }
      }

      this.layout.min_width = Math.max(min_width, 1);
      this.layout.min_height = Math.max(min_height, 1);
      d3__WEBPACK_IMPORTED_MODULE_0__["select"](this.svg.node().parentNode).style('min-width', "".concat(this.layout.min_width, "px")).style('min-height', "".concat(this.layout.min_height, "px")); // If width and height arguments were passed then adjust them against plot minimums if necessary.
      // Then resize the plot and proportionally resize panels to fit inside the new plot dimensions.

      if (!isNaN(width) && width >= 0 && !isNaN(height) && height >= 0) {
        this.layout.width = Math.max(Math.round(+width), this.layout.min_width);
        this.layout.height = Math.max(Math.round(+height), this.layout.min_height); // Override discrete values if resizing responsively

        if (this.layout.responsive_resize) {
          // All resize modes will affect width
          if (this.svg) {
            this.layout.width = Math.max(this.svg.node().parentNode.getBoundingClientRect().width, this.layout.min_width);
          }
        } // Resize/reposition panels to fit, update proportional origins if necessary


        var y_offset = 0;
        this.panel_ids_by_y_index.forEach(function (panel_id) {
          var panel_width = _this8.layout.width;
          var panel_height = _this8.panels[panel_id].layout.proportional_height * _this8.layout.height;

          _this8.panels[panel_id].setDimensions(panel_width, panel_height);

          _this8.panels[panel_id].setOrigin(0, y_offset);

          _this8.panels[panel_id].layout.proportional_origin.x = 0;
          _this8.panels[panel_id].layout.proportional_origin.y = y_offset / _this8.layout.height;
          y_offset += panel_height;

          _this8.panels[panel_id].toolbar.update();
        });
      } else if (Object.keys(this.panels).length) {
        // If width and height arguments were NOT passed (and panels exist) then determine the plot dimensions
        // by making it conform to panel dimensions, assuming panels are already positioned correctly.
        this.layout.width = 0;
        this.layout.height = 0;

        for (id in this.panels) {
          this.layout.width = Math.max(this.panels[id].layout.width, this.layout.width);
          this.layout.height += this.panels[id].layout.height;
        }

        this.layout.width = Math.max(this.layout.width, this.layout.min_width);
        this.layout.height = Math.max(this.layout.height, this.layout.min_height);
      } // Apply layout width and height as discrete values or viewbox values


      if (this.svg !== null) {
        // The viewBox must always be specified in order for "save as image" button to work
        this.svg.attr('viewBox', "0 0 ".concat(this.layout.width, " ").concat(this.layout.height));
        this.svg.attr('width', this.layout.width).attr('height', this.layout.height);
      } // If the plot has been initialized then trigger some necessary render functions


      if (this.initialized) {
        this.panel_boundaries.position();
        this.toolbar.update();
        this.curtain.update();
        this.loader.update();
      }

      return this.emit('layout_changed');
    }
    /**
     * Automatically position panels based on panel positioning rules and values.
     * Keep panels from overlapping vertically by adjusting origins, and keep the sum of proportional heights at 1.
     *
     * LocusZoom panels can only be stacked vertically (not horizontally)
     * @private
     */

  }, {
    key: "positionPanels",
    value: function positionPanels() {
      var _this9 = this;

      var id; // We want to enforce that all x-linked panels have consistent horizontal margins
      // (to ensure that aligned items stay aligned despite inconsistent initial layout parameters)
      // NOTE: This assumes panels have consistent widths already. That should probably be enforced too!

      var x_linked_margins = {
        left: 0,
        right: 0
      }; // Proportional heights for newly added panels default to null unless explicitly set, so determine appropriate
      // proportional heights for all panels with a null value from discretely set dimensions.
      // Likewise handle default nulls for proportional widths, but instead just force a value of 1 (full width)

      for (id in this.panels) {
        if (this.panels[id].layout.proportional_height === null) {
          this.panels[id].layout.proportional_height = this.panels[id].layout.height / this.layout.height;
        }

        if (this.panels[id].layout.proportional_width === null) {
          this.panels[id].layout.proportional_width = 1;
        }

        if (this.panels[id].layout.interaction.x_linked) {
          x_linked_margins.left = Math.max(x_linked_margins.left, this.panels[id].layout.margin.left);
          x_linked_margins.right = Math.max(x_linked_margins.right, this.panels[id].layout.margin.right);
        }
      } // Sum the proportional heights and then adjust all proportionally so that the sum is exactly 1


      var total_proportional_height = this.sumProportional('height');

      if (!total_proportional_height) {
        return this;
      }

      var proportional_adjustment = 1 / total_proportional_height;

      for (id in this.panels) {
        this.panels[id].layout.proportional_height *= proportional_adjustment;
      } // Update origins on all panels without changing plot-level dimensions yet
      // Also apply x-linked margins to x-linked panels, updating widths as needed


      var y_offset = 0;
      this.panel_ids_by_y_index.forEach(function (panel_id) {
        _this9.panels[panel_id].setOrigin(0, y_offset);

        _this9.panels[panel_id].layout.proportional_origin.x = 0;
        y_offset += _this9.panels[panel_id].layout.height;

        if (_this9.panels[panel_id].layout.interaction.x_linked) {
          var delta = Math.max(x_linked_margins.left - _this9.panels[panel_id].layout.margin.left, 0) + Math.max(x_linked_margins.right - _this9.panels[panel_id].layout.margin.right, 0);
          _this9.panels[panel_id].layout.width += delta;
          _this9.panels[panel_id].layout.margin.left = x_linked_margins.left;
          _this9.panels[panel_id].layout.margin.right = x_linked_margins.right;
          _this9.panels[panel_id].layout.cliparea.origin.x = x_linked_margins.left;
        }
      });
      var calculated_plot_height = y_offset;
      this.panel_ids_by_y_index.forEach(function (panel_id) {
        _this9.panels[panel_id].layout.proportional_origin.y = _this9.panels[panel_id].layout.origin.y / calculated_plot_height;
      }); // Update dimensions on the plot to accommodate repositioned panels

      this.setDimensions(); // Set dimensions on all panels using newly set plot-level dimensions and panel-level proportional dimensions

      this.panel_ids_by_y_index.forEach(function (panel_id) {
        _this9.panels[panel_id].setDimensions(_this9.layout.width * _this9.panels[panel_id].layout.proportional_width, _this9.layout.height * _this9.panels[panel_id].layout.proportional_height);
      });
      return this;
    }
    /**
     * Prepare the first rendering of the plot. This includes initializing the individual panels, but also creates shared
     *   elements such as mouse events, panel guides/boundaries, and loader/curtain.
     * @private
     * @returns {Plot}
     */

  }, {
    key: "initialize",
    value: function initialize() {
      var _this12 = this;

      // Ensure proper responsive class is present on the containing node if called for
      if (this.layout.responsive_resize) {
        d3__WEBPACK_IMPORTED_MODULE_0__["select"](this.container).classed('lz-container-responsive', true);
      } // Create an element/layer for containing mouse guides


      if (this.layout.mouse_guide) {
        var mouse_guide_svg = this.svg.append('g').attr('class', 'lz-mouse_guide').attr('id', "".concat(this.id, ".mouse_guide"));
        var mouse_guide_vertical_svg = mouse_guide_svg.append('rect').attr('class', 'lz-mouse_guide-vertical').attr('x', -1);
        var mouse_guide_horizontal_svg = mouse_guide_svg.append('rect').attr('class', 'lz-mouse_guide-horizontal').attr('y', -1);
        this.mouse_guide = {
          svg: mouse_guide_svg,
          vertical: mouse_guide_vertical_svg,
          horizontal: mouse_guide_horizontal_svg
        };
      } // Add curtain and loader prototpyes to the plot


      this.curtain = _helpers_common__WEBPACK_IMPORTED_MODULE_5__["generateCurtain"].call(this);
      this.loader = _helpers_common__WEBPACK_IMPORTED_MODULE_5__["generateLoader"].call(this); // Create the panel_boundaries object with show/position/hide methods

      this.panel_boundaries = {
        parent: this,
        hide_timeout: null,
        showing: false,
        dragging: false,
        selectors: [],
        corner_selector: null,
        show: function show() {
          var _this10 = this;

          // Generate panel boundaries
          if (!this.showing && !this.parent.curtain.showing) {
            this.showing = true; // Loop through all panels to create a horizontal boundary for each

            this.parent.panel_ids_by_y_index.forEach(function (panel_id, panel_idx) {
              var selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"](_this10.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip').attr('class', 'lz-panel-boundary').attr('title', 'Resize panel');
              selector.append('span');
              var panel_resize_drag = d3__WEBPACK_IMPORTED_MODULE_0__["drag"]();
              panel_resize_drag.on('start', function () {
                _this10.dragging = true;
              });
              panel_resize_drag.on('end', function () {
                _this10.dragging = false;
              });
              panel_resize_drag.on('drag', function () {
                // First set the dimensions on the panel we're resizing
                var this_panel = _this10.parent.panels[_this10.parent.panel_ids_by_y_index[panel_idx]];
                var original_panel_height = this_panel.layout.height;
                this_panel.setDimensions(this_panel.layout.width, this_panel.layout.height + d3__WEBPACK_IMPORTED_MODULE_0__["event"].dy);
                var panel_height_change = this_panel.layout.height - original_panel_height;
                var new_calculated_plot_height = _this10.parent.layout.height + panel_height_change; // Next loop through all panels.
                // Update proportional dimensions for all panels including the one we've resized using discrete heights.
                // Reposition panels with a greater y-index than this panel to their appropriate new origin.

                _this10.parent.panel_ids_by_y_index.forEach(function (loop_panel_id, loop_panel_idx) {
                  var loop_panel = _this10.parent.panels[_this10.parent.panel_ids_by_y_index[loop_panel_idx]];
                  loop_panel.layout.proportional_height = loop_panel.layout.height / new_calculated_plot_height;

                  if (loop_panel_idx > panel_idx) {
                    loop_panel.setOrigin(loop_panel.layout.origin.x, loop_panel.layout.origin.y + panel_height_change);
                    loop_panel.toolbar.position();
                  }
                }); // Reset dimensions on the entire plot and reposition panel boundaries


                _this10.parent.positionPanels();

                _this10.position();
              });
              selector.call(panel_resize_drag);

              _this10.parent.panel_boundaries.selectors.push(selector);
            }); // Create a corner boundary / resize element on the bottom-most panel that resizes the entire plot

            var corner_selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip').attr('class', 'lz-panel-corner-boundary').attr('title', 'Resize plot');
            corner_selector.append('span').attr('class', 'lz-panel-corner-boundary-outer');
            corner_selector.append('span').attr('class', 'lz-panel-corner-boundary-inner');
            var corner_drag = d3__WEBPACK_IMPORTED_MODULE_0__["drag"]();
            corner_drag.on('start', function () {
              _this10.dragging = true;
            });
            corner_drag.on('end', function () {
              _this10.dragging = false;
            });
            corner_drag.on('drag', function () {
              _this10.parent.setDimensions(_this10.parent.layout.width + d3__WEBPACK_IMPORTED_MODULE_0__["event"].dx, _this10.parent.layout.height + d3__WEBPACK_IMPORTED_MODULE_0__["event"].dy);
            });
            corner_selector.call(corner_drag);
            this.parent.panel_boundaries.corner_selector = corner_selector;
          }

          return this.position();
        },
        position: function position() {
          var _this11 = this;

          if (!this.showing) {
            return this;
          } // Position panel boundaries


          var plot_page_origin = this.parent._getPageOrigin();

          this.selectors.forEach(function (selector, panel_idx) {
            var panel_page_origin = _this11.parent.panels[_this11.parent.panel_ids_by_y_index[panel_idx]]._getPageOrigin();

            var left = plot_page_origin.x;
            var top = panel_page_origin.y + _this11.parent.panels[_this11.parent.panel_ids_by_y_index[panel_idx]].layout.height - 12;
            var width = _this11.parent.layout.width - 1;
            selector.style('top', "".concat(top, "px")).style('left', "".concat(left, "px")).style('width', "".concat(width, "px"));
            selector.select('span').style('width', "".concat(width, "px"));
          }); // Position corner selector

          var corner_padding = 10;
          var corner_size = 16;
          this.corner_selector.style('top', "".concat(plot_page_origin.y + this.parent.layout.height - corner_padding - corner_size, "px")).style('left', "".concat(plot_page_origin.x + this.parent.layout.width - corner_padding - corner_size, "px"));
          return this;
        },
        hide: function hide() {
          if (!this.showing) {
            return this;
          }

          this.showing = false; // Panel panel boundaries

          this.selectors.forEach(function (selector) {
            selector.remove();
          });
          this.selectors = []; // Remove corner boundary

          this.corner_selector.remove();
          this.corner_selector = null;
          return this;
        }
      }; // Show panel boundaries stipulated by the layout (basic toggle, only show on mouse over plot)

      if (this.layout.panel_boundaries) {
        d3__WEBPACK_IMPORTED_MODULE_0__["select"](this.svg.node().parentNode).on("mouseover.".concat(this.id, ".panel_boundaries"), function () {
          clearTimeout(_this12.panel_boundaries.hide_timeout);

          _this12.panel_boundaries.show();
        }).on("mouseout.".concat(this.id, ".panel_boundaries"), function () {
          _this12.panel_boundaries.hide_timeout = setTimeout(function () {
            _this12.panel_boundaries.hide();
          }, 300);
        });
      } // Create the toolbar object and immediately show it


      this.toolbar = new _toolbar__WEBPACK_IMPORTED_MODULE_3__["default"](this).show(); // Initialize all panels

      for (var id in this.panels) {
        this.panels[id].initialize();
      } // Define plot-level mouse events


      var namespace = ".".concat(this.id);

      if (this.layout.mouse_guide) {
        var mouseout_mouse_guide = function mouseout_mouse_guide() {
          _this12.mouse_guide.vertical.attr('x', -1);

          _this12.mouse_guide.horizontal.attr('y', -1);
        };

        var mousemove_mouse_guide = function mousemove_mouse_guide() {
          var coords = d3__WEBPACK_IMPORTED_MODULE_0__["mouse"](_this12.svg.node());

          _this12.mouse_guide.vertical.attr('x', coords[0]);

          _this12.mouse_guide.horizontal.attr('y', coords[1]);
        };

        this.svg.on("mouseout".concat(namespace, "-mouse_guide"), mouseout_mouse_guide).on("touchleave".concat(namespace, "-mouse_guide"), mouseout_mouse_guide).on("mousemove".concat(namespace, "-mouse_guide"), mousemove_mouse_guide);
      }

      var mouseup = function mouseup() {
        _this12.stopDrag();
      };

      var mousemove = function mousemove() {
        if (_this12.interaction.dragging) {
          var coords = d3__WEBPACK_IMPORTED_MODULE_0__["mouse"](_this12.svg.node());

          if (d3__WEBPACK_IMPORTED_MODULE_0__["event"]) {
            d3__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
          }

          _this12.interaction.dragging.dragged_x = coords[0] - _this12.interaction.dragging.start_x;
          _this12.interaction.dragging.dragged_y = coords[1] - _this12.interaction.dragging.start_y;

          _this12.panels[_this12.interaction.panel_id].render();

          _this12.interaction.linked_panel_ids.forEach(function (panel_id) {
            _this12.panels[panel_id].render();
          });
        }
      };

      this.svg.on("mouseup".concat(namespace), mouseup).on("touchend".concat(namespace), mouseup).on("mousemove".concat(namespace), mousemove).on("touchmove".concat(namespace), mousemove); // Add an extra namespaced mouseup handler to the containing body, if there is one
      // This helps to stop interaction events gracefully when dragging outside of the plot element

      var body_selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"]('body');
      var body_node = body_selector.node();

      if (body_node) {
        body_node.addEventListener('mouseup', mouseup);
        body_node.addEventListener('touchend', mouseup);
        this.trackExternalListener(body_node, 'mouseup', mouseup);
        this.trackExternalListener(body_node, 'touchend', mouseup);
      }

      this.on('match_requested', function (eventData) {
        // Layers can broadcast that a specific point has been selected, and the plot will tell every other layer
        //  to look for that value. Whenever a point is de-selected, it clears the match.
        var data = eventData.data;
        var to_send = data.active ? data.value : null;

        _this12.applyState({
          lz_match_value: to_send
        });
      });
      this.initialized = true; // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip
      // positioning. TODO: make this additional call unnecessary.

      var client_rect = this.svg.node().getBoundingClientRect();
      var width = client_rect.width ? client_rect.width : this.layout.width;
      var height = client_rect.height ? client_rect.height : this.layout.height;
      this.setDimensions(width, height);
      return this;
    }
    /**
     * Register interactions along the specified axis, provided that the target panel allows interaction.
     * @private
     * @param {Panel} panel
     * @param {('background'|'x_tick'|'y1_tick'|'y2_tick')} method The direction (axis) along which dragging is being performed.
     * @returns {Plot}
     */

  }, {
    key: "startDrag",
    value: function startDrag(panel, method) {
      panel = panel || null;
      method = method || null;
      var axis = null;

      switch (method) {
        case 'background':
        case 'x_tick':
          axis = 'x';
          break;

        case 'y1_tick':
          axis = 'y1';
          break;

        case 'y2_tick':
          axis = 'y2';
          break;
      }

      if (!(panel instanceof _panel__WEBPACK_IMPORTED_MODULE_4__["default"]) || !axis || !this._canInteract()) {
        return this.stopDrag();
      }

      var coords = d3__WEBPACK_IMPORTED_MODULE_0__["mouse"](this.svg.node());
      this.interaction = {
        panel_id: panel.id,
        linked_panel_ids: panel.getLinkedPanelIds(axis),
        dragging: {
          method: method,
          start_x: coords[0],
          start_y: coords[1],
          dragged_x: 0,
          dragged_y: 0,
          axis: axis
        }
      };
      this.svg.style('cursor', 'all-scroll');
      return this;
    }
    /**
     * Process drag interactions across the target panel and synchronize plot state across other panels in sync;
     *   clear the event when complete
     * @private
     * @returns {Plot}
     */

  }, {
    key: "stopDrag",
    value: function stopDrag() {
      if (!this.interaction.dragging) {
        return this;
      }

      if (_typeof(this.panels[this.interaction.panel_id]) != 'object') {
        this.interaction = {};
        return this;
      }

      var panel = this.panels[this.interaction.panel_id]; // Helper function to find the appropriate axis layouts on child data layers
      // Once found, apply the extent as floor/ceiling and remove all other directives
      // This forces all associated axes to conform to the extent generated by a drag action

      var overrideAxisLayout = function overrideAxisLayout(axis, axis_number, extent) {
        panel.data_layer_ids_by_z_index.forEach(function (id) {
          var axis_layout = panel.data_layers[id].layout["".concat(axis, "_axis")];

          if (axis_layout.axis === axis_number) {
            axis_layout.floor = extent[0];
            axis_layout.ceiling = extent[1];
            delete axis_layout.lower_buffer;
            delete axis_layout.upper_buffer;
            delete axis_layout.min_extent;
            delete axis_layout.ticks;
          }
        });
      };

      switch (this.interaction.dragging.method) {
        case 'background':
        case 'x_tick':
          if (this.interaction.dragging.dragged_x !== 0) {
            overrideAxisLayout('x', 1, panel.x_extent);
            this.applyState({
              start: panel.x_extent[0],
              end: panel.x_extent[1]
            });
          }

          break;

        case 'y1_tick':
        case 'y2_tick':
          if (this.interaction.dragging.dragged_y !== 0) {
            var y_axis_number = parseInt(this.interaction.dragging.method[1]);
            overrideAxisLayout('y', y_axis_number, panel["y".concat(y_axis_number, "_extent")]);
          }

          break;
      }

      this.interaction = {};
      this.svg.style('cursor', null);
      return this;
    }
  }]);

  return Plot;
}();

 // Only for testing



/***/ }),

/***/ "./esm/components/toolbar/index.js":
/*!*****************************************!*\
  !*** ./esm/components/toolbar/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Toolbar; });
/* harmony import */ var _registry_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../registry/widgets */ "./esm/registry/widgets.js");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */


/**
 * A Toolbar is an HTML element used for presenting arbitrary user interface widgets. Toolbars are anchored
 *   to either the entire Plot or to individual Panels.
 *
 * Each toolbar is an HTML-based (read: not SVG) collection of widgets used to display information or provide
 *   user interface. Toolbars can exist on entire plots, where their visibility is permanent and vertically adjacent
 *   to the plot, or on individual panels, where their visibility is tied to a behavior (e.g. a mouseover) and is as
 *   an overlay.
 *
 * This class is used internally for rendering, and is not part of the public interface
 * @private
 */

var Toolbar = /*#__PURE__*/function () {
  function Toolbar(parent) {
    _classCallCheck(this, Toolbar);

    // parent must be a locuszoom plot or panel
    // if (!(parent instanceof LocusZoom.Plot) && !(parent instanceof LocusZoom.Panel)) {
    //     throw new Error('Unable to create toolbar, parent must be a locuszoom plot or panel');
    // }

    /** @member {Plot|Panel} */
    this.parent = parent;
    /** @member {String} */

    this.id = "".concat(this.parent.getBaseId(), ".toolbar");
    /** @member {('plot'|'panel')} */

    this.type = this.parent.parent ? 'panel' : 'plot';
    /** @member {Plot} */

    this.parent_plot = this.parent.parent_plot;
    /** @member {d3.selection} */

    this.selector = null;
    /** @member {BaseWidget[]} */

    this.widgets = [];
    /**
     * The timer identifier as returned by setTimeout
     * @member {Number}
     */

    this.hide_timeout = null;
    /**
     * Whether to hide the toolbar. Can be overridden by a child widget. Check via `shouldPersist`
     * @protected
     * @member {Boolean}
     */

    this.persist = false;
    this.initialize();
  }
  /**
   * Prepare the toolbar for first use: generate all widget instances for this toolbar, based on the provided
   *   layout of the parent. Connects event listeners and shows/hides as appropriate.
   * @returns {Toolbar}
   */


  _createClass(Toolbar, [{
    key: "initialize",
    value: function initialize() {
      var _this = this;

      // Parse layout to generate widget instances
      // In LZ 0.12, `dashboard.components` was renamed to `toolbar.widgets`. Preserve a backwards-compatible alias.
      var options = this.parent.layout.dashboard && this.parent.layout.dashboard.components || this.parent.layout.toolbar.widgets;

      if (Array.isArray(options)) {
        options.forEach(function (layout) {
          try {
            var widget = _registry_widgets__WEBPACK_IMPORTED_MODULE_0__["default"].create(layout.type, layout, _this);

            _this.widgets.push(widget);
          } catch (e) {
            console.warn('Failed to create widget');
            console.error(e);
          }
        });
      } // Add mouseover event handlers to show/hide panel toolbar


      if (this.type === 'panel') {
        d3__WEBPACK_IMPORTED_MODULE_1__["select"](this.parent.parent.svg.node().parentNode).on("mouseover.".concat(this.id), function () {
          clearTimeout(_this.hide_timeout);

          if (!_this.selector || _this.selector.style('visibility') === 'hidden') {
            _this.show();
          }
        }).on("mouseout.".concat(this.id), function () {
          clearTimeout(_this.hide_timeout);
          _this.hide_timeout = setTimeout(function () {
            _this.hide();
          }, 300);
        });
      }

      return this;
    }
    /**
     * Whether to persist the toolbar. Returns true if at least one widget should persist, or if the panel is engaged
     *   in an active drag event.
     * @returns {boolean}
     */

  }, {
    key: "shouldPersist",
    value: function shouldPersist() {
      if (this.persist) {
        return true;
      }

      var persist = false; // Persist if at least one widget should also persist

      this.widgets.forEach(function (widget) {
        persist = persist || widget.shouldPersist();
      }); // Persist if in a parent drag event

      persist = persist || this.parent_plot.panel_boundaries.dragging || this.parent_plot.interaction.dragging;
      return !!persist;
    }
    /**
     * Make the toolbar appear. If it doesn't exist yet create it, including creating/positioning all widgets within,
     *   and make sure it is set to be visible.
     */

  }, {
    key: "show",
    value: function show() {
      if (!this.selector) {
        switch (this.type) {
          case 'plot':
            this.selector = d3__WEBPACK_IMPORTED_MODULE_1__["select"](this.parent.svg.node().parentNode).insert('div', ':first-child');
            break;

          case 'panel':
            this.selector = d3__WEBPACK_IMPORTED_MODULE_1__["select"](this.parent.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip, .lz-toolbar-menu, .lz-curtain').classed('lz-panel-toolbar', true);
            break;

          default:
            throw new Error("Toolbar cannot be a child of ".concat(this.type));
        }

        this.selector.classed('lz-toolbar', true).classed("lz-".concat(this.type, "-toolbar"), true).attr('id', this.id);
      }

      this.widgets.forEach(function (widget) {
        return widget.show();
      });
      this.selector.style('visibility', 'visible');
      return this.update();
    }
    /**
     * Update the toolbar and rerender all child widgets. This can be called whenever plot state changes.
     * @returns {Toolbar}
     */

  }, {
    key: "update",
    value: function update() {
      if (!this.selector) {
        return this;
      }

      this.widgets.forEach(function (widget) {
        return widget.update();
      });
      return this.position();
    }
    /**
     * Position the toolbar (and child widgets) within the panel
     * @returns {Toolbar}
     */

  }, {
    key: "position",
    value: function position() {
      if (!this.selector) {
        return this;
      } // Position the toolbar itself (panel only)


      if (this.type === 'panel') {
        var page_origin = this.parent._getPageOrigin();

        var top = "".concat((page_origin.y + 3.5).toString(), "px");
        var left = "".concat(page_origin.x.toString(), "px");
        var width = "".concat((this.parent.layout.width - 4).toString(), "px");
        this.selector.style('position', 'absolute').style('top', top).style('left', left).style('width', width);
      } // Recursively position widgets


      this.widgets.forEach(function (widget) {
        return widget.position();
      });
      return this;
    }
    /**
     * Hide the toolbar (make invisible but do not destroy). Will do nothing if `shouldPersist` returns true.
     *
     * @returns {Toolbar}
     */

  }, {
    key: "hide",
    value: function hide() {
      if (!this.selector || this.shouldPersist()) {
        return this;
      }

      this.widgets.forEach(function (widget) {
        return widget.hide();
      });
      this.selector.style('visibility', 'hidden');
      return this;
    }
    /**
     * Completely remove toolbar and all child widgets. (may be overridden by persistence settings)
     * @param {Boolean} [force=false] If true, will ignore persistence settings and always destroy the toolbar
     * @returns {Toolbar}
     */

  }, {
    key: "destroy",
    value: function destroy(force) {
      if (typeof force == 'undefined') {
        force = false;
      }

      if (!this.selector) {
        return this;
      }

      if (this.shouldPersist() && !force) {
        return this;
      }

      this.widgets.forEach(function (widget) {
        return widget.destroy(true);
      });
      this.widgets = [];
      this.selector.remove();
      this.selector = null;
      return this;
    }
  }]);

  return Toolbar;
}();



/***/ }),

/***/ "./esm/components/toolbar/widgets.js":
/*!*******************************************!*\
  !*** ./esm/components/toolbar/widgets.js ***!
  \*******************************************/
/*! exports provided: BaseWidget, _Button, dimensions, display_options, download, download_png, filter_field, menu, move_panel_down, move_panel_up, region_scale, resize_to_data, set_state, shift_region, remove_panel, title, toggle_legend, zoom_region */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseWidget", function() { return BaseWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dimensions", function() { return Dimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "display_options", function() { return DisplayOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "download", function() { return DownloadSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "download_png", function() { return DownloadPNG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter_field", function() { return FilterField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "menu", function() { return Menu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "move_panel_down", function() { return MovePanelDown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "move_panel_up", function() { return MovePanelUp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "region_scale", function() { return RegionScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resize_to_data", function() { return ResizeToData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_state", function() { return SetState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shift_region", function() { return ShiftRegion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove_panel", function() { return RemovePanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "title", function() { return Title; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggle_legend", function() { return ToggleLegend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoom_region", function() { return ZoomRegion; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers/display */ "./esm/helpers/display.js");
/* harmony import */ var _helpers_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/common */ "./esm/helpers/common.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers/layouts */ "./esm/helpers/layouts.js");
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */



 // FIXME: Button creation should occur in the constructors, not in update functions

/**
 *
 * A widget is an empty div rendered on a toolbar that can display custom
 * html of user interface elements.
 * @param {Object} layout A JSON-serializable object of layout configuration parameters
 * @param {('left'|'right')} [layout.position='left']  Whether to float the widget left or right.
 * @param {('start'|'middle'|'end')} [layout.group_position] Buttons can optionally be gathered into a visually
 *  distinctive group whose elements are closer together. If a button is identified as the start or end of a group,
 *  it will be drawn with rounded corners and an extra margin of spacing from any button not part of the group.
 *  For example, the region_nav_plot toolbar is a defined as a group.
 * @param {('gray'|'red'|'orange'|'yellow'|'green'|'blue'|'purple')} [layout.color='gray']  Color scheme for the
 *   widget. Applies to buttons and menus.
 * @param {Toolbar} parent The toolbar that contains this widget
 */

var BaseWidget = /*#__PURE__*/function () {
  function BaseWidget(layout, parent) {
    _classCallCheck(this, BaseWidget);

    /** @member {Object} */
    this.layout = layout || {};

    if (!this.layout.color) {
      this.layout.color = 'gray';
    }
    /** @member {Toolbar|*} */


    this.parent = parent || null;
    /**
     * Some widgets are attached to a panel, rather than directly to a plot
     * @member {Panel|null}
     */

    this.parent_panel = null;
    /** @member {Plot} */

    this.parent_plot = null;
    /**
     * This is a reference to either the panel or the plot, depending on what the toolbar is
     *   tied to. Useful when absolutely positioning toolbar widgets relative to their SVG anchor.
     * @member {Plot|Panel}
     */

    this.parent_svg = null;

    if (this.parent) {
      if (this.parent.type === 'panel') {
        this.parent_panel = this.parent.parent;
        this.parent_plot = this.parent.parent.parent;
        this.parent_svg = this.parent_panel;
      } else {
        this.parent_plot = this.parent.parent;
        this.parent_svg = this.parent_plot;
      }
    }
    /** @member {d3.selection} */


    this.selector = null;
    /**
     * If this is an interactive widget, it will contain a button or menu instance that handles the interactivity.
     *   There is a 1-to-1 relationship of toolbar widget to button
     * @member {null|Button}
     */

    this.button = null;
    /**
     * If any single widget is marked persistent, it will bubble up to prevent automatic hide behavior on a
     *   widget's parent toolbar. Check via `shouldPersist`
     * @protected
     * @member {Boolean}
     */

    this.persist = false;

    if (!this.layout.position) {
      this.layout.position = 'left';
    }
  }
  /**
   * Perform all rendering of widget, including toggling visibility to true. Will initialize and create SVG element
   *   if necessary, as well as updating with new data and performing layout actions.
   */


  _createClass(BaseWidget, [{
    key: "show",
    value: function show() {
      if (!this.parent || !this.parent.selector) {
        return;
      }

      if (!this.selector) {
        var group_position = ['start', 'middle', 'end'].includes(this.layout.group_position) ? " lz-toolbar-group-".concat(this.layout.group_position) : '';
        this.selector = this.parent.selector.append('div').attr('class', "lz-toolbar-".concat(this.layout.position).concat(group_position));

        if (this.layout.style) {
          Object(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["applyStyles"])(this.selector, this.layout.style);
        }

        if (typeof this.initialize == 'function') {
          this.initialize();
        }
      }

      if (this.button && this.button.status === 'highlighted') {
        this.button.menu.show();
      }

      this.selector.style('visibility', 'visible');
      this.update();
      return this.position();
    }
    /**
     * Update the toolbar widget with any new data or plot state as appropriate. This method performs all
     *  necessary rendering steps.
     */

  }, {
    key: "update",
    value: function update() {
      /* stub */
    }
    /**
     * Place the widget correctly in the plot
     * @returns {BaseWidget}
     */

  }, {
    key: "position",
    value: function position() {
      if (this.button) {
        this.button.menu.position();
      }

      return this;
    }
    /**
     * Determine whether the widget should persist (will bubble up to parent toolbar)
     * @returns {boolean}
     */

  }, {
    key: "shouldPersist",
    value: function shouldPersist() {
      if (this.persist) {
        return true;
      }

      return !!(this.button && this.button.persist);
    }
    /**
     * Toggle visibility to hidden, unless marked as persistent
     * @returns {BaseWidget}
     */

  }, {
    key: "hide",
    value: function hide() {
      if (!this.selector || this.shouldPersist()) {
        return this;
      }

      if (this.button) {
        this.button.menu.hide();
      }

      this.selector.style('visibility', 'hidden');
      return this;
    }
    /**
     * Completely remove widget and button. (may be overridden by persistence settings)
     * @param {Boolean} [force=false] If true, will ignore persistence settings and always destroy the toolbar
     * @returns {Toolbar}
     */

  }, {
    key: "destroy",
    value: function destroy(force) {
      if (typeof force == 'undefined') {
        force = false;
      }

      if (!this.selector) {
        return this;
      }

      if (this.shouldPersist() && !force) {
        return this;
      }

      if (this.button && this.button.menu) {
        this.button.menu.destroy();
      }

      this.selector.remove();
      this.selector = null;
      this.button = null;
      return this;
    }
  }]);

  return BaseWidget;
}();
/**
 * Plots and panels may have a "toolbar" element suited for showing HTML widgets that may be interactive.
 *   When widgets need to incorporate a generic button, or additionally a button that generates a menu, this
 *   class provides much of the necessary framework.
 * @param {BaseWidget} parent
 */


var Button = /*#__PURE__*/function () {
  function Button(parent) {
    var _this = this;

    _classCallCheck(this, Button);

    if (!(parent instanceof BaseWidget)) {
      throw new Error('Unable to create toolbar widget button, invalid parent');
    }
    /** @member {BaseWidget} */


    this.parent = parent;
    /** @member {Panel} */

    this.parent_panel = this.parent.parent_panel;
    /** @member {Plot} */

    this.parent_plot = this.parent.parent_plot;
    /** @member {Plot|Panel} */

    this.parent_svg = this.parent.parent_svg;
    /** @member {Toolbar|null|*} */

    this.parent_toolbar = this.parent.parent;
    /** @member {d3.selection} */

    this.selector = null;
    /**
     * Tag to use for the button (default: a)
     * @member {String}
     */

    this.tag = 'a';
    /**
     * HTML for the button to show.
     * @protected
     * @member {String}
     */

    this.html = '';
    /**
     * Mouseover title text for the button to show
     * @protected
     * @member {String}
     */

    this.title = '';
    /**
     * Color of the button
     * @member {String}
     */

    this.color = 'gray';
    /**
     * Hash of arbitrary button styles to apply as {name: value} entries
     * @protected
     * @member {Object}
     */

    this.style = {}; // Permanence

    /**
     * Track internal state on whether to keep showing the button/ menu contents at the moment
     * @protected
     * @member {Boolean}
     */

    this.persist = false;
    /**
     * Configuration when defining a button: track whether this widget should be allowed to keep open
     *   menu/button contents in response to certain events
     * @protected
     * @member {Boolean}
     */

    this.permanent = false;
    /**
     * Button status (highlighted / disabled/ etc)
     * @protected
     * @member {String}
     */

    this.status = '';
    /**
     * Button Menu Object
     * The menu is an HTML overlay that can appear below a button. It can contain arbitrary HTML and
     *   has logic to be automatically positioned and sized to behave more or less like a dropdown menu.
     * @member {Object}
     */

    this.menu = {
      outer_selector: null,
      inner_selector: null,
      scroll_position: 0,
      hidden: true,

      /**
       * Show the button menu, including setting up any DOM elements needed for first rendering
       */
      show: function show() {
        if (!_this.menu.outer_selector) {
          _this.menu.outer_selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"](_this.parent_plot.svg.node().parentNode).append('div').attr('class', "lz-toolbar-menu lz-toolbar-menu-".concat(_this.color)).attr('id', "".concat(_this.parent_svg.getBaseId(), ".toolbar.menu"));
          _this.menu.inner_selector = _this.menu.outer_selector.append('div').attr('class', 'lz-toolbar-menu-content');

          _this.menu.inner_selector.on('scroll', function () {
            _this.menu.scroll_position = _this.menu.inner_selector.node().scrollTop;
          });
        }

        _this.menu.outer_selector.style('visibility', 'visible');

        _this.menu.hidden = false;
        return _this.menu.update();
      },

      /**
       * Update the rendering of the menu
       */
      update: function update() {
        if (!_this.menu.outer_selector) {
          return _this.menu;
        }

        _this.menu.populate(); // This function is stubbed for all buttons by default and custom implemented in widget definition


        if (_this.menu.inner_selector) {
          _this.menu.inner_selector.node().scrollTop = _this.menu.scroll_position;
        }

        return _this.menu.position();
      },
      position: function position() {
        if (!_this.menu.outer_selector) {
          return _this.menu;
        } // Unset any explicitly defined outer selector height so that menus dynamically shrink if content is removed


        _this.menu.outer_selector.style('height', null);

        var padding = 3;
        var scrollbar_padding = 20;
        var menu_height_padding = 14; // 14: 2x 6px padding, 2x 1px border

        var page_origin = _this.parent_svg._getPageOrigin();

        var page_scroll_top = document.documentElement.scrollTop || document.body.scrollTop;

        var container_offset = _this.parent_plot.getContainerOffset();

        var toolbar_client_rect = _this.parent_toolbar.selector.node().getBoundingClientRect();

        var button_client_rect = _this.selector.node().getBoundingClientRect();

        var menu_client_rect = _this.menu.outer_selector.node().getBoundingClientRect();

        var total_content_height = _this.menu.inner_selector.node().scrollHeight;

        var top;
        var left;

        if (_this.parent_toolbar.type === 'panel') {
          top = page_origin.y + toolbar_client_rect.height + 2 * padding;
          left = Math.max(page_origin.x + _this.parent_svg.layout.width - menu_client_rect.width - padding, page_origin.x + padding);
        } else {
          top = button_client_rect.bottom + page_scroll_top + padding - container_offset.top;
          left = Math.max(button_client_rect.left + button_client_rect.width - menu_client_rect.width - container_offset.left, page_origin.x + padding);
        }

        var base_max_width = Math.max(_this.parent_svg.layout.width - 2 * padding - scrollbar_padding, scrollbar_padding);
        var container_max_width = base_max_width;
        var content_max_width = base_max_width - 4 * padding;
        var base_max_height = Math.max(_this.parent_svg.layout.height - 10 * padding - menu_height_padding, menu_height_padding);
        var height = Math.min(total_content_height, base_max_height);

        _this.menu.outer_selector.style('top', "".concat(top, "px")).style('left', "".concat(left, "px")).style('max-width', "".concat(container_max_width, "px")).style('max-height', "".concat(base_max_height, "px")).style('height', "".concat(height, "px"));

        _this.menu.inner_selector.style('max-width', "".concat(content_max_width, "px"));

        _this.menu.inner_selector.node().scrollTop = _this.menu.scroll_position;
        return _this.menu;
      },
      hide: function hide() {
        if (!_this.menu.outer_selector) {
          return _this.menu;
        }

        _this.menu.outer_selector.style('visibility', 'hidden');

        _this.menu.hidden = true;
        return _this.menu;
      },
      destroy: function destroy() {
        if (!_this.menu.outer_selector) {
          return _this.menu;
        }

        _this.menu.inner_selector.remove();

        _this.menu.outer_selector.remove();

        _this.menu.inner_selector = null;
        _this.menu.outer_selector = null;
        return _this.menu;
      },

      /**
       * Internal method definition
       * By convention populate() does nothing and should be reimplemented with each toolbar button definition
       *   Reimplement by way of Toolbar.BaseWidget.Button.menu.setPopulate to define the populate method and hook
       *   up standard menu click-toggle behavior prototype.
       * @protected
       */
      populate: function populate() {
        throw new Error('Method must be implemented');
      },

      /**
       * Define how the menu is populated with items, and set up click and display properties as appropriate
       * @public
       */
      setPopulate: function setPopulate(menu_populate_function) {
        if (typeof menu_populate_function == 'function') {
          _this.menu.populate = menu_populate_function;

          _this.setOnclick(function () {
            if (_this.menu.hidden) {
              _this.menu.show();

              _this.highlight().update();

              _this.persist = true;
            } else {
              _this.menu.hide();

              _this.highlight(false).update();

              if (!_this.permanent) {
                _this.persist = false;
              }
            }
          });
        } else {
          _this.setOnclick();
        }

        return _this;
      }
    };
  }
  /**
   * Set the color associated with this button
   * @param {('gray'|'red'|'orange'|'yellow'|'green'|'blue'|'purple')} color Any selection not in the preset list
   *   will be replaced with gray.
   * @returns {Button}
   */


  _createClass(Button, [{
    key: "setColor",
    value: function setColor(color) {
      if (typeof color != 'undefined') {
        if (['gray', 'red', 'orange', 'yellow', 'green', 'blue', 'purple'].includes(color)) {
          this.color = color;
        } else {
          this.color = 'gray';
        }
      }

      return this;
    }
    /**
     * Allow code to change whether the button is allowed to be `permanent`
     * @param {boolean} bool
     * @returns {Button}
     */

  }, {
    key: "setPermanent",
    value: function setPermanent(bool) {
      if (typeof bool == 'undefined') {
        bool = true;
      } else {
        bool = Boolean(bool);
      }

      this.permanent = bool;

      if (this.permanent) {
        this.persist = true;
      }

      return this;
    }
    /**
     * Determine whether the button/menu contents should persist in response to a specific event
     * @returns {Boolean}
     */

  }, {
    key: "shouldPersist",
    value: function shouldPersist() {
      return this.permanent || this.persist;
    }
    /**
    * Set a collection of custom styles to be used by the button
    * @param {Object} style Hash of {name:value} entries
    * @returns {Button}
    */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      if (typeof style != 'undefined') {
        this.style = style;
      }

      return this;
    }
    /**
     * Method to generate a CSS class string
     * @returns {string}
     */

  }, {
    key: "getClass",
    value: function getClass() {
      var group_position = ['start', 'middle', 'end'].includes(this.parent.layout.group_position) ? " lz-toolbar-button-group-".concat(this.parent.layout.group_position) : '';
      return "lz-toolbar-button lz-toolbar-button-".concat(this.color).concat(this.status ? "-".concat(this.status) : '').concat(group_position);
    }
    /**
     * Change button state
     * @param {('highlighted'|'disabled'|'')} status
     */

  }, {
    key: "setStatus",
    value: function setStatus(status) {
      if (typeof status != 'undefined' && ['', 'highlighted', 'disabled'].includes(status)) {
        this.status = status;
      }

      return this.update();
    }
    /**
     * Toggle whether the button is highlighted
     * @param {boolean} bool If provided, explicitly set highlighted state
     * @returns {Button}
     */

  }, {
    key: "highlight",
    value: function highlight(bool) {
      if (typeof bool == 'undefined') {
        bool = true;
      } else {
        bool = Boolean(bool);
      }

      if (bool) {
        return this.setStatus('highlighted');
      } else if (this.status === 'highlighted') {
        return this.setStatus('');
      }

      return this;
    }
    /**
     * Toggle whether the button is disabled
     * @param {boolean} bool If provided, explicitly set disabled state
     * @returns {Button}
     */

  }, {
    key: "disable",
    value: function disable(bool) {
      if (typeof bool == 'undefined') {
        bool = true;
      } else {
        bool = Boolean(bool);
      }

      if (bool) {
        return this.setStatus('disabled');
      } else if (this.status === 'disabled') {
        return this.setStatus('');
      }

      return this;
    } // Mouse events

    /** @member {function} */

  }, {
    key: "onmouseover",
    value: function onmouseover() {}
  }, {
    key: "setOnMouseover",
    value: function setOnMouseover(onmouseover) {
      if (typeof onmouseover == 'function') {
        this.onmouseover = onmouseover;
      } else {
        this.onmouseover = function () {};
      }

      return this;
    }
    /** @member {function} */

  }, {
    key: "onmouseout",
    value: function onmouseout() {}
  }, {
    key: "setOnMouseout",
    value: function setOnMouseout(onmouseout) {
      if (typeof onmouseout == 'function') {
        this.onmouseout = onmouseout;
      } else {
        this.onmouseout = function () {};
      }

      return this;
    }
    /** @member {function} */

  }, {
    key: "onclick",
    value: function onclick() {}
  }, {
    key: "setOnclick",
    value: function setOnclick(onclick) {
      if (typeof onclick == 'function') {
        this.onclick = onclick;
      } else {
        this.onclick = function () {};
      }

      return this;
    }
    /**
     * Set the mouseover title text for the button (if any)
     * @param {String} title Simple text to display
     * @returns {Button}
     */

  }, {
    key: "setTitle",
    value: function setTitle(title) {
      if (typeof title != 'undefined') {
        this.title = title.toString();
      }

      return this;
    }
    /**
     * Specify the HTML content of this button.
     * WARNING: The string provided will be inserted into the document as raw markup; XSS mitigation is the
     *   responsibility of each button implementation.
     * @param {String} html
     * @returns {Button}
     */

  }, {
    key: "setHtml",
    value: function setHtml(html) {
      if (typeof html != 'undefined') {
        this.html = html.toString();
      }

      return this;
    } // Primary behavior functions

    /**
     * Show the button, including creating DOM elements if necessary for first render
     */

  }, {
    key: "show",
    value: function show() {
      if (!this.parent) {
        return;
      }

      if (!this.selector) {
        this.selector = this.parent.selector.append(this.tag).attr('class', this.getClass());
      }

      return this.update();
    }
    /**
     * Hook for any actions or state cleanup to be performed before rerendering
     * @returns {Button}
     */

  }, {
    key: "preUpdate",
    value: function preUpdate() {
      return this;
    }
    /**
     * Update button state and contents, and fully rerender
     * @returns {Button}
     */

  }, {
    key: "update",
    value: function update() {
      if (!this.selector) {
        return this;
      }

      this.preUpdate();
      this.selector.attr('class', this.getClass()).attr('title', this.title).on('mouseover', this.status === 'disabled' ? null : this.onmouseover).on('mouseout', this.status === 'disabled' ? null : this.onmouseout).on('click', this.status === 'disabled' ? null : this.onclick).html(this.html).call(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["applyStyles"], this.style);
      this.menu.update();
      this.postUpdate();
      return this;
    }
    /**
     * Hook for any behavior to be added/changed after the button has been re-rendered
     * @returns {Button}
     */

  }, {
    key: "postUpdate",
    value: function postUpdate() {
      return this;
    }
    /**
     * Hide the button by removing it from the DOM (may be overridden by current persistence setting)
     * @returns {Button}
     */

  }, {
    key: "hide",
    value: function hide() {
      if (this.selector && !this.shouldPersist()) {
        this.selector.remove();
        this.selector = null;
      }

      return this;
    }
  }]);

  return Button;
}();
/**
 * Renders arbitrary text with title formatting
 * @param {object} layout
 * @param {string} layout.title Text to render
 */


var Title = /*#__PURE__*/function (_BaseWidget) {
  _inherits(Title, _BaseWidget);

  var _super = _createSuper(Title);

  function Title() {
    _classCallCheck(this, Title);

    return _super.apply(this, arguments);
  }

  _createClass(Title, [{
    key: "show",
    value: function show() {
      if (!this.div_selector) {
        this.div_selector = this.parent.selector.append('div').attr('class', "lz-toolbar-title lz-toolbar-".concat(this.layout.position));
        this.title_selector = this.div_selector.append('h3');
      }

      return this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var title = this.layout.title.toString();

      if (this.layout.subtitle) {
        title += " <small>".concat(this.layout.subtitle, "</small>");
      }

      this.title_selector.html(title);
      return this;
    }
  }]);

  return Title;
}(BaseWidget);
/**
 * Renders text to display the current dimensions of the plot. Automatically updated as plot dimensions change
 */


var Dimensions = /*#__PURE__*/function (_BaseWidget2) {
  _inherits(Dimensions, _BaseWidget2);

  var _super2 = _createSuper(Dimensions);

  function Dimensions() {
    _classCallCheck(this, Dimensions);

    return _super2.apply(this, arguments);
  }

  _createClass(Dimensions, [{
    key: "update",
    value: function update() {
      var display_width = !this.parent_plot.layout.width.toString().includes('.') ? this.parent_plot.layout.width : this.parent_plot.layout.width.toFixed(2);
      var display_height = !this.parent_plot.layout.height.toString().includes('.') ? this.parent_plot.layout.height : this.parent_plot.layout.height.toFixed(2);
      this.selector.html("".concat(display_width, "px \xD7 ").concat(display_height, "px"));

      if (this.layout["class"]) {
        this.selector.attr('class', this.layout["class"]);
      }

      if (this.layout.style) {
        Object(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["applyStyles"])(this.selector, this.layout.style);
      }

      return this;
    }
  }]);

  return Dimensions;
}(BaseWidget);
/**
 * Display the current scale of the genome region displayed in the plot, as defined by the difference between
 *  `state.end` and `state.start`.
 */


var RegionScale = /*#__PURE__*/function (_BaseWidget3) {
  _inherits(RegionScale, _BaseWidget3);

  var _super3 = _createSuper(RegionScale);

  function RegionScale() {
    _classCallCheck(this, RegionScale);

    return _super3.apply(this, arguments);
  }

  _createClass(RegionScale, [{
    key: "update",
    value: function update() {
      if (!isNaN(this.parent_plot.state.start) && !isNaN(this.parent_plot.state.end) && this.parent_plot.state.start !== null && this.parent_plot.state.end !== null) {
        this.selector.style('display', null);
        this.selector.html(Object(_helpers_display__WEBPACK_IMPORTED_MODULE_1__["positionIntToString"])(this.parent_plot.state.end - this.parent_plot.state.start, null, true));
      } else {
        this.selector.style('display', 'none');
      }

      if (this.layout["class"]) {
        this.selector.attr('class', this.layout["class"]);
      }

      if (this.layout.style) {
        Object(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["applyStyles"])(this.selector, this.layout.style);
      }

      return this;
    }
  }]);

  return RegionScale;
}(BaseWidget);

var FilterField = /*#__PURE__*/function (_BaseWidget4) {
  _inherits(FilterField, _BaseWidget4);

  var _super4 = _createSuper(FilterField);

  /**
   * @param {string} layout.layer_name The data layer to control with filtering
   * @param {string} [layout.filter_id = null] Sometimes we want to define more than one filter with the same operator
   *  (eg != null, != bacon). The `filter_id` option allows us to identify which filter is controlled by this widget.
   * @param {string} layout.field The field to be filtered (eg `assoc:log_pvalue`)
   * @param {string} layout.field_display_html Human-readable label for the field to be filtered (`-log<sub>10</sub>p`)
   * @param {string} layout.operator The operator to use when filtering. This must be one of the options allowed by data_layer.filter.
   * @param {number} [layout.input_size=4] The number of characters to allow in the text field
   * @param {('number'|'string')} [layout.data_type='number'] Convert the text box input to the specified type, and warn the
   *  user if the value would be invalid (eg, not numeric)
   */
  function FilterField(layout, parent) {
    var _this2;

    _classCallCheck(this, FilterField);

    _this2 = _super4.call(this, layout, parent);

    if (!_this2.parent_panel) {
      throw new Error('Filter widget can only be used in panel toolbars');
    }

    _this2._data_layer = _this2.parent_panel.data_layers[layout.layer_name];

    if (!_this2._data_layer) {
      throw new Error("Filter widget could not locate the specified layer_name: '".concat(layout.layer_name, "'"));
    }

    _this2._field = layout.field;
    _this2._field_display_html = layout.field_display_html;
    _this2._operator = layout.operator;
    _this2._filter_id = null;
    _this2._data_type = layout.data_type || 'number';

    if (!['number', 'string'].includes(_this2._data_type)) {
      throw new Error('Filter must be either string or number');
    }

    _this2._value_selector = null;
    return _this2;
  }

  _createClass(FilterField, [{
    key: "_getTarget",
    value: function _getTarget() {
      var _this3 = this;

      // Find the specific filter in layer.layout.filters, and if not present, add one
      if (!this._data_layer.layout.filters) {
        this._data_layer.layout.filters = [];
      }

      var result = this._data_layer.layout.filters.find(function (item) {
        return item.field === _this3._field && item.operator === _this3._operator && (!_this3._filter_id || item.id === _this3._filter_id);
      });

      if (!result) {
        result = {
          field: this._field,
          operator: this._operator,
          value: null
        };

        if (this._filter_id) {
          result['id'] = this._filter_id;
        }

        this._data_layer.layout.filters.push(result);
      }

      return result;
    }
    /** Clear the filter by removing it from the list */

  }, {
    key: "_clearFilter",
    value: function _clearFilter() {
      if (this._data_layer.layout.filters) {
        var index = this._data_layer.layout.filters.indexOf(this._getTarget());

        this._data_layer.layout.filters.splice(index, 1);
      }
    }
    /** Set the filter based on a provided value */

  }, {
    key: "_setFilter",
    value: function _setFilter(value) {
      if (value === null) {
        // On blank or invalid value, remove the filter & warn
        this._value_selector.style('border', '1px solid red').style('color', 'red');

        this._clearFilter();
      } else {
        var filter = this._getTarget();

        filter.value = value;
      }
    }
    /** Get the user-entered value, coercing type if necessary. Returns null for invalid or missing values.
     * @return {null|number|string}
     * @private
     */

  }, {
    key: "_getValue",
    value: function _getValue() {
      var value = this._value_selector.property('value');

      if (value === null || value === '') {
        return null;
      }

      if (this._data_type === 'number') {
        value = +value;

        if (Number.isNaN(value)) {
          return null;
        }
      }

      return value;
    }
  }, {
    key: "update",
    value: function update() {
      var _this4 = this;

      if (this._value_selector) {
        return;
      }

      this.selector.style('padding', '0 6px'); // Label

      this.selector.append('span').html(this._field_display_html).style('background', '#fff').style('padding-left', '3px'); // Operator label

      this.selector.append('span').text(this._operator).style('padding', '0 3px').style('background', '#fff');
      this._value_selector = this.selector.append('input').attr('size', this.layout.input_size || 4).on('input', Object(_helpers_common__WEBPACK_IMPORTED_MODULE_2__["debounce"])(function () {
        // Clear validation state
        _this4._value_selector.style('border', null).style('color', null);

        var value = _this4._getValue();

        _this4._setFilter(value);

        _this4.parent_panel.render();
      }, 750));
    }
  }]);

  return FilterField;
}(BaseWidget);
/**
 * Button to export current plot to an SVG image
 */


var DownloadSVG = /*#__PURE__*/function (_BaseWidget5) {
  _inherits(DownloadSVG, _BaseWidget5);

  var _super5 = _createSuper(DownloadSVG);

  /**
   * @param {string} [layout.button_html="Download SVG"]
   * @param {string} [layout.button_title="Download image of the current plot as locuszoom.svg"]
   * @param {string} [layout.filename="locuszoom.svg"] The default filename to use when saving the image
  */
  function DownloadSVG(layout, parent) {
    var _this5;

    _classCallCheck(this, DownloadSVG);

    _this5 = _super5.call(this, layout, parent);
    _this5._filename = _this5.layout.filename || 'locuszoom.svg';
    _this5._button_html = _this5.layout.button_html || 'Save SVG';
    _this5._button_title = _this5.layout.button_title || 'Download hi-res image';
    return _this5;
  }

  _createClass(DownloadSVG, [{
    key: "update",
    value: function update() {
      var _this6 = this;

      if (this.button) {
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml(this._button_html).setTitle(this._button_title).setOnMouseover(function () {
        _this6.button.selector.classed('lz-toolbar-button-gray-disabled', true).html('Preparing Image');

        _this6._getBlobUrl().then(function (url) {
          var old = _this6.button.selector.attr('href');

          if (old) {
            // Clean up old url instance to prevent memory leaks
            URL.revokeObjectURL(old);
          }

          _this6.button.selector.attr('href', url).classed('lz-toolbar-button-gray-disabled', false).classed('lz-toolbar-button-gray-highlighted', true).html(_this6._button_html);
        });
      }).setOnMouseout(function () {
        _this6.button.selector.classed('lz-toolbar-button-gray-highlighted', false);
      });
      this.button.show();
      this.button.selector.attr('href-lang', 'image/svg+xml').attr('download', this._filename);
      return this;
    }
    /**
     * Extract all CSS rules whose selectors directly reference elements under the root node
     * @param {Element} root
     * @return {string}
     * @private
     */

  }, {
    key: "_getCSS",
    value: function _getCSS(root) {
      // Hack: this method is based on text matching the rules on a given node; it doesn't handle, eg ancestors.
      // Since all LZ cssRules are written as "svg .classname", we need to strip the parent selector prefix in order
      // to extract CSS.
      var ancestor_pattern = /^svg\.lz-locuszoom\s*/; // Extract all relevant CSS Rules by iterating through all available stylesheets

      var extractedCSSText = '';

      for (var i = 0; i < document.styleSheets.length; i++) {
        var s = document.styleSheets[i];

        try {
          if (!s.cssRules) {
            continue;
          }
        } catch (e) {
          if (e.name !== 'SecurityError') {
            throw e;
          } // for Firefox


          continue;
        }

        var cssRules = s.cssRules;

        for (var _i = 0; _i < cssRules.length; _i++) {
          // FIXME: We could write smaller SVGs by extracting only the exact CSS rules for this plot. However,
          //   extracting rules (including parent selectors) is a finicky process
          // Instead just fetch all LZ plot rules, under a known hardcoded parent selector.
          var rule = cssRules[_i];
          var is_match = rule.selectorText && rule.selectorText.match(ancestor_pattern);

          if (is_match) {
            extractedCSSText += rule.cssText;
          }
        }
      }

      return extractedCSSText;
    }
  }, {
    key: "_appendCSS",
    value: function _appendCSS(cssText, element) {
      // Append styles to the constructed SVG DOM node
      var styleElement = document.createElement('style');
      styleElement.setAttribute('type', 'text/css');
      styleElement.innerHTML = cssText;
      var refNode = element.hasChildNodes() ? element.children[0] : null;
      element.insertBefore(styleElement, refNode);
    }
    /**
     * Get the target dimensions for the rendered image.
     *
     * For non-vector displays, these dimensions will yield ~300 DPI image for an 8" wide print figure.
     * @return {number[]}
     * @private
     */

  }, {
    key: "_getDimensions",
    value: function _getDimensions() {
      var _this$parent_plot$svg = this.parent_plot.svg.node().getBoundingClientRect(),
          width = _this$parent_plot$svg.width,
          height = _this$parent_plot$svg.height;

      var target_width = 2400;
      var rescale = target_width / width;
      return [rescale * width, rescale * height];
    }
  }, {
    key: "_generateSVG",
    value: function _generateSVG() {
      var _this7 = this;

      return new Promise(function (resolve) {
        // Copy the DOM node so that we can modify the image for publication
        var copy = _this7.parent_plot.svg.node().cloneNode(true);

        copy.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
        copy = d3__WEBPACK_IMPORTED_MODULE_0__["select"](copy); // Remove unnecessary elements

        copy.selectAll('g.lz-curtain').remove();
        copy.selectAll('g.lz-mouse_guide').remove(); // Convert units on axis tick dy attributes from ems to pixels

        copy.selectAll('g.tick text').each(function () {
          var dy = +d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).attr('dy').substring(-2).slice(0, -2) * 10;
          d3__WEBPACK_IMPORTED_MODULE_0__["select"](this).attr('dy', dy);
        }); // Pull the svg into a string and add the contents of the locuszoom stylesheet
        // Don't add this with d3 because it will escape the CDATA declaration incorrectly

        var serializer = new XMLSerializer();
        copy = copy.node(); // Firefox has issues saving the SVG in certain contexts (esp rendering to canvas) unless a width is given.
        //  See: https://bugzilla.mozilla.org/show_bug.cgi?id=700533

        var _this7$_getDimensions = _this7._getDimensions(),
            _this7$_getDimensions2 = _slicedToArray(_this7$_getDimensions, 2),
            width = _this7$_getDimensions2[0],
            height = _this7$_getDimensions2[1];

        copy.setAttribute('width', width);
        copy.setAttribute('height', height); // Add CSS to the node

        _this7._appendCSS(_this7._getCSS(copy), copy);

        var svg_markup = serializer.serializeToString(copy);
        resolve(svg_markup);
      });
    }
    /**
     * Converts the SVG string into a downloadable binary object
     * @return {Promise}
     */

  }, {
    key: "_getBlobUrl",
    value: function _getBlobUrl() {
      return this._generateSVG().then(function (markup) {
        var blob = new Blob([markup], {
          type: 'image/svg+xml'
        });
        return URL.createObjectURL(blob);
      });
    }
  }]);

  return DownloadSVG;
}(BaseWidget);
/**
 * Button to export current plot to a PNG image
 */


var DownloadPNG = /*#__PURE__*/function (_DownloadSVG) {
  _inherits(DownloadPNG, _DownloadSVG);

  var _super6 = _createSuper(DownloadPNG);

  function DownloadPNG(layout, parent) {
    var _this8;

    _classCallCheck(this, DownloadPNG);

    _this8 = _super6.apply(this, arguments);
    _this8._filename = _this8.layout.filename || 'locuszoom.png';
    _this8._button_html = _this8.layout.button_html || 'Save PNG';
    _this8._button_title = _this8.layout.button_title || 'Download image';
    return _this8;
  }

  _createClass(DownloadPNG, [{
    key: "_getBlobUrl",
    value: function _getBlobUrl() {
      var _this9 = this;

      return _get(_getPrototypeOf(DownloadPNG.prototype), "_getBlobUrl", this).call(this).then(function (svg_url) {
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');

        var _this9$_getDimensions = _this9._getDimensions(),
            _this9$_getDimensions2 = _slicedToArray(_this9$_getDimensions, 2),
            width = _this9$_getDimensions2[0],
            height = _this9$_getDimensions2[1];

        canvas.width = width;
        canvas.height = height;
        return new Promise(function (resolve, reject) {
          var image = new Image();

          image.onload = function () {
            context.drawImage(image, 0, 0, width, height); // Once canvas rendered, revoke svg blob to avoid memory leaks, and create new url for the canvas

            URL.revokeObjectURL(svg_url);
            canvas.toBlob(function (png) {
              resolve(URL.createObjectURL(png));
            });
          };

          image.src = svg_url;
        });
      });
    }
  }]);

  return DownloadPNG;
}(DownloadSVG);
/**
 * Button to remove panel from plot.
 *   NOTE: Will only work on panel widgets.
 * @param {Boolean} [layout.suppress_confirm=false] If true, removes the panel without prompting user for confirmation
 */


var RemovePanel = /*#__PURE__*/function (_BaseWidget6) {
  _inherits(RemovePanel, _BaseWidget6);

  var _super7 = _createSuper(RemovePanel);

  function RemovePanel() {
    _classCallCheck(this, RemovePanel);

    return _super7.apply(this, arguments);
  }

  _createClass(RemovePanel, [{
    key: "update",
    value: function update() {
      var _this10 = this;

      if (this.button) {
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml('×').setTitle('Remove panel').setOnclick(function () {
        if (!_this10.layout.suppress_confirm && !confirm('Are you sure you want to remove this panel? This cannot be undone.')) {
          return false;
        }

        var panel = _this10.parent_panel;
        panel.toolbar.hide(true);
        d3__WEBPACK_IMPORTED_MODULE_0__["select"](panel.parent.svg.node().parentNode).on("mouseover.".concat(panel.getBaseId(), ".toolbar"), null);
        d3__WEBPACK_IMPORTED_MODULE_0__["select"](panel.parent.svg.node().parentNode).on("mouseout.".concat(panel.getBaseId(), ".toolbar"), null);
        return panel.parent.removePanel(panel.id);
      });
      this.button.show();
      return this;
    }
  }]);

  return RemovePanel;
}(BaseWidget);
/**
 * Button to move panel up relative to other panels (in terms of y-index on the page)
 *   NOTE: Will only work on panel widgets.
 */


var MovePanelUp = /*#__PURE__*/function (_BaseWidget7) {
  _inherits(MovePanelUp, _BaseWidget7);

  var _super8 = _createSuper(MovePanelUp);

  function MovePanelUp() {
    _classCallCheck(this, MovePanelUp);

    return _super8.apply(this, arguments);
  }

  _createClass(MovePanelUp, [{
    key: "update",
    value: function update() {
      var _this11 = this;

      if (this.button) {
        var is_at_top = this.parent_panel.layout.y_index === 0;
        this.button.disable(is_at_top);
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml('▴').setTitle('Move panel up').setOnclick(function () {
        _this11.parent_panel.moveUp();

        _this11.update();
      });
      this.button.show();
      return this.update();
    }
  }]);

  return MovePanelUp;
}(BaseWidget);
/**
 * Button to move panel down relative to other panels (in terms of y-index on the page)
 *   NOTE: Will only work on panel widgets.
 */


var MovePanelDown = /*#__PURE__*/function (_BaseWidget8) {
  _inherits(MovePanelDown, _BaseWidget8);

  var _super9 = _createSuper(MovePanelDown);

  function MovePanelDown() {
    _classCallCheck(this, MovePanelDown);

    return _super9.apply(this, arguments);
  }

  _createClass(MovePanelDown, [{
    key: "update",
    value: function update() {
      var _this12 = this;

      if (this.button) {
        var is_at_bottom = this.parent_panel.layout.y_index === this.parent_plot.panel_ids_by_y_index.length - 1;
        this.button.disable(is_at_bottom);
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml('▾').setTitle('Move panel down').setOnclick(function () {
        _this12.parent_panel.moveDown();

        _this12.update();
      });
      this.button.show();
      return this.update();
    }
  }]);

  return MovePanelDown;
}(BaseWidget);
/**
 * Button to shift plot region forwards or back by a `step` increment provided in the layout
 * @param {object} layout
 * @param {number} [layout.step=50000] The stepsize to change the region by
 * @param {string} [layout.button_html]
 * @param {string} [layout.button_title]
 */


var ShiftRegion = /*#__PURE__*/function (_BaseWidget9) {
  _inherits(ShiftRegion, _BaseWidget9);

  var _super10 = _createSuper(ShiftRegion);

  function ShiftRegion(layout, parent) {
    var _this13;

    _classCallCheck(this, ShiftRegion);

    if (isNaN(layout.step) || layout.step === 0) {
      layout.step = 50000;
    }

    if (typeof layout.button_html !== 'string') {
      layout.button_html = layout.step > 0 ? '>' : '<';
    }

    if (typeof layout.button_title !== 'string') {
      layout.button_title = "Shift region by ".concat(layout.step > 0 ? '+' : '-').concat(Object(_helpers_display__WEBPACK_IMPORTED_MODULE_1__["positionIntToString"])(Math.abs(layout.step), null, true));
    }

    _this13 = _super10.call(this, layout, parent);

    if (isNaN(_this13.parent_plot.state.start) || isNaN(_this13.parent_plot.state.end)) {
      throw new Error('Unable to add shift_region toolbar widget: plot state does not have region bounds');
    }

    return _this13;
  }

  _createClass(ShiftRegion, [{
    key: "update",
    value: function update() {
      var _this14 = this;

      if (this.button) {
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml(this.layout.button_html).setTitle(this.layout.button_title).setOnclick(function () {
        _this14.parent_plot.applyState({
          start: Math.max(_this14.parent_plot.state.start + _this14.layout.step, 1),
          end: _this14.parent_plot.state.end + _this14.layout.step
        });
      });
      this.button.show();
      return this;
    }
  }]);

  return ShiftRegion;
}(BaseWidget);
/**
 * Zoom in or out on the plot, centered on the middle of the plot region, by the specified amount
 * @param {object} layout
 * @param {number} [layout.step=0.2] The amount to zoom in by (where 1 indicates 100%)
 */


var ZoomRegion = /*#__PURE__*/function (_BaseWidget10) {
  _inherits(ZoomRegion, _BaseWidget10);

  var _super11 = _createSuper(ZoomRegion);

  function ZoomRegion(layout, parent) {
    var _this15;

    _classCallCheck(this, ZoomRegion);

    if (isNaN(layout.step) || layout.step === 0) {
      layout.step = 0.2;
    }

    if (typeof layout.button_html != 'string') {
      layout.button_html = layout.step > 0 ? 'z–' : 'z+';
    }

    if (typeof layout.button_title != 'string') {
      layout.button_title = "Zoom region ".concat(layout.step > 0 ? 'out' : 'in', " by ").concat((Math.abs(layout.step) * 100).toFixed(1), "%");
    }

    _this15 = _super11.call(this, layout, parent);

    if (isNaN(_this15.parent_plot.state.start) || isNaN(_this15.parent_plot.state.end)) {
      throw new Error('Unable to add zoom_region toolbar widget: plot state does not have region bounds');
    }

    return _this15;
  }

  _createClass(ZoomRegion, [{
    key: "update",
    value: function update() {
      var _this16 = this;

      if (this.button) {
        var can_zoom = true;
        var current_region_scale = this.parent_plot.state.end - this.parent_plot.state.start;

        if (this.layout.step > 0 && !isNaN(this.parent_plot.layout.max_region_scale) && current_region_scale >= this.parent_plot.layout.max_region_scale) {
          can_zoom = false;
        }

        if (this.layout.step < 0 && !isNaN(this.parent_plot.layout.min_region_scale) && current_region_scale <= this.parent_plot.layout.min_region_scale) {
          can_zoom = false;
        }

        this.button.disable(!can_zoom);
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml(this.layout.button_html).setTitle(this.layout.button_title).setOnclick(function () {
        var current_region_scale = _this16.parent_plot.state.end - _this16.parent_plot.state.start;
        var zoom_factor = 1 + _this16.layout.step;
        var new_region_scale = current_region_scale * zoom_factor;

        if (!isNaN(_this16.parent_plot.layout.max_region_scale)) {
          new_region_scale = Math.min(new_region_scale, _this16.parent_plot.layout.max_region_scale);
        }

        if (!isNaN(_this16.parent_plot.layout.min_region_scale)) {
          new_region_scale = Math.max(new_region_scale, _this16.parent_plot.layout.min_region_scale);
        }

        var delta = Math.floor((new_region_scale - current_region_scale) / 2);

        _this16.parent_plot.applyState({
          start: Math.max(_this16.parent_plot.state.start - delta, 1),
          end: _this16.parent_plot.state.end + delta
        });
      });
      this.button.show();
      return this;
    }
  }]);

  return ZoomRegion;
}(BaseWidget);
/**
 * Renders button with arbitrary text that, when clicked, shows a dropdown containing arbitrary HTML
 *  NOTE: Trusts content exactly as given. XSS prevention is the responsibility of the implementer.
 * @param {object} layout
 * @param {string} layout.button_html The HTML to render inside the button
 * @param {string} layout.button_title Text to display as a tooltip when hovering over the button
 * @param {string} layout.menu_html The HTML content of the dropdown menu
 */


var Menu = /*#__PURE__*/function (_BaseWidget11) {
  _inherits(Menu, _BaseWidget11);

  var _super12 = _createSuper(Menu);

  function Menu() {
    _classCallCheck(this, Menu);

    return _super12.apply(this, arguments);
  }

  _createClass(Menu, [{
    key: "update",
    value: function update() {
      var _this17 = this;

      if (this.button) {
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml(this.layout.button_html).setTitle(this.layout.button_title);
      this.button.menu.setPopulate(function () {
        _this17.button.menu.inner_selector.html(_this17.layout.menu_html);
      });
      this.button.show();
      return this;
    }
  }]);

  return Menu;
}(BaseWidget);
/**
 * Button to resize panel height to fit available data (eg when showing a list of tracks)
 * @param {string} [layout.button_html="Resize to Data"]
 * @param {string} [layout.button_title]
 */


var ResizeToData = /*#__PURE__*/function (_BaseWidget12) {
  _inherits(ResizeToData, _BaseWidget12);

  var _super13 = _createSuper(ResizeToData);

  function ResizeToData() {
    _classCallCheck(this, ResizeToData);

    return _super13.apply(this, arguments);
  }

  _createClass(ResizeToData, [{
    key: "update",
    value: function update() {
      var _this18 = this;

      if (this.button) {
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setHtml(this.layout.button_html || 'Resize to Data').setTitle(this.layout.button_title || 'Automatically resize this panel to show all data available').setOnclick(function () {
        _this18.parent_panel.scaleHeightToData();

        _this18.update();
      });
      this.button.show();
      return this;
    }
  }]);

  return ResizeToData;
}(BaseWidget);
/**
 * Button to toggle legend
 */


var ToggleLegend = /*#__PURE__*/function (_BaseWidget13) {
  _inherits(ToggleLegend, _BaseWidget13);

  var _super14 = _createSuper(ToggleLegend);

  function ToggleLegend() {
    _classCallCheck(this, ToggleLegend);

    return _super14.apply(this, arguments);
  }

  _createClass(ToggleLegend, [{
    key: "update",
    value: function update() {
      var _this19 = this;

      var html = this.parent_panel.legend.layout.hidden ? 'Show Legend' : 'Hide Legend';

      if (this.button) {
        this.button.setHtml(html).show();
        this.parent.position();
        return this;
      }

      this.button = new Button(this).setColor(this.layout.color).setTitle('Show or hide the legend for this panel').setOnclick(function () {
        _this19.parent_panel.legend.layout.hidden = !_this19.parent_panel.legend.layout.hidden;

        _this19.parent_panel.legend.render();

        _this19.update();
      });
      return this.update();
    }
  }]);

  return ToggleLegend;
}(BaseWidget);
/**
 * Dropdown menu allowing the user to choose between different display options for a single specific data layer
 *  within a panel.
 *
 * This allows controlling how points on a datalayer can be displayed- any display options supported via the layout for the target datalayer. This includes point
 *  size/shape, coloring, etc.
 *
 * This button intentionally limits display options it can control to those available on common plot types.
 *   Although the list of options it sets can be overridden (to control very special custom plot types), this
 *   capability should be used sparingly if at all.
 *
 * @param {object} layout
 * @param {String} [layout.button_html="Display options..."] Text to display on the toolbar button
 * @param {String} [layout.button_title="Control how plot items are displayed"] Hover text for the toolbar button
 * @param {string} layout.layer_name Specify the datalayer that this button should affect
 * @param {string} [layout.default_config_display_name] Store the default configuration for this datalayer
 *  configuration, and show a button to revert to the "default" (listing the human-readable display name provided)
 * @param {Array} [layout.fields_whitelist='see code'] The list of presentation fields that this button can control.
 *  This can be overridden if this button needs to be used on a custom layer type with special options.
 * @typedef {{display_name: string, display: Object}} DisplayOptionsButtonConfigField
 * @param {DisplayOptionsButtonConfigField[]} layout.options Specify a label and set of layout directives associated
 *  with this `display` option. Display field should include all changes to datalayer presentation options.
 */


var DisplayOptions = /*#__PURE__*/function (_BaseWidget14) {
  _inherits(DisplayOptions, _BaseWidget14);

  var _super15 = _createSuper(DisplayOptions);

  function DisplayOptions(layout, parent) {
    var _this20;

    _classCallCheck(this, DisplayOptions);

    if (typeof layout.button_html != 'string') {
      layout.button_html = 'Display options...';
    }

    if (typeof layout.button_title != 'string') {
      layout.button_title = 'Control how plot items are displayed';
    }

    _this20 = _super15.apply(this, arguments); // List of layout fields that this button is allowed to control. This ensures that we don't override any other
    //  information (like plot height etc) while changing point rendering

    var allowed_fields = layout.fields_whitelist || ['color', 'fill_opacity', 'filters', 'label', 'legend', 'point_shape', 'point_size', 'tooltip', 'tooltip_positioning'];
    var dataLayer = _this20.parent_panel.data_layers[layout.layer_name];

    if (!dataLayer) {
      throw new Error("Display options could not locate the specified layer_name: '".concat(layout.layer_name, "'"));
    }

    var dataLayerLayout = dataLayer.layout; // Store default configuration for the layer as a clean deep copy, so we may revert later

    var defaultConfig = {};
    allowed_fields.forEach(function (name) {
      var configSlot = dataLayerLayout[name];

      if (configSlot !== undefined) {
        defaultConfig[name] = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_3__["deepCopy"])(configSlot);
      }
    });
    /**
     * Which item in the menu is currently selected. (track for rerendering menu)
     * @member {String}
     * @private
     */

    _this20._selected_item = 'default'; // Define the button + menu that provides the real functionality for this toolbar widget

    _this20.button = new Button(_assertThisInitialized(_this20)).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title).setOnclick(function () {
      _this20.button.menu.populate();
    });

    _this20.button.menu.setPopulate(function () {
      // Multiple copies of this button might be used on a single LZ page; append unique IDs where needed
      var uniqueID = Math.floor(Math.random() * 1e4).toString();

      _this20.button.menu.inner_selector.html('');

      var table = _this20.button.menu.inner_selector.append('table');

      var menuLayout = _this20.layout;

      var renderRow = function renderRow(display_name, display_options, row_id) {
        // Helper method
        var row = table.append('tr');
        var radioId = "".concat(uniqueID).concat(row_id);
        row.append('td').append('input').attr('id', radioId).attr('type', 'radio').attr('name', "display-option-".concat(uniqueID)).attr('value', row_id).style('margin', 0) // Override css libraries (eg skeleton) that style form inputs
        .property('checked', row_id === _this20._selected_item).on('click', function () {
          // If an option is not specified in these display options, use the original defaults
          allowed_fields.forEach(function (field_name) {
            var has_option = typeof display_options[field_name] !== 'undefined';
            dataLayer.layout[field_name] = has_option ? display_options[field_name] : defaultConfig[field_name];
          });
          _this20._selected_item = row_id;

          _this20.parent_panel.render();

          var legend = _this20.parent_panel.legend;

          if (legend) {
            legend.render();
          }
        });
        row.append('td').append('label').style('font-weight', 'normal').attr('for', radioId).text(display_name);
      }; // Render the "display options" menu: default and special custom options


      var defaultName = menuLayout.default_config_display_name || 'Default style';
      renderRow(defaultName, defaultConfig, 'default');
      menuLayout.options.forEach(function (item, index) {
        return renderRow(item.display_name, item.display, index);
      });
      return _assertThisInitialized(_this20);
    });

    return _this20;
  }

  _createClass(DisplayOptions, [{
    key: "update",
    value: function update() {
      this.button.show();
      return this;
    }
  }]);

  return DisplayOptions;
}(BaseWidget);
/**
 * Dropdown menu allowing the user to set the value of a specific `state_field` in plot.state
 * This is useful for things (like datasources) that allow dynamic configuration based on global information in state
 *
 * For example, the LDServer data source can use it to change LD reference population (for all panels) after render
 *
 * @param {object} layout
 * @param {String} [layout.button_html="Set option..."] Text to display on the toolbar button
 * @param {String} [layout.button_title="Choose an option to customize the plot"] Hover text for the toolbar button
 * @param {bool} [layout.show_selected=false] Whether to append the selected value to the button label
 * @param {string} [layout.state_field] The name of the field in plot.state that will be set by this button
 * @typedef {{display_name: string, value: *}} SetStateOptionsConfigField
 * @param {SetStateOptionsConfigField[]} layout.options Specify human labels and associated values for the dropdown menu
 */


var SetState = /*#__PURE__*/function (_BaseWidget15) {
  _inherits(SetState, _BaseWidget15);

  var _super16 = _createSuper(SetState);

  function SetState(layout, parent) {
    var _this21;

    _classCallCheck(this, SetState);

    if (typeof layout.button_html != 'string') {
      layout.button_html = 'Set option...';
    }

    if (typeof layout.button_title != 'string') {
      layout.button_title = 'Choose an option to customize the plot';
    }

    _this21 = _super16.call(this, layout, parent);

    if (_this21.parent_panel) {
      throw new Error('This widget is designed to set global options, so it can only be used at the top (plot) level');
    }

    if (!layout.state_field) {
      throw new Error('Must specify the `state_field` that this widget controls');
    }
    /**
     * Which item in the menu is currently selected. (track for rerendering menu)
     * @member {String}
     * @private
     */
    // The first option listed is automatically assumed to be the default, unless a value exists in plot.state


    _this21._selected_item = _this21.parent_plot.state[layout.state_field] || layout.options[0].value;

    if (!layout.options.find(function (item) {
      return item.value === _this21._selected_item;
    })) {
      // Check only gets run at widget creation, but generally this widget is assumed to be an exclusive list of options
      throw new Error('There is an existing state value that does not match the known values in this widget');
    } // Define the button + menu that provides the real functionality for this toolbar widget


    _this21.button = new Button(_assertThisInitialized(_this21)).setColor(layout.color).setHtml(layout.button_html + (layout.show_selected ? _this21._selected_item : '')).setTitle(layout.button_title).setOnclick(function () {
      _this21.button.menu.populate();
    });

    _this21.button.menu.setPopulate(function () {
      // Multiple copies of this button might be used on a single LZ page; append unique IDs where needed
      var uniqueID = Math.floor(Math.random() * 1e4).toString();

      _this21.button.menu.inner_selector.html('');

      var table = _this21.button.menu.inner_selector.append('table');

      var renderRow = function renderRow(display_name, value, row_id) {
        // Helper method
        var row = table.append('tr');
        var radioId = "".concat(uniqueID).concat(row_id);
        row.append('td').append('input').attr('id', radioId).attr('type', 'radio').attr('name', "set-state-".concat(uniqueID)).attr('value', row_id).style('margin', 0) // Override css libraries (eg skeleton) that style form inputs
        .property('checked', value === _this21._selected_item).on('click', function () {
          var new_state = {};
          new_state[layout.state_field] = value;
          _this21._selected_item = value;

          _this21.parent_plot.applyState(new_state);

          _this21.button.setHtml(layout.button_html + (layout.show_selected ? _this21._selected_item : ''));
        });
        row.append('td').append('label').style('font-weight', 'normal').attr('for', radioId).text(display_name);
      };

      layout.options.forEach(function (item, index) {
        return renderRow(item.display_name, item.value, index);
      });
      return _assertThisInitialized(_this21);
    });

    return _this21;
  }

  _createClass(SetState, [{
    key: "update",
    value: function update() {
      this.button.show();
      return this;
    }
  }]);

  return SetState;
}(BaseWidget);



/***/ }),

/***/ "./esm/data/adapters.js":
/*!******************************!*\
  !*** ./esm/data/adapters.js ***!
  \******************************/
/*! exports provided: BaseAdapter, BaseApiAdapter, AssociationLZ, ConnectorSource, GeneConstraintLZ, GeneLZ, GwasCatalogLZ, LDServer, PheWASLZ, RecombLZ, StaticSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseAdapter", function() { return BaseAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseApiAdapter", function() { return BaseApiAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssociationLZ", function() { return AssociationLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectorSource", function() { return ConnectorSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneConstraintLZ", function() { return GeneConstraintLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneLZ", function() { return GeneLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GwasCatalogLZ", function() { return GwasCatalogLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDServer", function() { return LDServer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PheWASLZ", function() { return PheWASLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RecombLZ", function() { return RecombLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticSource", function() { return StaticSource; });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Define standard data adapters used to retrieve data (usually from REST APIs)
 * @module
 */
function validateBuildSource(class_name, build, source) {
  // Build OR Source, not both
  if (build && source || !(build || source)) {
    throw new Error("".concat(class_name, " must provide a parameter specifying either \"build\" or \"source\". It should not specify both."));
  } // If the build isn't recognized, our APIs can't transparently select a source to match


  if (build && !['GRCh37', 'GRCh38'].includes(build)) {
    throw new Error("".concat(class_name, " must specify a valid genome build number"));
  }
}
/**
 * Base class for LocusZoom data sources (any). See also: BaseApiAdapter
 * @public
 */


var BaseAdapter = /*#__PURE__*/function () {
  function BaseAdapter(config) {
    _classCallCheck(this, BaseAdapter);

    /**
     * Whether this source should enable caching
     * @member {Boolean}
     */
    this._enableCache = true;
    this._cachedKey = null;
    /**
     * Whether this data source type is dependent on previous requests- for example, the LD source cannot annotate
     *  association data if no data was found for that region.
     * @member {boolean}
     */

    this.__dependentSource = false; // Parse configuration options

    this.parseInit(config);
  }
  /**
   * Parse configuration used to create the data source. Many custom sources will override this method to suit their
   *  needs (eg specific config options, or for sources that do not retrieve data from a URL)
   * @protected
   * @param {String|Object} config Basic configuration- either a url, or a config object
   * @param {String} [config.url] The datasource URL
   * @param {String} [config.params] Initial config params for the datasource
   */


  _createClass(BaseAdapter, [{
    key: "parseInit",
    value: function parseInit(config) {
      /** @member {Object} */
      this.params = config.params || {};
    }
    /**
     * A unique identifier that indicates whether cached data is valid for this request. For most sources using GET
     *  requests to a REST API, this is usually the URL.
     * @protected
     * @param {Object} state Information available in plot.state (chr, start, end). Sometimes used to inject globally
     *  available information that influences the request being made.
     * @param {Object} chain The data chain from previous requests made in a sequence.
     * @param fields
     * @returns {String|undefined}
     */

  }, {
    key: "getCacheKey",
    value: function getCacheKey(state, chain, fields) {
      return this.getURL(state, chain, fields);
    }
    /**
     * Stub: build the URL for any requests made by this source.
     * @protected
     */

  }, {
    key: "getURL",
    value: function getURL(state, chain, fields) {
      return this.url;
    }
    /**
     * Perform a network request to fetch data for this source. This is usually the method that is used to override
     *  when defining how to retrieve data.
     * @protected
     * @param {Object} state The state of the parent plot
     * @param chain
     * @param fields
     * @returns {Promise}
     */

  }, {
    key: "fetchRequest",
    value: function fetchRequest(state, chain, fields) {
      var url = this.getURL(state, chain, fields);
      return fetch(url).then(function (response) {
        if (!response.ok) {
          throw new Error(response.statusText);
        }

        return response.text();
      });
    }
    /**
     * Gets the data for just this source, typically via a network request (but using cache where possible)
     *
     * For most use cases, it is better to override `fetchRequest` instead, to avoid bypassing the cache mechanism
     * by accident.
     * @protected
     */

  }, {
    key: "getRequest",
    value: function getRequest(state, chain, fields) {
      var req;
      var cacheKey = this.getCacheKey(state, chain, fields);

      if (this._enableCache && typeof cacheKey !== 'undefined' && cacheKey === this._cachedKey) {
        req = Promise.resolve(this._cachedResponse); // Resolve to the value of the current promise
      } else {
        req = this.fetchRequest(state, chain, fields);

        if (this._enableCache) {
          this._cachedKey = cacheKey;
          this._cachedResponse = req;
        }
      }

      return req;
    }
    /**
     * Ensure the server response is in a canonical form, an array of one object per record. [ {field: oneval} ].
     * If the server response contains columns, reformats the response from {column1: [], column2: []} to the above.
     *
     * Does not apply namespacing, transformations, or field extraction.
     *
     * May be overridden by data sources that inherently return more complex payloads, or that exist to annotate other
     *  sources (eg, if the payload provides extra data rather than a series of records).
     * @protected
     * @param {Object[]|Object} data The original parsed server response
     */

  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      if (Array.isArray(data)) {
        // Already in the desired form
        return data;
      } // Otherwise, assume the server response is an object representing columns of data.
      // Each array should have the same length (verify), and a given array index corresponds to a single row.


      var keys = Object.keys(data);
      var N = data[keys[0]].length;
      var sameLength = keys.every(function (key) {
        var item = data[key];
        return item.length === N;
      });

      if (!sameLength) {
        throw new Error("".concat(this.constructor.name, " expects a response in which all arrays of data are the same length"));
      } // Go down the rows, and create an object for each record


      var records = [];
      var fields = Object.keys(data);

      for (var i = 0; i < N; i++) {
        var record = {};

        for (var j = 0; j < fields.length; j++) {
          record[fields[j]] = data[fields[j]][i];
        }

        records.push(record);
      }

      return records;
    }
    /**
     * Hook to post-process the data returned by this source with new, additional behavior.
     *   (eg cleaning up API values or performing complex calculations on the returned data)
     *
     * @protected
     * @param {Object[]} records The parsed data from the source (eg standardized api response)
     * @param {Object} chain The data chain object. For example, chain.headers may provide useful annotation metadata
     * @returns {Object[]|Promise} The modified set of records
     */

  }, {
    key: "annotateData",
    value: function annotateData(records, chain) {
      // Default behavior: no transformations
      return records;
    }
    /**
     * Clean up the server records for use by datalayers: extract only certain fields, with the specified names.
     *   Apply per-field transformations as appropriate.
     *
     * This hook can be overridden, eg to create a source that always returns all records and ignores the "fields" array.
     *  This is particularly common for sources at the end of a chain- many "dependent" sources do not allow
     *  cherry-picking individual fields, in which case by **convention** the fields array specifies "last_source_name:all"
     *
     * @protected
     * @param {Object[]} data One record object per element
     * @param {String[]} fields The names of fields to extract (as named in the source data). Eg "afield"
     * @param {String[]} outnames How to represent the source fields in the output. Eg "namespace:afield|atransform"
     * @param {function[]} trans An array of transformation functions (if any). One function per data element, or null.
     * @protected
     */

  }, {
    key: "extractFields",
    value: function extractFields(data, fields, outnames, trans) {
      //intended for an array of objects
      //  [ {"id":1, "val":5}, {"id":2, "val":10}]
      // Since a number of sources exist that do not obey this format, we will provide a convenient pass-through
      if (!Array.isArray(data)) {
        return data;
      }

      if (!data.length) {
        // Sometimes there are regions that just don't have data- this should not trigger a missing field error message!
        return data;
      }

      var fieldFound = [];

      for (var k = 0; k < fields.length; k++) {
        fieldFound[k] = 0;
      }

      var records = data.map(function (item) {
        var output_record = {};

        for (var j = 0; j < fields.length; j++) {
          var val = item[fields[j]];

          if (typeof val != 'undefined') {
            fieldFound[j] = 1;
          }

          if (trans && trans[j]) {
            val = trans[j](val);
          }

          output_record[outnames[j]] = val;
        }

        return output_record;
      });
      fieldFound.forEach(function (v, i) {
        if (!v) {
          throw new Error("field ".concat(fields[i], " not found in response for ").concat(outnames[i]));
        }
      });
      return records;
    }
    /**
     * Combine records from this source with others in the chain to yield final chain body.
     *   Handles merging this data with other sources (if applicable).
     *
     * @protected
     * @param {Object[]} data The data That would be returned from this source alone
     * @param {Object} chain The data chain built up during previous requests
     * @param {String[]} fields
     * @param {String[]} outnames
     * @param {String[]} trans
     * @return {Promise|Object[]} The new chain body
     */

  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      return data;
    }
    /**
     * Coordinates the work of parsing a response and returning records. This is broken into 4 steps, which may be
     *  overridden separately for fine-grained control. Each step can return either raw data or a promise.
     *
     * @protected
     *
     * @param {String|Object} resp The raw data associated with the response
     * @param {Object} chain The combined parsed response data from this and all other requests made in the chain
     * @param {String[]} fields Array of requested field names (as they would appear in the response payload)
     * @param {String[]} outnames  Array of field names as they will be represented in the data returned by this source,
     *  including the namespace. This must be an array with the same length as `fields`
     * @param {Function[]} trans The collection of transformation functions to be run on selected fields.
     *     This must be an array with the same length as `fields`
     * @returns {Promise} A promise that resolves to an object containing
     *   request metadata (`headers: {}`), the consolidated data for plotting (`body: []`), and the individual responses that would be
     *   returned by each source in the chain in isolation (`discrete: {}`)
     */

  }, {
    key: "parseResponse",
    value: function parseResponse(resp, chain, fields, outnames, trans) {
      var _this = this;

      var source_id = this.source_id || this.constructor.name;

      if (!chain.discrete) {
        chain.discrete = {};
      }

      var json = typeof resp == 'string' ? JSON.parse(resp) : resp; // Perform the 4 steps of parsing the payload and return a combined chain object

      return Promise.resolve(this.normalizeResponse(json.data || json)).then(function (standardized) {
        // Perform calculations on the data from just this source
        return Promise.resolve(_this.annotateData(standardized, chain));
      }).then(function (data) {
        return Promise.resolve(_this.extractFields(data, fields, outnames, trans));
      }).then(function (one_source_body) {
        // Store a copy of the data that would be returned by parsing this source in isolation (and taking the
        //   fields array into account). This is useful when we want to re-use the source output in many ways.
        chain.discrete[source_id] = one_source_body;
        return Promise.resolve(_this.combineChainBody(one_source_body, chain, fields, outnames, trans));
      }).then(function (new_body) {
        return {
          header: chain.header || {},
          discrete: chain.discrete,
          body: new_body
        };
      });
    }
    /**
     * Fetch the data from the specified data source, and apply transformations requested by an external consumer.
     * This is the public-facing datasource method that will most be called by the plot, but custom data sources will
     *  almost never want to override this method directly- more specific hooks are provided to control individual pieces
     *  of the request lifecycle.
     *
     * @private
     * @param {Object} state The current "state" of the plot, such as chromosome and start/end positions
     * @param {String[]} fields Array of field names that the plot has requested from this data source. (without the "namespace" prefix)
     * @param {String[]} outnames  Array describing how the output data should refer to this field. This represents the
     *     originally requested field name, including the namespace. This must be an array with the same length as `fields`
     * @param {Function[]} trans The collection of transformation functions to be run on selected fields.
     *     This must be an array with the same length as `fields`
     * @returns {function} A callable operation that can be used as part of the data chain
     */

  }, {
    key: "getData",
    value: function getData(state, fields, outnames, trans) {
      var _this2 = this;

      if (this.preGetData) {
        // TODO try to remove this method if at all possible
        var pre = this.preGetData(state, fields, outnames, trans);

        if (this.pre) {
          state = pre.state || state;
          fields = pre.fields || fields;
          outnames = pre.outnames || outnames;
          trans = pre.trans || trans;
        }
      }

      return function (chain) {
        if (_this2.__dependentSource && chain && chain.body && !chain.body.length) {
          // A "dependent" source should not attempt to fire a request if there is no data for it to act on.
          // Therefore, it should simply return the previous data chain.
          return Promise.resolve(chain);
        }

        return _this2.getRequest(state, chain, fields).then(function (resp) {
          return _this2.parseResponse(resp, chain, fields, outnames, trans);
        });
      };
    }
  }]);

  return BaseAdapter;
}();
/**
 * Base source for LocusZoom data sources that receive their data over the web. Adds default config parameters
 *  (and potentially other behavior) that are relevant to URL-based requests.
 */


var BaseApiAdapter = /*#__PURE__*/function (_BaseAdapter) {
  _inherits(BaseApiAdapter, _BaseAdapter);

  var _super = _createSuper(BaseApiAdapter);

  function BaseApiAdapter() {
    _classCallCheck(this, BaseApiAdapter);

    return _super.apply(this, arguments);
  }

  _createClass(BaseApiAdapter, [{
    key: "parseInit",
    value: function parseInit(config) {
      _get(_getPrototypeOf(BaseApiAdapter.prototype), "parseInit", this).call(this, config);
      /** @member {String} */


      this.url = config.url;

      if (!this.url) {
        throw new Error('Source not initialized with required URL');
      }
    }
  }]);

  return BaseApiAdapter;
}(BaseAdapter);
/**
 * Data Source for Association Data from the LocusZoom/ Portaldev API (or compatible). Defines how to make a requesr
 * @public
 */


var AssociationLZ = /*#__PURE__*/function (_BaseApiAdapter) {
  _inherits(AssociationLZ, _BaseApiAdapter);

  var _super2 = _createSuper(AssociationLZ);

  function AssociationLZ() {
    _classCallCheck(this, AssociationLZ);

    return _super2.apply(this, arguments);
  }

  _createClass(AssociationLZ, [{
    key: "preGetData",
    value: function preGetData(state, fields, outnames, trans) {
      // TODO: Modify internals to see if we can go without this method
      var id_field = this.params.id_field || 'id';
      [id_field, 'position'].forEach(function (x) {
        if (!fields.includes(x)) {
          fields.unshift(x);
          outnames.unshift(x);
          trans.unshift(null);
        }
      });
      return {
        fields: fields,
        outnames: outnames,
        trans: trans
      };
    }
  }, {
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var analysis = chain.header.analysis || this.params.source || this.params.analysis; // Old usages called this param "analysis"

      if (typeof analysis == 'undefined') {
        throw new Error('Association source must specify an analysis ID to plot');
      }

      return "".concat(this.url, "results/?filter=analysis in ").concat(analysis, " and chromosome in  '").concat(state.chr, "' and position ge ").concat(state.start, " and position le ").concat(state.end);
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      // Some association sources do not sort their data in a predictable order, which makes it hard to reliably
      //  align with other sources (such as LD). For performance reasons, sorting is an opt-in argument.
      // TODO: Consider more fine grained sorting control in the future. This was added as a very specific
      //   workaround for the original T2D portal.
      data = _get(_getPrototypeOf(AssociationLZ.prototype), "normalizeResponse", this).call(this, data);

      if (this.params && this.params.sort && data.length && data[0]['position']) {
        data.sort(function (a, b) {
          return a['position'] - b['position'];
        });
      }

      return data;
    }
  }]);

  return AssociationLZ;
}(BaseApiAdapter);
/**
 * Fetch linkage disequilibrium information from a UMich LDServer-compatible API
 *
 * This source is designed to connect its results to association data, and therefore depends on association data having
 *  been loaded by a previous request in the data chain.
 *
 * In older versions of LocusZoom, this was known as "LDServer". A prior source (targeted at older APIs) has been removed.
 */


var LDServer = /*#__PURE__*/function (_BaseApiAdapter2) {
  _inherits(LDServer, _BaseApiAdapter2);

  var _super3 = _createSuper(LDServer);

  function LDServer(config) {
    var _this3;

    _classCallCheck(this, LDServer);

    _this3 = _super3.call(this, config);
    _this3.__dependentSource = true;
    return _this3;
  }

  _createClass(LDServer, [{
    key: "preGetData",
    value: function preGetData(state, fields) {
      if (fields.length > 1) {
        if (fields.length !== 2 || !fields.includes('isrefvar')) {
          throw new Error("LD does not know how to get all fields: ".concat(fields.join(', ')));
        }
      }
    }
  }, {
    key: "findMergeFields",
    value: function findMergeFields(chain) {
      // Find the fields (as provided by a previous step in the chain, like an association source) that will be needed to
      //  combine LD data with existing information
      // Since LD information may be shared across multiple assoc sources with different namespaces,
      //   we use regex to find columns to join on, rather than requiring exact matches
      var exactMatch = function exactMatch(arr) {
        return function () {
          var regexes = arguments;

          var _loop = function _loop(i) {
            var regex = regexes[i];
            var m = arr.filter(function (x) {
              return x.match(regex);
            });

            if (m.length) {
              return {
                v: m[0]
              };
            }
          };

          for (var i = 0; i < regexes.length; i++) {
            var _ret = _loop(i);

            if (_typeof(_ret) === "object") return _ret.v;
          }

          return null;
        };
      };

      var dataFields = {
        id: this.params.id_field,
        position: this.params.position_field,
        pvalue: this.params.pvalue_field,
        _names_: null
      };

      if (chain && chain.body && chain.body.length > 0) {
        var names = Object.keys(chain.body[0]);
        var nameMatch = exactMatch(names); // Internally, fields are generally prefixed with the name of the source they come from.
        // If the user provides an id_field (like `variant`), it should work across data sources( `assoc1:variant`,
        //  assoc2:variant), but not match fragments of other field names (assoc1:variant_thing)
        // Note: these lookups hard-code a couple of common fields that will work based on known APIs in the wild

        var id_match = dataFields.id && nameMatch(new RegExp("".concat(dataFields.id, "\\b")));
        dataFields.id = id_match || nameMatch(/\bvariant\b/) || nameMatch(/\bid\b/);
        dataFields.position = dataFields.position || nameMatch(/\bposition\b/i, /\bpos\b/i);
        dataFields.pvalue = dataFields.pvalue || nameMatch(/\bpvalue\b/i, /\blog_pvalue\b/i);
        dataFields._names_ = names;
      }

      return dataFields;
    }
  }, {
    key: "findRequestedFields",
    value: function findRequestedFields(fields, outnames) {
      // Assumption: all usages of this source will only ever ask for "isrefvar" or "state". This maps to output names.
      var obj = {};

      for (var i = 0; i < fields.length; i++) {
        if (fields[i] === 'isrefvar') {
          obj.isrefvarin = fields[i];
          obj.isrefvarout = outnames && outnames[i];
        } else {
          obj.ldin = fields[i];
          obj.ldout = outnames && outnames[i];
        }
      }

      return obj;
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      // The LD API payload does not obey standard format conventions; do not try to transform it.
      return data;
    }
    /**
     * Get the LD reference variant, which by default will be the most significant hit in the assoc results
     *   This will be used in making the original query to the LD server for pairwise LD information
     * @returns {*|string} The marker id (expected to be in `chr:pos_ref/alt` format) of the reference variant
     */

  }, {
    key: "getRefvar",
    value: function getRefvar(state, chain, fields) {
      var findExtremeValue = function findExtremeValue(records, pval_field) {
        // Finds the most significant hit (smallest pvalue, or largest -log10p). Will try to auto-detect the appropriate comparison.
        pval_field = pval_field || 'log_pvalue'; // The official LZ API returns log_pvalue

        var is_log = /log/.test(pval_field);
        var cmp;

        if (is_log) {
          cmp = function cmp(a, b) {
            return a > b;
          };
        } else {
          cmp = function cmp(a, b) {
            return a < b;
          };
        }

        var extremeVal = records[0][pval_field],
            extremeIdx = 0;

        for (var i = 1; i < records.length; i++) {
          if (cmp(records[i][pval_field], extremeVal)) {
            extremeVal = records[i][pval_field];
            extremeIdx = i;
          }
        }

        return extremeIdx;
      };

      var reqFields = this.findRequestedFields(fields);
      var refVar = reqFields.ldin;

      if (refVar === 'state') {
        refVar = state.ldrefvar || chain.header.ldrefvar || 'best';
      }

      if (refVar === 'best') {
        if (!chain.body) {
          throw new Error('No association data found to find best pvalue');
        }

        var keys = this.findMergeFields(chain);

        if (!keys.pvalue || !keys.id) {
          var columns = '';

          if (!keys.id) {
            columns += "".concat(columns.length ? ', ' : '', "id");
          }

          if (!keys.pvalue) {
            columns += "".concat(columns.length ? ', ' : '', "pvalue");
          }

          throw new Error("Unable to find necessary column(s) for merge: ".concat(columns, " (available: ").concat(keys._names_, ")"));
        }

        refVar = chain.body[findExtremeValue(chain.body, keys.pvalue)][keys.id];
      }

      return refVar;
    }
  }, {
    key: "getURL",
    value: function getURL(state, chain, fields) {
      // Accept the following params in this.params:
      // - method (r, rsquare, cov)
      // - source (aka panel)
      // - population (ALL, AFR, EUR, etc)
      // - build
      // The LD source/pop can be overridden from plot.state for dynamic layouts
      var build = state.genome_build || this.params.build || 'GRCh37';
      var source = state.ld_source || this.params.source || '1000G';
      var population = state.ld_pop || this.params.population || 'ALL'; // LDServer panels will always have an ALL

      var method = this.params.method || 'rsquare';

      if (source === '1000G' && build === 'GRCh38') {
        // For build 38 (only), there is a newer/improved 1000G LD panel available that uses WGS data. Auto upgrade by default.
        source = '1000G-FRZ09';
      }

      validateBuildSource(this.constructor.name, build, null); // LD doesn't need to validate `source` option

      var refVar = this.getRefvar(state, chain, fields); // Some datasets, notably the Portal, use a different marker format.
      //  Coerce it into one that will work with the LDServer API. (CHROM:POS_REF/ALT)

      var REGEX_MARKER = /^(?:chr)?([a-zA-Z0-9]+?)[_:-](\d+)[_:|-]?(\w+)?[/_:|-]?([^_]+)?_?(.*)?/;
      var match = refVar && refVar.match(REGEX_MARKER);

      if (!match) {
        throw new Error('Could not request LD for a missing or incomplete marker format');
      }

      var _match = _slicedToArray(match, 5),
          original = _match[0],
          chrom = _match[1],
          pos = _match[2],
          ref = _match[3],
          alt = _match[4]; // Currently, the LD server only accepts full variant specs; it won't return LD w/o ref+alt. Allowing
      //  a partial match at most leaves room for potential future features.


      refVar = "".concat(chrom, ":").concat(pos);

      if (ref && alt) {
        refVar += "_".concat(ref, "/").concat(alt);
      } // Preserve the user-provided variant spec for use when matching to assoc data


      chain.header.ldrefvar = original;
      return [this.url, 'genome_builds/', build, '/references/', source, '/populations/', population, '/variants', '?correlation=', method, '&variant=', encodeURIComponent(refVar), '&chrom=', encodeURIComponent(state.chr), '&start=', encodeURIComponent(state.start), '&stop=', encodeURIComponent(state.end)].join('');
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      var keys = this.findMergeFields(chain);
      var reqFields = this.findRequestedFields(fields, outnames);

      if (!keys.position) {
        throw new Error("Unable to find position field for merge: ".concat(keys._names_));
      }

      var leftJoin = function leftJoin(left, right, lfield, rfield) {
        var i = 0,
            j = 0;

        while (i < left.length && j < right.position2.length) {
          if (left[i][keys.position] === right.position2[j]) {
            left[i][lfield] = right[rfield][j];
            i++;
            j++;
          } else if (left[i][keys.position] < right.position2[j]) {
            i++;
          } else {
            j++;
          }
        }
      };

      var tagRefVariant = function tagRefVariant(data, refvar, idfield, outrefname, outldname) {
        for (var i = 0; i < data.length; i++) {
          if (data[i][idfield] && data[i][idfield] === refvar) {
            data[i][outrefname] = 1;
            data[i][outldname] = 1; // For label/filter purposes, implicitly mark the ref var as LD=1 to itself
          } else {
            data[i][outrefname] = 0;
          }
        }
      }; // LD servers vary slightly. Some report corr as "rsquare", others as "correlation"


      var corrField = data.rsquare ? 'rsquare' : 'correlation';
      leftJoin(chain.body, data, reqFields.ldout, corrField);

      if (reqFields.isrefvarin && chain.header.ldrefvar) {
        tagRefVariant(chain.body, chain.header.ldrefvar, keys.id, reqFields.isrefvarout, reqFields.ldout);
      }

      return chain.body;
    }
  }, {
    key: "fetchRequest",
    value: function fetchRequest(state, chain, fields) {
      // The API is paginated, but we need all of the data to render a plot. Depaginate and combine where appropriate.
      var url = this.getURL(state, chain, fields);
      var combined = {
        data: {}
      };

      var chainRequests = function chainRequests(url) {
        return fetch(url).then().then(function (response) {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          return response.text();
        }).then(function (payload) {
          payload = JSON.parse(payload);
          Object.keys(payload.data).forEach(function (key) {
            combined.data[key] = (combined.data[key] || []).concat(payload.data[key]);
          });

          if (payload.next) {
            return chainRequests(payload.next);
          }

          return combined;
        });
      };

      return chainRequests(url);
    }
  }]);

  return LDServer;
}(BaseApiAdapter);
/**
 * Data source for GWAS catalogs of known variants
 * @public
 * @class
 * @param {Object|String} init Configuration (URL or object)
 * @param {Object} [init.params] Optional configuration parameters
 * @param {Number} [init.params.source=2] The ID of the chosen catalog. Defaults to EBI GWAS catalog, GRCh37
 * @param {('strict'|'loose')} [init.params.match_type='strict'] Whether to match on exact variant, or just position.
 */


var GwasCatalogLZ = /*#__PURE__*/function (_BaseApiAdapter3) {
  _inherits(GwasCatalogLZ, _BaseApiAdapter3);

  var _super4 = _createSuper(GwasCatalogLZ);

  function GwasCatalogLZ(config) {
    var _this4;

    _classCallCheck(this, GwasCatalogLZ);

    _this4 = _super4.call(this, config);
    _this4.__dependentSource = true;
    return _this4;
  }

  _createClass(GwasCatalogLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      // This is intended to be aligned with another source- we will assume they are always ordered by position, asc
      //  (regardless of the actual match field)
      var build_option = state.genome_build || this.params.build;
      validateBuildSource(this.constructor.name, build_option, null); // Source can override build- not mutually exclusive
      // Most of our annotations will respect genome build before any other option.
      //   But there can be more than one GWAS catalog version available in the same API, for the same build- an
      //   explicit config option will always take
      //   precedence.
      // See: http://portaldev.sph.umich.edu/api/v1/annotation/gwascatalog/?format=objects

      var default_source = build_option === 'GRCh38' ? 5 : 6; // EBI GWAS catalog

      var source = this.params.source || default_source;
      return "".concat(this.url, "?format=objects&sort=pos&filter=id eq ").concat(source, " and chrom eq '").concat(state.chr, "' and pos ge ").concat(state.start, " and pos le ").concat(state.end);
    }
  }, {
    key: "findMergeFields",
    value: function findMergeFields(records) {
      // Data from previous sources is already namespaced. Find the alignment field by matching.
      var knownFields = Object.keys(records); // Note: All API endoints involved only give results for 1 chromosome at a time; match is implied

      var posMatch = knownFields.find(function (item) {
        return item.match(/\b(position|pos)\b/i);
      });

      if (!posMatch) {
        throw new Error('Could not find data to align with GWAS catalog results');
      }

      return {
        'pos': posMatch
      };
    }
  }, {
    key: "extractFields",
    value: function extractFields(data, fields, outnames, trans) {
      // Skip the "individual field extraction" step; extraction will be handled when building chain body instead
      return data;
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      if (!data.length) {
        return chain.body;
      } //  TODO: Better reuse options in the future. This source is very specifically tied to the PortalDev API, where
      //   the field name is always "log_pvalue". Relatively few sites will write their own gwas-catalog endpoint.


      var decider = 'log_pvalue';
      var decider_out = outnames[fields.indexOf(decider)];

      function leftJoin(left, right, fields, outnames, trans) {
        // Add `fields` from `right` to `left`
        // Add a synthetic, un-namespaced field to all matching records
        var n_matches = left['n_catalog_matches'] || 0;
        left['n_catalog_matches'] = n_matches + 1;

        if (decider && left[decider_out] && left[decider_out] > right[decider]) {
          // There may be more than one GWAS catalog entry for the same SNP. This source is intended for a 1:1
          //  annotation scenario, so for now it only joins the catalog entry that has the best -log10 pvalue
          return;
        }

        for (var _j = 0; _j < fields.length; _j++) {
          var fn = fields[_j];
          var outn = outnames[_j];
          var val = right[fn];

          if (trans && trans[_j]) {
            val = trans[_j](val);
          }

          left[outn] = val;
        }
      }

      var chainNames = this.findMergeFields(chain.body[0]);
      var catNames = this.findMergeFields(data[0]);
      var i = 0,
          j = 0;

      while (i < chain.body.length && j < data.length) {
        var left = chain.body[i];
        var right = data[j];

        if (left[chainNames.pos] === right[catNames.pos]) {
          // There may be multiple catalog entries for each matching SNP; evaluate match one at a time
          leftJoin(left, right, fields, outnames, trans);
          j += 1;
        } else if (left[chainNames.pos] < right[catNames.pos]) {
          i += 1;
        } else {
          j += 1;
        }
      }

      return chain.body;
    }
  }]);

  return GwasCatalogLZ;
}(BaseApiAdapter);
/**
 * Data Source for Gene Data, as fetched from the LocusZoom/Portaldev API server (or compatible format)
 * @public
 */


var GeneLZ = /*#__PURE__*/function (_BaseApiAdapter4) {
  _inherits(GeneLZ, _BaseApiAdapter4);

  var _super5 = _createSuper(GeneLZ);

  function GeneLZ() {
    _classCallCheck(this, GeneLZ);

    return _super5.apply(this, arguments);
  }

  _createClass(GeneLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var build = state.genome_build || this.params.build;
      var source = this.params.source;
      validateBuildSource(this.constructor.name, build, source);

      if (build) {
        // If build specified, we auto-select the best current portaldev API dataset for that build
        // If build is not specified, we use the exact source ID provided by the user.
        // See: https://portaldev.sph.umich.edu/api/v1/annotation/genes/sources/?format=objects
        source = build === 'GRCh38' ? 4 : 5;
      }

      return "".concat(this.url, "?filter=source in ").concat(source, " and chrom eq '").concat(state.chr, "' and start le ").concat(state.end, " and end ge ").concat(state.start);
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      // Genes have a very complex internal data format. Bypass any record parsing, and provide the data layer with
      // the exact information returned by the API. (ignoring the fields array in the layout)
      return data;
    }
  }, {
    key: "extractFields",
    value: function extractFields(data, fields, outnames, trans) {
      return data;
    }
  }]);

  return GeneLZ;
}(BaseApiAdapter);
/**
 * Data Source for Gene Constraint Data, as fetched from the gnomAD server (or compatible)
 *
 * This is intended to be the second request in a chain, with special logic that connects it to Genes data
 *  already fetched.
 *
 * @public
*/


var GeneConstraintLZ = /*#__PURE__*/function (_BaseApiAdapter5) {
  _inherits(GeneConstraintLZ, _BaseApiAdapter5);

  var _super6 = _createSuper(GeneConstraintLZ);

  function GeneConstraintLZ(config) {
    var _this5;

    _classCallCheck(this, GeneConstraintLZ);

    _this5 = _super6.call(this, config);
    _this5.__dependentSource = true;
    return _this5;
  }

  _createClass(GeneConstraintLZ, [{
    key: "getURL",
    value: function getURL() {
      // GraphQL API: request details are encoded in the body, not the URL
      return this.url;
    }
  }, {
    key: "getCacheKey",
    value: function getCacheKey(state, chain, fields) {
      var build = state.genome_build || this.params.build; // GraphQL API: request not defined solely by the URL
      // Gather the state params that govern constraint query for a given region.

      return "".concat(this.url, " ").concat(state.chr, " ").concat(state.start, " ").concat(state.end, " ").concat(build);
    }
  }, {
    key: "normalizeResponse",
    value: function normalizeResponse(data) {
      return data;
    }
  }, {
    key: "fetchRequest",
    value: function fetchRequest(state, chain, fields) {
      var build = state.genome_build || this.params.build;

      if (!build) {
        throw new Error("Data source ".concat(this.constructor.name, " must specify a 'genome_build' option"));
      }

      var unique_gene_names = chain.body.reduce( // In rare cases, the same gene symbol may appear at multiple positions. (issue #179) We de-duplicate the
      //  gene names to avoid issuing a malformed GraphQL query.
      function (acc, gene) {
        acc[gene.gene_name] = null;
        return acc;
      }, {});
      var query = Object.keys(unique_gene_names).map(function (gene_name) {
        // GraphQL alias names must match a specific set of allowed characters: https://stackoverflow.com/a/45757065/1422268
        var alias = "_".concat(gene_name.replace(/[^A-Za-z0-9_]/g, '_')); // Each gene symbol is a separate graphQL query, grouped into one request using aliases

        return "".concat(alias, ": gene(gene_symbol: \"").concat(gene_name, "\", reference_genome: ").concat(build, ") { gnomad_constraint { exp_syn obs_syn syn_z oe_syn oe_syn_lower oe_syn_upper exp_mis obs_mis mis_z oe_mis oe_mis_lower oe_mis_upper exp_lof obs_lof pLI oe_lof oe_lof_lower oe_lof_upper } } ");
      });

      if (!query.length) {
        // If there are no genes, skip the network request
        return Promise.resolve({
          data: null
        });
      }

      query = "{".concat(query.join(' '), " }"); // GraphQL isn't quite JSON; items are separated by spaces but not commas

      var url = this.getURL(state, chain, fields); // See: https://graphql.org/learn/serving-over-http/

      var body = JSON.stringify({
        query: query
      });
      var headers = {
        'Content-Type': 'application/json'
      }; // FIXME: The gnomAD API sometimes has temporary CORS changes that temporarily break the genes track
      // If request blocked, return  a fake "no data" signal so the genes track can still render w/o constraint info

      return fetch(url, {
        method: 'POST',
        body: body,
        headers: headers
      }).then(function (response) {
        if (!response.ok) {
          return [];
        }

        return response.text();
      })["catch"](function (err) {
        return [];
      });
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(data, chain, fields, outnames, trans) {
      if (!data) {
        return chain;
      }

      chain.body.forEach(function (gene) {
        // Find payload keys that match gene names in this response
        var alias = "_".concat(gene.gene_name.replace(/[^A-Za-z0-9_]/g, '_')); // aliases are modified gene names

        var constraint = data[alias] && data[alias]['gnomad_constraint']; // gnomad API has two ways of specifying missing data for a requested gene

        if (constraint) {
          // Add all fields from constraint data- do not override fields present in the gene source
          Object.keys(constraint).forEach(function (key) {
            var val = constraint[key];

            if (typeof gene[key] === 'undefined') {
              if (typeof val == 'number' && val.toString().includes('.')) {
                val = parseFloat(val.toFixed(2));
              }

              gene[key] = val; // These two sources are both designed to bypass namespacing
            }
          });
        }
      });
      return chain.body;
    }
  }]);

  return GeneConstraintLZ;
}(BaseApiAdapter);
/**
 * Data Source for Recombination Rate Data, as fetched from the LocusZoom API server (or compatible)
 * @public
 */


var RecombLZ = /*#__PURE__*/function (_BaseApiAdapter6) {
  _inherits(RecombLZ, _BaseApiAdapter6);

  var _super7 = _createSuper(RecombLZ);

  function RecombLZ() {
    _classCallCheck(this, RecombLZ);

    return _super7.apply(this, arguments);
  }

  _createClass(RecombLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var build = state.genome_build || this.params.build;
      var source = this.params.source;
      validateBuildSource(this.constructor.SOURCE_NAME, build, source);

      if (build) {
        // If build specified, choose a known Portal API dataset IDs (build 37/38)
        source = build === 'GRCh38' ? 16 : 15;
      }

      return "".concat(this.url, "?filter=id in ").concat(source, " and chromosome eq '").concat(state.chr, "' and position le ").concat(state.end, " and position ge ").concat(state.start);
    }
  }]);

  return RecombLZ;
}(BaseApiAdapter);
/**
 * Data Source for static blobs of data as raw JS objects. This does not perform additional parsing, and it bypasses
 * namespaces. Therefore it is the responsibility of the user to pass information in a format that can be read and
 * understood by the chosen plot- a StaticJSON source is rarely a drop-in replacement.
 *
 * This source is largely here for legacy reasons. More often, a convenient way to serve static data is as separate
 *  JSON files to an existing source (with the JSON url in place of an API).
 * @public
 */


var StaticSource = /*#__PURE__*/function (_BaseAdapter2) {
  _inherits(StaticSource, _BaseAdapter2);

  var _super8 = _createSuper(StaticSource);

  function StaticSource() {
    _classCallCheck(this, StaticSource);

    return _super8.apply(this, arguments);
  }

  _createClass(StaticSource, [{
    key: "parseInit",
    value: function parseInit(data) {
      // Does not receive any config; the only argument is the raw data, embedded when source is created
      this._data = data;
    }
  }, {
    key: "getRequest",
    value: function getRequest(state, chain, fields) {
      return Promise.resolve(this._data);
    }
  }]);

  return StaticSource;
}(BaseAdapter);
/**
 * Data source for PheWAS data retrieved from a LocusZoom/PortalDev compatible API
 * @public
 * @param {String[]} init.params.build This datasource expects to be provided the name of the genome build that will
 *   be used to provide pheWAS results for this position. Note positions may not translate between builds.
 */


var PheWASLZ = /*#__PURE__*/function (_BaseApiAdapter7) {
  _inherits(PheWASLZ, _BaseApiAdapter7);

  var _super9 = _createSuper(PheWASLZ);

  function PheWASLZ() {
    _classCallCheck(this, PheWASLZ);

    return _super9.apply(this, arguments);
  }

  _createClass(PheWASLZ, [{
    key: "getURL",
    value: function getURL(state, chain, fields) {
      var build = (state.genome_build ? [state.genome_build] : null) || this.params.build;

      if (!build || !Array.isArray(build) || !build.length) {
        throw new Error(['Data source', this.constructor.SOURCE_NAME, 'requires that you specify array of one or more desired genome build names'].join(' '));
      }

      var url = [this.url, "?filter=variant eq '", encodeURIComponent(state.variant), "'&format=objects&", build.map(function (item) {
        return "build=".concat(encodeURIComponent(item));
      }).join('&')];
      return url.join('');
    }
  }]);

  return PheWASLZ;
}(BaseApiAdapter);
/**
 * Base class for "connectors"- this is meant to be subclassed, rather than used directly.
 *
 * A connector is a source that makes no server requests and caches no data of its own. Instead, it decides how to
 *  combine data from other sources in the chain. Connectors are useful when we want to request (or calculate) some
 *  useful piece of information once, but apply it to many different kinds of record types.
 *
 * Typically, a subclass will implement the field merging logic in `combineChainBody`.
 *
 * @public
 * @param {Object} init Configuration for this source
 * @param {Object} init.sources Specify how the hard-coded logic should find the data it relies on in the chain,
 *  as {internal_name: chain_source_id} pairs. This allows writing a reusable connector that does not need to make
 *  assumptions about what namespaces a source is using.
 * @type {*|Function}
 */


var ConnectorSource = /*#__PURE__*/function (_BaseAdapter3) {
  _inherits(ConnectorSource, _BaseAdapter3);

  var _super10 = _createSuper(ConnectorSource);

  function ConnectorSource(config) {
    var _this6;

    _classCallCheck(this, ConnectorSource);

    _this6 = _super10.call(this, config);

    if (!config || !config.sources) {
      throw new Error('Connectors must specify the data they require as init.sources = {internal_name: chain_source_id}} pairs');
    }
    /**
     * Tells the connector how to find the data it relies on
     *
     * For example, a connector that applies burden test information to the genes layer might specify:
     *  {gene_ns: "gene", aggregation_ns: "aggregation"}
     *
     * @member {Object}
     */


    _this6._source_name_mapping = config.sources; // Validate that this source has been told how to find the required information

    var specified_ids = Object.keys(config.sources);
    /** @property {String[]} Specifies the sources that must be provided in the original config object */

    _this6._getRequiredSources().forEach(function (k) {
      if (!specified_ids.includes(k)) {
        // TODO: Fix constructor.name usage in minified bundles
        throw new Error("Configuration for ".concat(_this6.constructor.name, " must specify a source ID corresponding to ").concat(k));
      }
    });

    return _this6;
  } // Stub- connectors don't have their own url or data, so the defaults don't make sense


  _createClass(ConnectorSource, [{
    key: "parseInit",
    value: function parseInit() {}
  }, {
    key: "getRequest",
    value: function getRequest(state, chain, fields) {
      var _this7 = this;

      // Connectors do not request their own data by definition, but they *do* depend on other sources having been loaded
      //  first. This method performs basic validation, and preserves the accumulated body from the chain so far.
      Object.keys(this._source_name_mapping).forEach(function (ns) {
        var chain_source_id = _this7._source_name_mapping[ns];

        if (chain.discrete && !chain.discrete[chain_source_id]) {
          throw new Error("".concat(_this7.constructor.name, " cannot be used before loading required data for: ").concat(chain_source_id));
        }
      });
      return Promise.resolve(chain.body || []);
    }
  }, {
    key: "parseResponse",
    value: function parseResponse(data, chain, fields, outnames, trans) {
      // A connector source does not update chain.discrete, but it may use it. It bypasses data formatting
      //  and field selection (both are assumed to have been done already, by the previous sources this draws from)
      // Because of how the chain works, connectors are not very good at applying new transformations or namespacing.
      // Typically connectors are called with `connector_name:all` in the fields array.
      return Promise.resolve(this.combineChainBody(data, chain, fields, outnames, trans)).then(function (new_body) {
        return {
          header: chain.header || {},
          discrete: chain.discrete || {},
          body: new_body
        };
      });
    }
  }, {
    key: "combineChainBody",
    value: function combineChainBody(records, chain) {
      // Stub method: specifies how to combine the data
      throw new Error('This method must be implemented in a subclass');
    }
    /**
     * Helper method since ES6 doesn't support class fields
     * @private
     */

  }, {
    key: "_getRequiredSources",
    value: function _getRequiredSources() {
      throw new Error('Must specify an array that identifes the kind of data required by this source');
    }
  }]);

  return ConnectorSource;
}(BaseAdapter);




/***/ }),

/***/ "./esm/data/field.js":
/*!***************************!*\
  !*** ./esm/data/field.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Field; });
/* harmony import */ var _registry_transforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry/transforms */ "./esm/registry/transforms.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */

/**
 * Represents an addressable unit of data from a namespaced datasource, subject to specified value transformations.
 *
 * When used by a data layer, fields will automatically be re-fetched from the appropriate data source whenever the
 *   state of a plot fetches, eg pan or zoom operations that would affect what data is displayed.
 *
 * @private
 * @class
 * @param {String} field A string representing the namespace of the datasource, the name of the desired field to fetch
 *   from that datasource, and arbitrarily many transformations to apply to the value. The namespace and
 *   transformation(s) are optional and information is delimited according to the general syntax
 *   `[namespace:]name[|transformation][|transformation]`. For example, `association:pvalue|neglog10`
 */

var Field = /*#__PURE__*/function () {
  function Field(field) {
    var _this = this;

    _classCallCheck(this, Field);

    var parts = /^(?:([^:]+):)?([^:|]*)(\|.+)*$/.exec(field);
    /** @member {String} */

    this.full_name = field;
    /** @member {String} */

    this.namespace = parts[1] || null;
    /** @member {String} */

    this.name = parts[2] || null;
    /** @member {Array} */

    this.transformations = [];

    if (typeof parts[3] == 'string' && parts[3].length > 1) {
      this.transformations = parts[3].substring(1).split('|');
      this.transformations.forEach(function (transform, i) {
        return _this.transformations[i] = _registry_transforms__WEBPACK_IMPORTED_MODULE_0__["default"].get(transform);
      });
    }
  }

  _createClass(Field, [{
    key: "_applyTransformations",
    value: function _applyTransformations(val) {
      this.transformations.forEach(function (transform) {
        val = transform(val);
      });
      return val;
    }
    /**
     * Resolve the field for a given data element.
     *   First look for a full match with transformations already applied by the data requester.
     *   Otherwise prefer a namespace match and fall back to just a name match, applying transformations on the fly.
     * @param {Object} data Returned data/fields into for this element
     * @param {Object} [extra] User-applied annotations for this point (info not provided by the server that we want
     *  to preserve across re-renders). Example usage: "should_show_label"
     * @returns {*}
     */

  }, {
    key: "resolve",
    value: function resolve(data, extra) {
      if (typeof data[this.full_name] == 'undefined') {
        // Check for cached result
        var val = null;

        if (typeof data["".concat(this.namespace, ":").concat(this.name)] != 'undefined') {
          // Fallback: value sans transforms
          val = data["".concat(this.namespace, ":").concat(this.name)];
        } else if (typeof data[this.name] != 'undefined') {
          // Fallback: value present without namespace
          val = data[this.name];
        } else if (extra && typeof extra[this.full_name] != 'undefined') {
          // Fallback: check annotations
          val = extra[this.full_name];
        } // We should really warn if no value found, but many bad layouts exist and this could break compatibility


        data[this.full_name] = this._applyTransformations(val);
      }

      return data[this.full_name];
    }
  }]);

  return Field;
}();



/***/ }),

/***/ "./esm/data/index.js":
/*!***************************!*\
  !*** ./esm/data/index.js ***!
  \***************************/
/*! exports provided: default, BaseAdapter, BaseApiAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sources */ "./esm/data/sources.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _sources__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _adapters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters */ "./esm/data/adapters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseAdapter", function() { return _adapters__WEBPACK_IMPORTED_MODULE_1__["BaseAdapter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseApiAdapter", function() { return _adapters__WEBPACK_IMPORTED_MODULE_1__["BaseApiAdapter"]; });

/**
 * Data methods and instances intended to be used publicly by third-party users
 * @module
 * @private
 */



/***/ }),

/***/ "./esm/data/requester.js":
/*!*******************************!*\
  !*** ./esm/data/requester.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./esm/registry/index.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *  @module
 *  @private
 */

/**
 * The Requester manages fetching of data across multiple data sources. It is used internally by LocusZoom data layers.
 *   It passes state information and ensures that data is formatted in the manner expected by the plot.
 *
 * This object is not part of the public interface. It should almost **never** be replaced or modified directly.
 *
 * It is also responsible for constructing a "chain" of dependent requests, by requesting each datasource
 *   sequentially in the order specified in the datalayer `fields` array. Data sources are only chained within a
 *   data layer, and only if that layer requests more than one kind of data source.
 * @param {DataSources} sources A set of data sources used specifically by this plot instance
 * @private
 */

var Requester = /*#__PURE__*/function () {
  function Requester(sources) {
    _classCallCheck(this, Requester);

    this._sources = sources;
  }

  _createClass(Requester, [{
    key: "__split_requests",
    value: function __split_requests(fields) {
      // Given a fields array, return an object specifying what datasource names the data layer should make requests
      //  to, and how to handle the returned data
      var requests = {}; // Regular expression finds namespace:field|trans

      var re = /^(?:([^:]+):)?([^:|]*)(\|.+)*$/;
      fields.forEach(function (raw) {
        var parts = re.exec(raw);
        var ns = parts[1] || 'base';
        var field = parts[2];
        var trans = _registry__WEBPACK_IMPORTED_MODULE_0__["TRANSFORMS"].get(parts[3]);

        if (typeof requests[ns] == 'undefined') {
          requests[ns] = {
            outnames: [],
            fields: [],
            trans: []
          };
        }

        requests[ns].outnames.push(raw);
        requests[ns].fields.push(field);
        requests[ns].trans.push(trans);
      });
      return requests;
    }
    /**
     * Fetch data, and create a chain that only connects two data sources if they depend on each other
     * @param {Object} state The current "state" of the plot, such as chromosome and start/end positions
     * @param {String[]} fields The list of data fields specified in the `layout` for a specific data layer
     * @returns {Promise}
     */

  }, {
    key: "getData",
    value: function getData(state, fields) {
      var _this = this;

      var requests = this.__split_requests(fields); // Create an array of functions that, when called, will trigger the request to the specified datasource


      var request_handles = Object.keys(requests).map(function (key) {
        if (!_this._sources.get(key)) {
          throw new Error("Datasource for namespace ".concat(key, " not found"));
        }

        return _this._sources.get(key).getData(state, requests[key].fields, requests[key].outnames, requests[key].trans);
      }); //assume the fields are requested in dependent order
      //TODO: better manage dependencies

      var ret = Promise.resolve({
        header: {},
        body: [],
        discrete: {}
      });

      for (var i = 0; i < request_handles.length; i++) {
        // If a single datalayer uses multiple sources, perform the next request when the previous one completes
        ret = ret.then(request_handles[i]);
      }

      return ret;
    }
  }]);

  return Requester;
}();

/* harmony default export */ __webpack_exports__["default"] = (Requester);

/***/ }),

/***/ "./esm/data/sources.js":
/*!*****************************!*\
  !*** ./esm/data/sources.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _registry_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry/base */ "./esm/registry/base.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./esm/registry/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** @module */


/**
 * Create and coordinate an ensemble of (namespaced) data source instances
 * This is the mechanism by which users create data sources for a specific plot, and should be considered part of the
 *  public interface for LocusZoom.
 *
 * @public
 */

var DataSources = /*#__PURE__*/function (_RegistryBase) {
  _inherits(DataSources, _RegistryBase);

  var _super = _createSuper(DataSources);

  /**
   * @param {RegistryBase} [registry] Primarily used for unit testing. When creating sources by name, specify where to
   *  find the registry of known sources.
   */
  function DataSources(registry) {
    var _this;

    _classCallCheck(this, DataSources);

    _this = _super.call(this); // This both acts as a registry (of the instantiated sources for this plot), and references a registry
    //   (to locate adapter classes by name, when creating from config)

    _this._registry = registry || _registry__WEBPACK_IMPORTED_MODULE_1__["ADAPTERS"];
    return _this;
  }
  /**
   * For data sources, there is a special behavior of "create item from config, then add"
   * @param {String} namespace Uniquely identify this datasource
   * @param {BaseAdapter|Array} item An instantiated datasource, or an array of arguments that can be used to
   *   create a known datasource type.
   * @param [override=false] Whether to allow existing sources to be redefined
   * @return {DataSources} Most registries return the created instance, but this registry returns a reference to
   *  itself (to support chaining)
   */


  _createClass(DataSources, [{
    key: "add",
    value: function add(namespace, item) {
      var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (this._registry.has(namespace)) {
        throw new Error("The namespace ".concat(namespace, " is already in use by another source"));
      }

      if (namespace.match(/[^A-Za-z0-9_]/)) {
        throw new Error("Data source namespace names can only contain alphanumeric characters or underscores. Invalid name: ".concat(namespace));
      }

      if (Array.isArray(item)) {
        var _item = item,
            _item2 = _slicedToArray(_item, 2),
            type = _item2[0],
            options = _item2[1];

        item = this._registry.create(type, options);
      } // Each datasource in the chain should be aware of its assigned namespace


      item.source_id = namespace;

      _get(_getPrototypeOf(DataSources.prototype), "add", this).call(this, namespace, item, override);

      return this;
    }
  }]);

  return DataSources;
}(_registry_base__WEBPACK_IMPORTED_MODULE_0__["RegistryBase"]);

/* harmony default export */ __webpack_exports__["default"] = (DataSources);

/***/ }),

/***/ "./esm/helpers/common.js":
/*!*******************************!*\
  !*** ./esm/helpers/common.js ***!
  \*******************************/
/*! exports provided: applyStyles, debounce, generateCurtain, generateLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return applyStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateCurtain", function() { return generateCurtain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateLoader", function() { return generateLoader; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * @module
 * @private
 */
// FIXME: A place for code that used to live under the `LocusZoom` namespace
// Eventually this should be moved into classes or some other mechanism for code sharing. No external uses should
//  depend on any items in this module.

/**
 * Generate a curtain object for a plot, panel, or any other subdivision of a layout
 * The panel curtain, like the plot curtain is an HTML overlay that obscures the entire panel. It can be styled
 *   arbitrarily and display arbitrary messages. It is useful for reporting error messages visually to an end user
 *   when the error renders the panel unusable.
 *   TODO: Improve type doc here
 * @returns {object}
 */

function generateCurtain() {
  var _this = this;

  return {
    showing: false,
    selector: null,
    content_selector: null,
    hide_delay: null,

    /**
     * Generate the curtain. Any content (string) argument passed will be displayed in the curtain as raw HTML.
     *   CSS (object) can be passed which will apply styles to the curtain and its content.
     * @param {string} content Content to be displayed on the curtain (as raw HTML)
     * @param {object} css Apply the specified styles to the curtain and its contents
     */
    show: function show(content, css) {
      if (!_this.curtain.showing) {
        _this.curtain.selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"](_this.parent_plot.svg.node().parentNode).insert('div').attr('class', 'lz-curtain').attr('id', "".concat(_this.id, ".curtain"));
        _this.curtain.content_selector = _this.curtain.selector.append('div').attr('class', 'lz-curtain-content');

        _this.curtain.selector.append('div').attr('class', 'lz-curtain-dismiss').html('Dismiss').on('click', function () {
          return _this.curtain.hide();
        });

        _this.curtain.showing = true;
      }

      return _this.curtain.update(content, css);
    },

    /**
     * Update the content and css of the curtain that's currently being shown. This method also adjusts the size
     *   and positioning of the curtain to ensure it still covers the entire panel with no overlap.
     * @param {string} content Content to be displayed on the curtain (as raw HTML)
     * @param {object} css Apply the specified styles to the curtain and its contents
     */
    update: function update(content, css) {
      if (!_this.curtain.showing) {
        return _this.curtain;
      }

      clearTimeout(_this.curtain.hide_delay); // Apply CSS if provided

      if (_typeof(css) == 'object') {
        applyStyles(_this.curtain.selector, css);
      } // Update size and position


      var page_origin = _this._getPageOrigin();

      _this.curtain.selector.style('top', "".concat(page_origin.y, "px")).style('left', "".concat(page_origin.x, "px")).style('width', "".concat(_this.layout.width, "px")).style('height', "".concat(_this.layout.height, "px"));

      _this.curtain.content_selector.style('max-width', "".concat(_this.layout.width - 40, "px")).style('max-height', "".concat(_this.layout.height - 40, "px")); // Apply content if provided


      if (typeof content == 'string') {
        _this.curtain.content_selector.html(content);
      }

      return _this.curtain;
    },

    /**
     * Remove the curtain
     * @param {number} delay Time to wait (in ms)
     */
    hide: function hide(delay) {
      if (!_this.curtain.showing) {
        return _this.curtain;
      } // If a delay was passed then defer to a timeout


      if (typeof delay == 'number') {
        clearTimeout(_this.curtain.hide_delay);
        _this.curtain.hide_delay = setTimeout(_this.curtain.hide, delay);
        return _this.curtain;
      } // Remove curtain


      _this.curtain.selector.remove();

      _this.curtain.selector = null;
      _this.curtain.content_selector = null;
      _this.curtain.showing = false;
      return _this.curtain;
    }
  };
}
/**
 * Generate a loader object for a plot, panel, or any other subdivision of a layout
 *
 * The panel loader is a small HTML overlay that appears in the lower left corner of the panel. It cannot be styled
 *   arbitrarily, but can show a custom message and show a minimalist loading bar that can be updated to specific
 *   completion percentages or be animated.
 * TODO Improve type documentation
 * @returns {object}
 */


function generateLoader() {
  var _this2 = this;

  return {
    showing: false,
    selector: null,
    content_selector: null,
    progress_selector: null,
    cancel_selector: null,

    /**
     * Show a loading indicator
     * @param {string} [content='Loading...'] Loading message (displayed as raw HTML)
     */
    show: function show(content) {
      // Generate loader
      if (!_this2.loader.showing) {
        _this2.loader.selector = d3__WEBPACK_IMPORTED_MODULE_0__["select"](_this2.parent_plot.svg.node().parentNode).insert('div').attr('class', 'lz-loader').attr('id', "".concat(_this2.id, ".loader"));
        _this2.loader.content_selector = _this2.loader.selector.append('div').attr('class', 'lz-loader-content');
        _this2.loader.progress_selector = _this2.loader.selector.append('div').attr('class', 'lz-loader-progress-container').append('div').attr('class', 'lz-loader-progress');
        _this2.loader.showing = true;

        if (typeof content == 'undefined') {
          content = 'Loading...';
        }
      }

      return _this2.loader.update(content);
    },

    /**
     * Update the currently displayed loader and ensure the new content is positioned correctly.
     * @param {string} content The text to display (as raw HTML). If not a string, will be ignored.
     * @param {number} [percent] A number from 1-100. If a value is specified, it will stop all animations
     *   in progress.
     */
    update: function update(content, percent) {
      if (!_this2.loader.showing) {
        return _this2.loader;
      }

      clearTimeout(_this2.loader.hide_delay); // Apply content if provided

      if (typeof content == 'string') {
        _this2.loader.content_selector.html(content);
      } // Update size and position


      var padding = 6; // is there a better place to store/define this?

      var page_origin = _this2._getPageOrigin();

      var loader_boundrect = _this2.loader.selector.node().getBoundingClientRect();

      _this2.loader.selector.style('top', "".concat(page_origin.y + _this2.layout.height - loader_boundrect.height - padding, "px")).style('left', "".concat(page_origin.x + padding, "px"));
      /* Uncomment this code when a functional cancel button can be shown
      var cancel_boundrect = this.loader.cancel_selector.node().getBoundingClientRect();
      this.loader.content_selector.style({
          "padding-right": (cancel_boundrect.width + padding) + "px"
      });
      */
      // Apply percent if provided


      if (typeof percent == 'number') {
        _this2.loader.progress_selector.style('width', "".concat(Math.min(Math.max(percent, 1), 100), "%"));
      }

      return _this2.loader;
    },

    /**
     * Adds a class to the loading bar that makes it loop infinitely in a loading animation. Useful when exact
     *   percent progress is not available.
     */
    animate: function animate() {
      _this2.loader.progress_selector.classed('lz-loader-progress-animated', true);

      return _this2.loader;
    },

    /**
     *  Sets the loading bar in the loader to percentage width equal to the percent (number) value passed. Percents
     *    will automatically be limited to a range of 1 to 100. Will stop all animations in progress.
     */
    setPercentCompleted: function setPercentCompleted(percent) {
      _this2.loader.progress_selector.classed('lz-loader-progress-animated', false);

      return _this2.loader.update(null, percent);
    },

    /**
     * Remove the loader
     * @param {number} delay Time to wait (in ms)
     */
    hide: function hide(delay) {
      if (!_this2.loader.showing) {
        return _this2.loader;
      } // If a delay was passed then defer to a timeout


      if (typeof delay == 'number') {
        clearTimeout(_this2.loader.hide_delay);
        _this2.loader.hide_delay = setTimeout(_this2.loader.hide, delay);
        return _this2.loader;
      } // Remove loader


      _this2.loader.selector.remove();

      _this2.loader.selector = null;
      _this2.loader.content_selector = null;
      _this2.loader.progress_selector = null;
      _this2.loader.cancel_selector = null;
      _this2.loader.showing = false;
      return _this2.loader;
    }
  };
}
/**
 * Modern d3 removed the ability to set many styles at once (object syntax). This is a helper so that layouts with
 *  config-objects can set styles all at once
 * @private
 * @param {d3.selection} selection
 * @param {Object} styles
 */


function applyStyles(selection, styles) {
  styles = styles || {};

  for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        prop = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    selection.style(prop, value);
  }
}
/**
 * Prevent a UI function from being called more than once in a given interval. This allows, eg, search boxes to delay
 *   expensive operations until the user is done typing
 * @param {function} func The function to debounce. Returns a wrapper.
 * @param {number} delay Time to wait after last call (in ms)
 */


function debounce(func) {
  var _arguments = arguments,
      _this3 = this;

  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var timer;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(function () {
      return func.apply(_this3, _arguments);
    }, delay);
  };
}



/***/ }),

/***/ "./esm/helpers/display.js":
/*!********************************!*\
  !*** ./esm/helpers/display.js ***!
  \********************************/
/*! exports provided: parseFields, parsePositionQuery, populate, positionIntToString, positionStringToInt, prettyTicks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFields", function() { return parseFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePositionQuery", function() { return parsePositionQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "populate", function() { return populate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionIntToString", function() { return positionIntToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionStringToInt", function() { return positionStringToInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prettyTicks", function() { return prettyTicks; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/field */ "./esm/data/field.js");
/* harmony import */ var _components_plot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/plot */ "./esm/components/plot.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ "./esm/helpers/common.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Helpers that control the display of individual points and field values
 * @module
 */




/**
 * Convert an integer chromosome position to an SI string representation (e.g. 23423456 => "23.42" (Mb))
 * @param {Number} pos Position
 * @param {Number} [exp] Exponent to use for the returned string, eg 6=> MB. If not specified, will attempt to guess
 *   the most appropriate SI prefix based on the number provided.
 * @param {Boolean} [suffix=false] Whether or not to append a suffix (e.g. "Mb") to the end of the returned string
 * @returns {string}
 */

function positionIntToString(pos, exp, suffix) {
  var exp_symbols = {
    0: '',
    3: 'K',
    6: 'M',
    9: 'G'
  };
  suffix = suffix || false;

  if (isNaN(exp) || exp === null) {
    var log = Math.log(pos) / Math.LN10;
    exp = Math.min(Math.max(log - log % 3, 0), 9);
  }

  var places_exp = exp - Math.floor((Math.log(pos) / Math.LN10).toFixed(exp + 3));
  var min_exp = Math.min(Math.max(exp, 0), 2);
  var places = Math.min(Math.max(places_exp, min_exp), 12);
  var ret = "".concat((pos / Math.pow(10, exp)).toFixed(places));

  if (suffix && typeof exp_symbols[exp] !== 'undefined') {
    ret += " ".concat(exp_symbols[exp], "b");
  }

  return ret;
}
/**
 * Convert an SI string chromosome position to an integer representation (e.g. "5.8 Mb" => 58000000)
 * @param {String} p The chromosome position
 * @returns {Number}
 */


function positionStringToInt(p) {
  var val = p.toUpperCase();
  val = val.replace(/,/g, '');
  var suffixre = /([KMG])[B]*$/;
  var suffix = suffixre.exec(val);
  var mult = 1;

  if (suffix) {
    if (suffix[1] === 'M') {
      mult = 1e6;
    } else if (suffix[1] === 'G') {
      mult = 1e9;
    } else {
      mult = 1e3; //K
    }

    val = val.replace(suffixre, '');
  }

  val = Number(val) * mult;
  return val;
}
/**
 * Generate a "pretty" set of ticks (multiples of 1, 2, or 5 on the same order of magnitude for the range)
 *   Based on R's "pretty" function: https://github.com/wch/r-source/blob/b156e3a711967f58131e23c1b1dc1ea90e2f0c43/src/appl/pretty.c
 * @param {Number[]} range A two-item array specifying [low, high] values for the axis range
 * @param {('low'|'high'|'both'|'neither')} [clip_range='neither'] What to do if first and last generated ticks extend
 *   beyond the range. Set this to "low", "high", "both", or "neither" to clip the first (low) or last (high) tick to
 *   be inside the range or allow them to extend beyond.
 *   e.g. "low" will clip the first (low) tick if it extends beyond the low end of the range but allow the
 *  last (high) tick to extend beyond the range. "both" clips both ends, "neither" allows both to extend beyond.
 * @param {Number} [target_tick_count=5] The approximate number of ticks you would like to be returned; may not be exact
 * @returns {Number[]}
 */


function prettyTicks(range, clip_range, target_tick_count) {
  if (typeof target_tick_count == 'undefined' || isNaN(parseInt(target_tick_count))) {
    target_tick_count = 5;
  }

  target_tick_count = +target_tick_count;
  var min_n = target_tick_count / 3;
  var shrink_sml = 0.75;
  var high_u_bias = 1.5;
  var u5_bias = 0.5 + 1.5 * high_u_bias;
  var d = Math.abs(range[0] - range[1]);
  var c = d / target_tick_count;

  if (Math.log(d) / Math.LN10 < -2) {
    c = Math.max(Math.abs(d)) * shrink_sml / min_n;
  }

  var base = Math.pow(10, Math.floor(Math.log(c) / Math.LN10));
  var base_toFixed = 0;

  if (base < 1 && base !== 0) {
    base_toFixed = Math.abs(Math.round(Math.log(base) / Math.LN10));
  }

  var unit = base;

  if (2 * base - c < high_u_bias * (c - unit)) {
    unit = 2 * base;

    if (5 * base - c < u5_bias * (c - unit)) {
      unit = 5 * base;

      if (10 * base - c < high_u_bias * (c - unit)) {
        unit = 10 * base;
      }
    }
  }

  var ticks = [];
  var i = parseFloat((Math.floor(range[0] / unit) * unit).toFixed(base_toFixed));

  while (i < range[1]) {
    ticks.push(i);
    i += unit;

    if (base_toFixed > 0) {
      i = parseFloat(i.toFixed(base_toFixed));
    }
  }

  ticks.push(i);

  if (typeof clip_range == 'undefined' || ['low', 'high', 'both', 'neither'].indexOf(clip_range) === -1) {
    clip_range = 'neither';
  }

  if (clip_range === 'low' || clip_range === 'both') {
    if (ticks[0] < range[0]) {
      ticks = ticks.slice(1);
    }
  }

  if (clip_range === 'high' || clip_range === 'both') {
    if (ticks[ticks.length - 1] > range[1]) {
      ticks.pop();
    }
  }

  return ticks;
}
/**
 * Replace placeholders in an html string with field values defined in a data object
 *  Only works on scalar values in data! Will ignore non-scalars. This is useful in, eg, tooltip templates.
 *
 *  NOTE: Trusts content exactly as given. XSS prevention is the responsibility of the implementer.
 * @param {Object} data
 * @param {String} html A placeholder string in which to substitute fields. Supports several template options:
 *   `{{field_name}}` is a variable placeholder for the value of `field_name` from the provided data
 *   `{{#if field_name}} Conditional text {{/if}}` will insert the contents of the tag only if the value exists.
 *     Since this is only an existence check, **variables with a value of 0 will be evaluated as true**.
 *     This can be used with namespaced values, `{{#if assoc:field}}`; any dynamic namespacing will be applied when the
 *     layout is first retrieved.
 * @returns {string}
 */


function parseFields(data, html) {
  if (_typeof(data) != 'object') {
    throw new Error('invalid arguments: data is not an object');
  }

  if (typeof html != 'string') {
    throw new Error('invalid arguments: html is not a string');
  } // `tokens` is like [token,...]
  // `token` is like {text: '...'} or {variable: 'foo|bar'} or {condition: 'foo|bar'} or {close: 'if'}


  var tokens = [];
  var regex = /{{(?:(#if )?([A-Za-z0-9_:|]+)|(\/if))}}/;

  while (html.length > 0) {
    var m = regex.exec(html);

    if (!m) {
      tokens.push({
        text: html
      });
      html = '';
    } else if (m.index !== 0) {
      tokens.push({
        text: html.slice(0, m.index)
      });
      html = html.slice(m.index);
    } else if (m[1] === '#if ') {
      tokens.push({
        condition: m[2]
      });
      html = html.slice(m[0].length);
    } else if (m[2]) {
      tokens.push({
        variable: m[2]
      });
      html = html.slice(m[0].length);
    } else if (m[3] === '/if') {
      tokens.push({
        close: 'if'
      });
      html = html.slice(m[0].length);
    } else {
      console.error("Error tokenizing tooltip when remaining template is ".concat(JSON.stringify(html), " and previous tokens are ").concat(JSON.stringify(tokens), " and current regex match is ").concat(JSON.stringify([m[1], m[2], m[3]])));
      html = html.slice(m[0].length);
    }
  }

  var astify = function astify() {
    var token = tokens.shift();

    if (typeof token.text !== 'undefined' || token.variable) {
      return token;
    } else if (token.condition) {
      token.then = [];

      while (tokens.length > 0) {
        if (tokens[0].close === 'if') {
          tokens.shift();
          break;
        }

        token.then.push(astify());
      }

      return token;
    } else {
      console.error("Error making tooltip AST due to unknown token ".concat(JSON.stringify(token)));
      return {
        text: ''
      };
    }
  }; // `ast` is like [thing,...]
  // `thing` is like {text: "..."} or {variable:"foo|bar"} or {condition: "foo|bar", then:[thing,...]}


  var ast = [];

  while (tokens.length > 0) {
    ast.push(astify());
  }

  var resolve = function resolve(variable) {
    if (!Object.prototype.hasOwnProperty.call(resolve.cache, variable)) {
      resolve.cache[variable] = new _data_field__WEBPACK_IMPORTED_MODULE_1__["default"](variable).resolve(data);
    }

    return resolve.cache[variable];
  };

  resolve.cache = {};

  var render_node = function render_node(node) {
    if (typeof node.text !== 'undefined') {
      return node.text;
    } else if (node.variable) {
      try {
        var value = resolve(node.variable);

        if (['string', 'number', 'boolean'].indexOf(_typeof(value)) !== -1) {
          return value;
        }

        if (value === null) {
          return '';
        }
      } catch (error) {
        console.error("Error while processing variable ".concat(JSON.stringify(node.variable)));
      }

      return "{{".concat(node.variable, "}}");
    } else if (node.condition) {
      try {
        var condition = resolve(node.condition);

        if (condition || condition === 0) {
          return node.then.map(render_node).join('');
        }
      } catch (error) {
        console.error("Error while processing condition ".concat(JSON.stringify(node.variable)));
      }

      return '';
    } else {
      console.error("Error rendering tooltip due to unknown AST node ".concat(JSON.stringify(node)));
    }
  };

  return ast.map(render_node).join('');
}
/**
 * Populate a single element with a LocusZoom plot. This is the primary means of generating a new plot, and is part
 *  of the public interface for LocusZoom.
 * @public
 * @param {String|d3.selection} selector CSS selector for the container element where the plot will be mounted. Any pre-existing
 *   content in the container will be completely replaced.
 * @param {DataSources} datasource Ensemble of data providers used by the plot
 * @param {Object} layout A JSON-serializable object of layout configuration parameters
 * @returns {Plot} The newly created plot instance
 */


function populate(selector, datasource, layout) {
  if (typeof selector == 'undefined') {
    throw new Error('LocusZoom.populate selector not defined');
  } // Empty the selector of any existing content


  d3__WEBPACK_IMPORTED_MODULE_0__["select"](selector).html('');
  var plot;
  d3__WEBPACK_IMPORTED_MODULE_0__["select"](selector).call(function (target) {
    // Require each containing element have an ID. If one isn't present, create one.
    if (typeof target.node().id == 'undefined') {
      var iterator = 0;

      while (!d3__WEBPACK_IMPORTED_MODULE_0__["select"]("#lz-".concat(iterator)).empty()) {
        iterator++;
      }

      target.attr('id', "#lz-".concat(iterator));
    } // Create the plot


    plot = new _components_plot__WEBPACK_IMPORTED_MODULE_2__["default"](target.node().id, datasource, layout);
    plot.container = target.node(); // Detect HTML `data-region` attribute, and use it to fill in state values if present

    if (typeof target.node().dataset !== 'undefined' && typeof target.node().dataset.region !== 'undefined') {
      var parsed_state = parsePositionQuery(target.node().dataset.region);
      Object.keys(parsed_state).forEach(function (key) {
        plot.state[key] = parsed_state[key];
      });
    } // Add an SVG to the div and set its dimensions


    plot.svg = d3__WEBPACK_IMPORTED_MODULE_0__["select"]("div#".concat(plot.id)).append('svg').attr('version', '1.1').attr('xmlns', 'http://www.w3.org/2000/svg').attr('id', "".concat(plot.id, "_svg")).attr('class', 'lz-locuszoom').call(_common__WEBPACK_IMPORTED_MODULE_3__["applyStyles"], plot.layout.style);
    plot.setDimensions();
    plot.positionPanels(); // Initialize the plot

    plot.initialize(); // If the plot has defined data sources then trigger its first mapping based on state values

    if (datasource) {
      plot.refresh();
    }
  });
  return plot;
}
/**
 * Parse region queries into their constituent parts
 * @param {String} x A chromosome position query. May be any of the forms `chr:start-end`, `chr:center+offset`,
 *   or `chr:pos`
 * @returns {{chr:*, start: *, end:*} | {chr:*, position:*}}
 */


function parsePositionQuery(x) {
  var chrposoff = /^(\w+):([\d,.]+[kmgbKMGB]*)([-+])([\d,.]+[kmgbKMGB]*)$/;
  var chrpos = /^(\w+):([\d,.]+[kmgbKMGB]*)$/;
  var match = chrposoff.exec(x);

  if (match) {
    if (match[3] === '+') {
      var center = positionStringToInt(match[2]);
      var offset = positionStringToInt(match[4]);
      return {
        chr: match[1],
        start: center - offset,
        end: center + offset
      };
    } else {
      return {
        chr: match[1],
        start: positionStringToInt(match[2]),
        end: positionStringToInt(match[4])
      };
    }
  }

  match = chrpos.exec(x);

  if (match) {
    return {
      chr: match[1],
      position: positionStringToInt(match[2])
    };
  }

  return null;
}



/***/ }),

/***/ "./esm/helpers/layouts.js":
/*!********************************!*\
  !*** ./esm/helpers/layouts.js ***!
  \********************************/
/*! exports provided: applyNamespaces, deepCopy, merge, nameToSymbol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyNamespaces", function() { return applyNamespaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepCopy", function() { return deepCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nameToSymbol", function() { return nameToSymbol; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Utilities for modifying or working with layout objects
 *  @module
 */

var sqrt3 = Math.sqrt(3); // D3 v5 does not provide a triangle down symbol shape, but it is very useful for showing direction of effect.
//  Modified from https://github.com/d3/d3-shape/blob/master/src/symbol/triangle.js

var triangledown = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, -y * 2);
    context.lineTo(-sqrt3 * y, y);
    context.lineTo(sqrt3 * y, y);
    context.closePath();
  }
};
/**
 * Apply namespaces to layout, recursively
 * @private
  */

function applyNamespaces(element, namespace, default_namespace) {
  if (namespace) {
    if (typeof namespace == 'string') {
      namespace = {
        "default": namespace
      };
    }
  } else {
    namespace = {
      "default": ''
    };
  }

  if (typeof element == 'string') {
    var re = /\{\{namespace(\[[A-Za-z_0-9]+\]|)\}\}/g;
    var match, base, key, resolved_namespace;
    var replace = [];

    while ((match = re.exec(element)) !== null) {
      base = match[0];
      key = match[1].length ? match[1].replace(/(\[|\])/g, '') : null;
      resolved_namespace = default_namespace;

      if (namespace != null && _typeof(namespace) == 'object' && typeof namespace[key] != 'undefined') {
        resolved_namespace = namespace[key] + (namespace[key].length ? ':' : '');
      }

      replace.push({
        base: base,
        namespace: resolved_namespace
      });
    }

    for (var r in replace) {
      element = element.replace(replace[r].base, replace[r].namespace);
    }
  } else if (_typeof(element) == 'object' && element != null) {
    if (typeof element.namespace != 'undefined') {
      var merge_namespace = typeof element.namespace == 'string' ? {
        "default": element.namespace
      } : element.namespace;
      namespace = merge(namespace, merge_namespace);
    }

    var namespaced_element, namespaced_property;

    for (var property in element) {
      if (property === 'namespace') {
        continue;
      }

      namespaced_element = applyNamespaces(element[property], namespace, default_namespace);
      namespaced_property = applyNamespaces(property, namespace, default_namespace);

      if (property !== namespaced_property) {
        delete element[property];
      }

      element[namespaced_property] = namespaced_element;
    }
  }

  return element;
}
/**
 * A helper method used for merging two objects. If a key is present in both, takes the value from the first object
 *   Values from `default_layout` will be cleanly copied over, ensuring no references or shared state.
 *
 * Frequently used for preparing custom layouts. Both objects should be JSON-serializable.
 *
 * @param {object} custom_layout An object containing configuration parameters that override or add to defaults
 * @param {object} default_layout An object containing default settings.
 * @returns {object} The custom layout is modified in place and also returned from this method.
 */


function merge(custom_layout, default_layout) {
  if (_typeof(custom_layout) !== 'object' || _typeof(default_layout) !== 'object') {
    throw new Error("LocusZoom.Layouts.merge only accepts two layout objects; ".concat(_typeof(custom_layout), ", ").concat(_typeof(default_layout), " given"));
  }

  for (var property in default_layout) {
    if (!Object.prototype.hasOwnProperty.call(default_layout, property)) {
      continue;
    } // Get types for comparison. Treat nulls in the custom layout as undefined for simplicity.
    // (javascript treats nulls as "object" when we just want to overwrite them as if they're undefined)
    // Also separate arrays from objects as a discrete type.


    var custom_type = custom_layout[property] === null ? 'undefined' : _typeof(custom_layout[property]);

    var default_type = _typeof(default_layout[property]);

    if (custom_type === 'object' && Array.isArray(custom_layout[property])) {
      custom_type = 'array';
    }

    if (default_type === 'object' && Array.isArray(default_layout[property])) {
      default_type = 'array';
    } // Unsupported property types: throw an exception


    if (custom_type === 'function' || default_type === 'function') {
      throw new Error('LocusZoom.Layouts.merge encountered an unsupported property type');
    } // Undefined custom value: pull the default value


    if (custom_type === 'undefined') {
      custom_layout[property] = deepCopy(default_layout[property]);
      continue;
    } // Both values are objects: merge recursively


    if (custom_type === 'object' && default_type === 'object') {
      custom_layout[property] = merge(custom_layout[property], default_layout[property]);
      continue;
    }
  }

  return custom_layout;
}

function deepCopy(item) {
  return JSON.parse(JSON.stringify(item));
}
/**
 * Convert name to symbol
 * Layout objects accept symbol names as strings (circle, triangle, etc). Convert to symbol objects.
 * @return {object|null} An object that implements a draw method (eg d3-shape symbols or extra LZ items)
 */


function nameToSymbol(shape) {
  if (!shape) {
    return null;
  }

  if (shape === 'triangledown') {
    // D3 does not provide this symbol natively
    return triangledown;
  } // Legend shape names are strings; need to connect this to factory. Eg circle --> d3.symbolCircle


  var factory_name = "symbol".concat(shape.charAt(0).toUpperCase() + shape.slice(1));
  return d3__WEBPACK_IMPORTED_MODULE_0__[factory_name] || null;
}



/***/ }),

/***/ "./esm/helpers/render.js":
/*!*******************************!*\
  !*** ./esm/helpers/render.js ***!
  \*******************************/
/*! exports provided: coalesce_scatter_points */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coalesce_scatter_points", function() { return coalesce_scatter_points; });
/**
 Helper functions targeted at rendering operations
*/

/**
 * A very simple function aimed at scatter plots: attempts to coalesce "low-significance" SNPs that are too close to
 *  visually distinguish, thus creating a dataset with fewer points that can be rendered more quickly.
 *
 *  This depends on the strong and explicit assumption that points are ordered (typically in x position), so that
 *    nearby points can be grouped by iterating over the data in sequence.
 *
 * @param {Object[]} data Plot data, annotated with calculated `xc` and `yc` symbols for x and y coordinates (in px).
 * @param {Number} x_min The smallest x value of an "insignificant region" rectangle
 * @param {Number} x_max The largest x value of an "insignificant region" rectangle
 * @param {Number} x_gap Max px distance, in x direction, from the first point in a set, to qualify for grouping
 * @param {Number} y_min The smallest y value of an "insignificant region" rectangle
 * @param {Number} y_max The largest y value of an "insignificant region" rectangle
 * @param {Number} y_gap Max px distance, in y direction, from the first point in a set, to qualify for grouping
 * @return {Object[]} The simplified dataset with fewer points
 */
function coalesce_scatter_points(data, x_min, x_max, x_gap, y_min, y_max, y_gap) {
  var final_data = [];
  var xcs = Symbol["for"]('lzX');
  var ycs = Symbol["for"]('lzY');
  var x_start = null;
  var y_start = null;
  var current_group = [];

  function _combine() {
    if (current_group.length) {
      // If there are points near each other, return the middle item to represent the group
      // We use a real point (rather than a synthetic average point) to best handle extra fields
      var item = current_group[Math.floor((current_group.length - 1) / 2)];
      final_data.push(item);
    }

    x_start = y_start = null;
    current_group = [];
  }

  function _start_run(x, y, item) {
    x_start = x;
    y_start = y;
    current_group.push(item);
  }

  data.forEach(function (item) {
    var x = item[xcs];
    var y = item[ycs];
    var in_combine_region = x >= x_min && x <= x_max && y >= y_min && y <= y_max;

    if (item.lz_highlight_match || !in_combine_region) {
      // If an item is marked as interesting in some way, always render it explicitly
      // (and coalesce the preceding points if a run was in progress, to preserve ordering)
      _combine();

      final_data.push(item);
    } else if (x_start === null) {
      // If not tracking a group, start tracking
      _start_run(x, y, item);
    } else {
      // Otherwise, the decision to render the point depends on whether it is close to a run of other
      //  insignificant points
      var near_prior = Math.abs(x - x_start) <= x_gap && Math.abs(y - y_start) <= y_gap;

      if (near_prior) {
        current_group.push(item);
      } else {
        // "if in combine region, and not near a prior point, coalesce all prior items, then track this point
        //  as part of the next run that could be grouped"
        _combine();

        _start_run(x, y, item);
      }
    }
  }); // At the end of the dataset, check whether any runs of adjacent points were in progress, and coalesce if so

  _combine();

  return final_data;
}



/***/ }),

/***/ "./esm/helpers/scalable.js":
/*!*********************************!*\
  !*** ./esm/helpers/scalable.js ***!
  \*********************************/
/*! exports provided: categorical_bin, if_value, interpolate, numerical_bin, ordinal_cycle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "categorical_bin", function() { return categorical_bin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "if_value", function() { return if_value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numerical_bin", function() { return numerical_bin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ordinal_cycle", function() { return ordinal_cycle; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Define functions used by Scalable Layout Directives.
 *
 * These "scaling functions" are used during rendering to return output (eg color) based on input value
 * @module
 */

/**
 * Basic conditional function to evaluate the value of the input field and return based on equality.
 * @param {Object} parameters
 * @param {*} parameters.field_value The value against which to test the input value.
 * @param {*} parameters.then The value to return if the input value matches the field value
 * @param {*} parameters.else  The value to return if the input value does not match the field value. Optional. If not
 *   defined this scale function will return null (or value of null_value parameter, if defined) when input value fails
 *   to match field_value.
 * @param {*} input value
 */

var if_value = function if_value(parameters, input) {
  if (typeof input == 'undefined' || parameters.field_value !== input) {
    if (typeof parameters["else"] != 'undefined') {
      return parameters["else"];
    } else {
      return null;
    }
  } else {
    return parameters.then;
  }
};
/**
 * Function to sort numerical values into bins based on numerical break points. Will only operate on numbers and
 *   return null (or value of null_value parameter, if defined) if provided a non-numeric input value. Parameters:
 * @function numerical_bin
 * @param {Object} parameters
 * @param {Number[]} parameters.breaks  Array of numerical break points against which to evaluate the input value.
 *   Must be of equal length to values parameter. If the input value is greater than or equal to break n and less than
 *   or equal to break n+1 (or break n+1 doesn't exist) then returned value is the nth entry in the values parameter.
 * @param {Array} parameters.values  Array of values to return given evaluations against break points. Must be of
 *   equal length to breaks parameter. Each entry n represents the value to return if the input value is greater than
 *   or equal to break n and less than or equal to break n+1 (or break n+1 doesn't exist).
 * @param {*} parameters.null_value
 * @param {*} input value
 * @returns {*}
 */


var numerical_bin = function numerical_bin(parameters, input) {
  var breaks = parameters.breaks || [];
  var values = parameters.values || [];

  if (typeof input == 'undefined' || input === null || isNaN(+input)) {
    return parameters.null_value ? parameters.null_value : null;
  }

  var threshold = breaks.reduce(function (prev, curr) {
    if (+input < prev || +input >= prev && +input < curr) {
      return prev;
    } else {
      return curr;
    }
  });
  return values[breaks.indexOf(threshold)];
};
/**
 * Function to sort values of any type into bins based on direct equality testing with a list of categories.
 *   Will return null if provided an input value that does not match to a listed category.
 * @function categorical_bin
 * @param {Object} parameters
 * @param {Array} parameters.categories  Array of values against which to evaluate the input value. Must be of equal
 *   length to values parameter. If the input value is equal to category n then returned value is the nth entry in the
 *   values parameter.
 * @param {Array} parameters.values  Array of values to return given evaluations against categories. Must be of equal
 *   length to categories parameter. Each entry n represents the value to return if the input value is equal to the nth
 *   value in the categories parameter.
 * @param {*} parameters.null_value  Value to return if the input value fails to match to any categories. Optional.
 */


var categorical_bin = function categorical_bin(parameters, value) {
  if (typeof value == 'undefined' || !parameters.categories.includes(value)) {
    return parameters.null_value ? parameters.null_value : null;
  } else {
    return parameters.values[parameters.categories.indexOf(value)];
  }
};
/**
 * Cycle through a set of options, so that the each element in a set of data receives a value different than the
 *  element before it. For example: "use this palette of 10 colors to visually distinguish 100 adjacent items"
 *  @param {Object} parameters
 *  @param {Array} parameters.values A list of option values
 * @return {*}
 */


var ordinal_cycle = function ordinal_cycle(parameters, value, index) {
  var options = parameters.values;
  return options[index % options.length];
};
/**
 * Function for continuous interpolation of numerical values along a gradient with arbitrarily many break points.
 * @function interpolate
 * @parameters {Object} parameters
 * @parameters {Number[]} parameters.breaks  Array of numerical break points against which to evaluate the input value.
 *   Must be of equal length to values parameter and contain at least two elements. Input value will be evaluated for
 *   relative position between two break points n and n+1 and the returned value will be interpolated at a relative
 *   position between values n and n+1.
 * @parameters {*[]} parameters.values  Array of values to interpolate and return given evaluations against break
 *   points. Must be of equal length to breaks parameter and contain at least two elements. Each entry n represents
 *   the value to return if the input value matches the nth entry in breaks exactly. Note that this scale function
 *   uses d3.interpolate to provide for effective interpolation of many different value types, including numbers,
 *   colors, shapes, etc.
 * @parameters {*} parameters.null_value
 */


var interpolate = function interpolate(parameters, input) {
  var breaks = parameters.breaks || [];
  var values = parameters.values || [];
  var nullval = parameters.null_value ? parameters.null_value : null;

  if (breaks.length < 2 || breaks.length !== values.length) {
    return nullval;
  }

  if (typeof input == 'undefined' || input === null || isNaN(+input)) {
    return nullval;
  }

  if (+input <= parameters.breaks[0]) {
    return values[0];
  } else if (+input >= parameters.breaks[parameters.breaks.length - 1]) {
    return values[breaks.length - 1];
  } else {
    var upper_idx = null;
    breaks.forEach(function (brk, idx) {
      if (!idx) {
        return;
      }

      if (breaks[idx - 1] <= +input && breaks[idx] >= +input) {
        upper_idx = idx;
      }
    });

    if (upper_idx === null) {
      return nullval;
    }

    var normalized_input = (+input - breaks[upper_idx - 1]) / (breaks[upper_idx] - breaks[upper_idx - 1]);

    if (!isFinite(normalized_input)) {
      return nullval;
    }

    return d3__WEBPACK_IMPORTED_MODULE_0__["interpolate"](values[upper_idx - 1], values[upper_idx])(normalized_input);
  }
};



/***/ }),

/***/ "./esm/helpers/transforms.js":
/*!***********************************!*\
  !*** ./esm/helpers/transforms.js ***!
  \***********************************/
/*! exports provided: log10, neglog10, logtoscinotation, scinotation, htmlescape, urlencode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log10", function() { return log10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neglog10", function() { return neglog10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logtoscinotation", function() { return logtoscinotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scinotation", function() { return scinotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "htmlescape", function() { return htmlescape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlencode", function() { return urlencode; });
/**
 * Transformation functions: used to transform a raw value from the API. For example, a template or axis label
 *  can convert from pvalue to -log10pvalue
 * @module
 */

/**
 * Return the log10 of a value. Can be composed for, eg, loglog plots.
 * @param value
 * @return {null|number}
 */
function log10(value) {
  if (isNaN(value) || value <= 0) {
    return null;
  }

  return Math.log(value) / Math.LN10;
}
/**
 * Return the -log (base 10), a common means of representing pvalues in locuszoom plots
 * @function neglog10
 */

function neglog10(value) {
  if (isNaN(value) || value <= 0) {
    return null;
  }

  return -Math.log(value) / Math.LN10;
}
/**
 * Convert a number from logarithm to scientific notation. Useful for, eg, a datasource that returns -log(p) by default
 * @function logtoscinotation
 */

function logtoscinotation(value) {
  if (isNaN(value)) {
    return 'NaN';
  }

  if (value === 0) {
    return '1';
  }

  var exp = Math.ceil(value);
  var diff = exp - value;
  var base = Math.pow(10, diff);

  if (exp === 1) {
    return (base / 10).toFixed(4);
  } else if (exp === 2) {
    return (base / 100).toFixed(3);
  } else {
    return "".concat(base.toFixed(2), " \xD7 10^-").concat(exp);
  }
}
/**
 * Represent a number in scientific notation
 * @function scinotation
 * @param {Number} value
 * @returns {String}
 */

function scinotation(value) {
  if (isNaN(value)) {
    return 'NaN';
  }

  if (value === 0) {
    return '0';
  }

  var abs = Math.abs(value);
  var log;

  if (abs > 1) {
    log = Math.ceil(Math.log(abs) / Math.LN10);
  } else {
    // 0...1
    log = Math.floor(Math.log(abs) / Math.LN10);
  }

  if (Math.abs(log) <= 3) {
    return value.toFixed(3);
  } else {
    return value.toExponential(2).replace('+', '').replace('e', ' × 10^');
  }
}
/**
 * HTML-escape user entered values for use in constructed HTML fragments
 *
 * For example, this filter can be used on tooltips with custom HTML display
 * @function htmlescape
 * @param {String} value HTML-escape the provided value
 */

function htmlescape(value) {
  if (!value) {
    return '';
  }

  value = "".concat(value);
  return value.replace(/['"<>&`]/g, function (s) {
    switch (s) {
      case "'":
        return '&#039;';

      case '"':
        return '&quot;';

      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '&':
        return '&amp;';

      case '`':
        return '&#x60;';
    }
  });
}
/**
 * URL-encode the provided text, eg for constructing hyperlinks
 * @function urlencode
 * @param {String} value
 */

function urlencode(value) {
  return encodeURIComponent(value);
}

/***/ }),

/***/ "./esm/index.js":
/*!**********************!*\
  !*** ./esm/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ "./esm/version.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./esm/data/index.js");
/* harmony import */ var _helpers_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/display */ "./esm/helpers/display.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ "./esm/registry/index.js");
/**
 * Compatibility layer: expose symbols via UMD module to match the old LocusZoom API
 * A library using this file will need to load `locuszoom.css` separately.
 */




var LocusZoom = {
  version: _version__WEBPACK_IMPORTED_MODULE_0__["default"],
  // Helpers for creating plots- the main public interface for most use cases
  populate: _helpers_display__WEBPACK_IMPORTED_MODULE_2__["populate"],
  DataSources: _data__WEBPACK_IMPORTED_MODULE_1__["default"],
  // Registries for plugin system
  Adapters: _registry__WEBPACK_IMPORTED_MODULE_3__["ADAPTERS"],
  DataLayers: _registry__WEBPACK_IMPORTED_MODULE_3__["DATA_LAYERS"],
  Layouts: _registry__WEBPACK_IMPORTED_MODULE_3__["LAYOUTS"],
  ScaleFunctions: _registry__WEBPACK_IMPORTED_MODULE_3__["SCALABLE"],
  TransformationFunctions: _registry__WEBPACK_IMPORTED_MODULE_3__["TRANSFORMS"],
  Widgets: _registry__WEBPACK_IMPORTED_MODULE_3__["WIDGETS"],

  get KnownDataSources() {
    // Backwards- compatibility alias
    console.warn('Deprecation warning: KnownDataSources has been renamed to "Adapters"');
    return _registry__WEBPACK_IMPORTED_MODULE_3__["ADAPTERS"];
  }

};
/**
 * @callback pluginCallback
 * @param {Object} LocusZoom The global LocusZoom object
 */

var INSTALLED_PLUGINS = [];
/**
 *
 * @param {pluginCallback} plugin The plugin should be a module that exports the function as either the default export,
 *  or as a member named "install"
 * @param args Additional options to be passed when creating the plugin
 */

LocusZoom.use = function (plugin) {
  // Deliberately similar implementation to Vue.js .use() plugin system
  if (INSTALLED_PLUGINS.includes(plugin)) {
    // Avoid double-installation of a plugin
    return;
  }

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.unshift(LocusZoom); // All plugins are passed a reference to LocusZoom object

  if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args);
  } else if (typeof plugin === 'function') {
    plugin.apply(null, args);
  } else {
    throw new Error('Plugin must export a function that receives the LocusZoom object as an argument');
  }

  INSTALLED_PLUGINS.push(plugin);
};

/* harmony default export */ __webpack_exports__["default"] = (LocusZoom);

/***/ }),

/***/ "./esm/layouts/index.js":
/*!******************************!*\
  !*** ./esm/layouts/index.js ***!
  \******************************/
/*! exports provided: tooltip, toolbar_widgets, toolbar, data_layer, panel, plot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tooltip", function() { return tooltip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toolbar_widgets", function() { return toolbar_widgets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toolbar", function() { return toolbar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "data_layer", function() { return data_layer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "panel", function() { return panel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plot", function() { return plot; });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version */ "./esm/version.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
/**
 * Predefined base layouts used to populate the LZ registry
 * @module
 * @private
 */


var LZ_SIG_THRESHOLD_LOGP = 7.301; // -log10(.05/1e6)

/**
 * Tooltip Layouts
 */

var standard_association_tooltip = {
  namespace: {
    'assoc': 'assoc'
  },
  closable: true,
  show: {
    or: ['highlighted', 'selected']
  },
  hide: {
    and: ['unhighlighted', 'unselected']
  },
  html: "<strong>{{{{namespace[assoc]}}variant|htmlescape}}</strong><br>\n        P Value: <strong>{{{{namespace[assoc]}}log_pvalue|logtoscinotation|htmlescape}}</strong><br>\n        Ref. Allele: <strong>{{{{namespace[assoc]}}ref_allele|htmlescape}}</strong><br>\n        <a href=\"javascript:void(0);\" \n        onclick=\"var data = this.parentNode.__data__;\n                 data.getDataLayer().makeLDReference(data);\"\n                 >Make LD Reference</a><br>"
};

var standard_association_tooltip_with_label = function () {
  // Add a special "toggle label" button to the base tooltip. This must be used in tandem with a custom layout
  //   directive (label.filters should check a boolean annotation field called "lz_show_label").
  var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_association_tooltip);
  base.html += "<a href=\"javascript:void(0);\" \n                  onclick=\"var item = this.parentNode.__data__, layer = item.getDataLayer(); \n                  var current = layer.getElementAnnotation(item, 'lz_show_label'); \n                  layer.setElementAnnotation(item, 'lz_show_label', !current );\n                  layer.parent_plot.applyState();\">Toggle label</a>";
  return base;
}();

var standard_genes_tooltip = {
  closable: true,
  show: {
    or: ['highlighted', 'selected']
  },
  hide: {
    and: ['unhighlighted', 'unselected']
  },
  html: '<h4><strong><i>{{gene_name|htmlescape}}</i></strong></h4>' + 'Gene ID: <a href="https://useast.ensembl.org/homo_sapiens/Gene/Summary?g={{gene_id|htmlescape}}&db=core" target="_blank" rel="noopener">{{gene_id|htmlescape}}</a><br>' + 'Transcript ID: <strong>{{transcript_id|htmlescape}}</strong><br>' + '{{#if pLI}}<table>' + '<tr><th>Constraint</th><th>Expected variants</th><th>Observed variants</th><th>Const. Metric</th></tr>' + '<tr><td>Synonymous</td><td>{{exp_syn}}</td><td>{{obs_syn}}</td><td>z = {{syn_z}}<br>o/e = {{oe_syn}} ({{oe_syn_lower}} - {{oe_syn_upper}})</td></tr>' + '<tr><td>Missense</td><td>{{exp_mis}}</td><td>{{obs_mis}}</td><td>z = {{mis_z}}<br>o/e = {{oe_mis}} ({{oe_mis_lower}} - {{oe_mis_upper}})</td></tr>' + '<tr><td>pLoF</td><td>{{exp_lof}}</td><td>{{obs_lof}}</td><td>pLI = {{pLI}}<br>o/e = {{oe_lof}} ({{oe_lof_lower}} - {{oe_lof_upper}})</td></tr>' + '</table><br>{{/if}}' + '<a href="https://gnomad.broadinstitute.org/gene/{{gene_id|htmlescape}}" target="_blank" rel="noopener">More data on gnomAD</a>'
};
var catalog_variant_tooltip = {
  namespace: {
    'assoc': 'assoc',
    'catalog': 'catalog'
  },
  closable: true,
  show: {
    or: ['highlighted', 'selected']
  },
  hide: {
    and: ['unhighlighted', 'unselected']
  },
  html: '<strong>{{{{namespace[catalog]}}variant|htmlescape}}</strong><br>' + 'Catalog entries: <strong>{{n_catalog_matches|htmlescape}}</strong><br>' + 'Top Trait: <strong>{{{{namespace[catalog]}}trait|htmlescape}}</strong><br>' + 'Top P Value: <strong>{{{{namespace[catalog]}}log_pvalue|logtoscinotation}}</strong><br>' // User note: if a different catalog is used, the tooltip will need to be replaced with a different link URL
  + 'More: <a href="https://www.ebi.ac.uk/gwas/search?query={{{{namespace[catalog]}}rsid|htmlescape}}" target="_blank" rel="noopener">GWAS catalog</a> / <a href="https://www.ncbi.nlm.nih.gov/snp/{{{{namespace[catalog]}}rsid|htmlescape}}" target="_blank" rel="noopener">dbSNP</a>'
};
var coaccessibility_tooltip = {
  namespace: {
    'access': 'access'
  },
  closable: true,
  show: {
    or: ['highlighted', 'selected']
  },
  hide: {
    and: ['unhighlighted', 'unselected']
  },
  // TODO: Is there a more generic terminology? (eg not every technique is in terms of cis-regulatory element)
  html: '<strong>Regulatory element</strong><br>' + '{{{{namespace[access]}}start1|htmlescape}}-{{{{namespace[access]}}end1|htmlescape}}<br>' + '<strong>Promoter</strong><br>' + '{{{{namespace[access]}}start2|htmlescape}}-{{{{namespace[access]}}end2|htmlescape}}<br>' + '{{#if {{namespace[access]}}target}}<strong>Target</strong>: {{{{namespace[access]}}target|htmlescape}}<br>{{/if}}' + '<strong>Score</strong>: {{{{namespace[access]}}score|htmlescape}}'
};
/**
 * Data Layer Layouts: represent specific information from a data source
 */

var significance_layer = {
  id: 'significance',
  type: 'orthogonal_line',
  orientation: 'horizontal',
  offset: LZ_SIG_THRESHOLD_LOGP
};
var recomb_rate_layer = {
  namespace: {
    'recomb': 'recomb'
  },
  id: 'recombrate',
  type: 'line',
  fields: ['{{namespace[recomb]}}position', '{{namespace[recomb]}}recomb_rate'],
  z_index: 1,
  style: {
    'stroke': '#0000FF',
    'stroke-width': '1.5px'
  },
  x_axis: {
    field: '{{namespace[recomb]}}position'
  },
  y_axis: {
    axis: 2,
    field: '{{namespace[recomb]}}recomb_rate',
    floor: 0,
    ceiling: 100
  }
};
var association_pvalues_layer = {
  namespace: {
    'assoc': 'assoc',
    'ld': 'ld'
  },
  id: 'associationpvalues',
  type: 'scatter',
  coalesce: {
    active: true
  },
  point_shape: {
    scale_function: 'if',
    field: '{{namespace[ld]}}isrefvar',
    parameters: {
      field_value: 1,
      then: 'diamond',
      "else": 'circle'
    }
  },
  point_size: {
    scale_function: 'if',
    field: '{{namespace[ld]}}isrefvar',
    parameters: {
      field_value: 1,
      then: 80,
      "else": 40
    }
  },
  color: [{
    scale_function: 'if',
    field: '{{namespace[ld]}}isrefvar',
    parameters: {
      field_value: 1,
      then: '#9632b8'
    }
  }, {
    scale_function: 'numerical_bin',
    field: '{{namespace[ld]}}state',
    parameters: {
      breaks: [0, 0.2, 0.4, 0.6, 0.8],
      values: ['#357ebd', '#46b8da', '#5cb85c', '#eea236', '#d43f3a']
    }
  }, '#B8B8B8'],
  legend: [{
    shape: 'diamond',
    color: '#9632b8',
    size: 40,
    label: 'LD Ref Var',
    "class": 'lz-data_layer-scatter'
  }, {
    shape: 'circle',
    color: '#d43f3a',
    size: 40,
    label: '1.0 > r² ≥ 0.8',
    "class": 'lz-data_layer-scatter'
  }, {
    shape: 'circle',
    color: '#eea236',
    size: 40,
    label: '0.8 > r² ≥ 0.6',
    "class": 'lz-data_layer-scatter'
  }, {
    shape: 'circle',
    color: '#5cb85c',
    size: 40,
    label: '0.6 > r² ≥ 0.4',
    "class": 'lz-data_layer-scatter'
  }, {
    shape: 'circle',
    color: '#46b8da',
    size: 40,
    label: '0.4 > r² ≥ 0.2',
    "class": 'lz-data_layer-scatter'
  }, {
    shape: 'circle',
    color: '#357ebd',
    size: 40,
    label: '0.2 > r² ≥ 0.0',
    "class": 'lz-data_layer-scatter'
  }, {
    shape: 'circle',
    color: '#B8B8B8',
    size: 40,
    label: 'no r² data',
    "class": 'lz-data_layer-scatter'
  }],
  label: null,
  fields: ['{{namespace[assoc]}}variant', '{{namespace[assoc]}}position', '{{namespace[assoc]}}log_pvalue', '{{namespace[assoc]}}log_pvalue|logtoscinotation', '{{namespace[assoc]}}ref_allele', '{{namespace[ld]}}state', '{{namespace[ld]}}isrefvar'],
  id_field: '{{namespace[assoc]}}variant',
  z_index: 2,
  x_axis: {
    field: '{{namespace[assoc]}}position'
  },
  y_axis: {
    axis: 1,
    field: '{{namespace[assoc]}}log_pvalue',
    floor: 0,
    upper_buffer: 0.10,
    min_extent: [0, 10]
  },
  behaviors: {
    onmouseover: [{
      action: 'set',
      status: 'highlighted'
    }],
    onmouseout: [{
      action: 'unset',
      status: 'highlighted'
    }],
    onclick: [{
      action: 'toggle',
      status: 'selected',
      exclusive: true
    }]
  },
  tooltip: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_association_tooltip)
};
var coaccessibility_layer = {
  namespace: {
    'access': 'access'
  },
  id: 'coaccessibility',
  type: 'arcs',
  fields: ['{{namespace[access]}}start1', '{{namespace[access]}}end1', '{{namespace[access]}}start2', '{{namespace[access]}}end2', '{{namespace[access]}}id', '{{namespace[access]}}target', '{{namespace[access]}}score'],
  match: {
    send: '{{namespace[access]}}target',
    receive: '{{namespace[access]}}target'
  },
  id_field: '{{namespace[access]}}id',
  filters: [{
    field: '{{namespace[access]}}score',
    operator: '!=',
    value: null
  }],
  color: [{
    field: 'lz_highlight_match',
    // Special field name whose presence triggers custom rendering
    scale_function: 'if',
    parameters: {
      field_value: true,
      then: '#ff0000'
    }
  }, {
    field: 'lz_highlight_match',
    // Special field name whose presence triggers custom rendering
    scale_function: 'if',
    parameters: {
      field_value: false,
      then: '#EAE6E6'
    }
  }, {
    scale_function: 'ordinal_cycle',
    parameters: {
      values: ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'] // Drawn from d3v3 "category20"

    }
  }],
  x_axis: {
    field1: '{{namespace[access]}}start1',
    field2: '{{namespace[access]}}start2'
  },
  y_axis: {
    axis: 1,
    field: '{{namespace[access]}}score',
    upper_buffer: 0.1,
    min_extent: [0, 1]
  },
  behaviors: {
    onmouseover: [{
      action: 'set',
      status: 'highlighted'
    }],
    onmouseout: [{
      action: 'unset',
      status: 'highlighted'
    }],
    onclick: [{
      action: 'toggle',
      status: 'selected',
      exclusive: true
    }]
  },
  tooltip: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(coaccessibility_tooltip)
};

var association_pvalues_catalog_layer = function () {
  // Slightly modify an existing layout
  var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(association_pvalues_layer);
  base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
    id: 'associationpvaluescatalog',
    fill_opacity: 0.7
  }, base);
  base.tooltip.html += '{{#if {{namespace[catalog]}}rsid}}<br><a href="https://www.ebi.ac.uk/gwas/search?query={{{{namespace[catalog]}}rsid|htmlescape}}" target="_blank" rel="noopener">See hits in GWAS catalog</a>{{/if}}';
  base.namespace.catalog = 'catalog';
  base.fields.push('{{namespace[catalog]}}rsid', '{{namespace[catalog]}}trait', '{{namespace[catalog]}}log_pvalue');
  return base;
}();

var phewas_pvalues_layer = {
  namespace: {
    'phewas': 'phewas'
  },
  id: 'phewaspvalues',
  type: 'category_scatter',
  point_shape: 'circle',
  point_size: 70,
  tooltip_positioning: 'vertical',
  id_field: '{{namespace[phewas]}}id',
  fields: ['{{namespace[phewas]}}id', '{{namespace[phewas]}}log_pvalue', '{{namespace[phewas]}}trait_group', '{{namespace[phewas]}}trait_label'],
  x_axis: {
    field: '{{namespace[phewas]}}x',
    // Synthetic/derived field added by `category_scatter` layer
    category_field: '{{namespace[phewas]}}trait_group',
    lower_buffer: 0.025,
    upper_buffer: 0.025
  },
  y_axis: {
    axis: 1,
    field: '{{namespace[phewas]}}log_pvalue',
    floor: 0,
    upper_buffer: 0.15
  },
  color: [{
    field: '{{namespace[phewas]}}trait_group',
    scale_function: 'categorical_bin',
    parameters: {
      categories: [],
      values: [],
      null_value: '#B8B8B8'
    }
  }],
  fill_opacity: 0.7,
  tooltip: {
    closable: true,
    show: {
      or: ['highlighted', 'selected']
    },
    hide: {
      and: ['unhighlighted', 'unselected']
    },
    html: ['<strong>Trait:</strong> {{{{namespace[phewas]}}trait_label|htmlescape}}<br>', '<strong>Trait Category:</strong> {{{{namespace[phewas]}}trait_group|htmlescape}}<br>', '<strong>P-value:</strong> {{{{namespace[phewas]}}log_pvalue|logtoscinotation|htmlescape}}<br>'].join('')
  },
  behaviors: {
    onmouseover: [{
      action: 'set',
      status: 'highlighted'
    }],
    onmouseout: [{
      action: 'unset',
      status: 'highlighted'
    }],
    onclick: [{
      action: 'toggle',
      status: 'selected',
      exclusive: true
    }]
  },
  label: {
    text: '{{{{namespace[phewas]}}trait_label}}',
    spacing: 6,
    lines: {
      style: {
        'stroke-width': '2px',
        'stroke': '#333333',
        'stroke-dasharray': '2px 2px'
      }
    },
    filters: [{
      field: '{{namespace[phewas]}}log_pvalue',
      operator: '>=',
      value: 20
    }],
    style: {
      'font-size': '14px',
      'font-weight': 'bold',
      'fill': '#333333'
    }
  }
};
var genes_layer = {
  namespace: {
    'gene': 'gene',
    'constraint': 'constraint'
  },
  id: 'genes',
  type: 'genes',
  fields: ['{{namespace[gene]}}all', '{{namespace[constraint]}}all'],
  id_field: 'gene_id',
  behaviors: {
    onmouseover: [{
      action: 'set',
      status: 'highlighted'
    }],
    onmouseout: [{
      action: 'unset',
      status: 'highlighted'
    }],
    onclick: [{
      action: 'toggle',
      status: 'selected',
      exclusive: true
    }]
  },
  tooltip: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_genes_tooltip)
};
var genes_layer_filtered = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
  // By default this layer doesn't show everything. Often used in tandem with a panel-level toolbar "show all" button.
  filters: [{
    field: 'gene_type',
    operator: 'in',
    // A manually curated subset of Gencode biotypes, based on user suggestions
    //  See full list: https://www.gencodegenes.org/human/stats.html
    // This is approximately intended to cover elements of generally known function, and exclude things
    //  like pseudogenes.
    value: ['protein_coding', 'IG_C_gene', 'IG_D_gene', 'IG_J_gene', 'IG_V_gene', 'TR_C_gene', 'TR_D_gene', 'TR_J_gene', 'TR_V_gene', 'rRNA', 'Mt_rRNA', 'Mt_tRNA']
  }]
}, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(genes_layer));
var annotation_catalog_layer = {
  // Identify GWAS hits that are present in the GWAS catalog
  namespace: {
    'assoc': 'assoc',
    'catalog': 'catalog'
  },
  id: 'annotation_catalog',
  type: 'annotation_track',
  id_field: '{{namespace[assoc]}}variant',
  x_axis: {
    field: '{{namespace[assoc]}}position'
  },
  color: '#0000CC',
  fields: ['{{namespace[assoc]}}variant', '{{namespace[assoc]}}chromosome', '{{namespace[assoc]}}position', '{{namespace[catalog]}}variant', '{{namespace[catalog]}}rsid', '{{namespace[catalog]}}trait', '{{namespace[catalog]}}log_pvalue', '{{namespace[catalog]}}pos'],
  filters: [// Specify which points to show on the track. Any selection must satisfy ALL filters
  {
    field: '{{namespace[catalog]}}rsid',
    operator: '!=',
    value: null
  }, {
    field: '{{namespace[catalog]}}log_pvalue',
    operator: '>',
    value: LZ_SIG_THRESHOLD_LOGP
  }],
  behaviors: {
    onmouseover: [{
      action: 'set',
      status: 'highlighted'
    }],
    onmouseout: [{
      action: 'unset',
      status: 'highlighted'
    }],
    onclick: [{
      action: 'toggle',
      status: 'selected',
      exclusive: true
    }]
  },
  tooltip: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(catalog_variant_tooltip),
  tooltip_positioning: 'top'
};
/**
 * Individual toolbar buttons
 */

var ldlz2_pop_selector_menu = {
  // **Note**: this widget is aimed at the LDServer datasource, and the UM 1000G LDServer
  type: 'set_state',
  position: 'right',
  color: 'blue',
  button_html: 'LD Population: ',
  show_selected: true,
  button_title: 'Select LD Population: ',
  state_field: 'ld_pop',
  // This list below is hardcoded to work with the UMich LDServer, default 1000G populations
  //  It can be customized to work with other LD servers that specify population differently
  // https://portaldev.sph.umich.edu/ld/genome_builds/GRCh37/references/1000G/populations
  options: [{
    display_name: 'ALL (default)',
    value: 'ALL'
  }, {
    display_name: 'AFR',
    value: 'AFR'
  }, {
    display_name: 'AMR',
    value: 'AMR'
  }, {
    display_name: 'EAS',
    value: 'EAS'
  }, {
    display_name: 'EUR',
    value: 'EUR'
  }, {
    display_name: 'SAS',
    value: 'SAS'
  }]
};
var gene_selector_menu = {
  type: 'display_options',
  position: 'right',
  color: 'blue',
  // Below: special config specific to this widget
  button_html: 'Filter...',
  button_title: 'Choose which genes to show',
  layer_name: 'genes',
  default_config_display_name: 'Coding genes & rRNA',
  options: [{
    display_name: 'All features',
    display: {
      filters: null
    }
  }]
};
/**
 * Toolbar Layouts: Collections of toolbar buttons etc
 */

var standard_panel_toolbar = {
  widgets: [{
    type: 'remove_panel',
    position: 'right',
    color: 'red',
    group_position: 'end'
  }, {
    type: 'move_panel_up',
    position: 'right',
    group_position: 'middle'
  }, {
    type: 'move_panel_down',
    position: 'right',
    group_position: 'start',
    style: {
      'margin-left': '0.75em'
    }
  }]
};
var standard_plot_toolbar = {
  // Suitable for most any type of plot drawn with LZ. Title and download buttons.
  widgets: [{
    type: 'title',
    title: 'LocusZoom',
    subtitle: "<a href=\"https://statgen.github.io/locuszoom/\" target=\"_blank\" rel=\"noopener\">v".concat(_version__WEBPACK_IMPORTED_MODULE_0__["default"], "</a>"),
    position: 'left'
  }, {
    type: 'download',
    position: 'right',
    group_position: 'end'
  }, {
    type: 'download_png',
    position: 'right',
    group_position: 'start'
  }]
};

var standard_association_toolbar = function () {
  // Suitable for association plots (adds a button for LD data)
  var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_plot_toolbar);
  base.widgets.push(Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(ldlz2_pop_selector_menu));
  return base;
}();

var region_nav_plot_toolbar = function () {
  // Generic region nav buttons
  var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_plot_toolbar);
  base.widgets.push({
    type: 'shift_region',
    step: 500000,
    button_html: '>>',
    position: 'right',
    group_position: 'end'
  }, {
    type: 'shift_region',
    step: 50000,
    button_html: '>',
    position: 'right',
    group_position: 'middle'
  }, {
    type: 'zoom_region',
    step: 0.2,
    position: 'right',
    group_position: 'middle'
  }, {
    type: 'zoom_region',
    step: -0.2,
    position: 'right',
    group_position: 'middle'
  }, {
    type: 'shift_region',
    step: -50000,
    button_html: '<',
    position: 'right',
    group_position: 'middle'
  }, {
    type: 'shift_region',
    step: -500000,
    button_html: '<<',
    position: 'right',
    group_position: 'start'
  });
  return base;
}();
/**
 * Panel Layouts
 */


var association_panel = {
  id: 'association',
  width: 800,
  height: 225,
  min_width: 400,
  min_height: 200,
  proportional_width: 1,
  margin: {
    top: 35,
    right: 50,
    bottom: 40,
    left: 50
  },
  inner_border: 'rgb(210, 210, 210)',
  toolbar: function () {
    var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_panel_toolbar);
    base.widgets.push({
      type: 'toggle_legend',
      position: 'right'
    });
    return base;
  }(),
  axes: {
    x: {
      label: 'Chromosome {{chr}} (Mb)',
      label_offset: 32,
      tick_format: 'region',
      extent: 'state'
    },
    y1: {
      label: '-log10 p-value',
      label_offset: 28
    },
    y2: {
      label: 'Recombination Rate (cM/Mb)',
      label_offset: 40
    }
  },
  legend: {
    orientation: 'vertical',
    origin: {
      x: 55,
      y: 40
    },
    hidden: true
  },
  interaction: {
    drag_background_to_pan: true,
    drag_x_ticks_to_scale: true,
    drag_y1_ticks_to_scale: true,
    drag_y2_ticks_to_scale: true,
    scroll_to_zoom: true,
    x_linked: true
  },
  data_layers: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(significance_layer), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(recomb_rate_layer), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(association_pvalues_layer)]
};
var coaccessibility_panel = {
  id: 'coaccessibility',
  width: 800,
  height: 225,
  min_width: 400,
  min_height: 100,
  proportional_width: 1,
  margin: {
    top: 35,
    right: 50,
    bottom: 40,
    left: 50
  },
  inner_border: 'rgb(210, 210, 210)',
  toolbar: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_panel_toolbar),
  axes: {
    x: {
      label: 'Chromosome {{chr}} (Mb)',
      label_offset: 32,
      tick_format: 'region',
      extent: 'state'
    },
    y1: {
      label: 'Score',
      label_offset: 28,
      render: false // We are mainly concerned with the relative magnitudes: hide y axis to avoid clutter.

    }
  },
  interaction: {
    drag_background_to_pan: true,
    drag_x_ticks_to_scale: true,
    drag_y1_ticks_to_scale: true,
    scroll_to_zoom: true,
    x_linked: true
  },
  data_layers: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(coaccessibility_layer)]
};

var association_catalog_panel = function () {
  var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(association_panel);
  base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
    id: 'associationcatalog',
    namespace: {
      'assoc': 'assoc',
      'ld': 'ld',
      'catalog': 'catalog'
    } // Required to resolve display options

  }, base);
  base.toolbar.widgets.push({
    type: 'display_options',
    position: 'right',
    color: 'blue',
    // Below: special config specific to this widget
    button_html: 'Display options...',
    button_title: 'Control how plot items are displayed',
    layer_name: 'associationpvaluescatalog',
    default_config_display_name: 'No catalog labels (default)',
    // display name for the default plot color option (allow user to revert to plot defaults)
    options: [{
      // First dropdown menu item
      display_name: 'Label catalog traits',
      // Human readable representation of field name
      display: {
        // Specify layout directives that control display of the plot for this option
        label: {
          text: '{{{{namespace[catalog]}}trait}}',
          spacing: 6,
          lines: {
            style: {
              'stroke-width': '2px',
              'stroke': '#333333',
              'stroke-dasharray': '2px 2px'
            }
          },
          filters: [// Only label points if they are significant for some trait in the catalog, AND in high LD
          //  with the top hit of interest
          {
            field: '{{namespace[catalog]}}trait',
            operator: '!=',
            value: null
          }, {
            field: '{{namespace[catalog]}}log_pvalue',
            operator: '>',
            value: LZ_SIG_THRESHOLD_LOGP
          }, {
            field: '{{namespace[ld]}}state',
            operator: '>',
            value: 0.4
          }],
          style: {
            'font-size': '10px',
            'font-weight': 'bold',
            'fill': '#333333'
          }
        }
      }
    }]
  });
  base.data_layers = [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(significance_layer), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(recomb_rate_layer), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(association_pvalues_catalog_layer)];
  return base;
}();

var genes_panel = {
  id: 'genes',
  width: 800,
  height: 225,
  min_width: 400,
  min_height: 112.5,
  proportional_width: 1,
  margin: {
    top: 20,
    right: 50,
    bottom: 20,
    left: 50
  },
  axes: {},
  interaction: {
    drag_background_to_pan: true,
    scroll_to_zoom: true,
    x_linked: true
  },
  toolbar: function () {
    var base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_panel_toolbar);
    base.widgets.push({
      type: 'resize_to_data',
      position: 'right',
      button_html: 'Resize'
    }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(gene_selector_menu));
    return base;
  }(),
  data_layers: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(genes_layer_filtered)]
};
var phewas_panel = {
  id: 'phewas',
  width: 800,
  height: 300,
  min_width: 800,
  min_height: 300,
  proportional_width: 1,
  margin: {
    top: 20,
    right: 50,
    bottom: 120,
    left: 50
  },
  inner_border: 'rgb(210, 210, 210)',
  axes: {
    x: {
      ticks: {
        // Object based config (shared defaults; allow layers to specify ticks)
        style: {
          'font-weight': 'bold',
          'font-size': '11px',
          'text-anchor': 'start'
        },
        transform: 'rotate(50)',
        position: 'left' // Special param recognized by `category_scatter` layers

      }
    },
    y1: {
      label: '-log10 p-value',
      label_offset: 28
    }
  },
  data_layers: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(significance_layer), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(phewas_pvalues_layer)]
};
var annotation_catalog_panel = {
  id: 'annotationcatalog',
  width: 800,
  height: 45,
  min_height: 45,
  proportional_width: 1,
  margin: {
    top: 25,
    right: 50,
    bottom: 0,
    left: 50
  },
  inner_border: 'rgb(210, 210, 210)',
  toolbar: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_panel_toolbar),
  interaction: {
    drag_background_to_pan: true,
    scroll_to_zoom: true,
    x_linked: true
  },
  data_layers: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(annotation_catalog_layer)]
};
/**
 * Plot Layouts
 */

var standard_association_plot = {
  state: {},
  width: 800,
  height: 450,
  responsive_resize: true,
  min_region_scale: 20000,
  max_region_scale: 1000000,
  toolbar: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_association_toolbar),
  panels: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
    proportional_height: 0.5
  }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(association_panel)), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
    proportional_height: 0.5
  }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(genes_panel))]
};
var association_catalog_plot = {
  state: {},
  width: 800,
  height: 500,
  responsive_resize: true,
  min_region_scale: 20000,
  max_region_scale: 1000000,
  toolbar: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_association_toolbar),
  panels: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(annotation_catalog_panel), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(association_catalog_panel), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(genes_panel)]
};
var standard_phewas_plot = {
  width: 800,
  height: 600,
  min_width: 800,
  min_height: 600,
  responsive_resize: true,
  toolbar: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_plot_toolbar),
  panels: [Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
    proportional_height: 0.5
  }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(phewas_panel)), Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])({
    proportional_height: 0.5,
    margin: {
      bottom: 40
    },
    axes: {
      x: {
        label: 'Chromosome {{chr}} (Mb)',
        label_offset: 32,
        tick_format: 'region',
        extent: 'state'
      }
    }
  }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(genes_panel))],
  mouse_guide: false
};
var coaccessibility_plot = {
  state: {},
  width: 800,
  height: 450,
  responsive_resize: true,
  min_region_scale: 20000,
  max_region_scale: 1000000,
  toolbar: Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(standard_plot_toolbar),
  panels: [Object.assign({
    proportional_height: 0.4
  }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(coaccessibility_panel)), function () {
    // Take the default genes panel, and add a custom feature to highlight gene tracks based on short name
    // This is a companion to the "match" directive in the coaccessibility panel
    var base = Object.assign({
      proportional_height: 0.6
    }, Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(genes_panel));
    var layer = base.data_layers[0];
    layer.match = {
      send: 'gene_name',
      receive: 'gene_name'
    };
    var color_config = [{
      field: 'lz_highlight_match',
      // Special field name whose presence triggers custom rendering
      scale_function: 'if',
      parameters: {
        field_value: true,
        then: '#ff0000'
      }
    }, {
      field: 'lz_highlight_match',
      // Special field name whose presence triggers custom rendering
      scale_function: 'if',
      parameters: {
        field_value: false,
        then: '#EAE6E6'
      }
    }, '#363696'];
    layer.color = color_config;
    layer.stroke = color_config;
    return base;
  }()]
};
var tooltip = {
  standard_association: standard_association_tooltip,
  standard_association_with_label: standard_association_tooltip_with_label,
  standard_genes: standard_genes_tooltip,
  catalog_variant: catalog_variant_tooltip,
  coaccessibility: coaccessibility_tooltip
};
var toolbar_widgets = {
  ldlz2_pop_selector: ldlz2_pop_selector_menu,
  gene_selector_menu: gene_selector_menu
};
var toolbar = {
  standard_panel: standard_panel_toolbar,
  standard_plot: standard_plot_toolbar,
  standard_association: standard_association_toolbar,
  region_nav_plot: region_nav_plot_toolbar
};
var data_layer = {
  significance: significance_layer,
  recomb_rate: recomb_rate_layer,
  association_pvalues: association_pvalues_layer,
  coaccessibility: coaccessibility_layer,
  association_pvalues_catalog: association_pvalues_catalog_layer,
  phewas_pvalues: phewas_pvalues_layer,
  genes: genes_layer,
  genes_filtered: genes_layer_filtered,
  annotation_catalog: annotation_catalog_layer
};
var panel = {
  association: association_panel,
  coaccessibility: coaccessibility_panel,
  association_catalog: association_catalog_panel,
  genes: genes_panel,
  phewas: phewas_panel,
  annotation_catalog: annotation_catalog_panel
};
var plot = {
  standard_association: standard_association_plot,
  association_catalog: association_catalog_plot,
  standard_phewas: standard_phewas_plot,
  coaccessibility: coaccessibility_plot
};

/***/ }),

/***/ "./esm/registry/adapters.js":
/*!**********************************!*\
  !*** ./esm/registry/adapters.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/registry/base.js");
/* harmony import */ var _data_adapters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/adapters */ "./esm/data/adapters.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * A registry of known data sources. Can be used to find sources by name, either from predefined
 *  classes, or plugins.
 *  @module
 *  @private
 */

 // KnownDataSources is a basic registry with no special behavior.

var registry = new _base__WEBPACK_IMPORTED_MODULE_0__["ClassRegistry"]();

for (var _i = 0, _Object$entries = Object.entries(_data_adapters__WEBPACK_IMPORTED_MODULE_1__); _i < _Object$entries.length; _i++) {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      name = _Object$entries$_i[0],
      type = _Object$entries$_i[1];

  registry.add(name, type);
} // Add some hard-coded aliases for backwards compatibility


registry.add('StaticJSON', _data_adapters__WEBPACK_IMPORTED_MODULE_1__["StaticSource"]);
registry.add('LDLZ2', _data_adapters__WEBPACK_IMPORTED_MODULE_1__["LDServer"]);
/* harmony default export */ __webpack_exports__["default"] = (registry);

/***/ }),

/***/ "./esm/registry/base.js":
/*!******************************!*\
  !*** ./esm/registry/base.js ***!
  \******************************/
/*! exports provided: default, RegistryBase, ClassRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RegistryBase", function() { return RegistryBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClassRegistry", function() { return ClassRegistry; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/** @module */

/**
 * Base class for all registries
 *
 * LocusZoom is plugin-extensible, and layouts are string-based and JSON serializable. This is achieved through the use
 *  of a central registry that holds a reference to each possible feature.
 *
 * Each registry has some syntactical sugar, with common elements are defined in a base class
 */
var RegistryBase = /*#__PURE__*/function () {
  function RegistryBase() {
    _classCallCheck(this, RegistryBase);

    this._items = new Map();
  }
  /**
   * Return the registry member. If the registry stores classes, this returns the class, not the instance.
   * @param {String} name
   * @returns {Function}
   */


  _createClass(RegistryBase, [{
    key: "get",
    value: function get(name) {
      if (!this._items.has(name)) {
        throw new Error("Item not found: ".concat(name));
      }

      return this._items.get(name);
    }
    /**
     * Add a new item to the registry
     * @param {String} name The name of the item to add to the registry
     * @param {*} item The item to be added (constructor, value, etc)
     * @param {boolean} [override=false] Allow redefining an existing item?
     * @return {*} The actual object as added to the registry
     */

  }, {
    key: "add",
    value: function add(name, item) {
      var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!override && this._items.has(name)) {
        throw new Error("Item ".concat(name, " is already defined"));
      }

      this._items.set(name, item);

      return item;
    }
    /**
     * Remove a datasource from the registry (if present)
     * @param {String} name
     * @returns {boolean} True if item removed, false if item was never present
     */

  }, {
    key: "remove",
    value: function remove(name) {
      return this._items["delete"](name);
    }
    /**
     * Check whether the specified item is registered
     * @param {String} name
     * @returns {boolean}
     */

  }, {
    key: "has",
    value: function has(name) {
      return this._items.has(name);
    }
    /**
     * Names of each allowed
     * @returns {String[]}
     */

  }, {
    key: "list",
    value: function list() {
      return Array.from(this._items.keys());
    }
  }]);

  return RegistryBase;
}();
/**
 * A specialized registry whose members are class constructors. Contains helper methods for creating instances
 *  and subclasses.
 */


var ClassRegistry = /*#__PURE__*/function (_RegistryBase) {
  _inherits(ClassRegistry, _RegistryBase);

  var _super = _createSuper(ClassRegistry);

  function ClassRegistry() {
    _classCallCheck(this, ClassRegistry);

    return _super.apply(this, arguments);
  }

  _createClass(ClassRegistry, [{
    key: "create",

    /**
     * Create an instance of the specified class from the registry
     * @param {String} name
     * @param {*} args Any additional arguments to be passed to the constructor
     * @returns {*}
     */
    value: function create(name) {
      var base = this.get(name);

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return _construct(base, args);
    }
    /**
     * Create a new child class for an item in the registry.
     *
     * This is (almost, but not quite) a compatibility layer for old sites that used locuszoom
     *
     * This is primarily aimed at low-tooling environments. It is syntactic sugar, roughly equivalent to:
     *   `registry.get(base); registry.add(name, class A extends base {});`
     *
     * Because this bypasses es6 class mechanics, certain things, esp super calls, may not work as well as using the
     *   "real" class expression. This method is provided solely for convenience.
     *
     * This method is a compatibility layer for old versions. Born to be deprecated!
     * @deprecated
     * @param {string} parent_name The name of the desired parent class as represented in the registry
     * @param {string} source_name The desired name of the class to be created, as it will be named in the registry
     * @param {object} overrides An object
     * @return {*}
     */

  }, {
    key: "extend",
    value: function extend(parent_name, source_name, overrides) {
      console.warn('Deprecation warning: .extend method will be removed in future versions, in favor of explicit ES6 subclasses');

      if (arguments.length !== 3) {
        throw new Error('Invalid arguments to .extend');
      }

      var base = this.get(parent_name);

      var sub = /*#__PURE__*/function (_base) {
        _inherits(sub, _base);

        var _super2 = _createSuper(sub);

        function sub() {
          _classCallCheck(this, sub);

          return _super2.apply(this, arguments);
        }

        return sub;
      }(base);

      Object.assign(sub.prototype, overrides, base);
      this.add(source_name, sub);
      return sub;
    }
  }]);

  return ClassRegistry;
}(RegistryBase);

/* harmony default export */ __webpack_exports__["default"] = (RegistryBase);


/***/ }),

/***/ "./esm/registry/data_layers.js":
/*!*************************************!*\
  !*** ./esm/registry/data_layers.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/registry/base.js");
/* harmony import */ var _components_data_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/data_layer */ "./esm/components/data_layer/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @module
 * @private
 */


var registry = new _base__WEBPACK_IMPORTED_MODULE_0__["ClassRegistry"]();

for (var _i = 0, _Object$entries = Object.entries(_components_data_layer__WEBPACK_IMPORTED_MODULE_1__); _i < _Object$entries.length; _i++) {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      name = _Object$entries$_i[0],
      type = _Object$entries$_i[1];

  registry.add(name, type);
}

/* harmony default export */ __webpack_exports__["default"] = (registry);

/***/ }),

/***/ "./esm/registry/index.js":
/*!*******************************!*\
  !*** ./esm/registry/index.js ***!
  \*******************************/
/*! exports provided: ADAPTERS, DATA_LAYERS, LAYOUTS, SCALABLE, TRANSFORMS, WIDGETS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adapters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters */ "./esm/registry/adapters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ADAPTERS", function() { return _adapters__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _data_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data_layers */ "./esm/registry/data_layers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DATA_LAYERS", function() { return _data_layers__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layouts */ "./esm/registry/layouts.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LAYOUTS", function() { return _layouts__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _scalable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scalable */ "./esm/registry/scalable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SCALABLE", function() { return _scalable__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _transforms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transforms */ "./esm/registry/transforms.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TRANSFORMS", function() { return _transforms__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./widgets */ "./esm/registry/widgets.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WIDGETS", function() { return _widgets__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/**
 * Registries that track all registered features available to LocusZoom (including active plugins)
 * @module
 * @public
 */








/***/ }),

/***/ "./esm/registry/layouts.js":
/*!*********************************!*\
  !*** ./esm/registry/layouts.js ***!
  \*********************************/
/*! exports provided: default, _LayoutRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_LayoutRegistry", function() { return LayoutRegistry; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/registry/base.js");
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
/* harmony import */ var _layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layouts */ "./esm/layouts/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @module
 * @private
 */



/**
 * Helper for working with predefined layouts
 *
 * This is part of the public interface with LocusZoom and a major way that users interact to configure plots.
 *
 * Each layout object that is added or retrieved here is a deep copy and totally independent from any other object
 * @public
 */

var LayoutRegistry = /*#__PURE__*/function (_RegistryBase) {
  _inherits(LayoutRegistry, _RegistryBase);

  var _super = _createSuper(LayoutRegistry);

  function LayoutRegistry() {
    _classCallCheck(this, LayoutRegistry);

    return _super.apply(this, arguments);
  }

  _createClass(LayoutRegistry, [{
    key: "get",
    // Implemented as a "registry of registries"- one lookup each for panels, plots, etc...
    value: function get(type, name) {
      var overrides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!(type && name)) {
        throw new Error('Must specify both the type and name for the layout desired. See .list() for available options');
      } // This is a registry of registries. Fetching an item may apply additional custom behaviors, such as
      //  applying overrides or using namespaces to convert an abstract layout into a concrete one.


      var base = _get(_getPrototypeOf(LayoutRegistry.prototype), "get", this).call(this, type).get(name);

      base = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])(overrides, base);

      if (base.unnamespaced) {
        delete base.unnamespaced;
        return Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(base);
      }

      var default_namespace = '';

      if (typeof base.namespace == 'string') {
        default_namespace = base.namespace;
      } else if (_typeof(base.namespace) == 'object' && Object.keys(base.namespace).length) {
        if (typeof base.namespace["default"] != 'undefined') {
          default_namespace = base.namespace["default"];
        } else {
          default_namespace = base.namespace[Object.keys(base.namespace)[0]].toString();
        }
      }

      default_namespace += default_namespace.length ? ':' : '';
      var result = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["applyNamespaces"])(base, base.namespace, default_namespace);
      return Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(result);
    }
    /**
     * Add a type of layout to the registry
     * @param {String} type
     * @param {String} name
     * @param {Object} item
     * @param {boolean} override
     * @return {*}
     */

  }, {
    key: "add",
    value: function add(type, name, item) {
      var override = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!(type && name && item)) {
        throw new Error('To add a layout, type, name, and item must all be specified');
      }

      if (!(_typeof(item) === 'object')) {
        throw new Error('The configuration to be added must be an object');
      }

      if (!this.has(type)) {
        _get(_getPrototypeOf(LayoutRegistry.prototype), "add", this).call(this, type, new _base__WEBPACK_IMPORTED_MODULE_0__["RegistryBase"]());
      } // Ensure that each use of a layout can be modified, by returning a copy is independent


      var copy = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(item);
      return _get(_getPrototypeOf(LayoutRegistry.prototype), "get", this).call(this, type).add(name, copy, override);
    }
    /**
     * List all available types of layout (eg toolbar, panel, etc). If a specific type name is provided, list the
     *  layouts for that widget type.
     * @param {String} [type] The type of layout (eg toolbar, panel, etc)
     * @return {String[]|Object}
     */

  }, {
    key: "list",
    value: function list(type) {
      if (!type) {
        var result = {};

        var _iterator = _createForOfIteratorHelper(this._items),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                _type = _step$value[0],
                contents = _step$value[1];

            result[_type] = contents.list();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return result;
      }

      return _get(_getPrototypeOf(LayoutRegistry.prototype), "get", this).call(this, type).list();
    }
    /**
     * Static alias to a helper method. Preserved for backwards compatibility, so that UMD users can access this method.
     * @static
     */

  }, {
    key: "merge",
    value: function merge(custom_layout, default_layout) {
      return Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_1__["merge"])(custom_layout, default_layout);
    }
  }]);

  return LayoutRegistry;
}(_base__WEBPACK_IMPORTED_MODULE_0__["RegistryBase"]);

var registry = new LayoutRegistry();

for (var _i2 = 0, _Object$entries = Object.entries(_layouts__WEBPACK_IMPORTED_MODULE_2__); _i2 < _Object$entries.length; _i2++) {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
      type = _Object$entries$_i[0],
      entries = _Object$entries$_i[1];

  for (var _i3 = 0, _Object$entries2 = Object.entries(entries); _i3 < _Object$entries2.length; _i3++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),
        name = _Object$entries2$_i[0],
        config = _Object$entries2$_i[1];

    registry.add(type, name, config);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (registry); // Export base class for unit testing



/***/ }),

/***/ "./esm/registry/scalable.js":
/*!**********************************!*\
  !*** ./esm/registry/scalable.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/registry/base.js");
/* harmony import */ var _helpers_scalable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/scalable */ "./esm/helpers/scalable.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @module
 * @private
 */


var registry = new _base__WEBPACK_IMPORTED_MODULE_0__["RegistryBase"]();

for (var _i = 0, _Object$entries = Object.entries(_helpers_scalable__WEBPACK_IMPORTED_MODULE_1__); _i < _Object$entries.length; _i++) {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      name = _Object$entries$_i[0],
      type = _Object$entries$_i[1];

  registry.add(name, type);
} // Alias for the "if_value" function (can't export reserved language keywords directly)


registry.add('if', _helpers_scalable__WEBPACK_IMPORTED_MODULE_1__["if_value"]);
/* harmony default export */ __webpack_exports__["default"] = (registry);

/***/ }),

/***/ "./esm/registry/transforms.js":
/*!************************************!*\
  !*** ./esm/registry/transforms.js ***!
  \************************************/
/*! exports provided: default, _TransformationFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_TransformationFunctions", function() { return TransformationFunctions; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/registry/base.js");
/* harmony import */ var _helpers_transforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/transforms */ "./esm/helpers/transforms.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * @module
 * @private
 */


/**
 * Registry of transformation functions that may be applied to template values.
 * Provides syntactic sugar atop a standard registry.
 * @private
 */

var TransformationFunctions = /*#__PURE__*/function (_RegistryBase) {
  _inherits(TransformationFunctions, _RegistryBase);

  var _super = _createSuper(TransformationFunctions);

  function TransformationFunctions() {
    _classCallCheck(this, TransformationFunctions);

    return _super.apply(this, arguments);
  }

  _createClass(TransformationFunctions, [{
    key: "_collectTransforms",
    value: function _collectTransforms(template_string) {
      var _this = this;

      // Helper function that turns a sequence of function names into a single callable
      var funcs = template_string.match(/\|([^|]+)/g).map(function (item) {
        return _get(_getPrototypeOf(TransformationFunctions.prototype), "get", _this).call(_this, item.substring(1));
      });
      return function (value) {
        return funcs.reduce(function (acc, func) {
          return func(acc);
        }, value);
      };
    }
    /**
     * In templates, we often use a single concatenated string to ask for several transformation functions at once:
     *  `value|func1|func2`
     * This class offers syntactical sugar to retrieve the entire sequence of transformations as a single callable
     * @param name
     */

  }, {
    key: "get",
    value: function get(name) {
      if (!name) {
        // This function is sometimes called with no value, and the expected behavior is to return null instead of
        //  a callable
        return null;
      }

      if (name.substring(0, 1) === '|') {
        // Legacy artifact of how this function is called- if a pipe is present, this is the template string
        //  (`|func1|func2...`), rather than any one single transformation function.
        // A sequence of transformation functions is expected
        return this._collectTransforms(name);
      } else {
        // If not a template string, then user is asking for an item by name directly
        return _get(_getPrototypeOf(TransformationFunctions.prototype), "get", this).call(this, name);
      }
    }
  }]);

  return TransformationFunctions;
}(_base__WEBPACK_IMPORTED_MODULE_0__["RegistryBase"]);

var registry = new TransformationFunctions();

for (var _i = 0, _Object$entries = Object.entries(_helpers_transforms__WEBPACK_IMPORTED_MODULE_1__); _i < _Object$entries.length; _i++) {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      name = _Object$entries$_i[0],
      type = _Object$entries$_i[1];

  registry.add(name, type);
}

/* harmony default export */ __webpack_exports__["default"] = (registry); // Export helper class for unit testing



/***/ }),

/***/ "./esm/registry/widgets.js":
/*!*********************************!*\
  !*** ./esm/registry/widgets.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./esm/registry/base.js");
/* harmony import */ var _components_toolbar_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/toolbar/widgets */ "./esm/components/toolbar/widgets.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @module
 * @private
 */


var registry = new _base__WEBPACK_IMPORTED_MODULE_0__["ClassRegistry"]();

for (var _i = 0, _Object$entries = Object.entries(_components_toolbar_widgets__WEBPACK_IMPORTED_MODULE_1__); _i < _Object$entries.length; _i++) {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      name = _Object$entries$_i[0],
      type = _Object$entries$_i[1];

  registry.add(name, type);
}

/* harmony default export */ __webpack_exports__["default"] = (registry);

/***/ }),

/***/ "./esm/version.js":
/*!************************!*\
  !*** ./esm/version.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ('0.13.0-beta.2');

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2NvbXBvbmVudHMvY29uc3RhbnRzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9jb21wb25lbnRzL2RhdGFfbGF5ZXIvYW5ub3RhdGlvbl90cmFjay5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vY29tcG9uZW50cy9kYXRhX2xheWVyL2FyY3MuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2NvbXBvbmVudHMvZGF0YV9sYXllci9iYXNlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9jb21wb25lbnRzL2RhdGFfbGF5ZXIvZm9yZXN0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9jb21wb25lbnRzL2RhdGFfbGF5ZXIvZ2VuZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2NvbXBvbmVudHMvZGF0YV9sYXllci9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vY29tcG9uZW50cy9kYXRhX2xheWVyL2xpbmUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2NvbXBvbmVudHMvZGF0YV9sYXllci9zY2F0dGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9jb21wb25lbnRzL2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vY29tcG9uZW50cy9wYW5lbC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vY29tcG9uZW50cy9wbG90LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9jb21wb25lbnRzL3Rvb2xiYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2NvbXBvbmVudHMvdG9vbGJhci93aWRnZXRzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9kYXRhL2FkYXB0ZXJzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9kYXRhL2ZpZWxkLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9kYXRhL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9kYXRhL3JlcXVlc3Rlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vZGF0YS9zb3VyY2VzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9oZWxwZXJzL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vaGVscGVycy9kaXNwbGF5LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9oZWxwZXJzL2xheW91dHMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2hlbHBlcnMvcmVuZGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9oZWxwZXJzL3NjYWxhYmxlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9oZWxwZXJzL3RyYW5zZm9ybXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9sYXlvdXRzL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9yZWdpc3RyeS9hZGFwdGVycy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vcmVnaXN0cnkvYmFzZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vcmVnaXN0cnkvZGF0YV9sYXllcnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL3JlZ2lzdHJ5L2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9yZWdpc3RyeS9sYXlvdXRzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9yZWdpc3RyeS9zY2FsYWJsZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vcmVnaXN0cnkvdHJhbnNmb3Jtcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vcmVnaXN0cnkvd2lkZ2V0cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9lc20vdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwgXCJkM1wiIl0sIm5hbWVzIjpbIlNUQVRVU0VTIiwidmVyYnMiLCJhZGplY3RpdmVzIiwiZGVmYXVsdF9sYXlvdXQiLCJjb2xvciIsImZpbHRlcnMiLCJ0b29sdGlwX3Bvc2l0aW9uaW5nIiwiaGl0YXJlYV93aWR0aCIsIkFubm90YXRpb25UcmFjayIsImxheW91dCIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwibWVyZ2UiLCJhcmd1bWVudHMiLCJ0cmFja19kYXRhIiwiX2FwcGx5RmlsdGVycyIsInZpc2libGVfbGluZXNfZ3JvdXAiLCJzdmciLCJncm91cCIsInNlbGVjdCIsInR5cGUiLCJzaXplIiwiYXBwZW5kIiwiYXR0ciIsInNlbGVjdGlvbiIsInNlbGVjdEFsbCIsImRhdGEiLCJkIiwiaWRfZmllbGQiLCJ3aWR0aCIsImVudGVyIiwiZ2V0RWxlbWVudElkIiwicGFyZW50IiwieF9heGlzIiwiZmllbGQiLCJoZWlnaHQiLCJpIiwicmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyIiwiZXhpdCIsInJlbW92ZSIsImhpdF9hcmVhc19ncm91cCIsImhpdF9hcmVhc19zZWxlY3Rpb24iLCJfZ2V0WCIsInhfY2VudGVyIiwieF9sZWZ0IiwibGVmdF9ub2RlIiwibGVmdF9ub2RlX3hfY2VudGVyIiwiTWF0aCIsIm1heCIsImNyZHMiLCJjYWxsIiwiYXBwbHlCZWhhdmlvcnMiLCJiaW5kIiwidG9vbHRpcCIsInBhbmVsIiwiZGF0YV9sYXllcl9oZWlnaHQiLCJtYXJnaW4iLCJ0b3AiLCJib3R0b20iLCJzdHJva2Vfd2lkdGgiLCJ4X3NjYWxlIiwieV9jZW50ZXIiLCJ4X21pbiIsInhfbWF4IiwieV9taW4iLCJ5X21heCIsIkJhc2VEYXRhTGF5ZXIiLCJzdHlsZSIsImZpbGwiLCJBcmNzIiwic2VsZiIsInlfc2NhbGUiLCJ5X2F4aXMiLCJheGlzIiwiX21ha2VfbGluZSIsIngxIiwiZmllbGQxIiwieDIiLCJmaWVsZDIiLCJ4bWlkIiwiY29vcmRzIiwibGluZSIsImQzIiwieCIsInkiLCJjdXJ2ZSIsImhpdGFyZWFzIiwiYXBwbHlTdHlsZXMiLCJtaW4iLCJmaWVsZHMiLCJpbml0aWFsaXplZCIsImxheW91dF9pZHgiLCJpZCIsIl9iYXNlX2lkIiwicGFyZW50X3Bsb3QiLCJfZmlsdGVyX2Z1bmMiLCJfYmFzZV9sYXlvdXQiLCJkZWVwQ29weSIsInN0YXRlIiwic3RhdGVfaWQiLCJsYXllcl9zdGF0ZSIsIl9zZXREZWZhdWx0U3RhdGUiLCJ0b29sdGlwcyIsImdsb2JhbF9zdGF0dXNlcyIsImRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXgiLCJ6X2luZGV4IiwicmVzb3J0RGF0YUxheWVycyIsImVsZW1lbnQiLCJrZXkiLCJ2YWx1ZSIsImV4dHJhX2ZpZWxkcyIsImZ1bmMiLCJheGlzX2NvbmZpZyIsImYiLCJGaWVsZCIsInJlc29sdmUiLCJpZF9rZXkiLCJTeW1ib2wiLCJlbGVtZW50X2lkIiwidG9TdHJpbmciLCJyZXBsYWNlIiwiZ2V0QmFzZUlkIiwic2VsZWN0b3IiLCJlbXB0eSIsImxlbmd0aCIsImZpZWxkX3RvX21hdGNoIiwibWF0Y2giLCJyZWNlaXZlIiwiYnJvYWRjYXN0X3ZhbHVlIiwibHpfbWF0Y2hfdmFsdWUiLCJmb3JFYWNoIiwiaXRlbSIsInVuZGVmaW5lZCIsImx6X2hpZ2hsaWdodF9tYXRjaCIsInRvSFRNTCIsImh0bWwiLCJnZXREYXRhTGF5ZXIiLCJnZXRQYW5lbCIsImdldFBsb3QiLCJkZXNlbGVjdCIsImRhdGFfbGF5ZXIiLCJ1bnNlbGVjdEVsZW1lbnQiLCJhcHBseUN1c3RvbURhdGFNZXRob2RzIiwiZWxlbWVudF9kYXRhIiwiZGF0YV9pbmRleCIsInJldCIsImlkeCIsInNjYWxlX2Z1bmN0aW9uIiwic2NhbGFibGUiLCJnZXQiLCJleHRyYSIsImUiLCJwYXJhbWV0ZXJzIiwiZGltZW5zaW9uIiwiaW5jbHVkZXMiLCJheGlzX25hbWUiLCJheGlzX2xheW91dCIsImlzTmFOIiwiZmxvb3IiLCJjZWlsaW5nIiwiZGF0YV9leHRlbnQiLCJtaW5fZXh0ZW50IiwiX2dldERhdGFFeHRlbnQiLCJvcmlnaW5hbF9leHRlbnRfc3BhbiIsImxvd2VyX2J1ZmZlciIsInVwcGVyX2J1ZmZlciIsInJhbmdlX21pbiIsInJhbmdlX21heCIsInN0YXJ0IiwiZW5kIiwiY29uZmlnIiwieV9leHRlbnQiLCJ4X2V4dGVudCIsInBvc2l0aW9uIiwicGFuZWxfbGF5b3V0IiwibGF5ZXJfbGF5b3V0IiwiYXJyb3dfc2l6ZSIsImFycm93X3RvdGFsIiwidG9vbHRpcF9wYWRkaW5nIiwicGFnZV9vcmlnaW4iLCJfZ2V0UGFnZU9yaWdpbiIsInRvb2x0aXBfYm94Iiwibm9kZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRhdGFfbGF5ZXJfd2lkdGgiLCJsZWZ0IiwicmlnaHQiLCJ4X29mZnNldCIsInlfb2Zmc2V0IiwicGxhY2VtZW50IiwidG9vbHRpcF90b3AiLCJ0b29sdGlwX2xlZnQiLCJhcnJvd190eXBlIiwiYXJyb3dfdG9wIiwiYXJyb3dfbGVmdCIsIm9mZnNldF9yaWdodCIsIm9mZnNldF9sZWZ0IiwiYXJyb3ciLCJpbmRleCIsImFycmF5IiwidGVzdCIsImZpbHRlciIsIm9wZXJhdG9yIiwidGFyZ2V0Iiwib3BlcmF0b3JzIiwiYSIsImIiLCJmaWVsZF92YWx1ZSIsInN0YXR1c19mbGFncyIsInN0YXR1cyIsImRhdGFCQ1IiLCJiYXNlX2lkIiwiY29udGFpbmVyIiwiY2xpcFJlY3QiLCJwb3NpdGlvblRvb2x0aXAiLCJwYXJlbnROb2RlIiwicHVzaCIsInVwZGF0ZVRvb2x0aXAiLCJwYXJzZUZpZWxkcyIsImNsb3NhYmxlIiwiaW5zZXJ0IiwidGV4dCIsIm9uIiwiZGVzdHJveVRvb2x0aXAiLCJlbGVtZW50X29yX2lkIiwidGVtcG9yYXJ5IiwibGFiZWxfbWFya19wb3NpdGlvbiIsImluZGV4T2YiLCJzcGxpY2UiLCJfZ2V0VG9vbHRpcFBvc2l0aW9uIiwiX2RyYXdUb29sdGlwIiwiZmlyc3RfdGltZSIsInJlc29sdmVTdGF0dXMiLCJzdGF0dXNlcyIsImRpcmVjdGl2ZSIsInJlZHVjZSIsInByZXZpb3VzVmFsdWUiLCJjdXJyZW50VmFsdWUiLCJzdWJfc3RhdHVzIiwic3ViX29wZXJhdG9yIiwic2hvd19kaXJlY3RpdmUiLCJzaG93IiwiYW5kIiwiaGlkZV9kaXJlY3RpdmUiLCJoaWRlIiwiYW50aXN0YXR1cyIsInNob3dfcmVzb2x2ZWQiLCJoaWRlX3Jlc29sdmVkIiwiaGFzX3Rvb2x0aXAiLCJ0b29sdGlwX3dhc19jbG9zZWQiLCJjcmVhdGVUb29sdGlwIiwiYWN0aXZlIiwiZXhjbHVzaXZlIiwiZ2V0X2VsZW1lbnRfaWRfZXJyb3IiLCJzZXRBbGxFbGVtZW50U3RhdHVzIiwiY2xhc3NlZCIsImVsZW1lbnRfc3RhdHVzX25vZGVfaWQiLCJnZXRFbGVtZW50U3RhdHVzTm9kZUlkIiwiZWxlbWVudF9zdGF0dXNfaWR4IiwiYWRkZWRfc3RhdHVzIiwic2hvd09ySGlkZVRvb2x0aXAiLCJlbWl0IiwiaXNfc2VsZWN0ZWQiLCJ2YWx1ZV90b19icm9hZGNhc3QiLCJzZW5kIiwidG9nZ2xlIiwic2V0RWxlbWVudFN0YXR1cyIsInN0YXR1c19pZHMiLCJzbGljZSIsImdldEVsZW1lbnRCeUlkIiwiYmVoYXZpb3JzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZW50X21hdGNoIiwiZXhlYyIsImV4ZWN1dGVCZWhhdmlvcnMiLCJyZXF1aXJlZEtleVN0YXRlcyIsImRhdHVtIiwiY3RybCIsImN0cmxLZXkiLCJzaGlmdCIsInNoaWZ0S2V5IiwiYmVoYXZpb3IiLCJjdXJyZW50X3N0YXR1c19ib29sZWFuIiwiYWN0aW9uIiwiaHJlZiIsInVybCIsIndpbmRvdyIsIm9wZW4iLCJsb2NhdGlvbiIsInBhbmVsX29yaWdpbiIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwiY2xpcGFyZWEiLCJvcmlnaW4iLCJwb3NpdGlvbkFsbFRvb2x0aXBzIiwiZGVzdHJveUFsbFRvb2x0aXBzIiwibHpkIiwiZ2V0RGF0YSIsInRoZW4iLCJuZXdfZGF0YSIsImJvZHkiLCJhcHBseURhdGFNZXRob2RzIiwidmVyYiIsImFkamVjdGl2ZSIsImFudGl2ZXJiIiwicG9pbnRfc2l6ZSIsInBvaW50X3NoYXBlIiwiZmlsbF9vcGFjaXR5IiwiY29uZmlkZW5jZV9pbnRlcnZhbHMiLCJzdGFydF9maWVsZCIsImVuZF9maWVsZCIsInNob3dfbm9fc2lnbmlmaWNhbmNlX2xpbmUiLCJGb3Jlc3QiLCJvZmZzZXQiLCJzcXJ0IiwiUEkiLCJjaV9zZWxlY3Rpb24iLCJjaV90cmFuc2Zvcm0iLCJjaV93aWR0aCIsImNpX2hlaWdodCIsInBvaW50c19zZWxlY3Rpb24iLCJpbml0aWFsX3kiLCJ0cmFuc2Zvcm0iLCJzaGFwZSIsIm5hbWVUb1N5bWJvbCIsIkNhdGVnb3J5Rm9yZXN0IiwiY2lfY29uZmlnIiwiYXhpc19udW0iLCJjYXRlZ29yeV9maWVsZCIsIm1hcCIsImZpZWxkX3RvX2FkZCIsInN0cm9rZSIsImxhYmVsX2ZvbnRfc2l6ZSIsImxhYmVsX2V4b25fc3BhY2luZyIsImV4b25faGVpZ2h0IiwiYm91bmRpbmdfYm94X3BhZGRpbmciLCJ0cmFja192ZXJ0aWNhbF9zcGFjaW5nIiwiR2VuZXMiLCJ0cmFuc2NyaXB0X2lkeCIsInRyYWNrcyIsImdlbmVfdHJhY2tfaW5kZXgiLCJfZ2V0TGFiZWxXaWR0aCIsImdlbmVfbmFtZSIsImZvbnRfc2l6ZSIsInRlbXBfdGV4dCIsImxhYmVsX3dpZHRoIiwiZ2V0QkJveCIsImdlbmVfaWQiLCJzcGxpdCIsImdlbmVfdmVyc2lvbiIsInRyYW5zY3JpcHRfaWQiLCJ0cmFuc2NyaXB0cyIsImRpc3BsYXlfcmFuZ2UiLCJ0ZXh0X2FuY2hvciIsImNlbnRlcmVkX21hcmdpbiIsImRpc3BsYXlfZG9tYWluIiwiaW52ZXJ0IiwidHJhY2siLCJwb3RlbnRpYWxfdHJhY2siLCJjb2xsaXNpb25fb25fcG90ZW50aWFsX3RyYWNrIiwicGxhY2VkX2dlbmUiLCJtaW5fc3RhcnQiLCJtYXhfZW5kIiwidCIsImV4b25zIiwiYXNzaWduVHJhY2tzIiwiZWFjaCIsImdlbmUiLCJiYm94ZXMiLCJnZXRUcmFja0hlaWdodCIsImJvdW5kYXJpZXMiLCJsYWJlbHMiLCJzdHJhbmQiLCJleG9uX2lkIiwiY2xpY2thcmVhcyIsImdlbmVfYmJveF9pZCIsImdlbmVfYmJveCIsImludGVycG9sYXRlIiwiTGluZSIsInhfZmllbGQiLCJ5X2ZpZWxkIiwicGF0aCIsInkwIiwieTEiLCJwYXRoX2NsYXNzIiwiZ2xvYmFsX3N0YXR1cyIsImRlZmF1bHRfb3J0aG9nb25hbF9sYXlvdXQiLCJvcmllbnRhdGlvbiIsImRlY291cGxlZCIsIk9ydGhvZ29uYWxMaW5lIiwieF9yYW5nZSIsImRlZmF1bHRfeSIsImNvYWxlc2NlIiwibWF4X3BvaW50cyIsInhfZ2FwIiwieV9nYXAiLCJTY2F0dGVyIiwibGFiZWwiLCJzcGFjaW5nIiwiaGFuZGxlX2xpbmVzIiwiQm9vbGVhbiIsImxpbmVzIiwibWluX3giLCJtYXhfeCIsImZsaXAiLCJkbiIsImRubCIsImRueCIsInRleHRfc3dpbmciLCJkbmx4MiIsImxpbmVfc3dpbmciLCJsYWJlbF90ZXh0cyIsImRhIiwiZGF4IiwiYWJvdW5kIiwiZGFsIiwibGFiZWxfbGluZXMiLCJub2RlcyIsImRiIiwiYmJvdW5kIiwiY29sbGlzaW9uIiwic2VwZXJhdGVfaXRlcmF0aW9ucyIsImFscGhhIiwiYWdhaW4iLCJ5MiIsInNpZ24iLCJhZGp1c3QiLCJuZXdfYV95IiwibmV3X2JfeSIsIm1pbl95IiwibWF4X3kiLCJkZWx0YSIsImxhYmVsX2VsZW1lbnRzIiwibGFiZWxfbGluZSIsInNldFRpbWVvdXQiLCJzZXBhcmF0ZV9sYWJlbHMiLCJ4Y3MiLCJ5Y3MiLCJ4X21pbl9weCIsImlzRmluaXRlIiwiSW5maW5pdHkiLCJ4X21heF9weCIsInlfbWluX3B4IiwieV9tYXhfcHgiLCJjb2FsZXNjZV9zY2F0dGVyX3BvaW50cyIsImxhYmVsX2RhdGEiLCJsYWJlbF9ncm91cHMiLCJzdHlsZV9jbGFzcyIsImdyb3Vwc19lbnRlciIsImZsaXBfbGFiZWxzIiwiaXRlbV9kYXRhIiwicmVmIiwiYXBwbHlTdGF0ZSIsImxkcmVmdmFyIiwiQ2F0ZWdvcnlTY2F0dGVyIiwiX2NhdGVnb3JpZXMiLCJ4RmllbGQiLCJzb3VyY2VEYXRhIiwic29ydCIsImFrIiwiYmsiLCJhdiIsInRvTG93ZXJDYXNlIiwiYnYiLCJ1bmlxdWVDYXRlZ29yaWVzIiwiY2F0ZWdvcnkiLCJib3VuZHMiLCJjYXRlZ29yeU5hbWVzIiwiX3NldER5bmFtaWNDb2xvclNjaGVtZSIsImZyb21fc291cmNlIiwiY29sb3JfcGFyYW1zIiwiZmluZCIsImNvbG9yUGFyYW1zIiwiX2dldENvbG9yU2NhbGUiLCJiYXNlUGFyYW1zIiwiY2F0ZWdvcmllcyIsInZhbHVlcyIsInBhcmFtZXRlcnNfY2F0ZWdvcmllc19oYXNoIiwiZXZlcnkiLCJuYW1lIiwiY29sb3JzIiwiY29uY2F0IiwiY2F0ZWdvcnlCb3VuZHMiLCJrbm93bkNhdGVnb3JpZXMiLCJrbm93bkNvbG9ycyIsInhQb3MiLCJkaWZmIiwiX3ByZXBhcmVEYXRhIiwiX2dlbmVyYXRlQ2F0ZWdvcnlCb3VuZHMiLCJwYWRkaW5nIiwibGFiZWxfc2l6ZSIsImhpZGRlbiIsIkxlZ2VuZCIsImxlZ2VuZCIsImJhY2tncm91bmRfcmVjdCIsImVsZW1lbnRzIiwiZWxlbWVudHNfZ3JvdXAiLCJyZW5kZXIiLCJsaW5lX2hlaWdodCIsInJldmVyc2UiLCJkYXRhX2xheWVycyIsImxhYmVsX3giLCJsYWJlbF95Iiwic2hhcGVfZmFjdG9yeSIsInBhdGhfeSIsInJhZGl1cyIsImNlaWwiLCJiY3IiLCJyaWdodF94IiwicGFkX2Zyb21fYm90dG9tIiwicGFkX2Zyb21fcmlnaHQiLCJ0aXRsZSIsInlfaW5kZXgiLCJtaW5fd2lkdGgiLCJtaW5faGVpZ2h0IiwicHJvcG9ydGlvbmFsX3dpZHRoIiwicHJvcG9ydGlvbmFsX2hlaWdodCIsInByb3BvcnRpb25hbF9vcmlnaW4iLCJiYWNrZ3JvdW5kX2NsaWNrIiwidG9vbGJhciIsIndpZGdldHMiLCJheGVzIiwiaW50ZXJhY3Rpb24iLCJkcmFnX2JhY2tncm91bmRfdG9fcGFuIiwiZHJhZ194X3RpY2tzX3RvX3NjYWxlIiwiZHJhZ195MV90aWNrc190b19zY2FsZSIsImRyYWdfeTJfdGlja3NfdG9fc2NhbGUiLCJzY3JvbGxfdG9fem9vbSIsInhfbGlua2VkIiwieTFfbGlua2VkIiwieTJfbGlua2VkIiwiUGFuZWwiLCJyYW5kb20iLCJwb3ciLCJnZW5lcmF0ZUlEIiwicGFuZWxzIiwiZGF0YV9wcm9taXNlcyIsInkxX3NjYWxlIiwieTJfc2NhbGUiLCJ5MV9leHRlbnQiLCJ5Ml9leHRlbnQiLCJ4X3RpY2tzIiwieTFfdGlja3MiLCJ5Ml90aWNrcyIsInpvb21fdGltZW91dCIsImV2ZW50X2hvb2tzIiwiaW5pdGlhbGl6ZUxheW91dCIsImV2ZW50IiwiaG9vayIsInRoZXNlSG9va3MiLCJob29rTWF0Y2giLCJldmVudERhdGEiLCJidWJibGUiLCJzb3VyY2VJRCIsImV2ZW50Q29udGV4dCIsImhvb2tUb1J1biIsInBhcnNlRmxvYXQiLCJjcmVhdGUiLCJkbGlkIiwiZGF0YV9sYXllcl9sYXlvdXQiLCJhcHBseURhdGFMYXllclpJbmRleGVzVG9EYXRhTGF5ZXJMYXlvdXRzIiwiaW5uZXJfYm9yZGVyIiwic2V0VGl0bGUiLCJnZW5lcmF0ZUV4dGVudHMiLCJjb25zdHJhaW4iLCJsaW1pdF9leHBvbmVudCIsIm5lZ19taW4iLCJuZWdfbWF4IiwicG9zX21pbiIsInBvc19tYXgiLCJyYW5nZXMiLCJiYXNlX3hfcmFuZ2UiLCJyYW5nZSIsInhfc2hpZnRlZCIsImJhc2VfeTFfcmFuZ2UiLCJ5MV9zaGlmdGVkIiwiYmFzZV95Ml9yYW5nZSIsInkyX3NoaWZ0ZWQiLCJwYW5lbF9pZCIsImxpbmtlZF9wYW5lbF9pZHMiLCJhbmNob3IiLCJzY2FsYXIiLCJ6b29taW5nIiwiY3VycmVudF9leHRlbnRfc2l6ZSIsImFicyIsImN1cnJlbnRfc2NhbGVkX2V4dGVudF9zaXplIiwicm91bmQiLCJ6b29tX2ZhY3RvciIsInNjYWxlIiwicG90ZW50aWFsX2V4dGVudF9zaXplIiwibWF4X3JlZ2lvbl9zY2FsZSIsIm1pbl9yZWdpb25fc2NhbGUiLCJuZXdfZXh0ZW50X3NpemUiLCJjZW50ZXIiLCJvZmZzZXRfcmF0aW8iLCJuZXdfeF9leHRlbnRfc3RhcnQiLCJkcmFnZ2luZyIsIm1ldGhvZCIsImRyYWdnZWRfeCIsInN0YXJ0X3giLCJ5X3NoaWZ0ZWQiLCJkcmFnZ2VkX3kiLCJzdGFydF95IiwiZG9tYWluIiwicmVuZGVyQXhpcyIsInpvb21faGFuZGxlciIsImFsdEtleSIsIl9jYW5JbnRlcmFjdCIsImxvYWRlciIsInByZXZlbnREZWZhdWx0Iiwid2hlZWxEZWx0YSIsImRldGFpbCIsImRlbHRhWSIsImdldExpbmtlZFBhbmVsSWRzIiwiY2xlYXJUaW1lb3V0IiwiZGF0YV9sYXllcl9pZCIsImRyYXciLCJzaG93X2ltbWVkaWF0ZWx5IiwiYW5pbWF0ZSIsInBsb3Rfb3JpZ2luIiwicGFuZWxfY291bnQiLCJzZXREaW1lbnNpb25zIiwic2V0T3JpZ2luIiwic2V0TWFyZ2luIiwieTFfcmFuZ2UiLCJ5Ml9yYW5nZSIsImFkZERhdGFMYXllciIsImN1cnRhaW4iLCJ1cGRhdGUiLCJtIiwiY2xpcFBhdGgiLCJnZW5lcmF0ZUN1cnRhaW4iLCJnZW5lcmF0ZUxvYWRlciIsIlRvb2xiYXIiLCJjbGVhclNlbGVjdGlvbnMiLCJ4X2F4aXNfbGFiZWwiLCJ5MV9heGlzIiwieTFfYXhpc19sYWJlbCIsInkyX2F4aXMiLCJ5Ml9heGlzX2xhYmVsIiwiaW5pdGlhbGl6ZSIsIm5hbWVzcGFjZSIsIm1vdXNlZG93biIsInN0YXJ0RHJhZyIsInBhbmVsX2lkc19ieV95X2luZGV4IiwiYXBwbHlQYW5lbFlJbmRleGVzVG9QYW5lbExheW91dHMiLCJwb3NpdGlvblBhbmVscyIsInJlTWFwIiwibWVzc2FnZSIsIlByb21pc2UiLCJhbGwiLCJnZXRBeGlzRXh0ZW50IiwiZXh0ZW50IiwidGlja3MiLCJiYXNlVGlja0NvbmZpZyIsImNvbWJpbmVkVGlja3MiLCJhY2MiLCJuZXh0TGF5ZXIiLCJnZXRUaWNrcyIsIml0ZW1Db25maWciLCJwcmV0dHlUaWNrcyIsImNhblJlbmRlciIsImF4aXNfcGFyYW1zIiwibGFiZWxfb2Zmc2V0IiwibGFiZWxfcm90YXRlIiwiZ2VuZXJhdGVUaWNrcyIsInRpY2tzQXJlQWxsTnVtYmVycyIsImF4aXNfZmFjdG9yeSIsInRpY2tQYWRkaW5nIiwidGlja1ZhbHVlcyIsInRpY2tfZm9ybWF0IiwidGlja0Zvcm1hdCIsInBvc2l0aW9uSW50VG9TdHJpbmciLCJzdWJzdHIiLCJ0aWNrX3NlbGVjdG9yIiwidGlja19tb3VzZW92ZXIiLCJmb2N1cyIsImN1cnNvciIsInRhcmdldF9oZWlnaHQiLCJkaCIsImdldEFic29sdXRlRGF0YUhlaWdodCIsInJlc3BvbnNpdmVfcmVzaXplIiwicGFuZWxfYm91bmRhcmllcyIsIm1vdXNlX2d1aWRlIiwiX3VwZGF0ZVN0YXRlUG9zaXRpb24iLCJuZXdfc3RhdGUiLCJ2YWxpZGF0ZWRfcmVnaW9uIiwiYXR0ZW1wdGVkX21pZHBvaW50IiwiYXR0ZW1wdGVkX3NjYWxlIiwiY2hyIiwicGFyc2VJbnQiLCJ0ZW1wIiwiUGxvdCIsImRhdGFzb3VyY2UiLCJyZW1hcF9wcm9taXNlcyIsIlJlcXVlc3RlciIsIl9leHRlcm5hbF9saXN0ZW5lcnMiLCJNYXAiLCJwYW5lbElkIiwibW9kZSIsInBhbmVsc0xpc3QiLCJwaWQiLCJsYXllciIsImNsZWFyUGFuZWxEYXRhIiwiZGVzdHJveSIsInN1Y2Nlc3NfY2FsbGJhY2siLCJvcHRzIiwiZXJyb3JfY2FsbGJhY2siLCJvbmVycm9yIiwiZXJyIiwibG9nIiwibGlzdGVuZXIiLCJkaXNjcmV0ZSIsInN0YXRlX2NoYW5nZXMiLCJtb2RzIiwibG9hZGluZ19kYXRhIiwiYXBwbHlBbGxFbGVtZW50U3RhdHVzIiwicG9zaXRpb25fY2hhbmdlZCIsInNvbWUiLCJldmVudF9uYW1lIiwiaGFzIiwic2V0IiwidHJhY2tlciIsImVudHJpZXMiLCJyZWdpc3RlcmVkX2V2ZW50cyIsImxpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsYXN0RWxlbWVudENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJvdXRlckhUTUwiLCJib3VuZGluZ19jbGllbnRfcmVjdCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9mZnNldFBhcmVudCIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJ0b3RhbCIsImNsaWVudFJlY3QiLCJyZXNpemVfbGlzdGVuZXIiLCJyZXNjYWxlU1ZHIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRyYWNrRXh0ZXJuYWxMaXN0ZW5lciIsImxvYWRfbGlzdGVuZXIiLCJhZGRQYW5lbCIsInBhbmVsX3dpZHRoIiwicGFuZWxfaGVpZ2h0IiwieF9saW5rZWRfbWFyZ2lucyIsInRvdGFsX3Byb3BvcnRpb25hbF9oZWlnaHQiLCJzdW1Qcm9wb3J0aW9uYWwiLCJwcm9wb3J0aW9uYWxfYWRqdXN0bWVudCIsImNhbGN1bGF0ZWRfcGxvdF9oZWlnaHQiLCJtb3VzZV9ndWlkZV9zdmciLCJtb3VzZV9ndWlkZV92ZXJ0aWNhbF9zdmciLCJtb3VzZV9ndWlkZV9ob3Jpem9udGFsX3N2ZyIsInZlcnRpY2FsIiwiaG9yaXpvbnRhbCIsImhpZGVfdGltZW91dCIsInNob3dpbmciLCJzZWxlY3RvcnMiLCJjb3JuZXJfc2VsZWN0b3IiLCJwYW5lbF9pZHgiLCJwYW5lbF9yZXNpemVfZHJhZyIsInRoaXNfcGFuZWwiLCJvcmlnaW5hbF9wYW5lbF9oZWlnaHQiLCJkeSIsInBhbmVsX2hlaWdodF9jaGFuZ2UiLCJuZXdfY2FsY3VsYXRlZF9wbG90X2hlaWdodCIsImxvb3BfcGFuZWxfaWQiLCJsb29wX3BhbmVsX2lkeCIsImxvb3BfcGFuZWwiLCJjb3JuZXJfZHJhZyIsImR4IiwicGxvdF9wYWdlX29yaWdpbiIsInBhbmVsX3BhZ2Vfb3JpZ2luIiwiY29ybmVyX3BhZGRpbmciLCJjb3JuZXJfc2l6ZSIsIm1vdXNlb3V0X21vdXNlX2d1aWRlIiwibW91c2Vtb3ZlX21vdXNlX2d1aWRlIiwibW91c2V1cCIsInN0b3BEcmFnIiwibW91c2Vtb3ZlIiwiYm9keV9zZWxlY3RvciIsImJvZHlfbm9kZSIsInRvX3NlbmQiLCJjbGllbnRfcmVjdCIsIm92ZXJyaWRlQXhpc0xheW91dCIsImF4aXNfbnVtYmVyIiwieV9heGlzX251bWJlciIsInBlcnNpc3QiLCJvcHRpb25zIiwiZGFzaGJvYXJkIiwiY29tcG9uZW50cyIsIndpZGdldCIsInNob3VsZFBlcnNpc3QiLCJmb3JjZSIsIkJhc2VXaWRnZXQiLCJwYXJlbnRfcGFuZWwiLCJwYXJlbnRfc3ZnIiwiYnV0dG9uIiwiZ3JvdXBfcG9zaXRpb24iLCJtZW51IiwiQnV0dG9uIiwicGFyZW50X3Rvb2xiYXIiLCJ0YWciLCJwZXJtYW5lbnQiLCJvdXRlcl9zZWxlY3RvciIsImlubmVyX3NlbGVjdG9yIiwic2Nyb2xsX3Bvc2l0aW9uIiwicG9wdWxhdGUiLCJzY3JvbGxiYXJfcGFkZGluZyIsIm1lbnVfaGVpZ2h0X3BhZGRpbmciLCJwYWdlX3Njcm9sbF90b3AiLCJjb250YWluZXJfb2Zmc2V0IiwiZ2V0Q29udGFpbmVyT2Zmc2V0IiwidG9vbGJhcl9jbGllbnRfcmVjdCIsImJ1dHRvbl9jbGllbnRfcmVjdCIsIm1lbnVfY2xpZW50X3JlY3QiLCJ0b3RhbF9jb250ZW50X2hlaWdodCIsInNjcm9sbEhlaWdodCIsImJhc2VfbWF4X3dpZHRoIiwiY29udGFpbmVyX21heF93aWR0aCIsImNvbnRlbnRfbWF4X3dpZHRoIiwiYmFzZV9tYXhfaGVpZ2h0Iiwic2V0UG9wdWxhdGUiLCJtZW51X3BvcHVsYXRlX2Z1bmN0aW9uIiwic2V0T25jbGljayIsImhpZ2hsaWdodCIsImJvb2wiLCJzZXRTdGF0dXMiLCJvbm1vdXNlb3ZlciIsIm9ubW91c2VvdXQiLCJvbmNsaWNrIiwiZ2V0Q2xhc3MiLCJwcmVVcGRhdGUiLCJwb3N0VXBkYXRlIiwiVGl0bGUiLCJkaXZfc2VsZWN0b3IiLCJ0aXRsZV9zZWxlY3RvciIsInN1YnRpdGxlIiwiRGltZW5zaW9ucyIsImRpc3BsYXlfd2lkdGgiLCJ0b0ZpeGVkIiwiZGlzcGxheV9oZWlnaHQiLCJSZWdpb25TY2FsZSIsIkZpbHRlckZpZWxkIiwiX2RhdGFfbGF5ZXIiLCJsYXllcl9uYW1lIiwiX2ZpZWxkIiwiX2ZpZWxkX2Rpc3BsYXlfaHRtbCIsImZpZWxkX2Rpc3BsYXlfaHRtbCIsIl9vcGVyYXRvciIsIl9maWx0ZXJfaWQiLCJfZGF0YV90eXBlIiwiZGF0YV90eXBlIiwiX3ZhbHVlX3NlbGVjdG9yIiwicmVzdWx0IiwiX2dldFRhcmdldCIsIl9jbGVhckZpbHRlciIsIk51bWJlciIsImlucHV0X3NpemUiLCJkZWJvdW5jZSIsIl9nZXRWYWx1ZSIsIl9zZXRGaWx0ZXIiLCJEb3dubG9hZFNWRyIsIl9maWxlbmFtZSIsImZpbGVuYW1lIiwiX2J1dHRvbl9odG1sIiwiYnV0dG9uX2h0bWwiLCJfYnV0dG9uX3RpdGxlIiwiYnV0dG9uX3RpdGxlIiwic2V0Q29sb3IiLCJzZXRIdG1sIiwic2V0T25Nb3VzZW92ZXIiLCJfZ2V0QmxvYlVybCIsIm9sZCIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsInNldE9uTW91c2VvdXQiLCJyb290IiwiYW5jZXN0b3JfcGF0dGVybiIsImV4dHJhY3RlZENTU1RleHQiLCJzdHlsZVNoZWV0cyIsInMiLCJjc3NSdWxlcyIsInJ1bGUiLCJpc19tYXRjaCIsInNlbGVjdG9yVGV4dCIsImNzc1RleHQiLCJzdHlsZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiaW5uZXJIVE1MIiwicmVmTm9kZSIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbiIsImluc2VydEJlZm9yZSIsInRhcmdldF93aWR0aCIsInJlc2NhbGUiLCJjb3B5IiwiY2xvbmVOb2RlIiwic3Vic3RyaW5nIiwic2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJfZ2V0RGltZW5zaW9ucyIsIl9hcHBlbmRDU1MiLCJfZ2V0Q1NTIiwic3ZnX21hcmt1cCIsInNlcmlhbGl6ZVRvU3RyaW5nIiwiX2dlbmVyYXRlU1ZHIiwibWFya3VwIiwiYmxvYiIsIkJsb2IiLCJjcmVhdGVPYmplY3RVUkwiLCJEb3dubG9hZFBORyIsInN2Z191cmwiLCJjYW52YXMiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsInJlamVjdCIsImltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJkcmF3SW1hZ2UiLCJ0b0Jsb2IiLCJwbmciLCJzcmMiLCJSZW1vdmVQYW5lbCIsInN1cHByZXNzX2NvbmZpcm0iLCJjb25maXJtIiwicmVtb3ZlUGFuZWwiLCJNb3ZlUGFuZWxVcCIsImlzX2F0X3RvcCIsImRpc2FibGUiLCJtb3ZlVXAiLCJNb3ZlUGFuZWxEb3duIiwiaXNfYXRfYm90dG9tIiwibW92ZURvd24iLCJTaGlmdFJlZ2lvbiIsInN0ZXAiLCJab29tUmVnaW9uIiwiY2FuX3pvb20iLCJjdXJyZW50X3JlZ2lvbl9zY2FsZSIsIm5ld19yZWdpb25fc2NhbGUiLCJNZW51IiwibWVudV9odG1sIiwiUmVzaXplVG9EYXRhIiwic2NhbGVIZWlnaHRUb0RhdGEiLCJUb2dnbGVMZWdlbmQiLCJEaXNwbGF5T3B0aW9ucyIsImFsbG93ZWRfZmllbGRzIiwiZmllbGRzX3doaXRlbGlzdCIsImRhdGFMYXllciIsImRhdGFMYXllckxheW91dCIsImRlZmF1bHRDb25maWciLCJjb25maWdTbG90IiwiX3NlbGVjdGVkX2l0ZW0iLCJ1bmlxdWVJRCIsInRhYmxlIiwibWVudUxheW91dCIsInJlbmRlclJvdyIsImRpc3BsYXlfbmFtZSIsImRpc3BsYXlfb3B0aW9ucyIsInJvd19pZCIsInJvdyIsInJhZGlvSWQiLCJmaWVsZF9uYW1lIiwiaGFzX29wdGlvbiIsImRlZmF1bHROYW1lIiwiZGVmYXVsdF9jb25maWdfZGlzcGxheV9uYW1lIiwiZGlzcGxheSIsIlNldFN0YXRlIiwic3RhdGVfZmllbGQiLCJzaG93X3NlbGVjdGVkIiwidmFsaWRhdGVCdWlsZFNvdXJjZSIsImNsYXNzX25hbWUiLCJidWlsZCIsInNvdXJjZSIsIkJhc2VBZGFwdGVyIiwiX2VuYWJsZUNhY2hlIiwiX2NhY2hlZEtleSIsIl9fZGVwZW5kZW50U291cmNlIiwicGFyc2VJbml0IiwicGFyYW1zIiwiY2hhaW4iLCJnZXRVUkwiLCJmZXRjaCIsInJlc3BvbnNlIiwib2siLCJzdGF0dXNUZXh0IiwicmVxIiwiY2FjaGVLZXkiLCJnZXRDYWNoZUtleSIsIl9jYWNoZWRSZXNwb25zZSIsImZldGNoUmVxdWVzdCIsIk4iLCJzYW1lTGVuZ3RoIiwiY29uc3RydWN0b3IiLCJyZWNvcmRzIiwicmVjb3JkIiwiaiIsIm91dG5hbWVzIiwidHJhbnMiLCJmaWVsZEZvdW5kIiwiayIsIm91dHB1dF9yZWNvcmQiLCJ2YWwiLCJ2IiwicmVzcCIsInNvdXJjZV9pZCIsImpzb24iLCJKU09OIiwicGFyc2UiLCJub3JtYWxpemVSZXNwb25zZSIsInN0YW5kYXJkaXplZCIsImFubm90YXRlRGF0YSIsImV4dHJhY3RGaWVsZHMiLCJvbmVfc291cmNlX2JvZHkiLCJjb21iaW5lQ2hhaW5Cb2R5IiwibmV3X2JvZHkiLCJoZWFkZXIiLCJwcmVHZXREYXRhIiwicHJlIiwiZ2V0UmVxdWVzdCIsInBhcnNlUmVzcG9uc2UiLCJCYXNlQXBpQWRhcHRlciIsIkFzc29jaWF0aW9uTFoiLCJ1bnNoaWZ0IiwiYW5hbHlzaXMiLCJMRFNlcnZlciIsImpvaW4iLCJleGFjdE1hdGNoIiwiYXJyIiwicmVnZXhlcyIsInJlZ2V4IiwiZGF0YUZpZWxkcyIsInBvc2l0aW9uX2ZpZWxkIiwicHZhbHVlIiwicHZhbHVlX2ZpZWxkIiwiX25hbWVzXyIsIm5hbWVzIiwibmFtZU1hdGNoIiwiaWRfbWF0Y2giLCJSZWdFeHAiLCJvYmoiLCJpc3JlZnZhcmluIiwiaXNyZWZ2YXJvdXQiLCJsZGluIiwibGRvdXQiLCJmaW5kRXh0cmVtZVZhbHVlIiwicHZhbF9maWVsZCIsImlzX2xvZyIsImNtcCIsImV4dHJlbWVWYWwiLCJleHRyZW1lSWR4IiwicmVxRmllbGRzIiwiZmluZFJlcXVlc3RlZEZpZWxkcyIsInJlZlZhciIsImZpbmRNZXJnZUZpZWxkcyIsImNvbHVtbnMiLCJnZW5vbWVfYnVpbGQiLCJsZF9zb3VyY2UiLCJwb3B1bGF0aW9uIiwibGRfcG9wIiwiZ2V0UmVmdmFyIiwiUkVHRVhfTUFSS0VSIiwib3JpZ2luYWwiLCJjaHJvbSIsInBvcyIsImFsdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImxlZnRKb2luIiwibGZpZWxkIiwicmZpZWxkIiwicG9zaXRpb24yIiwidGFnUmVmVmFyaWFudCIsInJlZnZhciIsImlkZmllbGQiLCJvdXRyZWZuYW1lIiwib3V0bGRuYW1lIiwiY29yckZpZWxkIiwicnNxdWFyZSIsImNvbWJpbmVkIiwiY2hhaW5SZXF1ZXN0cyIsInBheWxvYWQiLCJuZXh0IiwiR3dhc0NhdGFsb2dMWiIsImJ1aWxkX29wdGlvbiIsImRlZmF1bHRfc291cmNlIiwia25vd25GaWVsZHMiLCJwb3NNYXRjaCIsImRlY2lkZXIiLCJkZWNpZGVyX291dCIsIm5fbWF0Y2hlcyIsImZuIiwib3V0biIsImNoYWluTmFtZXMiLCJjYXROYW1lcyIsIkdlbmVMWiIsIkdlbmVDb25zdHJhaW50TFoiLCJ1bmlxdWVfZ2VuZV9uYW1lcyIsInF1ZXJ5IiwiYWxpYXMiLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwiY29uc3RyYWludCIsIlJlY29tYkxaIiwiU09VUkNFX05BTUUiLCJTdGF0aWNTb3VyY2UiLCJfZGF0YSIsIlBoZVdBU0xaIiwidmFyaWFudCIsIkNvbm5lY3RvclNvdXJjZSIsInNvdXJjZXMiLCJfc291cmNlX25hbWVfbWFwcGluZyIsInNwZWNpZmllZF9pZHMiLCJfZ2V0UmVxdWlyZWRTb3VyY2VzIiwibnMiLCJjaGFpbl9zb3VyY2VfaWQiLCJwYXJ0cyIsImZ1bGxfbmFtZSIsInRyYW5zZm9ybWF0aW9ucyIsInRyYW5zZm9ybXMiLCJfYXBwbHlUcmFuc2Zvcm1hdGlvbnMiLCJfc291cmNlcyIsInJlcXVlc3RzIiwicmUiLCJyYXciLCJUUkFOU0ZPUk1TIiwiX19zcGxpdF9yZXF1ZXN0cyIsInJlcXVlc3RfaGFuZGxlcyIsIkRhdGFTb3VyY2VzIiwicmVnaXN0cnkiLCJfcmVnaXN0cnkiLCJBREFQVEVSUyIsIm92ZXJyaWRlIiwiUmVnaXN0cnlCYXNlIiwiY29udGVudF9zZWxlY3RvciIsImhpZGVfZGVsYXkiLCJjb250ZW50IiwiY3NzIiwiZGVsYXkiLCJwcm9ncmVzc19zZWxlY3RvciIsImNhbmNlbF9zZWxlY3RvciIsInBlcmNlbnQiLCJsb2FkZXJfYm91bmRyZWN0Iiwic2V0UGVyY2VudENvbXBsZXRlZCIsInN0eWxlcyIsInByb3AiLCJ0aW1lciIsImFwcGx5IiwiZXhwIiwic3VmZml4IiwiZXhwX3N5bWJvbHMiLCJMTjEwIiwicGxhY2VzX2V4cCIsIm1pbl9leHAiLCJwbGFjZXMiLCJwb3NpdGlvblN0cmluZ1RvSW50IiwicCIsInRvVXBwZXJDYXNlIiwic3VmZml4cmUiLCJtdWx0IiwiY2xpcF9yYW5nZSIsInRhcmdldF90aWNrX2NvdW50IiwibWluX24iLCJzaHJpbmtfc21sIiwiaGlnaF91X2JpYXMiLCJ1NV9iaWFzIiwiYyIsImJhc2UiLCJiYXNlX3RvRml4ZWQiLCJ1bml0IiwicG9wIiwidG9rZW5zIiwiY29uZGl0aW9uIiwidmFyaWFibGUiLCJjbG9zZSIsImFzdGlmeSIsInRva2VuIiwiYXN0IiwiY2FjaGUiLCJyZW5kZXJfbm9kZSIsInBsb3QiLCJpdGVyYXRvciIsImRhdGFzZXQiLCJyZWdpb24iLCJwYXJzZWRfc3RhdGUiLCJwYXJzZVBvc2l0aW9uUXVlcnkiLCJyZWZyZXNoIiwiY2hycG9zb2ZmIiwiY2hycG9zIiwic3FydDMiLCJ0cmlhbmdsZWRvd24iLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJhcHBseU5hbWVzcGFjZXMiLCJkZWZhdWx0X25hbWVzcGFjZSIsInJlc29sdmVkX25hbWVzcGFjZSIsInIiLCJtZXJnZV9uYW1lc3BhY2UiLCJuYW1lc3BhY2VkX2VsZW1lbnQiLCJuYW1lc3BhY2VkX3Byb3BlcnR5IiwiY3VzdG9tX2xheW91dCIsImN1c3RvbV90eXBlIiwiZGVmYXVsdF90eXBlIiwiZmFjdG9yeV9uYW1lIiwiY2hhckF0IiwiZmluYWxfZGF0YSIsInhfc3RhcnQiLCJ5X3N0YXJ0IiwiY3VycmVudF9ncm91cCIsIl9jb21iaW5lIiwiX3N0YXJ0X3J1biIsImluX2NvbWJpbmVfcmVnaW9uIiwibmVhcl9wcmlvciIsImlmX3ZhbHVlIiwiaW5wdXQiLCJudW1lcmljYWxfYmluIiwiYnJlYWtzIiwibnVsbF92YWx1ZSIsInRocmVzaG9sZCIsInByZXYiLCJjdXJyIiwiY2F0ZWdvcmljYWxfYmluIiwib3JkaW5hbF9jeWNsZSIsIm51bGx2YWwiLCJ1cHBlcl9pZHgiLCJicmsiLCJub3JtYWxpemVkX2lucHV0IiwibG9nMTAiLCJuZWdsb2cxMCIsImxvZ3Rvc2Npbm90YXRpb24iLCJzY2lub3RhdGlvbiIsInRvRXhwb25lbnRpYWwiLCJodG1sZXNjYXBlIiwidXJsZW5jb2RlIiwiTG9jdXNab29tIiwidmVyc2lvbiIsIkFkYXB0ZXJzIiwiRGF0YUxheWVycyIsIkxheW91dHMiLCJTY2FsZUZ1bmN0aW9ucyIsIlRyYW5zZm9ybWF0aW9uRnVuY3Rpb25zIiwiV2lkZ2V0cyIsIktub3duRGF0YVNvdXJjZXMiLCJJTlNUQUxMRURfUExVR0lOUyIsInVzZSIsInBsdWdpbiIsImFyZ3MiLCJpbnN0YWxsIiwiTFpfU0lHX1RIUkVTSE9MRF9MT0dQIiwic3RhbmRhcmRfYXNzb2NpYXRpb25fdG9vbHRpcCIsIm9yIiwic3RhbmRhcmRfYXNzb2NpYXRpb25fdG9vbHRpcF93aXRoX2xhYmVsIiwic3RhbmRhcmRfZ2VuZXNfdG9vbHRpcCIsImNhdGFsb2dfdmFyaWFudF90b29sdGlwIiwiY29hY2Nlc3NpYmlsaXR5X3Rvb2x0aXAiLCJzaWduaWZpY2FuY2VfbGF5ZXIiLCJyZWNvbWJfcmF0ZV9sYXllciIsImFzc29jaWF0aW9uX3B2YWx1ZXNfbGF5ZXIiLCJjb2FjY2Vzc2liaWxpdHlfbGF5ZXIiLCJhc3NvY2lhdGlvbl9wdmFsdWVzX2NhdGFsb2dfbGF5ZXIiLCJjYXRhbG9nIiwicGhld2FzX3B2YWx1ZXNfbGF5ZXIiLCJnZW5lc19sYXllciIsImdlbmVzX2xheWVyX2ZpbHRlcmVkIiwiYW5ub3RhdGlvbl9jYXRhbG9nX2xheWVyIiwibGRsejJfcG9wX3NlbGVjdG9yX21lbnUiLCJnZW5lX3NlbGVjdG9yX21lbnUiLCJzdGFuZGFyZF9wYW5lbF90b29sYmFyIiwic3RhbmRhcmRfcGxvdF90b29sYmFyIiwic3RhbmRhcmRfYXNzb2NpYXRpb25fdG9vbGJhciIsInJlZ2lvbl9uYXZfcGxvdF90b29sYmFyIiwiYXNzb2NpYXRpb25fcGFuZWwiLCJjb2FjY2Vzc2liaWxpdHlfcGFuZWwiLCJhc3NvY2lhdGlvbl9jYXRhbG9nX3BhbmVsIiwiZ2VuZXNfcGFuZWwiLCJwaGV3YXNfcGFuZWwiLCJhbm5vdGF0aW9uX2NhdGFsb2dfcGFuZWwiLCJzdGFuZGFyZF9hc3NvY2lhdGlvbl9wbG90IiwiYXNzb2NpYXRpb25fY2F0YWxvZ19wbG90Iiwic3RhbmRhcmRfcGhld2FzX3Bsb3QiLCJjb2FjY2Vzc2liaWxpdHlfcGxvdCIsImFzc2lnbiIsImNvbG9yX2NvbmZpZyIsInN0YW5kYXJkX2Fzc29jaWF0aW9uIiwic3RhbmRhcmRfYXNzb2NpYXRpb25fd2l0aF9sYWJlbCIsInN0YW5kYXJkX2dlbmVzIiwiY2F0YWxvZ192YXJpYW50IiwiY29hY2Nlc3NpYmlsaXR5IiwidG9vbGJhcl93aWRnZXRzIiwibGRsejJfcG9wX3NlbGVjdG9yIiwic3RhbmRhcmRfcGFuZWwiLCJzdGFuZGFyZF9wbG90IiwicmVnaW9uX25hdl9wbG90Iiwic2lnbmlmaWNhbmNlIiwicmVjb21iX3JhdGUiLCJhc3NvY2lhdGlvbl9wdmFsdWVzIiwiYXNzb2NpYXRpb25fcHZhbHVlc19jYXRhbG9nIiwicGhld2FzX3B2YWx1ZXMiLCJnZW5lcyIsImdlbmVzX2ZpbHRlcmVkIiwiYW5ub3RhdGlvbl9jYXRhbG9nIiwiYXNzb2NpYXRpb24iLCJhc3NvY2lhdGlvbl9jYXRhbG9nIiwicGhld2FzIiwic3RhbmRhcmRfcGhld2FzIiwiQ2xhc3NSZWdpc3RyeSIsImFkYXB0ZXJzIiwiYWRkIiwiX2l0ZW1zIiwiZnJvbSIsInBhcmVudF9uYW1lIiwic291cmNlX25hbWUiLCJvdmVycmlkZXMiLCJzdWIiLCJsYXllcnMiLCJMYXlvdXRSZWdpc3RyeSIsInVubmFtZXNwYWNlZCIsImNvbnRlbnRzIiwibGlzdCIsImxheW91dHMiLCJ0ZW1wbGF0ZV9zdHJpbmciLCJmdW5jcyIsIl9jb2xsZWN0VHJhbnNmb3JtcyJdLCJtYXBwaW5ncyI6Ijs7O1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQVVPLElBQU1BLFFBQVEsR0FBRztBQUNwQkMsT0FBSyxFQUFFLENBQUMsV0FBRCxFQUFjLFFBQWQsRUFBd0IsTUFBeEIsRUFBZ0MsTUFBaEMsQ0FEYTtBQUVwQkMsWUFBVSxFQUFFLENBQUMsYUFBRCxFQUFnQixVQUFoQixFQUE0QixPQUE1QixFQUFxQyxRQUFyQztBQUZRLENBQWpCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QTtBQUFlLDhFQUFmLEU7Ozs7Ozs7Ozs7O0FDQUEsb0IiLCJmaWxlIjoibG9jdXN6b29tLmFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2VzbS9pbmRleC5qc1wiKTtcbiIsIi8qKlxuICogQXZhaWxhYmxlIHN0YXR1c2VzIHRoYXQgaW5kaXZpZHVhbCBlbGVtZW50cyBjYW4gaGF2ZS4gRWFjaCBzdGF0dXMgaXMgZGVzY3JpYmVkIGJ5XG4gKiAgIGEgdmVyYiBhbmQgYW4gYWRqZWN0aXZlLiBWZXJicyBhcmUgdXNlZCB0byBnZW5lcmF0ZSBkYXRhIGxheWVyXG4gKiAgIG1ldGhvZHMgZm9yIHVwZGF0aW5nIHRoZSBzdGF0dXMgb24gb25lIG9yIG1vcmUgZWxlbWVudHMuIEFkamVjdGl2ZXMgYXJlIHVzZWQgaW4gY2xhc3NcbiAqICAgbmFtZXMgYW5kIGFwcGxpZWQgb3IgcmVtb3ZlZCBmcm9tIGVsZW1lbnRzIHRvIGhhdmUgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0YXR1cyxcbiAqICAgYXMgd2VsbCBhcyB1c2VkIGFzIGtleXMgaW4gdGhlIHN0YXRlIGZvciB0cmFja2luZyB3aGljaCBlbGVtZW50cyBhcmUgaW4gd2hpY2ggc3RhdHVzKGVzKVxuICogQHN0YXRpY1xuICogQHR5cGUge3t2ZXJiczogU3RyaW5nW10sIGFkamVjdGl2ZXM6IFN0cmluZ1tdfX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBTVEFUVVNFUyA9IHtcbiAgICB2ZXJiczogWydoaWdobGlnaHQnLCAnc2VsZWN0JywgJ2ZhZGUnLCAnaGlkZSddLFxuICAgIGFkamVjdGl2ZXM6IFsnaGlnaGxpZ2h0ZWQnLCAnc2VsZWN0ZWQnLCAnZmFkZWQnLCAnaGlkZGVuJ10sXG59O1xuIiwiLyoqIEBtb2R1bGUgKi9cbmltcG9ydCBCYXNlRGF0YUxheWVyIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQge21lcmdlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2xheW91dHMnO1xuXG5jb25zdCBkZWZhdWx0X2xheW91dCA9IHtcbiAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgIGZpbHRlcnM6IG51bGwsXG4gICAgdG9vbHRpcF9wb3NpdGlvbmluZzogJ3ZlcnRpY2FsJywgLy8gQWxsb3dlZCB2YWx1ZXM6IHRvcCwgbWlkZGxlLCBib3R0b21cbiAgICBoaXRhcmVhX3dpZHRoOiA4LFxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzaW5nbGUgY29udGludW91cyAyRCB0cmFjayB0aGF0IHByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggZGF0YXBvaW50XG4gKlxuICogRm9yIGV4YW1wbGUsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY29sb3IgYnkgbWVtYmVyc2hpcCBpbiBhIGdyb3VwLCBhbG9uZ3NpZGUgaW5mb3JtYXRpb24gaW4gb3RoZXIgcGFuZWxzXG4gKlxuICovXG5jbGFzcyBBbm5vdGF0aW9uVHJhY2sgZXh0ZW5kcyBCYXNlRGF0YUxheWVyIHtcbiAgICAvKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtsYXlvdXQuY29sb3JdXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbGF5b3V0LmZpbHRlcnMgQW4gYXJyYXkgb2YgZmlsdGVyIGVudHJpZXMgc3BlY2lmeWluZyB3aGljaCBwb2ludHMgdG8gZHJhdyBhbm5vdGF0aW9ucyBmb3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYXlvdXQuZmlsdGVycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW5ub3RhdGlvbiB0cmFjayBtdXN0IHNwZWNpZnkgYXJyYXkgb2YgZmlsdGVycyBmb3Igc2VsZWN0aW5nIHBvaW50cyB0byBhbm5vdGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKGxheW91dCwgZGVmYXVsdF9sYXlvdXQpO1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gQXBwbHkgZmlsdGVycyB0byBvbmx5IHJlbmRlciBhIHNwZWNpZmllZCBzZXQgb2YgcG9pbnRzXG4gICAgICAgIGNvbnN0IHRyYWNrX2RhdGEgPSB0aGlzLl9hcHBseUZpbHRlcnMoKTtcblxuICAgICAgICAvLyBQdXQgdGhlIDxnPiBjb250YWluaW5nIHZpc2libGUgbGluZXMgYmVmb3JlIHRoZSBvbmUgY29udGFpbmluZyBoaXQgYXJlYXMsIHNvIHRoYXQgdGhlIGhpdCBhcmVhcyB3aWxsIGJlIG9uIHRvcC5cbiAgICAgICAgbGV0IHZpc2libGVfbGluZXNfZ3JvdXAgPSB0aGlzLnN2Zy5ncm91cC5zZWxlY3QoYGcubHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9LXZpc2libGVfbGluZXNgKTtcbiAgICAgICAgaWYgKHZpc2libGVfbGluZXNfZ3JvdXAuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB2aXNpYmxlX2xpbmVzX2dyb3VwID0gdGhpcy5zdmcuZ3JvdXAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgbHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9LXZpc2libGVfbGluZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB2aXNpYmxlX2xpbmVzX2dyb3VwLnNlbGVjdEFsbChgcmVjdC5sei1kYXRhX2xheWVyLSR7dGhpcy5sYXlvdXQudHlwZX1gKVxuICAgICAgICAgICAgLmRhdGEodHJhY2tfZGF0YSwgKGQpID0+IGRbdGhpcy5sYXlvdXQuaWRfZmllbGRdKTtcblxuICAgICAgICBjb25zdCB3aWR0aCA9IDE7XG4gICAgICAgIC8vIERyYXcgcmVjdGFuZ2xlcyAodmlzdWFsIGFuZCB0b29sdGlwIHBvc2l0aW9uaW5nKVxuICAgICAgICBzZWxlY3Rpb24uZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgbHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9YClcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiB0aGlzLmdldEVsZW1lbnRJZChkKSlcbiAgICAgICAgICAgIC5tZXJnZShzZWxlY3Rpb24pXG4gICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiB0aGlzLnBhcmVudFsneF9zY2FsZSddKGRbdGhpcy5sYXlvdXQueF9heGlzLmZpZWxkXSkgLSB3aWR0aCAvIDIpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnBhcmVudC5sYXlvdXQuaGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4gdGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQuY29sb3IsIGQsIGkpKTtcblxuICAgICAgICAvLyBSZW1vdmUgdW51c2VkIGVsZW1lbnRzXG4gICAgICAgIHNlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgaGl0X2FyZWFzX2dyb3VwID0gdGhpcy5zdmcuZ3JvdXAuc2VsZWN0KGBnLmx6LWRhdGFfbGF5ZXItJHt0aGlzLmxheW91dC50eXBlfS1oaXRfYXJlYXNgKTtcbiAgICAgICAgaWYgKGhpdF9hcmVhc19ncm91cC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIGhpdF9hcmVhc19ncm91cCA9IHRoaXMuc3ZnLmdyb3VwLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYGx6LWRhdGFfbGF5ZXItJHt0aGlzLmxheW91dC50eXBlfS1oaXRfYXJlYXNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaXRfYXJlYXNfc2VsZWN0aW9uID0gaGl0X2FyZWFzX2dyb3VwLnNlbGVjdEFsbChgcmVjdC5sei1kYXRhX2xheWVyLSR7dGhpcy5sYXlvdXQudHlwZX1gKVxuICAgICAgICAgICAgLmRhdGEodHJhY2tfZGF0YSwgKGQpID0+IGRbdGhpcy5sYXlvdXQuaWRfZmllbGRdKTtcblxuICAgICAgICBjb25zdCBfZ2V0WCA9IChkLCBpKSA9PiB7IC8vIEhlbHBlciBmb3IgcG9zaXRpb24gY2FsY3MgYmVsb3dcbiAgICAgICAgICAgIGNvbnN0IHhfY2VudGVyID0gdGhpcy5wYXJlbnRbJ3hfc2NhbGUnXShkW3RoaXMubGF5b3V0LnhfYXhpcy5maWVsZF0pO1xuICAgICAgICAgICAgbGV0IHhfbGVmdCA9IHhfY2VudGVyIC0gdGhpcy5sYXlvdXQuaGl0YXJlYV93aWR0aCAvIDI7XG4gICAgICAgICAgICBpZiAoaSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGRhdGEgYXJlIGluIHNvcnRlZCBvcmRlci5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0X25vZGUgPSB0cmFja19kYXRhW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0X25vZGVfeF9jZW50ZXIgPSB0aGlzLnBhcmVudFsneF9zY2FsZSddKGxlZnRfbm9kZVt0aGlzLmxheW91dC54X2F4aXMuZmllbGRdKTtcbiAgICAgICAgICAgICAgICB4X2xlZnQgPSBNYXRoLm1heCh4X2xlZnQsICh4X2NlbnRlciArIGxlZnRfbm9kZV94X2NlbnRlcikgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeF9sZWZ0LCB4X2NlbnRlcl07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5ldyBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgaGl0X2FyZWFzX3NlbGVjdGlvbi5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei1kYXRhX2xheWVyLSR7dGhpcy5sYXlvdXQudHlwZX1gKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IHRoaXMuZ2V0RWxlbWVudElkKGQpKVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXQgb2YgZWxlbWVudHMgdG8gcmVmbGVjdCBuZXcgZGF0YVxuICAgICAgICAgICAgLm1lcmdlKGhpdF9hcmVhc19zZWxlY3Rpb24pXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmRzID0gX2dldFgoZCwgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZHNbMF07XG4gICAgICAgICAgICB9KS5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JkcyA9IF9nZXRYKGQsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3Jkc1sxXSAtIGNyZHNbMF0pICsgdGhpcy5sYXlvdXQuaGl0YXJlYV93aWR0aCAvIDI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgdXAgdG9vbHRpcHMgYW5kIG1vdXNlIGludGVyYWN0aW9uXG4gICAgICAgIHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmFwcGx5QmVoYXZpb3JzLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB1bnVzZWQgZWxlbWVudHNcbiAgICAgICAgaGl0X2FyZWFzX3NlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBfZ2V0VG9vbHRpcFBvc2l0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgY29uc3QgZGF0YV9sYXllcl9oZWlnaHQgPSBwYW5lbC5sYXlvdXQuaGVpZ2h0IC0gKHBhbmVsLmxheW91dC5tYXJnaW4udG9wICsgcGFuZWwubGF5b3V0Lm1hcmdpbi5ib3R0b20pO1xuICAgICAgICBjb25zdCBzdHJva2Vfd2lkdGggPSAxOyAvLyBhcyBkZWZpbmVkIGluIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXRcblxuICAgICAgICBjb25zdCB4X2NlbnRlciA9IHBhbmVsLnhfc2NhbGUodG9vbHRpcC5kYXRhW3RoaXMubGF5b3V0LnhfYXhpcy5maWVsZF0pO1xuICAgICAgICBjb25zdCB5X2NlbnRlciA9IGRhdGFfbGF5ZXJfaGVpZ2h0IC8gMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhfbWluOiB4X2NlbnRlciAtIHN0cm9rZV93aWR0aCxcbiAgICAgICAgICAgIHhfbWF4OiB4X2NlbnRlciArIHN0cm9rZV93aWR0aCxcbiAgICAgICAgICAgIHlfbWluOiB5X2NlbnRlciAtIHBhbmVsLmxheW91dC5tYXJnaW4udG9wLFxuICAgICAgICAgICAgeV9tYXg6IHlfY2VudGVyICsgcGFuZWwubGF5b3V0Lm1hcmdpbi5ib3R0b20sXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQge0Fubm90YXRpb25UcmFjayBhcyBkZWZhdWx0fTtcbiIsIi8qKlxuICogQXJjIERhdGEgTGF5ZXJcbiAqIEltcGxlbWVudHMgYSBkYXRhIGxheWVyIHRoYXQgd2lsbCByZW5kZXIgY2hyb21hdGluIGFjY2Vzc2liaWxpdHkgdHJhY2tzLlxuICogVGhpcyBsYXllciBkcmF3cyBhcmNzIChvbmUgcGVyIGRhdGFwb2ludCkgdGhhdCBjb25uZWN0IHR3byBlbmRwb2ludHMgKHguZmllbGQxIGFuZCB4LmZpZWxkMikgYnkgbWVhbnMgb2YgYW4gYXJjLFxuICogIHdpdGggYSBoZWlnaHQgZGV0ZXJtaW5lZCBieSB5LmZpZWxkLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cbmltcG9ydCBCYXNlRGF0YUxheWVyIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQge21lcmdlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2xheW91dHMnO1xuaW1wb3J0IHthcHBseVN0eWxlc30gZnJvbSAnLi4vLi4vaGVscGVycy9jb21tb24nO1xuXG5jb25zdCBkZWZhdWx0X2xheW91dCA9IHtcbiAgICBjb2xvcjogJ3NlYWdyZWVuJyxcbiAgICBoaXRhcmVhX3dpZHRoOiAnMTBweCcsXG4gICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogJzFweCcsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6ICcxMDAlJyxcbiAgICB9LFxuICAgIHRvb2x0aXBfcG9zaXRpb25pbmc6ICd0b3AnLFxufTtcblxuY2xhc3MgQXJjcyBleHRlbmRzIEJhc2VEYXRhTGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICBsYXlvdXQgPSBtZXJnZShsYXlvdXQsIGRlZmF1bHRfbGF5b3V0KTtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBJbXBsZW1lbnQgdGhlIG1haW4gcmVuZGVyIGZ1bmN0aW9uXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gc2VsZi5sYXlvdXQ7XG4gICAgICAgIGNvbnN0IHhfc2NhbGUgPSBzZWxmLnBhcmVudFsneF9zY2FsZSddO1xuICAgICAgICBjb25zdCB5X3NjYWxlID0gc2VsZi5wYXJlbnRbYHkke2xheW91dC55X2F4aXMuYXhpc31fc2NhbGVgXTtcblxuICAgICAgICAvLyBBcHBseSBmaWx0ZXJzIHRvIG9ubHkgcmVuZGVyIGEgc3BlY2lmaWVkIHNldCBvZiBwb2ludHNcbiAgICAgICAgY29uc3QgdHJhY2tfZGF0YSA9IHRoaXMuX2FwcGx5RmlsdGVycygpO1xuXG4gICAgICAgIC8vIEhlbHBlcjogRWFjaCBpbmRpdmlkdWFsIGRhdGEgcG9pbnQgZGVzY3JpYmVzIGEgcGF0aCBjb21wb3NlZCBvZiAzIHBvaW50cywgd2l0aCBhIHNwbGluZSB0byBzbW9vdGggdGhlIGxpbmVcbiAgICAgICAgZnVuY3Rpb24gX21ha2VfbGluZShkKSB7XG4gICAgICAgICAgICBjb25zdCB4MSA9IGRbbGF5b3V0LnhfYXhpcy5maWVsZDFdO1xuICAgICAgICAgICAgY29uc3QgeDIgPSBkW2xheW91dC54X2F4aXMuZmllbGQyXTtcbiAgICAgICAgICAgIGNvbnN0IHhtaWQgPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gW1xuICAgICAgICAgICAgICAgIFt4X3NjYWxlKHgxKSwgeV9zY2FsZSgwKV0sXG4gICAgICAgICAgICAgICAgW3hfc2NhbGUoeG1pZCksIHlfc2NhbGUoZFtsYXlvdXQueV9heGlzLmZpZWxkXSldLFxuICAgICAgICAgICAgICAgIFt4X3NjYWxlKHgyKSwgeV9zY2FsZSgwKV0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gU21vb3RoaW5nIG9wdGlvbnM6IGh0dHBzOi8vYmwub2Nrcy5vcmcvZW1tYXNhdW5kZXJzL2Y3MTc4ZWQ3MTVhNjAxYzViMmM0NThhMmM3MDkzZjc4XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZDMubGluZSgpXG4gICAgICAgICAgICAgICAgLngoKGQpID0+IGRbMF0pXG4gICAgICAgICAgICAgICAgLnkoKGQpID0+IGRbMV0pXG4gICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlTmF0dXJhbCk7XG4gICAgICAgICAgICByZXR1cm4gbGluZShjb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyByZWFsIGxpbmVzLCBhbmQgYWxzbyBpbnZpc2libGUgaGl0YXJlYXMgZm9yIGVhc2llciBtb3VzZSBldmVudHNcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zdmcuZ3JvdXBcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgubHotZGF0YV9sYXllci1hcmNzJylcbiAgICAgICAgICAgIC5kYXRhKHRyYWNrX2RhdGEsIChkKSA9PiB0aGlzLmdldEVsZW1lbnRJZChkKSk7XG5cbiAgICAgICAgY29uc3QgaGl0YXJlYXMgPSB0aGlzLnN2Zy5ncm91cFxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5sei1kYXRhX2xheWVyLWFyY3MtaGl0YXJlYScpXG4gICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4gdGhpcy5nZXRFbGVtZW50SWQoZCkpO1xuXG4gICAgICAgIHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAuY2FsbChhcHBseVN0eWxlcywgbGF5b3V0LnN0eWxlKTtcblxuICAgICAgICAvLyBBZGQgbmV3IHBvaW50cyBhcyBuZWNlc3NhcnlcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1hcmNzJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiB0aGlzLmdldEVsZW1lbnRJZChkKSlcbiAgICAgICAgICAgIC5tZXJnZShzZWxlY3Rpb24pXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgKGQsIGkpID0+IHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHRoaXMubGF5b3V0LmNvbG9yLCBkLCBpKSlcbiAgICAgICAgICAgIC5hdHRyKCdkJywgKGQsIGkpID0+IF9tYWtlX2xpbmUoZCkpO1xuXG4gICAgICAgIGhpdGFyZWFzXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1hcmNzLWhpdGFyZWEnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IHRoaXMuZ2V0RWxlbWVudElkKGQpKVxuICAgICAgICAgICAgLm1lcmdlKGhpdGFyZWFzKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBsYXlvdXQuaGl0YXJlYV93aWR0aClcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAndHJhbnNwYXJlbnQnKVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAoZCkgPT4gX21ha2VfbGluZShkKSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgc2VsZWN0aW9uLmV4aXQoKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIGhpdGFyZWFzLmV4aXQoKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IG1vdXNlIGJlaGF2aW9ycyB0byBhcmNzXG4gICAgICAgIHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmFwcGx5QmVoYXZpb3JzLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9nZXRUb29sdGlwUG9zaXRpb24odG9vbHRpcCkge1xuICAgICAgICAvLyBDZW50ZXIgdGhlIHRvb2x0aXAgYXJyb3cgYXQgdGhlIGFwZXggb2YgdGhlIGFyYy4gU29tZXRpbWVzLCBvbmx5IHBhcnQgb2YgYW4gYXJjIHNob3dzIG9uIHRoZSBzY3JlZW4sIHNvIHdlXG4gICAgICAgIC8vICBjbGVhbiB1cCB0aGVzZSB2YWx1ZXMgdG8gZW5zdXJlIHRoYXQgdGhlIHRvb2x0aXAgd2lsbCBhcHBlYXIgd2l0aGluIHRoZSB3aW5kb3cuXG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMubGF5b3V0O1xuXG4gICAgICAgIGNvbnN0IHgxID0gdG9vbHRpcC5kYXRhW2xheW91dC54X2F4aXMuZmllbGQxXTtcbiAgICAgICAgY29uc3QgeDIgPSB0b29sdGlwLmRhdGFbbGF5b3V0LnhfYXhpcy5maWVsZDJdO1xuXG4gICAgICAgIGNvbnN0IHlfc2NhbGUgPSBwYW5lbFtgeSR7bGF5b3V0LnlfYXhpcy5heGlzfV9zY2FsZWBdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4X21pbjogcGFuZWwueF9zY2FsZShNYXRoLm1pbih4MSwgeDIpKSxcbiAgICAgICAgICAgIHhfbWF4OiBwYW5lbC54X3NjYWxlKE1hdGgubWF4KHgxLCB4MikpLFxuICAgICAgICAgICAgeV9taW46IHlfc2NhbGUodG9vbHRpcC5kYXRhW2xheW91dC55X2F4aXMuZmllbGRdKSxcbiAgICAgICAgICAgIHlfbWF4OiB5X3NjYWxlKDApLFxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG5leHBvcnQge0FyY3MgYXMgZGVmYXVsdH07XG4iLCIvKiogQG1vZHVsZSAqL1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuXG5pbXBvcnQge1NUQVRVU0VTfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IEZpZWxkIGZyb20gJy4uLy4uL2RhdGEvZmllbGQnO1xuaW1wb3J0IHtwYXJzZUZpZWxkc30gZnJvbSAnLi4vLi4vaGVscGVycy9kaXNwbGF5JztcbmltcG9ydCB7ZGVlcENvcHksIG1lcmdlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2xheW91dHMnO1xuaW1wb3J0IHNjYWxhYmxlIGZyb20gJy4uLy4uL3JlZ2lzdHJ5L3NjYWxhYmxlJztcblxuXG4vKipcbiAqIEEgYmFzaWMgZGVzY3JpcHRpb24gb2Yga2V5cyBleHBlY3RlZCBpbiBhIGxheW91dC4gTm90IGludGVuZGVkIHRvIGJlIGRpcmVjdGx5IHVzZWQgb3IgbW9kaWZpZWQgYnkgYW4gZW5kIHVzZXIuXG4gKiBAcHJvdGVjdGVkXG4gKiBAdHlwZSB7e3R5cGU6IHN0cmluZywgZmllbGRzOiBBcnJheSwgeF9heGlzOiB7fSwgeV9heGlzOiB7fX19XG4gKi9cbmNvbnN0IGRlZmF1bHRfbGF5b3V0ID0ge1xuICAgIHR5cGU6ICcnLFxuICAgIGZpbHRlcnM6IG51bGwsICAvLyBDYW4gYmUgYW4gYXJyYXkgb2Yge2ZpZWxkLCBvcGVyYXRvciwgdmFsdWV9IGVudHJpZXNcbiAgICBmaWVsZHM6IFtdLCAgLy8gQSBsaXN0IG9mIGZpZWxkcyByZXF1aXJlZCBmb3IgdGhpcyBkYXRhIGxheWVyOyBkZXRlcm1pbmVzIG91dHB1dCBvZiBgZXh0cmFjdEZpZWxkc2BcbiAgICB4X2F4aXM6IHt9LCAgLy8gQXhpcyBvcHRpb25zIHZhcnkgYmFzZWQgb24gZGF0YSBsYXllciB0eXBlXG4gICAgeV9heGlzOiB7fSwgIC8vIEF4aXMgb3B0aW9ucyB2YXJ5IGJhc2VkIG9uIGRhdGEgbGF5ZXIgdHlwZVxuICAgIHRvb2x0aXBfcG9zaXRpb25pbmc6ICdob3Jpem9udGFsJywgIC8vIFdoZXJlIHRvIGRyYXcgdG9vbHRpcHMgcmVsYXRpdmUgdG8gdGhlIHBvaW50LiBDYW4gYmUgXCJ2ZXJ0aWNhbFwiIG9yIFwiaG9yaXpvbnRhbFwiXG59O1xuXG5cbi8qKlxuICogQSBkYXRhIGxheWVyIGlzIGFuIGFic3RyYWN0IGNsYXNzIHJlcHJlc2VudGluZyBhIGRhdGEgc2V0IGFuZCBpdHMgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIHdpdGhpbiBhIHBhbmVsXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0IEEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGxheW91dCBmb3IgdGhpcyBsYXllclxuICogQHBhcmFtIHtQYW5lbHxudWxsfSBwYXJlbnQgV2hlcmUgdGhpcyBsYXlvdXQgaXMgdXNlZFxuKi9cbmNsYXNzIEJhc2VEYXRhTGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcGFyZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXlvdXRfaWR4ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGxheWVyLiBTaG91bGQgYmUgdW5pcXVlIHdpdGhpbiB0aGlzIHBhbmVsLlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgICAgID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZ1bGx5IHF1YWxpZmllZCBpZGVudGlmaWVyIGZvciB0aGUgZGF0YSBsYXllciwgcHJlZml4ZWQgYnkgYW55IHBhcmVudCBvciBjb250YWluZXIgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXNlX2lkID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtQYW5lbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHt7Z3JvdXA6IGQzLnNlbGVjdGlvbiwgY29udGFpbmVyOiBkMy5zZWxlY3Rpb24sIGNsaXBSZWN0OiBkMy5zZWxlY3Rpb259fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmcgICAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtQbG90fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRfcGxvdCA9IG51bGw7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGxheW91dCBjb25maWd1cmF0aW9uIGZvciB0aGlzIGRhdGEgbGF5ZXIuIFRoaXMgcmVmbGVjdHMgYW55IHJlc2l6aW5nIG9yIGR5bmFtaWNhbGx5IGdlbmVyYXRlZFxuICAgICAgICAgKiAgY29uZmlnIG9wdGlvbnMgcHJvZHVjZWQgZHVyaW5nIHJlbmRlcmluZy4gRGlyZWN0IGxheW91dCBtdXRhdGlvbnMgYXJlIGEgcG93ZXJmdWwgd2F5IHRvIGR5bmFtaWNhbGx5XG4gICAgICAgICAqICBtb2RpZnkgdGhlIHBsb3QgaW4gcmVzcG9uc2UgdG8gdXNlciBpbnRlcmFjdGlvbnMsIGJ1dCByZXF1aXJlIGEgZGVlcCBrbm93bGVkZ2Ugb2YgTFogaW50ZXJuYWxzIHRvIHVzZVxuICAgICAgICAgKiAgZWZmZWN0aXZlbHkuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBtZXJnZShsYXlvdXQgfHwge30sIGRlZmF1bHRfbGF5b3V0KTtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LmlkKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5sYXlvdXQuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIGRhdGEgZm9yIGRpc3BsYXkuIElmIHByb3ZpZGVkLCB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlY2xhcmF0aXZlXG4gICAgICAgICAqICBvcHRpb25zIGluIGBsYXlvdXQuZmlsdGVyc2BcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZpbHRlcl9mdW5jID0gbnVsbDtcblxuICAgICAgICAvLyBFbnN1cmUgYW55IGF4ZXMgZGVmaW5lZCBpbiB0aGUgbGF5b3V0IGhhdmUgYW4gZXhwbGljaXQgYXhpcyBudW1iZXIgKGRlZmF1bHQ6IDEpXG4gICAgICAgIGlmICh0aGlzLmxheW91dC54X2F4aXMgIT09IHt9ICYmIHR5cGVvZiB0aGlzLmxheW91dC54X2F4aXMuYXhpcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnhfYXhpcy5heGlzID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQueV9heGlzICE9PSB7fSAmJiB0eXBlb2YgdGhpcy5sYXlvdXQueV9heGlzLmF4aXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC55X2F4aXMuYXhpcyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIGluIHRoZSBsYXlvdXQgb2JqZWN0IG1heSBjaGFuZ2UgZHVyaW5nIHJlbmRlcmluZyBldGMuIFJldGFpbiBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGRhdGEgbGF5ZXIgc3RhdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXNlX2xheW91dCA9IGRlZXBDb3B5KHRoaXMubGF5b3V0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZV9pZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5sYXllcl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmF1bHQgc3RhdGUgKGFuZCBzZXQgYW55IHJlZmVyZW5jZXMgdG8gdGhlIHBhcmVudCBhcyBhcHByb3ByaWF0ZSlcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdFN0YXRlKCk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzIGZvciBzdG9yaW5nIGRhdGEgYW5kIHRvb2wgdGlwc1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEgcmV0cmlldmVkIGZyb20gYSByZWdpb24gcmVxdWVzdC4gVGhpcyBmaWVsZCBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZywgYnV0IHdpbGwgYmUgb3ZlcnJpZGRlbiBvblxuICAgICAgICAgKiAgcmUtcmVuZGVyOyBkbyBub3QgbW9kaWZ5IGl0IGRpcmVjdGx5LiBUaGUgcG9pbnQgYW5ub3RhdGlvbiBjYWNoZSBjYW4gYmUgdXNlZCB0byBwcmVzZXJ2ZSBtYXJraW5nc1xuICAgICAgICAgKiAgYWZ0ZXIgcmUtcmVuZGVyLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIGlmICh0aGlzLmxheW91dC50b29sdGlwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudG9vbHRpcHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZmxhZ3MgZm9yIHRyYWNraW5nIGdsb2JhbCBzdGF0dXNlc1xuICAgICAgICB0aGlzLmdsb2JhbF9zdGF0dXNlcyA9IHtcbiAgICAgICAgICAgICdoaWdobGlnaHRlZCc6IGZhbHNlLFxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogZmFsc2UsXG4gICAgICAgICAgICAnZmFkZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICdoaWRkZW4nOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKioqKioqIFB1YmxpYyBpbnRlcmZhY2U6IG1ldGhvZHMgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvbiAqL1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBkYXRhIGxheWVyIGZvcndhcmQgcmVsYXRpdmUgdG8gb3RoZXJzIGJ5IHotaW5kZXhcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge0Jhc2VEYXRhTGF5ZXJ9XG4gICAgICovXG4gICAgbW92ZUZvcndhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4W3RoaXMubGF5b3V0LnpfaW5kZXggKyAxXSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleFt0aGlzLmxheW91dC56X2luZGV4XSA9IHRoaXMucGFyZW50LmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXhbdGhpcy5sYXlvdXQuel9pbmRleCArIDFdO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleFt0aGlzLmxheW91dC56X2luZGV4ICsgMV0gPSB0aGlzLmlkO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVzb3J0RGF0YUxheWVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBkYXRhIGxheWVyIGJhY2sgcmVsYXRpdmUgdG8gb3RoZXJzIGJ5IHotaW5kZXhcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge0Jhc2VEYXRhTGF5ZXJ9XG4gICAgICovXG4gICAgbW92ZUJhY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4W3RoaXMubGF5b3V0LnpfaW5kZXggLSAxXSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleFt0aGlzLmxheW91dC56X2luZGV4XSA9IHRoaXMucGFyZW50LmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXhbdGhpcy5sYXlvdXQuel9pbmRleCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleFt0aGlzLmxheW91dC56X2luZGV4IC0gMV0gPSB0aGlzLmlkO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVzb3J0RGF0YUxheWVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBcImFubm90YXRpb25cIjogYSBwaWVjZSBvZiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGEgcG9pbnQgdGhhdCBpcyBwcmVzZXJ2ZWQgYWNyb3NzIHJlLXJlbmRlcixcbiAgICAgKiAgb3IgYXMgdGhlIHVzZXIgcGFucyBhbmQgem9vbXMgbmVhciB0aGlzIHJlZ2lvbi5cbiAgICAgKlxuICAgICAqIEFubm90YXRpb25zIGNhbiBiZSByZWZlcmVuY2VkIGFzIGEgbmFtZWQgcHNldWRvLWZpZWxkIGluIGFueSBmaWx0ZXJzIGFuZCBzY2FsYWJsZSBwYXJhbWV0ZXJzLiAodGVtcGxhdGUgc3VwcG9ydFxuICAgICAqICBtYXkgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZSlcbiAgICAgKiBTYW1wbGUgdXNlIGNhc2U6IHVzZXIgY2xpY2tzIGEgdG9vbHRpcCB0byBcImxhYmVsIHRoaXMgc3BlY2lmaWMgcG9pbnRcIi4gKG9yIGNoYW5nZSBhbnkgb3RoZXIgZGlzcGxheSBwcm9wZXJ0eSlcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGVsZW1lbnQgVGhlIGRhdGEgb2JqZWN0IG9yIElEIHN0cmluZyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBhbm5vdGF0aW9uIHRvIHRyYWNrXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG1hcmtlZCBmaWVsZFxuICAgICAqL1xuICAgIHNldEVsZW1lbnRBbm5vdGF0aW9uIChlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRFbGVtZW50SWQoZWxlbWVudCk7XG4gICAgICAgIGlmICghdGhpcy5sYXllcl9zdGF0ZS5leHRyYV9maWVsZHNbaWRdKSB7XG4gICAgICAgICAgICB0aGlzLmxheWVyX3N0YXRlLmV4dHJhX2ZpZWxkc1tpZF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxheWVyX3N0YXRlLmV4dHJhX2ZpZWxkc1tpZF1ba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gYmUgYXBwbGllZCB0byB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICovXG4gICAgc2V0RmlsdGVyKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyX2Z1bmMgPSBmdW5jO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqIFByb3RlY3RlZCBtZXRob2RzOiB1c2VmdWwgaW4gc3ViY2xhc3NlcyB0byBtYW5pcHVsYXRlIGRhdGEgbGF5ZXIgYmVoYXZpb3JzICovXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb24gaG9vayBmb3IgZmV0Y2hpbmcgdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBvZiBhdmFpbGFibGUgZGF0YS4gVXNlZCB0byBkZXRlcm1pbmUgYXhpcyByYW5nZSwgaWYgbm8gb3RoZXJcbiAgICAgKiAgIGV4cGxpY2l0IGF4aXMgc2V0dGluZ3Mgb3ZlcnJpZGUuIFVzZWZ1bCBmb3IgZGF0YSBsYXllcnMgd2hlcmUgdGhlIGRhdGEgZXh0ZW50IGRlcGVuZHMgb24gbW9yZSB0aGFuIG9uZSBmaWVsZC5cbiAgICAgKiAgIChlZyBjb25maWRlbmNlIGludGVydmFscyBpbiBhIGZvcmVzdCBwbG90KVxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIGF4aXNfY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBheGlzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gW21pbiwgbWF4XSB3aXRob3V0IGFueSBwYWRkaW5nIGFwcGxpZWRcbiAgICAgKi9cbiAgICBfZ2V0RGF0YUV4dGVudCAoZGF0YSwgYXhpc19jb25maWcpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5kYXRhO1xuICAgICAgICAvLyBCeSBkZWZhdWx0IHRoaXMgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLlxuICAgICAgICByZXR1cm4gZDMuZXh0ZW50KGRhdGEsIChkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gbmV3IEZpZWxkKGF4aXNfY29uZmlnLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiArZi5yZXNvbHZlKGQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgZnVsbHkgcXVhbGlmaWVkIElEIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNwZWNpZmljIHZpc3VhbCBlbGVtZW50LCBiYXNlZCBvbiB0aGUgZGF0YSB0byB3aGljaCB0aGF0XG4gICAgICogICBlbGVtZW50IGlzIGJvdW5kLiBJbiBnZW5lcmFsIHRoaXMgZWxlbWVudCBJRCB3aWxsIGJlIHVuaXF1ZSwgYWxsb3dpbmcgaXQgdG8gYmUgYWRkcmVzc2VkIGRpcmVjdGx5IHZpYSBzZWxlY3RvcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50SWQgKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gVXNlIGEgY2FjaGVkIHZhbHVlIGlmIHBvc3NpYmxlXG4gICAgICAgIGNvbnN0IGlkX2tleSA9IFN5bWJvbC5mb3IoJ2x6SUQnKTtcbiAgICAgICAgaWYgKGVsZW1lbnRbaWRfa2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRbaWRfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkX2ZpZWxkID0gdGhpcy5sYXlvdXQuaWRfZmllbGQgfHwgJ2lkJztcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50W2lkX2ZpZWxkXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2VuZXJhdGUgZWxlbWVudCBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRfaWQgPSBlbGVtZW50W2lkX2ZpZWxkXS50b1N0cmluZygpLnJlcGxhY2UoL1xcVy9nLCAnJyk7XG5cbiAgICAgICAgLy8gQ2FjaGUgSUQgdmFsdWUgZm9yIGZ1dHVyZSBjYWxsc1xuICAgICAgICBjb25zdCBrZXkgPSAoYCR7dGhpcy5nZXRCYXNlSWQoKX0tJHtlbGVtZW50X2lkfWApLnJlcGxhY2UoLyhbOi5bXFxdLF0pL2csICdfJyk7XG4gICAgICAgIGVsZW1lbnRbaWRfa2V5XSA9IGtleTtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbiBJRCB0aGF0IG1heSBiaW5kIGEgZGF0YSBlbGVtZW50IHRvIGEgc2VwYXJhdGUgdmlzdWFsIG5vZGUgZm9yIGRpc3BsYXlpbmcgc3RhdHVzXG4gICAgICogRXhhbXBsZXMgb2YgdGhpcyBtaWdodCBiZSBzZXBlcmF0ZSB2aXN1YWwgbm9kZXMgdG8gc2hvdyBzZWxlY3QvaGlnaGxpZ2h0IHN0YXR1c2VzLCBvclxuICAgICAqIGV2ZW4gYSBjb21tb24vc2hhcmVkIG5vZGUgdG8gc2hvdyBzdGF0dXMgYWNyb3NzIG1hbnkgZWxlbWVudHMgaW4gYSBzZXQuXG4gICAgICogQWJzdHJhY3QgbWV0aG9kLiBJdCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBkYXRhIGxheWVycyB0aGF0IGltcGxlbWVudCBzZXBlcmF0ZSBzdGF0dXNcbiAgICAgKiBub2RlcyBzcGVjaWZpY2FsbHkgdG8gdGhlIHVzZSBjYXNlIG9mIHRoZSBkYXRhIGxheWVyIHR5cGUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50U3RhdHVzTm9kZUlkIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgdmlzdWFsIGVsZW1lbnQgaW4gdGhlIGRhdGEgbGF5ZXIsIGFzXG4gICAgICogICByZWZlcmVuY2VkIGJ5IHRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZWxlbWVudCwgYXMgZGVmaW5lZCBieSBgZ2V0RWxlbWVudElkYFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGRhdGEgYm91bmQgdG8gdGhhdCBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBkMy5zZWxlY3QoYCMke2lkLnJlcGxhY2UoLyhbOi5bXFxdLF0pL2csICdcXFxcJDEnKX1gKTsgLy8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoIXNlbGVjdG9yLmVtcHR5KCkgJiYgc2VsZWN0b3IuZGF0YSgpICYmIHNlbGVjdG9yLmRhdGEoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5kYXRhKClbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2ljIG1ldGhvZCB0byBhcHBseSBhcmJpdHJhcnkgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0byBkYXRhIGVsZW1lbnRzLlxuICAgICAqICAgVGhpcyBpcyBjYWxsZWQgb24gYWxsIGRhdGEgaW1tZWRpYXRlbHkgYWZ0ZXIgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge0Jhc2VEYXRhTGF5ZXJ9XG4gICAgICovXG4gICAgYXBwbHlEYXRhTWV0aG9kcygpIHtcbiAgICAgICAgY29uc3QgZmllbGRfdG9fbWF0Y2ggPSAodGhpcy5sYXlvdXQubWF0Y2ggJiYgdGhpcy5sYXlvdXQubWF0Y2gucmVjZWl2ZSk7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdF92YWx1ZSA9IHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubHpfbWF0Y2hfdmFsdWU7XG5cbiAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIEJhc2ljIHRvSFRNTCgpIG1ldGhvZCAtIHJldHVybiB0aGUgc3RyaW5naWZpZWQgdmFsdWUgaW4gdGhlIGlkX2ZpZWxkLCBpZiBkZWZpbmVkLlxuXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMgbGF5ZXIgcmVjZWl2ZXMgZGF0YSwgbWFyayB3aGV0aGVyIHBvaW50cyBtYXRjaCAodmlhIGEgc3ludGhldGljIGJvb2xlYW4gZmllbGQpXG4gICAgICAgICAgICAvLyAgIEFueSBmaWVsZC1iYXNlZCBsYXlvdXQgZGlyZWN0aXZlcyAoY29sb3IsIHNpemUsIHNoYXBlKSBjYW4gdGhlbiBiZSB1c2VkIHRvIGNvbnRyb2wgZGlzcGxheVxuICAgICAgICAgICAgaWYgKGZpZWxkX3RvX21hdGNoICYmIGJyb2FkY2FzdF92YWx1ZSAhPT0gbnVsbCAmJiBicm9hZGNhc3RfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0ubHpfaGlnaGxpZ2h0X21hdGNoID0gKGl0ZW1bZmllbGRfdG9fbWF0Y2hdID09PSBicm9hZGNhc3RfdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLnRvSFRNTCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZF9maWVsZCA9IHRoaXMubGF5b3V0LmlkX2ZpZWxkIHx8ICdpZCc7XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVtpZF9maWVsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IGl0ZW1baWRfZmllbGRdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEhlbHBlciBtZXRob2RzIC0gcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHZhcmlvdXMgcGxvdCBsZXZlbHMuIFVzZWZ1bCBmb3IgaW50ZXJhY3RpdmUgdG9vbHRpcHMuXG4gICAgICAgICAgICBpdGVtLmdldERhdGFMYXllciA9ICgpID0+IHRoaXM7XG4gICAgICAgICAgICBpdGVtLmdldFBhbmVsID0gKCkgPT4gdGhpcy5wYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgICAgIGl0ZW0uZ2V0UGxvdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdW5pdCB0ZXN0aW5nIGV0YywgdGhpcyBsYXllciBtYXkgYmUgY3JlYXRlZCB3aXRob3V0IGEgcGFyZW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhbmVsID8gcGFuZWwucGFyZW50IDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBkZXNlbGVjdCgpIG1ldGhvZCAtIHNob3J0Y3V0IG1ldGhvZCB0byBkZXNlbGVjdCB0aGUgZWxlbWVudFxuICAgICAgICAgICAgaXRlbS5kZXNlbGVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gdGhpcy5nZXREYXRhTGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBkYXRhX2xheWVyLnVuc2VsZWN0RWxlbWVudCh0aGlzKTsgLy8gZHluYW1pY2FsbHkgZ2VuZXJhdGVkIG1ldGhvZCBuYW1lLiBJdCBleGlzdHMsIGhvbmVzdC5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGx5Q3VzdG9tRGF0YU1ldGhvZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0aGF0IGFsbG93cyBjdXN0b20gZGF0YWxheWVycyB0byBhcHBseSBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdG8gZGF0YSBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge0Jhc2VEYXRhTGF5ZXJ9XG4gICAgICovXG4gICAgYXBwbHlDdXN0b21EYXRhTWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGluZyBmdW5jdGlvbnMgdG8gYW4gZWxlbWVudCBhcyBuZWVkZWQsIGJhc2VkIG9uIHRoZSBsYXlvdXQgcnVsZXMgZ292ZXJuaW5nIGRpc3BsYXkgKyB0aGUgZWxlbWVudCdzIGRhdGFcbiAgICAgKiBJZiB0aGUgbGF5b3V0IHBhcmFtZXRlciBpcyBhbHJlYWR5IGEgcHJpbWl0aXZlIHR5cGUsIHNpbXBseSByZXR1cm4gdGhlIHZhbHVlIGFzIGdpdmVuXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZnV0dXJlIHRoaXMgbWF5IGJlIGZ1cnRoZXIgZXhwYW5kZWQsIHNvIHRoYXQgc2NhbGluZyBmdW5jdGlvbnMgY2FuIG9wZXJhdGUgc2ltaWxhciB0byBtYXBwZXJzXG4gICAgICogIChpdGVtLCBpbmRleCwgYXJyYXkpLiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3b3VsZCBiZSBhZGRlZCBhcyB0aGUgbmVlZCBhcm9zZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxTdHJpbmd8T2JqZWN0fSBsYXlvdXQgRWl0aGVyIGEgc2NhbGFyIChcImNvbG9yIGlzIHJlZFwiKSBvciBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogIChcInJ1bGVzIGZvciBob3cgdG8gY2hvb3NlIGNvbG9yIGJhc2VkIG9uIGl0ZW0gdmFsdWVcIilcbiAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnRfZGF0YSBUaGUgdmFsdWUgdG8gYmUgdXNlZCB3aXRoIHRoZSBmaWx0ZXIuIE1heSBiZSBhIHByaW1pdGl2ZSB2YWx1ZSwgb3IgYSBkYXRhIG9iamVjdCBmb3IgYSBzaW5nbGUgaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhX2luZGV4IFRoZSBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdHJhbnNmb3JtZWQgdmFsdWVcbiAgICAgKi9cbiAgICByZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIgKGxheW91dCwgZWxlbWVudF9kYXRhLCBkYXRhX2luZGV4KSB7XG4gICAgICAgIGxldCByZXQgPSBudWxsO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXlvdXQpKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyZXQgPT09IG51bGwgJiYgaWR4IDwgbGF5b3V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKGxheW91dFtpZHhdLCBlbGVtZW50X2RhdGEsIGRhdGFfaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgbGF5b3V0KSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXQgPSBsYXlvdXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXQuc2NhbGVfZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuYyA9IHNjYWxhYmxlLmdldChsYXlvdXQuc2NhbGVfZnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0LmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gbmV3IEZpZWxkKGxheW91dC5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXh0cmE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0gdGhpcy5sYXllcl9zdGF0ZSAmJiB0aGlzLmxheWVyX3N0YXRlLmV4dHJhX2ZpZWxkc1t0aGlzLmdldEVsZW1lbnRJZChlbGVtZW50X2RhdGEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmdW5jKGxheW91dC5wYXJhbWV0ZXJzIHx8IHt9LCBmLnJlc29sdmUoZWxlbWVudF9kYXRhLCBleHRyYSksIGRhdGFfaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZnVuYyhsYXlvdXQucGFyYW1ldGVycyB8fCB7fSwgZWxlbWVudF9kYXRhLCBkYXRhX2luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGRpbWVuc2lvbiBleHRlbnQgZnVuY3Rpb24gYmFzZWQgb24gbGF5b3V0IHBhcmFtZXRlcnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHsoJ3gnfCd5Jyl9IGRpbWVuc2lvblxuICAgICAqL1xuICAgIGdldEF4aXNFeHRlbnQgKGRpbWVuc2lvbikge1xuXG4gICAgICAgIGlmICghWyd4JywgJ3knXS5pbmNsdWRlcyhkaW1lbnNpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGltZW5zaW9uIGlkZW50aWZpZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGF4aXNfbmFtZSA9IGAke2RpbWVuc2lvbn1fYXhpc2A7XG4gICAgICAgIGNvbnN0IGF4aXNfbGF5b3V0ID0gdGhpcy5sYXlvdXRbYXhpc19uYW1lXTtcblxuICAgICAgICAvLyBJZiBhIGZsb29yIEFORCBhIGNlaWxpbmcgYXJlIGV4cGxpY2l0bHkgZGVmaW5lZCB0aGVuIGp1c3QgcmV0dXJuIHRoYXQgZXh0ZW50IGFuZCBiZSBkb25lXG4gICAgICAgIGlmICghaXNOYU4oYXhpc19sYXlvdXQuZmxvb3IpICYmICFpc05hTihheGlzX2xheW91dC5jZWlsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsrYXhpc19sYXlvdXQuZmxvb3IsICtheGlzX2xheW91dC5jZWlsaW5nXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgZmllbGQgaXMgZGVmaW5lZCBmb3IgdGhlIGF4aXMgYW5kIHRoZSBkYXRhIGxheWVyIGhhcyBkYXRhIHRoZW4gZ2VuZXJhdGUgdGhlIGV4dGVudCBmcm9tIHRoZSBkYXRhIHNldFxuICAgICAgICBsZXQgZGF0YV9leHRlbnQgPSBbXTtcbiAgICAgICAgaWYgKGF4aXNfbGF5b3V0LmZpZWxkICYmIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZGF0YSBoYXMgYmVlbiBmZXRjaGVkIChidXQgbm8gcG9pbnRzIGluIHJlZ2lvbiksIGVuZm9yY2UgdGhlIG1pbl9leHRlbnQgKHdpdGggbm8gYnVmZmVycyxcbiAgICAgICAgICAgICAgICAvLyAgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHBhZGRpbmcgYXJvdW5kIGFuIGVtcHR5IHNjcmVlbilcbiAgICAgICAgICAgICAgICBkYXRhX2V4dGVudCA9IGF4aXNfbGF5b3V0Lm1pbl9leHRlbnQgfHwgW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfZXh0ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhX2V4dGVudCA9IHRoaXMuX2dldERhdGFFeHRlbnQodGhpcy5kYXRhLCBheGlzX2xheW91dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSB1cHBlci9sb3dlciBidWZmZXJzLCBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxfZXh0ZW50X3NwYW4gPSBkYXRhX2V4dGVudFsxXSAtIGRhdGFfZXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oYXhpc19sYXlvdXQubG93ZXJfYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhX2V4dGVudFswXSAtPSBvcmlnaW5hbF9leHRlbnRfc3BhbiAqIGF4aXNfbGF5b3V0Lmxvd2VyX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihheGlzX2xheW91dC51cHBlcl9idWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfZXh0ZW50WzFdICs9IG9yaWdpbmFsX2V4dGVudF9zcGFuICogYXhpc19sYXlvdXQudXBwZXJfYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXhpc19sYXlvdXQubWluX2V4dGVudCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSBzaG91bGQgc3BhbiBhdCBsZWFzdCB0aGUgcmFuZ2Ugc3BlY2lmaWVkIGJ5IG1pbl9leHRlbnQsIGFuIGFycmF5IHdpdGggW2xvdywgaGlnaF1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VfbWluID0gYXhpc19sYXlvdXQubWluX2V4dGVudFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VfbWF4ID0gYXhpc19sYXlvdXQubWluX2V4dGVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihyYW5nZV9taW4pICYmICFpc05hTihyYW5nZV9tYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2V4dGVudFswXSA9IE1hdGgubWluKGRhdGFfZXh0ZW50WzBdLCByYW5nZV9taW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocmFuZ2VfbWF4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9leHRlbnRbMV0gPSBNYXRoLm1heChkYXRhX2V4dGVudFsxXSwgcmFuZ2VfbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBzcGVjaWZpZWQsIGZsb29yIGFuZCBjZWlsaW5nIHdpbGwgb3ZlcnJpZGUgdGhlIGFjdHVhbCBkYXRhIHJhbmdlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4oYXhpc19sYXlvdXQuZmxvb3IpID8gZGF0YV9leHRlbnRbMF0gOiBheGlzX2xheW91dC5mbG9vcixcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4oYXhpc19sYXlvdXQuY2VpbGluZykgPyBkYXRhX2V4dGVudFsxXSA6IGF4aXNfbGF5b3V0LmNlaWxpbmcsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgZm9yIHRoZSB4IGF4aXMgYW5kIG5vIGV4dGVudCBjb3VsZCBiZSBnZW5lcmF0ZWQgeWV0IGJ1dCBzdGF0ZSBoYXMgYSBkZWZpbmVkIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgLy8gdGhlbiBkZWZhdWx0IHRvIHVzaW5nIHRoZSBzdGF0ZS1kZWZpbmVkIHJlZ2lvbiBhcyB0aGUgZXh0ZW50XG4gICAgICAgIGlmIChkaW1lbnNpb24gPT09ICd4JyAmJiAhaXNOYU4odGhpcy5zdGF0ZS5zdGFydCkgJiYgIWlzTmFOKHRoaXMuc3RhdGUuZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXRlLnN0YXJ0LCB0aGlzLnN0YXRlLmVuZF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBjb25kaXRpb25zIG1ldCBmb3IgZ2VuZXJhdGluZyBhIHZhbGlkIGV4dGVudCwgcmV0dXJuIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIHJldHVybiBbXTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93IHRoaXMgZGF0YSBsYXllciB0byB0ZWxsIHRoZSBwYW5lbCB3aGF0IGF4aXMgdGlja3MgaXQgdGhpbmtzIGl0IHdpbGwgcmVxdWlyZS4gVGhlIHBhbmVsIG1heSBjaG9vc2Ugd2hldGhlclxuICAgICAqICAgdG8gdXNlIHNvbWUsIGFsbCwgb3Igbm9uZSBvZiB0aGVzZSB3aGVuIHJlbmRlcmluZywgZWl0aGVyIGFsb25lIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgZGF0YSBsYXllcnMuXG4gICAgICpcbiAgICAgKiAgIFRoaXMgbWV0aG9kIGlzIGEgc3R1YiBhbmQgc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gZGF0YSBsYXllcnMgdGhhdCBuZWVkIHRvIHNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7KCd4J3wneTEnfCd5MicpfSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgcGFuZWwgdG8gc3BlY2lmeSBob3cgaXQgd2FudHMgdGlja3MgdG8gYmUgZHJhd24uIFRoZSBuYW1lc1xuICAgICAqICAgYW5kIG1lYW5pbmdzIG9mIHRoZXNlIHBhcmFtZXRlcnMgbWF5IHZhcnkgYmV0d2VlbiBkaWZmZXJlbnQgZGF0YSBsYXllcnMuXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqICAgQW4gYXJyYXkgb2Ygb2JqZWN0czogZWFjaCBvYmplY3QgbXVzdCBoYXZlIGFuICd4JyBhdHRyaWJ1dGUgdG8gcG9zaXRpb24gdGhlIHRpY2suXG4gICAgICogICBPdGhlciBzdXBwb3J0ZWQgb2JqZWN0IGtleXM6XG4gICAgICogICAgICogdGV4dDogc3RyaW5nIHRvIHJlbmRlciBmb3IgYSBnaXZlbiB0aWNrXG4gICAgICogICAgICogc3R5bGU6IGQzLWNvbXBhdGlibGUgQ1NTIHN0eWxlIG9iamVjdFxuICAgICAqICAgICAqIHRyYW5zZm9ybTogU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgc3RyaW5nXG4gICAgICogICAgICogY29sb3I6IHN0cmluZyBvciBMb2N1c1pvb20gc2NhbGFibGUgcGFyYW1ldGVyIG9iamVjdFxuICAgICAqL1xuICAgIGdldFRpY2tzIChkaW1lbnNpb24sIGNvbmZpZykge1xuICAgICAgICBpZiAoIVsneCcsICd5MScsICd5MiddLmluY2x1ZGVzKGRpbWVuc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaW1lbnNpb24gaWRlbnRpZmllciAke2RpbWVuc2lvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBjb29yZGluYXRlcyBmb3Igd2hlcmUgdG8gcG9pbnQgdGhlIHRvb2x0aXAgYXQuIFR5cGljYWxseSwgdGhpcyBpcyB0aGUgY2VudGVyIG9mIGEgZGF0dW0gZWxlbWVudCAoZWcsXG4gICAgICogIHRoZSBtaWRkbGUgb2YgYSBzY2F0dGVyIHBsb3QgcG9pbnQpLiBBbHNvIHByb3ZpZGUgYW4gb2Zmc2V0IGlmIHRoZSB0b29sdGlwIHNob3VsZCBub3QgYmUgYXQgdGhhdCBjZW50ZXIgKG1vc3RcbiAgICAgKiAgZWxlbWVudHMgYXJlIG5vdCBzaW5nbGUgcG9pbnRzLCBlZyBhIHNjYXR0ZXIgcGxvdCBwb2ludCBoYXMgYSByYWRpdXMgYW5kIGEgZ2VuZSBpcyBhIHJlY3RhbmdsZSkuXG4gICAgICogIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIHF1aXRlIG5haXZlOiBpdCBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIG9yaWdpbiBmb3IgdGhhdCBsYXllci4gSW5kaXZpZHVhbCBsYXllcnNcbiAgICAgKiAgICBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNob3NlbiBkYXRhIGVsZW1lbnQgb3IgbW91c2UgZXZlbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b29sdGlwIEEgdG9vbHRpcCBvYmplY3QgKGluY2x1ZGluZyBhdHRyaWJ1dGUgdG9vbHRpcC5kYXRhKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFzIHt4X21pbiwgeF9tYXgsIHlfbWluLCB5X21heH0gaW4gcHgsIHJlcHJlc2VudGluZyBib3VuZGluZyBib3ggb2YgYSByZWN0YW5nbGUgYXJvdW5kIHRoZSBkYXRhIHB0XG4gICAgICogIE5vdGUgdGhhdCB0aGVzZSBwaXhlbHMgYXJlIGluIHRoZSBTVkcgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKi9cbiAgICBfZ2V0VG9vbHRpcFBvc2l0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLnBhcmVudDtcblxuICAgICAgICBjb25zdCB5X3NjYWxlID0gcGFuZWxbYHkke3RoaXMubGF5b3V0LnlfYXhpcy5heGlzfV9zY2FsZWBdO1xuICAgICAgICBjb25zdCB5X2V4dGVudCA9IHBhbmVsW2B5JHt0aGlzLmxheW91dC55X2F4aXMuYXhpc31fZXh0ZW50YF07XG5cbiAgICAgICAgY29uc3QgeCA9IHBhbmVsLnhfc2NhbGUocGFuZWwueF9leHRlbnRbMF0pO1xuICAgICAgICBjb25zdCB5ID0geV9zY2FsZSh5X2V4dGVudFswXSk7XG5cbiAgICAgICAgcmV0dXJuIHsgeF9taW46IHgsIHhfbWF4OiB4LCB5X21pbjogeSwgeV9tYXg6IHkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgdG9vbHRpcCBvbiB0aGUgZGF0YSBsYXllciBwb2ludGVkIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMsIGluIHRoZSBzcGVjaWZpZWQgb3JpZW50YXRpb24uXG4gICAgICogIFRvb2x0aXAgd2lsbCBiZSBkcmF3biBvbiB0aGUgZWRnZSBvZiB0aGUgbWFqb3IgYXhpcywgYW5kIGNlbnRlcmVkIGFsb25nIHRoZSBtaW5vciBheGlzLSBzZWUgZGlhZ3JhbS5cbiAgICAgKiAgIHZcbiAgICAgKiA+IG8gPFxuICAgICAqICAgXlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB0b29sdGlwIHtPYmplY3R9IFRoZSBvYmplY3QgcmVwcmVzZW50aW5nIGFsbCBkYXRhIGZvciB0aGUgdG9vbHRpcCB0byBiZSBkcmF3blxuICAgICAqIEBwYXJhbSB7J3ZlcnRpY2FsJ3wnaG9yaXpvbnRhbCd8J3RvcCd8J2JvdHRvbSd8J2xlZnQnfCdyaWdodCd9IHBvc2l0aW9uIFdoZXJlIHRvIGRyYXcgdGhlIHRvb2x0aXAgcmVsYXRpdmUgdG9cbiAgICAgKiAgdGhlIGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geF9taW4gVGhlIG1pbiB4LWNvb3JkaW5hdGUgZm9yIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGRhdGEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4X21heCBUaGUgbWF4IHgtY29vcmRpbmF0ZSBmb3IgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZGF0YSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlfbWluIFRoZSBtaW4geS1jb29yZGluYXRlIGZvciB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBkYXRhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geV9tYXggVGhlIG1heCB5LWNvb3JkaW5hdGUgZm9yIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGRhdGEgZWxlbWVudFxuICAgICAqL1xuICAgIF9kcmF3VG9vbHRpcCh0b29sdGlwLCBwb3NpdGlvbiwgeF9taW4sIHhfbWF4LCB5X21pbiwgeV9tYXgpIHtcbiAgICAgICAgY29uc3QgcGFuZWxfbGF5b3V0ID0gdGhpcy5wYXJlbnQubGF5b3V0O1xuICAgICAgICBjb25zdCBsYXllcl9sYXlvdXQgPSB0aGlzLmxheW91dDtcblxuICAgICAgICAvLyBUb29sdGlwIHBvc2l0aW9uIHBhcmFtczogYXMgZGVmaW5lZCBpbiB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0LCB1c2VkIGluIGNhbGN1bGF0aW9uc1xuICAgICAgICBjb25zdCBhcnJvd19zaXplID0gNztcbiAgICAgICAgY29uc3Qgc3Ryb2tlX3dpZHRoID0gMTtcbiAgICAgICAgY29uc3QgYXJyb3dfdG90YWwgPSBhcnJvd19zaXplICsgc3Ryb2tlX3dpZHRoOyAgLy8gVG9vbHRpcCBwb3Mgc2hvdWxkIGFjY291bnQgZm9yIGhvdyBtdWNoIHNwYWNlIHRoZSBhcnJvdyB0YWtlcyB1cFxuXG4gICAgICAgIGNvbnN0IHRvb2x0aXBfcGFkZGluZyA9IDY7ICAvLyBiYm94IHNpemUgbXVzdCBhY2NvdW50IGZvciBhbnkgaW50ZXJuYWwgcGFkZGluZyBhcHBsaWVkIGJldHdlZW4gZGF0YSBhbmQgYm9yZGVyXG5cbiAgICAgICAgY29uc3QgcGFnZV9vcmlnaW4gPSB0aGlzLl9nZXRQYWdlT3JpZ2luKCk7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBfYm94ID0gdG9vbHRpcC5zZWxlY3Rvci5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFfbGF5ZXJfaGVpZ2h0ID0gcGFuZWxfbGF5b3V0LmhlaWdodCAtIChwYW5lbF9sYXlvdXQubWFyZ2luLnRvcCArIHBhbmVsX2xheW91dC5tYXJnaW4uYm90dG9tKTtcbiAgICAgICAgY29uc3QgZGF0YV9sYXllcl93aWR0aCA9IHBhbmVsX2xheW91dC53aWR0aCAtIChwYW5lbF9sYXlvdXQubWFyZ2luLmxlZnQgKyBwYW5lbF9sYXlvdXQubWFyZ2luLnJpZ2h0KTtcblxuICAgICAgICAvLyBDbGlwIHRoZSBlZGdlcyBvZiB0aGUgZGF0dW0gdG8gdGhlIGF2YWlsYWJsZSBwbG90IGFyZWFcbiAgICAgICAgeF9taW4gPSBNYXRoLm1heCh4X21pbiwgMCk7XG4gICAgICAgIHhfbWF4ID0gTWF0aC5taW4oeF9tYXgsIGRhdGFfbGF5ZXJfd2lkdGgpO1xuICAgICAgICB5X21pbiA9IE1hdGgubWF4KHlfbWluLCAwKTtcbiAgICAgICAgeV9tYXggPSBNYXRoLm1pbih5X21heCwgZGF0YV9sYXllcl9oZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IHhfY2VudGVyID0gKHhfbWluICsgeF9tYXgpIC8gMjtcbiAgICAgICAgY29uc3QgeV9jZW50ZXIgPSAoeV9taW4gKyB5X21heCkgLyAyO1xuICAgICAgICAvLyBEZWZhdWx0IG9mZnNldHMgYXJlIHRoZSBmYXIgZWRnZSBvZiB0aGUgZGF0dW0gYm91bmRpbmcgYm94XG4gICAgICAgIGxldCB4X29mZnNldCA9IHhfbWF4IC0geF9jZW50ZXI7XG4gICAgICAgIGxldCB5X29mZnNldCA9IHlfbWF4IC0geV9jZW50ZXI7XG4gICAgICAgIGxldCBwbGFjZW1lbnQgPSBsYXllcl9sYXlvdXQudG9vbHRpcF9wb3NpdGlvbmluZztcblxuICAgICAgICAvLyBDb29yZGluYXRlIHN5c3RlbSBub3RlOiB0aGUgdG9vbHRpcCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBwbG90L3BhZ2U7IHRoZSBhcnJvdyBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvXG4gICAgICAgIC8vICB0aGUgdG9vbHRpcCBib3VuZGFyaWVzXG4gICAgICAgIGxldCB0b29sdGlwX3RvcCwgdG9vbHRpcF9sZWZ0LCBhcnJvd190eXBlLCBhcnJvd190b3AsIGFycm93X2xlZnQ7XG5cbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBnZW5lcmljIG9yaWVudGF0aW9uLCBhbmQgTG9jdXNab29tIHdpbGwgYXV0b3NlbGVjdCB3aGV0aGVyIHRvIHBsYWNlIHRoZSB0b29sdGlwIGFib3ZlIG9yIGJlbG93XG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIC8vIEF1dG8tc2VsZWN0IHdoZXRoZXIgdG8gcG9zaXRpb24gYWJvdmUgdGhlIGl0ZW0sIG9yIGJlbG93XG4gICAgICAgICAgICB4X29mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodG9vbHRpcF9ib3guaGVpZ2h0ICsgYXJyb3dfdG90YWwgPiBkYXRhX2xheWVyX2hlaWdodCAtICh5X2NlbnRlciArIHlfb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICd0b3AnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwbGFjZW1lbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgLy8gQXV0byBzZWxlY3Qgd2hldGhlciB0byBwb3NpdGlvbiB0byB0aGUgbGVmdCBvZiB0aGUgaXRlbSwgb3IgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB5X29mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoeF9jZW50ZXIgPD0gcGFuZWxfbGF5b3V0LndpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdsZWZ0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICd0b3AnIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGhvcml6b250YWxseSBjZW50ZXJlZCBhYm92ZSB0aGUgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldF9yaWdodCA9IE1hdGgubWF4KCh0b29sdGlwX2JveC53aWR0aCAvIDIpIC0geF9jZW50ZXIsIDApO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0X2xlZnQgPSBNYXRoLm1heCgodG9vbHRpcF9ib3gud2lkdGggLyAyKSArIHhfY2VudGVyIC0gZGF0YV9sYXllcl93aWR0aCwgMCk7XG4gICAgICAgICAgICB0b29sdGlwX2xlZnQgPSBwYWdlX29yaWdpbi54ICsgeF9jZW50ZXIgLSAodG9vbHRpcF9ib3gud2lkdGggLyAyKSAtIG9mZnNldF9sZWZ0ICsgb2Zmc2V0X3JpZ2h0O1xuICAgICAgICAgICAgYXJyb3dfbGVmdCA9ICBwYWdlX29yaWdpbi54ICsgeF9jZW50ZXIgLSB0b29sdGlwX2xlZnQgLSBhcnJvd19zaXplOyAgLy8gQXJyb3cgc2hvdWxkIGJlIGNlbnRlcmVkIG92ZXIgdGhlIGRhdGFcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIHZlcnRpY2FsbHkgYWJvdmUgdGhlIHBvaW50IHVubGVzcyB0aGVyZSdzIGluc3VmZmljaWVudCBzcGFjZSwgdGhlbiBnbyBiZWxvd1xuICAgICAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwX3RvcCA9IHBhZ2Vfb3JpZ2luLnkgKyB5X2NlbnRlciAtICh5X29mZnNldCArIHRvb2x0aXBfYm94LmhlaWdodCArIGFycm93X3RvdGFsKTtcbiAgICAgICAgICAgICAgICBhcnJvd190eXBlID0gJ2Rvd24nO1xuICAgICAgICAgICAgICAgIGFycm93X3RvcCA9IHRvb2x0aXBfYm94LmhlaWdodCAtIHN0cm9rZV93aWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcF90b3AgPSBwYWdlX29yaWdpbi55ICsgeV9jZW50ZXIgKyB5X29mZnNldCArIGFycm93X3RvdGFsO1xuICAgICAgICAgICAgICAgIGFycm93X3R5cGUgPSAndXAnO1xuICAgICAgICAgICAgICAgIGFycm93X3RvcCA9IDAgLSBhcnJvd190b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwbGFjZW1lbnQgPT09ICdsZWZ0JyB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIHRvb2x0aXAgaG9yaXpvbnRhbGx5IG9uIHRoZSBsZWZ0IG9yIHRoZSByaWdodCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZSBvZiB0aGUgcGxvdCB0aGUgcG9pbnQgaXMgb25cbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBfbGVmdCA9IHBhZ2Vfb3JpZ2luLnggKyB4X2NlbnRlciArIHhfb2Zmc2V0ICsgYXJyb3dfdG90YWw7XG4gICAgICAgICAgICAgICAgYXJyb3dfdHlwZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBhcnJvd19sZWZ0ID0gLTEgKiAoYXJyb3dfc2l6ZSArIHN0cm9rZV93aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBfbGVmdCA9IHBhZ2Vfb3JpZ2luLnggKyB4X2NlbnRlciAtIHRvb2x0aXBfYm94LndpZHRoIC0geF9vZmZzZXQgLSBhcnJvd190b3RhbDtcbiAgICAgICAgICAgICAgICBhcnJvd190eXBlID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBhcnJvd19sZWZ0ID0gdG9vbHRpcF9ib3gud2lkdGggLSBzdHJva2Vfd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiB3aXRoIGFycm93IHZlcnRpY2FsbHkgY2VudGVyZWQgYWxvbmcgdG9vbHRpcCBlZGdlIHVubGVzcyB3ZSdyZSBhdCB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgcGxvdFxuICAgICAgICAgICAgaWYgKHlfY2VudGVyIC0gKHRvb2x0aXBfYm94LmhlaWdodCAvIDIpIDw9IDApIHsgLy8gVG9vIGNsb3NlIHRvIHRoZSB0b3AsIHB1c2ggaXQgZG93blxuICAgICAgICAgICAgICAgIHRvb2x0aXBfdG9wID0gcGFnZV9vcmlnaW4ueSArIHlfY2VudGVyIC0gKDEuNSAqIGFycm93X3NpemUpIC0gdG9vbHRpcF9wYWRkaW5nO1xuICAgICAgICAgICAgICAgIGFycm93X3RvcCA9IHRvb2x0aXBfcGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeV9jZW50ZXIgKyAodG9vbHRpcF9ib3guaGVpZ2h0IC8gMikgPj0gZGF0YV9sYXllcl9oZWlnaHQpIHsgLy8gVG9vIGNsb3NlIHRvIHRoZSBib3R0b20sIHB1bGwgaXQgdXBcbiAgICAgICAgICAgICAgICB0b29sdGlwX3RvcCA9IHBhZ2Vfb3JpZ2luLnkgKyB5X2NlbnRlciArIGFycm93X3NpemUgKyB0b29sdGlwX3BhZGRpbmcgLSB0b29sdGlwX2JveC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYXJyb3dfdG9wID0gdG9vbHRpcF9ib3guaGVpZ2h0IC0gKDIgKiBhcnJvd19zaXplKSAtIHRvb2x0aXBfcGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHZlcnRpY2FsbHkgY2VudGVyZWRcbiAgICAgICAgICAgICAgICB0b29sdGlwX3RvcCA9IHBhZ2Vfb3JpZ2luLnkgKyB5X2NlbnRlciAtICh0b29sdGlwX2JveC5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBhcnJvd190b3AgPSAodG9vbHRpcF9ib3guaGVpZ2h0IC8gMikgLSBhcnJvd19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgcGxhY2VtZW50IHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgZGl2IGl0c2VsZiwgcmVsYXRpdmUgdG8gdGhlIGxheWVyIG9yaWdpblxuICAgICAgICB0b29sdGlwLnNlbGVjdG9yXG4gICAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCBgJHt0b29sdGlwX2xlZnR9cHhgKVxuICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBgJHt0b29sdGlwX3RvcH1weGApO1xuICAgICAgICAvLyBDcmVhdGUgLyB1cGRhdGUgcG9zaXRpb24gb24gYXJyb3cgY29ubmVjdGluZyB0b29sdGlwIHRvIGRhdGFcbiAgICAgICAgaWYgKCF0b29sdGlwLmFycm93KSB7XG4gICAgICAgICAgICB0b29sdGlwLmFycm93ID0gdG9vbHRpcC5zZWxlY3Rvci5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXAuYXJyb3dcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei1kYXRhX2xheWVyLXRvb2x0aXAtYXJyb3dfJHthcnJvd190eXBlfWApXG4gICAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCBgJHthcnJvd19sZWZ0fXB4YClcbiAgICAgICAgICAgIC5zdHlsZSgndG9wJywgYCR7YXJyb3dfdG9wfXB4YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gZGF0YSBlbGVtZW50IG1hdGNoZXMgc2V0IGNyaXRlcmlhXG4gICAgICpcbiAgICAgKiBUeXBpY2FsbHkgdGhpcyBpcyB1c2VkIHdpdGggYXJyYXkuZmlsdGVyICh0aGUgZmlyc3QgYXJndW1lbnQgaXMgY3VycmllZCwgYGZpbHRlci5iaW5kKHRoaXMsIG9wdGlvbnMpYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWx0ZXJzIEEgbGlzdCBvZiBmaWx0ZXIgZW50cmllczoge2ZpZWxkLCB2YWx1ZSwgb3BlcmF0b3J9IGRlc2NyaWJpbmcgZWFjaCBmaWx0ZXIuXG4gICAgICogIE9wZXJhdG9yIG11c3QgYmUgZnJvbSBhIGxpc3Qgb2YgYnVpbHQtaW4gb3BlcmF0b3JzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgaXRlbSBpcyBhIG1hdGNoXG4gICAgICovXG4gICAgZmlsdGVyKGZpbHRlcnMsIGl0ZW0sIGluZGV4LCBhcnJheSkge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKGVsZW1lbnQsIGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qge2ZpZWxkLCBvcGVyYXRvciwgdmFsdWU6IHRhcmdldH0gPSBmaWx0ZXI7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvcnMgPSB7XG4gICAgICAgICAgICAgICAgJz0nOiAoYSwgYikgPT4gYSA9PT0gYixcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgJyE9JzogKGEsIGIpID0+IGEgIT0gYiwgLy8gRm9yIGFic2VuY2Ugb2YgYSB2YWx1ZSwgZGVsaWJlcmF0ZWx5IGFsbG93IHdlYWsgY29tcGFyaXNvbnMgKGVnIHVuZGVmaW5lZC9udWxsKVxuICAgICAgICAgICAgICAgICc8JzogKGEsIGIpID0+IGEgPCBiLFxuICAgICAgICAgICAgICAgICc8PSc6IChhLCBiKSA9PiBhIDw9IGIsXG4gICAgICAgICAgICAgICAgJz4nOiAoYSwgYikgPT4gYSA+IGIsXG4gICAgICAgICAgICAgICAgJz49JzogKGEsIGIpID0+IGEgPj0gYixcbiAgICAgICAgICAgICAgICAnJSc6IChhLCBiKSA9PiBhICUgYixcbiAgICAgICAgICAgICAgICAnaW4nOiAoYSwgYikgPT4gYiAmJiBiLmluY2x1ZGVzKGEpLCAgLy8gd29ya3MgZm9yIHN0cmluZ3Mgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgJ21hdGNoJzogKGEsIGIpID0+IGEgJiYgYS5pbmNsdWRlcyhiKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHRoaXMubGF5ZXJfc3RhdGUuZXh0cmFfZmllbGRzW3RoaXMuZ2V0RWxlbWVudElkKGVsZW1lbnQpXTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkX3ZhbHVlID0gKG5ldyBGaWVsZChmaWVsZCkpLnJlc29sdmUoZWxlbWVudCwgZXh0cmEpO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yc1tvcGVyYXRvcl0oZmllbGRfdmFsdWUsIHRhcmdldCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgIGlmICghdGVzdChpdGVtLCBmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgXCJhbm5vdGF0aW9uXCIgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGVsZW1lbnQgVGhlIGRhdGEgb2JqZWN0IG9yIElEIHN0cmluZyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBhbm5vdGF0aW9uIHRvIHRyYWNrXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50QW5ub3RhdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRFbGVtZW50SWQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gdGhpcy5sYXllcl9zdGF0ZS5leHRyYV9maWVsZHNbaWRdO1xuICAgICAgICByZXR1cm4gZXh0cmEgJiYgZXh0cmFba2V5XTtcbiAgICB9XG5cbiAgICAvKioqKioqIFByaXZhdGUgbWV0aG9kczogcmFyZWx5IG92ZXJyaWRkZW4gb3IgbW9kaWZpZWQgYnkgZXh0ZXJuYWwgdXNhZ2VzICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBmaWx0ZXJpbmcgb3B0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHNldCBvZiBkYXRhIHRvIHJlbmRlclxuICAgICAqXG4gICAgICogVGhpcyBtdXN0IGJlIGFwcGxpZWQgb24gcmVuZGVyaW5nLCBub3QgZmV0Y2gsIHNvIHRoYXQgdGhlIGF4aXMgbGltaXRzIHJlZmxlY3QgdGhlIHRydWUgcmFuZ2Ugb2YgdGhlIGRhdGFzZXRcbiAgICAgKiAgIE90aGVyd2lzZSwgdHdvIHN0YWNrZWQgcGFuZWxzIChzYW1lIGRhdGFzZXQgZmlsdGVyZWQgaW4gZGlmZmVyZW50IHdheXMpIG1pZ2h0IG5vdCBsaW5lIHVwIG9uIHRoZSB4LWF4aXMgd2hlblxuICAgICAqICAgZmlsdGVycyBhcmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXBwbHlGaWx0ZXJzKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5kYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJfZnVuYykge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuZmlsdGVyKHRoaXMuX2ZpbHRlcl9mdW5jKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxheW91dC5maWx0ZXJzKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5maWx0ZXIodGhpcy5maWx0ZXIuYmluZCh0aGlzLCB0aGlzLmxheW91dC5maWx0ZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIGRlZmF1bHQgc3RhdGUgdGhhdCBzaG91bGQgZ2V0IHRyYWNrZWQgZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIGxheWVyLlxuICAgICAqXG4gICAgICogSW4gc29tZSBzcGVjaWFsIGN1c3RvbSB1c2FnZXMsIGl0IG1heSBiZSB1c2VmdWwgdG8gY29tcGxldGVseSByZXNldCBhIHBhbmVsIChlZyBcImNsaWNrIGZvclxuICAgICAqICAgZ2Vub21lIHJlZ2lvblwiIGxpbmtzKSwgcGxvdHRpbmcgbmV3IGRhdGEgdGhhdCBpbnZhbGlkYXRlcyBhbnkgcHJldmlvdXNseSB0cmFja2VkIHN0YXRlLiAgVGhpcyBob29rIG1ha2VzIGl0XG4gICAgICogICBwb3NzaWJsZSB0byByZXNldCB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIHBhbmVsIGVudGlyZWx5LiBJdCBpcyB1c2VkIGJ5IGBQbG90LmNsZWFyUGFuZWxEYXRhYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXREZWZhdWx0U3RhdGUoKSB7XG4gICAgICAgIC8vIEVhY2ggZGF0YWxheWVyIHRyYWNrcyB0d28ga2luZHMgb2Ygc3RhdHVzOiBmbGFncyBmb3IgaW50ZXJuYWwgc3RhdGUgKGhpZ2hsaWdodGVkLCBzZWxlY3RlZCwgdG9vbHRpcCksXG4gICAgICAgIC8vICBhbmQgXCJleHRyYSBmaWVsZHNcIiAoYW5ub3RhdGlvbnMgbGlrZSBcInNob3cgYSB0b29sdGlwXCIgdGhhdCBhcmUgbm90IGRldGVybWluZWQgYnkgdGhlIHNlcnZlciwgYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gIHBlcnNpc3QgYWNyb3NzIHJlLXJlbmRlcilcbiAgICAgICAgY29uc3QgbGF5ZXJfc3RhdGUgPSB7IHN0YXR1c19mbGFnczoge30sIGV4dHJhX2ZpZWxkczoge30gfTtcbiAgICAgICAgY29uc3Qgc3RhdHVzX2ZsYWdzID0gbGF5ZXJfc3RhdGUuc3RhdHVzX2ZsYWdzO1xuICAgICAgICBTVEFUVVNFUy5hZGplY3RpdmVzLmZvckVhY2goKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgc3RhdHVzX2ZsYWdzW3N0YXR1c10gPSBzdGF0dXNfZmxhZ3Nbc3RhdHVzXSB8fCBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFsc28gaW5pdGlhbGl6ZSBcImludGVybmFsLW9ubHlcIiBzdGF0ZSBmaWVsZHMgKHRoaW5ncyB0aGF0IGFyZSB0cmFja2VkLCBidXQgbm90IHNldCBkaXJlY3RseSBieSBleHRlcm5hbCBldmVudHMpXG4gICAgICAgIHN0YXR1c19mbGFnc1snaGFzX3Rvb2x0aXAnXSA9IHN0YXR1c19mbGFnc1snaGFzX3Rvb2x0aXAnXSB8fCBbXTtcblxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIGxheWVyIGhhcyBhIHBhcmVudCwgc3RvcmUgYSByZWZlcmVuY2UgaW4gdGhlIG92ZXJhcmNoaW5nIHBsb3Quc3RhdGUgb2JqZWN0XG4gICAgICAgICAgICB0aGlzLnN0YXRlX2lkID0gYCR7dGhpcy5wYXJlbnQuaWR9LiR7dGhpcy5pZH1gO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucGFyZW50LnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVt0aGlzLnN0YXRlX2lkXSA9IGxheWVyX3N0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJfc3RhdGUgPSBsYXllcl9zdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZ1bGx5IHF1YWxpZmllZCBpZGVudGlmaWVyIGZvciB0aGUgZGF0YSBsYXllciwgcHJlZml4ZWQgYnkgYW55IHBhcmVudCBvciBjb250YWluZXIgZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBkb3QtZGVsaW1pdGVkIHN0cmluZyBvZiB0aGUgZm9ybWF0IDxwbG90Pi48cGFuZWw+LjxkYXRhX2xheWVyPlxuICAgICAqL1xuICAgIGdldEJhc2VJZCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iYXNlX2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFzZV9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucGFyZW50X3Bsb3QuaWR9LiR7dGhpcy5wYXJlbnQuaWR9LiR7dGhpcy5pZH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlkIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBwaXhlbCBoZWlnaHQgb2YgZGF0YS1ib3VuZCBvYmplY3RzIHJlcHJlc2VudGVkIGluc2lkZSB0aGlzIGRhdGEgbGF5ZXIuIChleGNsdWRpbmcgZWxlbWVudHMgc3VjaCBhcyBheGVzKVxuICAgICAqXG4gICAgICogTWF5IGJlIHVzZWQgYnkgb3BlcmF0aW9ucyB0aGF0IHJlc2l6ZSB0aGUgZGF0YSBsYXllciB0byBmaXQgYXZhaWxhYmxlIGRhdGFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRBYnNvbHV0ZURhdGFIZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGFCQ1IgPSB0aGlzLnN2Zy5ncm91cC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBkYXRhQkNSLmhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgZGF0YSBsYXllclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Jhc2VEYXRhTGF5ZXJ9XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5fYmFzZV9pZCA9IHRoaXMuZ2V0QmFzZUlkKCk7XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgY29udGFpbmVyIGdyb3VwIGVsZW1lbnQgdG8gaG91c2UgdGhlIG1haW4gZGF0YSBsYXllciBncm91cCBlbGVtZW50IGFuZCB0aGUgY2xpcCBwYXRoXG4gICAgICAgIGNvbnN0IGJhc2VfaWQgPSB0aGlzLmdldEJhc2VJZCgpO1xuICAgICAgICB0aGlzLnN2Zy5jb250YWluZXIgPSB0aGlzLnBhcmVudC5zdmcuZ3JvdXAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWNvbnRhaW5lcicpXG4gICAgICAgICAgICAuYXR0cignaWQnLCBgJHtiYXNlX2lkfS5kYXRhX2xheWVyX2NvbnRhaW5lcmApO1xuXG4gICAgICAgIC8vIEFwcGVuZCBjbGlwIHBhdGggdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgIHRoaXMuc3ZnLmNsaXBSZWN0ID0gdGhpcy5zdmcuY29udGFpbmVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7YmFzZV9pZH0uY2xpcGApXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgICAgLy8gQXBwZW5kIHN2ZyBncm91cCBmb3IgcmVuZGVyaW5nIGFsbCBkYXRhIGxheWVyIGVsZW1lbnRzLCBjbGlwcGVkIGJ5IHRoZSBjbGlwIHBhdGhcbiAgICAgICAgdGhpcy5zdmcuZ3JvdXAgPSB0aGlzLnN2Zy5jb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGAke2Jhc2VfaWR9LmRhdGFfbGF5ZXJgKVxuICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGB1cmwoIyR7YmFzZV9pZH0uY2xpcClgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdG9vbCB0aXAgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhIERhdGEgZm9yIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9vbHRpcFxuICAgICAqL1xuICAgIGNyZWF0ZVRvb2x0aXAgKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxheW91dC50b29sdGlwICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFMYXllciBbJHt0aGlzLmlkfV0gbGF5b3V0IGRvZXMgbm90IGRlZmluZSBhIHRvb2x0aXBgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0RWxlbWVudElkKGRhdGEpO1xuICAgICAgICBpZiAodGhpcy50b29sdGlwc1tpZF0pIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Ub29sdGlwKGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvb2x0aXBzW2lkXSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBhcnJvdzogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBkMy5zZWxlY3QodGhpcy5wYXJlbnRfcGxvdC5zdmcubm9kZSgpLnBhcmVudE5vZGUpLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci10b29sdGlwJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBgJHtpZH0tdG9vbHRpcGApLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxheWVyX3N0YXRlLnN0YXR1c19mbGFnc1snaGFzX3Rvb2x0aXAnXS5wdXNoKGlkKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSB0b29sIHRpcCAoZ2VuZXJhdGUgaXRzIGlubmVyIEhUTUwpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZCBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2lkXSBBbiBpZGVudGlmaWVyIHRvIHRoZSB0b29sdGlwXG4gICAgICovXG4gICAgdXBkYXRlVG9vbHRpcChkLCBpZCkge1xuICAgICAgICBpZiAodHlwZW9mIGlkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuZ2V0RWxlbWVudElkKGQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtcHR5IHRoZSB0b29sdGlwIG9mIGFsbCBIVE1MIChpbmNsdWRpbmcgaXRzIGFycm93ISlcbiAgICAgICAgdGhpcy50b29sdGlwc1tpZF0uc2VsZWN0b3IuaHRtbCgnJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcHNbaWRdLmFycm93ID0gbnVsbDtcbiAgICAgICAgLy8gU2V0IHRoZSBuZXcgSFRNTFxuICAgICAgICBpZiAodGhpcy5sYXlvdXQudG9vbHRpcC5odG1sKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBzW2lkXS5zZWxlY3Rvci5odG1sKHBhcnNlRmllbGRzKGQsIHRoaXMubGF5b3V0LnRvb2x0aXAuaHRtbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBsYXlvdXQgYWxsb3dzIHRvb2wgdGlwcyBvbiB0aGlzIGRhdGEgbGF5ZXIgdG8gYmUgY2xvc2FibGUgdGhlbiBhZGQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICAvLyBhbmQgYWRkIHBhZGRpbmcgdG8gdGhlIHRvb2x0aXAgdG8gYWNjb21tb2RhdGUgaXRcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LnRvb2x0aXAuY2xvc2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcHNbaWRdLnNlbGVjdG9yLmluc2VydCgnYnV0dG9uJywgJzpmaXJzdC1jaGlsZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LXRvb2x0aXAtY2xvc2UtYnV0dG9uJylcbiAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCAnQ2xvc2UnKVxuICAgICAgICAgICAgICAgIC50ZXh0KCfDlycpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95VG9vbHRpcChpZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgZGF0YSBkaXJlY3RseSB0byB0aGUgdG9vbCB0aXAgZm9yIGVhc2llciByZXRyaWV2YWwgYnkgY3VzdG9tIFVJIGVsZW1lbnRzIGluc2lkZSB0aGUgdG9vbCB0aXBcbiAgICAgICAgdGhpcy50b29sdGlwc1tpZF0uc2VsZWN0b3IuZGF0YShbZF0pO1xuICAgICAgICAvLyBSZXBvc2l0aW9uIGFuZCBkcmF3IGEgbmV3IGFycm93XG4gICAgICAgIHRoaXMucG9zaXRpb25Ub29sdGlwKGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0b29sIHRpcCAtIHJlbW92ZSB0aGUgdG9vbCB0aXAgZWxlbWVudCBmcm9tIHRoZSBET00gYW5kIGRlbGV0ZSB0aGUgdG9vbCB0aXAncyByZWNvcmQgb24gdGhlIGRhdGEgbGF5ZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBlbGVtZW50X29yX2lkIFRoZSBlbGVtZW50IChvciBpZCkgYXNzb2NpYXRlZCB3aXRoIHRoZSB0b29sdGlwXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdGVtcG9yYXJ5PWZhbHNlXSBXaGV0aGVyIHRoaXMgaXMgdGVtcG9yYXJ5IChub3QgdG8gYmUgdHJhY2tlZCBpbiBzdGF0ZSkuIERpZmZlcmVudGlhdGVzXG4gICAgICogIFwicmVjcmVhdGUgdG9vbHRpcHMgb24gcmUtcmVuZGVyXCIgKHdoaWNoIGlzIHRlbXBvcmFyeSkgZnJvbSBcInVzZXIgaGFzIGNsb3NlZCB0aGlzIHRvb2x0aXBcIiAocGVybWFuZW50KVxuICAgICAqIEByZXR1cm5zIHtCYXNlRGF0YUxheWVyfVxuICAgICAqL1xuICAgIGRlc3Ryb3lUb29sdGlwKGVsZW1lbnRfb3JfaWQsIHRlbXBvcmFyeSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudF9vcl9pZCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWQgPSBlbGVtZW50X29yX2lkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWQgPSB0aGlzLmdldEVsZW1lbnRJZChlbGVtZW50X29yX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b29sdGlwc1tpZF0pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50b29sdGlwc1tpZF0uc2VsZWN0b3IgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXBzW2lkXS5zZWxlY3Rvci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRvb2x0aXBzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGEgdG9vbHRpcCBpcyByZW1vdmVkLCBhbHNvIHJlbW92ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIHN0YXRlXG4gICAgICAgIGlmICghdGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMubGF5ZXJfc3RhdGUuc3RhdHVzX2ZsYWdzWydoYXNfdG9vbHRpcCddO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxfbWFya19wb3NpdGlvbiA9IHN0YXRlLmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgc3RhdGUuc3BsaWNlKGxhYmVsX21hcmtfcG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvb3AgdGhyb3VnaCBhbmQgZGVzdHJveSBhbGwgdG9vbCB0aXBzIG9uIHRoaXMgZGF0YSBsYXllclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QmFzZURhdGFMYXllcn1cbiAgICAgKi9cbiAgICBkZXN0cm95QWxsVG9vbHRpcHMoKSB7XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudG9vbHRpcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVRvb2x0aXAoaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIGFuZCB0aGVuIHJlZHJhdyB0b29sIHRpcCAtIG5hw692ZSBmdW5jdGlvbiB0byBwbGFjZSBhIHRvb2wgdGlwIGluIHRoZSBkYXRhIGxheWVyLiBCeSBkZWZhdWx0LCBwb3NpdGlvbnMgd3J0XG4gICAgICogICB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBkYXRhIGxheWVyLlxuICAgICAqXG4gICAgICogRWFjaCBsYXllciB0eXBlIG1heSBoYXZlIG1vcmUgc3BlY2lmaWMgbG9naWMuIENvbnNpZGVyIG92ZXJyaWRpbmcgdGhlIHByb3ZpZGVkIGhvb2tzIGBfZ2V0VG9vbHRpcFBvc2l0aW9uYCBvclxuICAgICAqICBgX2RyYXdUb29sdGlwYCBhcyBhcHByb3ByaWF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRvb2x0aXAgdG8gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7QmFzZURhdGFMYXllcn1cbiAgICAgKi9cbiAgICBwb3NpdGlvblRvb2x0aXAoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcG9zaXRpb24gdG9vbHRpcDogaWQgaXMgbm90IGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcG9zaXRpb24gdG9vbHRpcDogaWQgZG9lcyBub3QgcG9pbnQgdG8gYSB2YWxpZCB0b29sdGlwJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMudG9vbHRpcHNbaWRdO1xuICAgICAgICBjb25zdCBjb29yZHMgPSB0aGlzLl9nZXRUb29sdGlwUG9zaXRpb24odG9vbHRpcCk7XG5cbiAgICAgICAgaWYgKCFjb29yZHMpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY3V0b3V0OiBub3JtYWxseSwgdG9vbHRpcHMgYXJlIHBvc2l0aW9uZWQgYmFzZWQgb24gdGhlIGRhdHVtIGVsZW1lbnQuIFNvbWUsIGxpa2UgbGluZXMvY3VydmVzLFxuICAgICAgICAgICAgLy8gIHdvcmsgYmV0dGVyIGlmIGJhc2VkIG9uIGEgbW91c2UgZXZlbnQuIFNpbmNlIG5vdCBldmVyeSByZWRyYXcgY29udGFpbnMgYSBtb3VzZSBldmVudCwgd2UgY2FuIGp1c3Qgc2tpcFxuICAgICAgICAgICAgLy8gIGNhbGN1bGF0aW5nIHBvc2l0aW9uIHdoZW4gbm8gcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZHJhd1Rvb2x0aXAodG9vbHRpcCwgdGhpcy5sYXlvdXQudG9vbHRpcF9wb3NpdGlvbmluZywgY29vcmRzLnhfbWluLCBjb29yZHMueF9tYXgsIGNvb3Jkcy55X21pbiwgY29vcmRzLnlfbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb29wIHRocm91Z2ggYW5kIHBvc2l0aW9uIGFsbCB0b29sIHRpcHMgb24gdGhpcyBkYXRhIGxheWVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtCYXNlRGF0YUxheWVyfVxuICAgICAqL1xuICAgIHBvc2l0aW9uQWxsVG9vbHRpcHMoKSB7XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudG9vbHRpcHMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Ub29sdGlwKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgYSB0b29sIHRpcCBieSBJRCBkZXBlbmRpbmcgb24gZGlyZWN0aXZlcyBpbiB0aGUgbGF5b3V0IGFuZCBzdGF0ZSB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIElEXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZWxlbWVudCBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0X3RpbWUgQmVjYXVzZSBwYW5lbHMgY2FuIHJlLXJlbmRlciwgdGhlIHJ1bGVzIGZvciBzaG93aW5nIGEgdG9vbHRpcFxuICAgICAqICBkZXBlbmQgb24gd2hldGhlciB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGEgc3RhdHVzIGNoYW5nZSBhZmZlY3RpbmcgZGlzcGxheSBoYXMgYmVlbiBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtCYXNlRGF0YUxheWVyfVxuICAgICAqL1xuICAgIHNob3dPckhpZGVUb29sdGlwKGVsZW1lbnQsIGZpcnN0X3RpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxheW91dC50b29sdGlwICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0RWxlbWVudElkKGVsZW1lbnQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBydWxlcyBhbmQgZGVjaWRlIHdoZXRoZXIgdG8gc2hvdyBvciBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0dXNlcyBBbGwgc3RhdHVzZXMgdGhhdCBhcHBseSB0byBhbiBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW118b2JqZWN0fSBkaXJlY3RpdmUgQSBsYXlvdXQgZGlyZWN0aXZlIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gb3BlcmF0b3JcbiAgICAgICAgICogQHJldHVybnMge251bGx8Ym9vbH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlc29sdmVTdGF0dXMgPSAoc3RhdHVzZXMsIGRpcmVjdGl2ZSwgb3BlcmF0b3IpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXNlcyAhPSAnb2JqZWN0JyB8fCBzdGF0dXNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGlyZWN0aXZlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gdGhlIGlubmVyIHBhcnQgb2YgdGhlIGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IgfHwgJ2FuZCc7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzZXNbZGlyZWN0aXZlWzBdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBkaXJlY3RpdmUucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2FuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHVzZXNbcHJldmlvdXNWYWx1ZV0gJiYgc3RhdHVzZXNbY3VycmVudFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHVzZXNbcHJldmlvdXNWYWx1ZV0gfHwgc3RhdHVzZXNbY3VycmVudFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkaXJlY3RpdmUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3ViX3N0YXR1cztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWJfb3BlcmF0b3IgaW4gZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yl9zdGF0dXMgPSByZXNvbHZlU3RhdHVzKHN0YXR1c2VzLCBkaXJlY3RpdmVbc3ViX29wZXJhdG9yXSwgc3ViX29wZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gc3ViX3N0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ2FuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHN0YXR1cyAmJiBzdWJfc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBzdGF0dXMgfHwgc3ViX3N0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgc2hvd19kaXJlY3RpdmUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxheW91dC50b29sdGlwLnNob3cgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNob3dfZGlyZWN0aXZlID0geyBhbmQ6IFsgdGhpcy5sYXlvdXQudG9vbHRpcC5zaG93IF0gfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5sYXlvdXQudG9vbHRpcC5zaG93ID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzaG93X2RpcmVjdGl2ZSA9IHRoaXMubGF5b3V0LnRvb2x0aXAuc2hvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoaWRlX2RpcmVjdGl2ZSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF5b3V0LnRvb2x0aXAuaGlkZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaGlkZV9kaXJlY3RpdmUgPSB7IGFuZDogWyB0aGlzLmxheW91dC50b29sdGlwLmhpZGUgXSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmxheW91dC50b29sdGlwLmhpZGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGhpZGVfZGlyZWN0aXZlID0gdGhpcy5sYXlvdXQudG9vbHRpcC5oaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIHN0YXR1c2VzIHRoYXQgYXBwbHkgdG8ganVzdCB0aGlzIHNpbmdsZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IGxheWVyX3N0YXRlID0gdGhpcy5sYXllcl9zdGF0ZTtcbiAgICAgICAgdmFyIHN0YXR1c19mbGFncyA9IHt9OyAgLy8ge3N0YXR1c19uYW1lOiBib29sfVxuICAgICAgICBTVEFUVVNFUy5hZGplY3RpdmVzLmZvckVhY2goKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYW50aXN0YXR1cyA9IGB1biR7c3RhdHVzfWA7XG4gICAgICAgICAgICBzdGF0dXNfZmxhZ3Nbc3RhdHVzXSA9IChsYXllcl9zdGF0ZS5zdGF0dXNfZmxhZ3Nbc3RhdHVzXS5pbmNsdWRlcyhpZCkpO1xuICAgICAgICAgICAgc3RhdHVzX2ZsYWdzW2FudGlzdGF0dXNdID0gIXN0YXR1c19mbGFnc1tzdGF0dXNdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZWNpZGUgd2hldGhlciB0byBzaG93L2hpZGUgdGhlIHRvb2x0aXAgYmFzZWQgc29sZWx5IG9uIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc2hvd19yZXNvbHZlZCA9IHJlc29sdmVTdGF0dXMoc3RhdHVzX2ZsYWdzLCBzaG93X2RpcmVjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGhpZGVfcmVzb2x2ZWQgPSByZXNvbHZlU3RhdHVzKHN0YXR1c19mbGFncywgaGlkZV9kaXJlY3RpdmUpO1xuXG4gICAgICAgIC8vIE1vc3Qgb2YgdGhlIHRvb2x0aXAgZGlzcGxheSBsb2dpYyBkZXBlbmRzIG9uIGJlaGF2aW9yIGxheW91dHM6IHdhcyBwb2ludCAodW4pc2VsZWN0ZWQsICh1biloaWdobGlnaHRlZCwgZXRjLlxuICAgICAgICAvLyBCdXQgc29tZXRpbWVzLCBhIHBvaW50IGlzIHNlbGVjdGVkLCBhbmQgdGhlIHVzZXIgdGhlbiBjbG9zZXMgdGhlIHRvb2x0aXAuIElmIHRoZSBwYW5lbCBpcyByZS1yZW5kZXJlZCBmb3JcbiAgICAgICAgLy8gIHNvbWUgb3V0c2lkZSByZWFzb24gKGxpa2Ugc3RhdGUgY2hhbmdlKSwgd2UgbXVzdCB0cmFjayB0aGlzIGluIHRoZSBjcmVhdGUvZGVzdHJveSBldmVudHMgYXMgdG9vbHRpcCBzdGF0ZS5cbiAgICAgICAgY29uc3QgaGFzX3Rvb2x0aXAgPSAobGF5ZXJfc3RhdGUuc3RhdHVzX2ZsYWdzWydoYXNfdG9vbHRpcCddLmluY2x1ZGVzKGlkKSk7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBfd2FzX2Nsb3NlZCA9IGZpcnN0X3RpbWUgPyBmYWxzZSA6ICFoYXNfdG9vbHRpcDtcbiAgICAgICAgaWYgKHNob3dfcmVzb2x2ZWQgJiYgIXRvb2x0aXBfd2FzX2Nsb3NlZCAmJiAhaGlkZV9yZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95VG9vbHRpcChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBhIHN0YXR1cyAoZS5nLiBoaWdobGlnaHRlZCwgc2VsZWN0ZWQsIGlkZW50aWZpZWQpIG9uIGFuIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzIFRoZSBuYW1lIG9mIGEgcmVjb2duaXplZCBzdGF0dXMgdG8gYmUgYWRkZWQvcmVtb3ZlZCBvbiBhbiBhcHByb3ByaWF0ZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBlbGVtZW50IFRoZSBkYXRhIGJvdW5kIHRvIHRoZSBlbGVtZW50IG9mIGludGVyZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhY3RpdmUgVHJ1ZSB0byBhZGQgdGhlIHN0YXR1cyAoYW5kIGFzc29jaWF0ZWQgQ1NTIHN0eWxlcyk7IGZhbHNlIHRvIHJlbW92ZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhjbHVzaXZlIFdoZXRoZXIgdG8gb25seSBhbGxvdyBhIHN0YXRlIGZvciBhIHNpbmdsZSBlbGVtZW50IGF0IGEgdGltZVxuICAgICAqIEByZXR1cm5zIHtCYXNlRGF0YUxheWVyfVxuICAgICAqL1xuICAgIHNldEVsZW1lbnRTdGF0dXMoc3RhdHVzLCBlbGVtZW50LCBhY3RpdmUsIGV4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnaGFzX3Rvb2x0aXAnKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBhZGplY3RpdmUgdGhhdCBleGlzdHMgc29sZWx5IHRvIHRyYWNrIHRvb2x0aXAgc3RhdGUuIEl0IGhhcyBubyBDU1MgYW5kIG5ldmVyIGdldHMgc2V0XG4gICAgICAgICAgICAvLyAgZGlyZWN0bHkuIEl0IGlzIGludmlzaWJsZSB0byB0aGUgb2ZmaWNpYWwgZW51bXMuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFjdGl2ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhbiBJRCBmb3IgdGhlIGVsZW1lbnQgb3IgcmV0dXJuIGhhdmluZyBjaGFuZ2VkIG5vdGhpbmdcbiAgICAgICAgbGV0IGVsZW1lbnRfaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbGVtZW50X2lkID0gdGhpcy5nZXRFbGVtZW50SWQoZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGdldF9lbGVtZW50X2lkX2Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZm9yY2UgZXhjbHVzaXZpdHkgKGZvcmNlIGFsbCBlbGVtZW50cyB0byBoYXZlIHRoZSBvcHBvc2l0ZSBvZiB0b2dnbGUgZmlyc3QpXG4gICAgICAgIGlmIChleGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxsRWxlbWVudFN0YXR1cyhzdGF0dXMsICFhY3RpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0L3Vuc2V0IHRoZSBwcm9wZXIgc3RhdHVzIGNsYXNzIG9uIHRoZSBhcHByb3ByaWF0ZSBET00gZWxlbWVudChzKVxuICAgICAgICBkMy5zZWxlY3QoYCMke2VsZW1lbnRfaWR9YCkuY2xhc3NlZChgbHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9LSR7c3RhdHVzfWAsIGFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRfc3RhdHVzX25vZGVfaWQgPSB0aGlzLmdldEVsZW1lbnRTdGF0dXNOb2RlSWQoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50X3N0YXR1c19ub2RlX2lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoYCMke2VsZW1lbnRfc3RhdHVzX25vZGVfaWR9YCkuY2xhc3NlZChgbHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9LXN0YXR1c25vZGUtJHtzdGF0dXN9YCwgYWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNrIGVsZW1lbnQgSUQgaW4gdGhlIHByb3BlciBzdGF0dXMgc3RhdGUgYXJyYXlcbiAgICAgICAgY29uc3QgZWxlbWVudF9zdGF0dXNfaWR4ID0gdGhpcy5sYXllcl9zdGF0ZS5zdGF0dXNfZmxhZ3Nbc3RhdHVzXS5pbmRleE9mKGVsZW1lbnRfaWQpO1xuICAgICAgICBjb25zdCBhZGRlZF9zdGF0dXMgPSAoZWxlbWVudF9zdGF0dXNfaWR4ID09PSAtMSk7ICAvLyBPbiBhIHJlLXJlbmRlciwgZXhpc3Rpbmcgc3RhdHVzZXMgd2lsbCBiZSByZWFwcGxpZWQuXG4gICAgICAgIGlmIChhY3RpdmUgJiYgYWRkZWRfc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLmxheWVyX3N0YXRlLnN0YXR1c19mbGFnc1tzdGF0dXNdLnB1c2goZWxlbWVudF9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhY3RpdmUgJiYgIWFkZGVkX3N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5sYXllcl9zdGF0ZS5zdGF0dXNfZmxhZ3Nbc3RhdHVzXS5zcGxpY2UoZWxlbWVudF9zdGF0dXNfaWR4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaWdnZXIgdG9vbCB0aXAgc2hvdy9oaWRlIGxvZ2ljXG4gICAgICAgIHRoaXMuc2hvd09ySGlkZVRvb2x0aXAoZWxlbWVudCwgYWRkZWRfc3RhdHVzKTtcblxuICAgICAgICAvLyBUcmlnZ2VyIGxheW91dCBjaGFuZ2VkIGV2ZW50IGhvb2tcbiAgICAgICAgaWYgKGFkZGVkX3N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZW1pdCgnbGF5b3V0X2NoYW5nZWQnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzX3NlbGVjdGVkID0gKHN0YXR1cyA9PT0gJ3NlbGVjdGVkJyk7XG4gICAgICAgIGlmIChpc19zZWxlY3RlZCAmJiAoYWRkZWRfc3RhdHVzIHx8ICFhY3RpdmUpKSB7XG4gICAgICAgICAgICAvLyBOb3RpZnkgcGFyZW50cyB0aGF0IGFuIGVsZW1lbnQgaGFzIGNoYW5nZWQgc2VsZWN0aW9uIHN0YXR1cyAoZWl0aGVyIGFjdGl2ZSwgb3IgaW5hY3RpdmUpXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5lbWl0KCdlbGVtZW50X3NlbGVjdGlvbicsIHsgZWxlbWVudDogZWxlbWVudCwgYWN0aXZlOiBhY3RpdmUgfSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZV90b19icm9hZGNhc3QgPSAodGhpcy5sYXlvdXQubWF0Y2ggJiYgdGhpcy5sYXlvdXQubWF0Y2guc2VuZCk7XG4gICAgICAgIGlmIChpc19zZWxlY3RlZCAmJiB2YWx1ZV90b19icm9hZGNhc3QgJiYgKGFkZGVkX3N0YXR1cyB8fCAhYWN0aXZlKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZW1pdChcbiAgICAgICAgICAgICAgICAnbWF0Y2hfcmVxdWVzdGVkJyxcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiBlbGVtZW50W3ZhbHVlX3RvX2Jyb2FkY2FzdF0sIGFjdGl2ZTogYWN0aXZlIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgYSBzdGF0dXMgb24gYWxsIGVsZW1lbnRzIGluIHRoZSBkYXRhIGxheWVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRvZ2dsZVxuICAgICAqIEByZXR1cm5zIHtCYXNlRGF0YUxheWVyfVxuICAgICAqL1xuICAgIHNldEFsbEVsZW1lbnRTdGF0dXMoc3RhdHVzLCB0b2dnbGUpIHtcblxuICAgICAgICAvLyBTYW5pdHkgY2hlY2tcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgPT0gJ3VuZGVmaW5lZCcgfHwgIVNUQVRVU0VTLmFkamVjdGl2ZXMuaW5jbHVkZXMoc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXR1cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXllcl9zdGF0ZS5zdGF0dXNfZmxhZ3Nbc3RhdHVzXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBzdGF0dXNlc1xuICAgICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgoZWxlbWVudCkgPT4gdGhpcy5zZXRFbGVtZW50U3RhdHVzKHN0YXR1cywgZWxlbWVudCwgdHJ1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzX2lkcyA9IHRoaXMubGF5ZXJfc3RhdGUuc3RhdHVzX2ZsYWdzW3N0YXR1c10uc2xpY2UoKTtcbiAgICAgICAgICAgIHN0YXR1c19pZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50U3RhdHVzKHN0YXR1cywgZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXllcl9zdGF0ZS5zdGF0dXNfZmxhZ3Nbc3RhdHVzXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0dXMgZmxhZ1xuICAgICAgICB0aGlzLmdsb2JhbF9zdGF0dXNlc1tzdGF0dXNdID0gdG9nZ2xlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFsbCBsYXlvdXQtZGVmaW5lZCBiZWhhdmlvcnMgKERPTSBldmVudCBoYW5kbGVycykgdG8gYSBzZWxlY3Rpb24gb2YgZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IHNlbGVjdGlvblxuICAgICAqL1xuICAgIGFwcGx5QmVoYXZpb3JzKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF5b3V0LmJlaGF2aW9ycyAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMubGF5b3V0LmJlaGF2aW9ycykuZm9yRWFjaCgoZGlyZWN0aXZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudF9tYXRjaCA9IC8oY2xpY2t8bW91c2VvdmVyfG1vdXNlb3V0KS8uZXhlYyhkaXJlY3RpdmUpO1xuICAgICAgICAgICAgaWYgKCFldmVudF9tYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbi5vbihgJHtldmVudF9tYXRjaFswXX0uJHtkaXJlY3RpdmV9YCwgdGhpcy5leGVjdXRlQmVoYXZpb3JzKGRpcmVjdGl2ZSwgdGhpcy5sYXlvdXQuYmVoYXZpb3JzW2RpcmVjdGl2ZV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFuIGFyYml0cmFyeSBsaXN0IG9mIGJlaGF2aW9ycyBvbiBhbiBlbGVtZW50IGR1cmluZyBhbiBldmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aXZlIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgYXMgZGVzY3JpYmVkIGluIGxheW91dC5iZWhhdmlvcnMgZm9yIHRoaXMgZGF0YWxheWVyXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gYmVoYXZpb3JzIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBiZWhhdmlvciB0byBhdHRhY2ggdG8gdGhpcyBzaW5nbGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiZWhhdmlvcnMuYWN0aW9uIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gdGhhdCB3b3VsZCB0cmlnZ2VyIHRoaXMgYmVoYXZpb3IgKGVnIGNsaWNrLCBtb3VzZW92ZXIsIGV0YylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmVoYXZpb3JzLnN0YXR1cyBXaGF0IHN0YXR1cyB0byBhcHBseSB0byB0aGUgZWxlbWVudCB3aGVuIHRoaXMgYmVoYXZpb3IgaXMgdHJpZ2dlcmVkIChoaWdobGlnaHRlZCxcbiAgICAgKiAgc2VsZWN0ZWQsIGV0YylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtiZWhhdmlvcnMuZXhjbHVzaXZlXSBXaGV0aGVyIHRyaWdnZXJpbmcgdGhlIGV2ZW50IGZvciB0aGlzIGVsZW1lbnQgc2hvdWxkIHVuc2V0IHRoZSByZWxldmFudCBzdGF0dXNcbiAgICAgKiAgIGZvciBhbGwgb3RoZXIgZWxlbWVudHMuIFVzZWZ1bCBmb3IsIGVnLCBjbGljayBldmVudHMgdGhhdCBleGNsdXNpdmVseSBoaWdobGlnaHQgb25lIHRoaW5nLlxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbih0aGlzOkJhc2VEYXRhTGF5ZXIpfSBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGhlIGV2ZW50IGluIGNvbnRleHQgd2l0aCB0aGUgYmVoYXZpb3JcbiAgICAgKiAgIGFuZCB0aGUgZWxlbWVudC0gY2FuIGJlIGF0dGFjaGVkIGFzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICovXG4gICAgZXhlY3V0ZUJlaGF2aW9ycyhkaXJlY3RpdmUsIGJlaGF2aW9ycykge1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcmVxdWlyZWQgc3RhdGUgb2YgY29udHJvbCBhbmQgc2hpZnQga2V5cyBkdXJpbmcgdGhlIGV2ZW50XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkS2V5U3RhdGVzID0ge1xuICAgICAgICAgICAgJ2N0cmwnOiAoZGlyZWN0aXZlLmluY2x1ZGVzKCdjdHJsJykpLFxuICAgICAgICAgICAgJ3NoaWZ0JzogKGRpcmVjdGl2ZS5pbmNsdWRlcygnc2hpZnQnKSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgbWF5IGJlIHVzZWQgb24gdHdvIGtpbmRzIG9mIGV2ZW50czogZGlyZWN0bHkgYXR0YWNoZWQsIG9yIGJ1YmJsZWQuXG4gICAgICAgICAgICAvLyBEMyBkb2Vzbid0IG5hdGl2ZWx5IHN1cHBvcnQgYnViYmxpbmcgdmVyeSB3ZWxsOyBpZiBubyBkYXRhIGlzIGJvdW5kIG9uIHRoZSBjdXJyZW50VGFyZ2V0LCBjaGVjayB0byBzZWVcbiAgICAgICAgICAgIC8vICBpZiB0aGVyZSBpcyBkYXRhIGF2YWlsYWJsZSBhdCB3aGVyZXZlciB0aGUgZXZlbnQgd2FzIGluaXRpYXRlZCBmcm9tXG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCBkMy5zZWxlY3QoZDMuZXZlbnQudGFyZ2V0KS5kYXR1bSgpO1xuXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSByZXF1aXJlZCBjb250cm9sIGFuZCBzaGlmdCBrZXkgcHJlc3NlcyAob3IgbGFjayB0aGVyZW9mKSBkb2Vzbid0IG1hdGNoIHRoZSBldmVudFxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkS2V5U3RhdGVzLmN0cmwgIT09ICEhZDMuZXZlbnQuY3RybEtleSB8fCByZXF1aXJlZEtleVN0YXRlcy5zaGlmdCAhPT0gISFkMy5ldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGJlaGF2aW9ycyBtYWtpbmcgZWFjaCBvbmUgZ28gaW4gc3VjY2Vzc2lvblxuICAgICAgICAgICAgYmVoYXZpb3JzLmZvckVhY2goKGJlaGF2aW9yKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyBSb3V0ZSBmaXJzdCBieSB0aGUgYWN0aW9uLCBpZiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWhhdmlvciAhPSAnb2JqZWN0JyB8fCBiZWhhdmlvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudF9zdGF0dXNfYm9vbGVhbiA9IChzZWxmLmxheWVyX3N0YXRlLnN0YXR1c19mbGFnc1tiZWhhdmlvci5zdGF0dXNdLmluY2x1ZGVzKHNlbGYuZ2V0RWxlbWVudElkKGVsZW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVzaXZlID0gYmVoYXZpb3IuZXhjbHVzaXZlICYmICFjdXJyZW50X3N0YXR1c19ib29sZWFuO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChiZWhhdmlvci5hY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBhIHN0YXR1cyAoc2V0IHRvIHRydWUgcmVnYXJkbGVzcyBvZiBjdXJyZW50IHN0YXR1cywgb3B0aW9uYWxseSB3aXRoIGV4Y2x1c2l2aXR5KVxuICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0RWxlbWVudFN0YXR1cyhiZWhhdmlvci5zdGF0dXMsIGVsZW1lbnQsIHRydWUsIGJlaGF2aW9yLmV4Y2x1c2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5zZXQgYSBzdGF0dXMgKHNldCB0byBmYWxzZSByZWdhcmRsZXNzIG9mIGN1cnJlbnQgc3RhdHVzLCBvcHRpb25hbGx5IHdpdGggZXhjbHVzaXZpdHkpXG4gICAgICAgICAgICAgICAgY2FzZSAndW5zZXQnOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEVsZW1lbnRTdGF0dXMoYmVoYXZpb3Iuc3RhdHVzLCBlbGVtZW50LCBmYWxzZSwgYmVoYXZpb3IuZXhjbHVzaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvLyBUb2dnbGUgYSBzdGF0dXNcbiAgICAgICAgICAgICAgICBjYXNlICd0b2dnbGUnOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldEVsZW1lbnRTdGF0dXMoYmVoYXZpb3Iuc3RhdHVzLCBlbGVtZW50LCAhY3VycmVudF9zdGF0dXNfYm9vbGVhbiwgZXhjbHVzaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvLyBMaW5rIHRvIGEgZHluYW1pYyBVUkxcbiAgICAgICAgICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWhhdmlvci5ocmVmID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUZpZWxkcyhlbGVtZW50LCBiZWhhdmlvci5ocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmVoYXZpb3IudGFyZ2V0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsLCBiZWhhdmlvci50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8vIEFjdGlvbiBub3QgZGVmaW5lZCwganVzdCByZXR1cm5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHBhbmVsJ3Mgb3JpZ2luIGluIHRlcm1zIG9mIHRoZSBlbnRpcmUgcGFnZVxuICAgICAqICAgTmVjZXNzYXJ5IGZvciBwb3NpdGlvbmluZyBhbnkgSFRNTCBlbGVtZW50cyBvdmVyIHRoZSBwYW5lbFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IE51bWJlciwgeTogTnVtYmVyfX1cbiAgICAgKi9cbiAgICBfZ2V0UGFnZU9yaWdpbigpIHtcbiAgICAgICAgY29uc3QgcGFuZWxfb3JpZ2luID0gdGhpcy5wYXJlbnQuX2dldFBhZ2VPcmlnaW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBhbmVsX29yaWdpbi54ICsgdGhpcy5wYXJlbnQubGF5b3V0Lm1hcmdpbi5sZWZ0LFxuICAgICAgICAgICAgeTogcGFuZWxfb3JpZ2luLnkgKyB0aGlzLnBhcmVudC5sYXlvdXQubWFyZ2luLnRvcCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhbGwgdHJhY2tlZCBlbGVtZW50IHN0YXR1c2VzLiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgcmUtcmVuZGVyaW5nIHRoZSBwbG90LCBpbiBvcmRlciB0byBwcmVzZXJ2ZVxuICAgICAqICBiZWhhdmlvcnMgd2hlbiBpdGVtcyBhcmUgdXBkYXRlZC5cbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBhcHBseUFsbEVsZW1lbnRTdGF0dXMgKCkge1xuICAgICAgICBjb25zdCBzdGF0dXNfZmxhZ3MgPSB0aGlzLmxheWVyX3N0YXRlLnN0YXR1c19mbGFncztcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHN0YXR1c19mbGFncykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdHVzX2ZsYWdzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXR1c19mbGFnc1twcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzX2ZsYWdzW3Byb3BlcnR5XS5mb3JFYWNoKChlbGVtZW50X2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRTdGF0dXMocHJvcGVydHksIHRoaXMuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudF9pZCksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuYWJsZSB0byBhcHBseSBzdGF0ZTogJHtzZWxmLnN0YXRlX2lkfSwgJHtwcm9wZXJ0eX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBkYXRhbGF5ZXIgYW5kIGFsbCB0b29sdGlwc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Jhc2VEYXRhTGF5ZXJ9XG4gICAgICovXG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhpcy5zdmcuY29udGFpbmVyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMucGFyZW50LmxheW91dC5jbGlwYXJlYS5vcmlnaW4ueH0sICR7dGhpcy5wYXJlbnQubGF5b3V0LmNsaXBhcmVhLm9yaWdpbi55fSlgKTtcbiAgICAgICAgdGhpcy5zdmcuY2xpcFJlY3RcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMucGFyZW50LmxheW91dC5jbGlwYXJlYS53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLnBhcmVudC5sYXlvdXQuY2xpcGFyZWEuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkFsbFRvb2x0aXBzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlLU1hcCBhIGRhdGEgbGF5ZXIgdG8gcmVmbGVjdCBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiBhIHBsb3QgKHN1Y2ggYXMgdmlld2luZyByZWdpb24vIGNocm9tb3NvbWUgcmFuZ2UpXG4gICAgICpcbiAgICAgKiBXaGVyZWFzIC5yZW5kZXIgZHJhd3Mgd2hhdGV2ZXIgZGF0YSBpcyBhdmFpbGFibGUsIHRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgdmlldyBhbmQgZmV0Y2hlcyBuZXcgZGF0YSBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgcmVNYXAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUFsbFRvb2x0aXBzKCk7IC8vIGhhY2sgLSBvbmx5IG5vbi12aXNpYmxlIHRvb2x0aXBzIHNob3VsZCBiZSBkZXN0cm95ZWRcbiAgICAgICAgLy8gYW5kIHRoZW4gcmVjcmVhdGVkIGlmIHJldHVybmluZyB0byB2aXNpYmlsaXR5XG5cbiAgICAgICAgLy8gRmV0Y2ggbmV3IGRhdGEuIERhdGFsYXllcnMgYXJlIG9ubHkgZ2l2ZW4gYWNjZXNzIHRvIHRoZSBmaW5hbCBjb25zb2xpZGF0ZWQgZGF0YSBmcm9tIHRoZSBjaGFpbiAobm90IGhlYWRlcnMgb3IgcmF3IHBheWxvYWRzKVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRfcGxvdC5semQuZ2V0RGF0YSh0aGlzLnN0YXRlLCB0aGlzLmxheW91dC5maWVsZHMpXG4gICAgICAgICAgICAudGhlbigobmV3X2RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXdfZGF0YS5ib2R5OyAgLy8gY2hhaW4uYm9keSBmcm9tIGRhdGFzb3VyY2VzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseURhdGFNZXRob2RzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cblNUQVRVU0VTLnZlcmJzLmZvckVhY2goKHZlcmIsIGlkeCkgPT4ge1xuICAgIGNvbnN0IGFkamVjdGl2ZSA9IFNUQVRVU0VTLmFkamVjdGl2ZXNbaWR4XTtcbiAgICBjb25zdCBhbnRpdmVyYiA9IGB1biR7dmVyYn1gO1xuICAgIC8vIFNldC91bnNldCBhIHNpbmdsZSBlbGVtZW50J3Mgc3RhdHVzXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBoaWdobGlnaHRFbGVtZW50XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gc2VsZWN0RWxlbWVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqICBAZnVuY3Rpb24gZmFkZUVsZW1lbnRcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIGhpZGVFbGVtZW50XG4gICAgICovXG4gICAgQmFzZURhdGFMYXllci5wcm90b3R5cGVbYCR7dmVyYn1FbGVtZW50YF0gPSBmdW5jdGlvbihlbGVtZW50LCBleGNsdXNpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleGNsdXNpdmUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4Y2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhjbHVzaXZlID0gISFleGNsdXNpdmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50U3RhdHVzKGFkamVjdGl2ZSwgZWxlbWVudCwgdHJ1ZSwgZXhjbHVzaXZlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHVuaGlnaGxpZ2h0RWxlbWVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqICBAZnVuY3Rpb24gdW5zZWxlY3RFbGVtZW50XG4gICAgICovXG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICogIEBmdW5jdGlvbiB1bmZhZGVFbGVtZW50XG4gICAgICovXG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICogIEBmdW5jdGlvbiB1bmhpZGVFbGVtZW50XG4gICAgICovXG4gICAgQmFzZURhdGFMYXllci5wcm90b3R5cGVbYCR7YW50aXZlcmJ9RWxlbWVudGBdID0gZnVuY3Rpb24oZWxlbWVudCwgZXhjbHVzaXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhjbHVzaXZlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleGNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4Y2x1c2l2ZSA9ICEhZXhjbHVzaXZlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudFN0YXR1cyhhZGplY3RpdmUsIGVsZW1lbnQsIGZhbHNlLCBleGNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gaGlnaGxpZ2h0QWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIHNlbGVjdEFsbEVsZW1lbnRzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICogIEBmdW5jdGlvbiBmYWRlQWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIGhpZGVBbGxFbGVtZW50c1xuICAgICAqL1xuICAgIC8vIFNldC91bnNldCBzdGF0dXMgZm9yIGFsbCBlbGVtZW50c1xuICAgIEJhc2VEYXRhTGF5ZXIucHJvdG90eXBlW2Ake3ZlcmJ9QWxsRWxlbWVudHNgXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldEFsbEVsZW1lbnRTdGF0dXMoYWRqZWN0aXZlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHVuaGlnaGxpZ2h0QWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIHVuc2VsZWN0QWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiB1bmZhZGVBbGxFbGVtZW50c1xuICAgICAqICovXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gdW5oaWRlQWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICBCYXNlRGF0YUxheWVyLnByb3RvdHlwZVtgJHthbnRpdmVyYn1BbGxFbGVtZW50c2BdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0QWxsRWxlbWVudFN0YXR1cyhhZGplY3RpdmUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn0pO1xuXG5leHBvcnQge0Jhc2VEYXRhTGF5ZXIgYXMgZGVmYXVsdH07XG4iLCIvKiogQG1vZHVsZSAqL1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuXG5pbXBvcnQgQmFzZURhdGFMYXllciBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IEZpZWxkIGZyb20gJy4uLy4uL2RhdGEvZmllbGQnO1xuaW1wb3J0IHttZXJnZSwgbmFtZVRvU3ltYm9sfSBmcm9tICcuLi8uLi9oZWxwZXJzL2xheW91dHMnO1xuXG5cbmNvbnN0IGRlZmF1bHRfbGF5b3V0ID0ge1xuICAgIHBvaW50X3NpemU6IDQwLFxuICAgIHBvaW50X3NoYXBlOiAnc3F1YXJlJyxcbiAgICBjb2xvcjogJyM4ODg4ODgnLFxuICAgIGZpbGxfb3BhY2l0eTogMSxcbiAgICB5X2F4aXM6IHtcbiAgICAgICAgYXhpczogMixcbiAgICB9LFxuICAgIGlkX2ZpZWxkOiAnaWQnLFxuICAgIGNvbmZpZGVuY2VfaW50ZXJ2YWxzOiB7XG4gICAgICAgIHN0YXJ0X2ZpZWxkOiAnY2lfc3RhcnQnLFxuICAgICAgICBlbmRfZmllbGQ6ICdjaV9lbmQnLFxuICAgIH0sXG4gICAgc2hvd19ub19zaWduaWZpY2FuY2VfbGluZTogdHJ1ZSxcbn07XG5cbi8qKlxuICogRm9yZXN0IERhdGEgTGF5ZXJcbiAqIEltcGxlbWVudHMgYSBzdGFuZGFyZCBmb3Jlc3QgcGxvdC4gSW4gb3JkZXIgdG8gc3BhY2Ugb3V0IHBvaW50cywgYW55IGxheW91dCB1c2luZyB0aGlzIG11c3Qgc3BlY2lmeSBheGlzIHRpY2tzXG4gKiAgYW5kIGV4dGVudCBpbiBhZHZhbmNlLlxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgZHluYW1pY2FsbHkgZmV0Y2hlZCBkYXRhLCBjb25zaWRlciB1c2luZyBgY2F0ZWdvcnlfZm9yZXN0YCBpbnN0ZWFkLlxuICpcbiAqL1xuY2xhc3MgRm9yZXN0IGV4dGVuZHMgQmFzZURhdGFMYXllciB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIGxheW91dCA9IG1lcmdlKGxheW91dCwgZGVmYXVsdF9sYXlvdXQpO1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIF9nZXRUb29sdGlwUG9zaXRpb24odG9vbHRpcCkge1xuICAgICAgICBjb25zdCB4X2NlbnRlciA9IHRoaXMucGFyZW50Lnhfc2NhbGUodG9vbHRpcC5kYXRhW3RoaXMubGF5b3V0LnhfYXhpcy5maWVsZF0pO1xuICAgICAgICBjb25zdCB5X3NjYWxlID0gYHkke3RoaXMubGF5b3V0LnlfYXhpcy5heGlzfV9zY2FsZWA7XG4gICAgICAgIGNvbnN0IHlfY2VudGVyID0gdGhpcy5wYXJlbnRbeV9zY2FsZV0odG9vbHRpcC5kYXRhW3RoaXMubGF5b3V0LnlfYXhpcy5maWVsZF0pO1xuXG4gICAgICAgIGNvbnN0IHBvaW50X3NpemUgPSB0aGlzLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcih0aGlzLmxheW91dC5wb2ludF9zaXplLCB0b29sdGlwLmRhdGEpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLnNxcnQocG9pbnRfc2l6ZSAvIE1hdGguUEkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeF9taW46IHhfY2VudGVyIC0gb2Zmc2V0LFxuICAgICAgICAgICAgeF9tYXg6IHhfY2VudGVyICsgb2Zmc2V0LFxuICAgICAgICAgICAgeV9taW46IHlfY2VudGVyIC0gb2Zmc2V0LFxuICAgICAgICAgICAgeV9tYXg6IHlfY2VudGVyICsgb2Zmc2V0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEltcGxlbWVudCB0aGUgbWFpbiByZW5kZXIgZnVuY3Rpb25cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIEFwcGx5IGZpbHRlcnMgdG8gb25seSByZW5kZXIgYSBzcGVjaWZpZWQgc2V0IG9mIHBvaW50c1xuICAgICAgICBjb25zdCB0cmFja19kYXRhID0gdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG5cbiAgICAgICAgY29uc3QgeF9zY2FsZSA9ICd4X3NjYWxlJztcbiAgICAgICAgY29uc3QgeV9zY2FsZSA9IGB5JHt0aGlzLmxheW91dC55X2F4aXMuYXhpc31fc2NhbGVgO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGNvbmZpZGVuY2UgaW50ZXJ2YWwgcGF0aHMgaWYgZmllbGRzIGFyZSBkZWZpbmVkXG4gICAgICAgIGlmICh0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFsc1xuICAgICAgICAgICAgJiYgdGhpcy5sYXlvdXQuZmllbGRzLmluY2x1ZGVzKHRoaXMubGF5b3V0LmNvbmZpZGVuY2VfaW50ZXJ2YWxzLnN0YXJ0X2ZpZWxkKVxuICAgICAgICAgICAgJiYgdGhpcy5sYXlvdXQuZmllbGRzLmluY2x1ZGVzKHRoaXMubGF5b3V0LmNvbmZpZGVuY2VfaW50ZXJ2YWxzLmVuZF9maWVsZCkpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgc2VsZWN0aW9uIGZvciBhbGwgZm9yZXN0IHBsb3QgY29uZmlkZW5jZSBpbnRlcnZhbHNcbiAgICAgICAgICAgIGNvbnN0IGNpX3NlbGVjdGlvbiA9IHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgncmVjdC5sei1kYXRhX2xheWVyLWZvcmVzdC5sei1kYXRhX2xheWVyLWZvcmVzdC1jaScpXG4gICAgICAgICAgICAgICAgLmRhdGEodHJhY2tfZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbdGhpcy5sYXlvdXQuaWRfZmllbGRdO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBjaV90cmFuc2Zvcm0gPSAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy5wYXJlbnRbeF9zY2FsZV0oZFt0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFscy5zdGFydF9maWVsZF0pO1xuICAgICAgICAgICAgICAgIGxldCB5ID0gdGhpcy5wYXJlbnRbeV9zY2FsZV0oZFt0aGlzLmxheW91dC55X2F4aXMuZmllbGRdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IC0xMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IC0xMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KWA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2lfd2lkdGggPSAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFt4X3NjYWxlXShkW3RoaXMubGF5b3V0LmNvbmZpZGVuY2VfaW50ZXJ2YWxzLmVuZF9maWVsZF0pXG4gICAgICAgICAgICAgICAgICAgIC0gdGhpcy5wYXJlbnRbeF9zY2FsZV0oZFt0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFscy5zdGFydF9maWVsZF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNpX2hlaWdodCA9IDE7XG4gICAgICAgICAgICAvLyBDcmVhdGUgY29uZmlkZW5jZSBpbnRlcnZhbCByZWN0IGVsZW1lbnRzXG4gICAgICAgICAgICBjaV9zZWxlY3Rpb24uZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWZvcmVzdCBsei1kYXRhX2xheWVyLWZvcmVzdC1jaScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IGAke3RoaXMuZ2V0RWxlbWVudElkKGQpfV9jaWApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtpc05hTih0aGlzLnBhcmVudC5sYXlvdXQuaGVpZ2h0KSA/IDAgOiB0aGlzLnBhcmVudC5sYXlvdXQuaGVpZ2h0fSlgKVxuICAgICAgICAgICAgICAgIC5tZXJnZShjaV9zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGNpX3RyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjaV93aWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY2lfaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgICAgIGNpX3NlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBhIHNlbGVjdGlvbiBmb3IgYWxsIGZvcmVzdCBwbG90IHBvaW50c1xuICAgICAgICBjb25zdCBwb2ludHNfc2VsZWN0aW9uID0gdGhpcy5zdmcuZ3JvdXBcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgubHotZGF0YV9sYXllci1mb3Jlc3QubHotZGF0YV9sYXllci1mb3Jlc3QtcG9pbnQnKVxuICAgICAgICAgICAgLmRhdGEodHJhY2tfZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZFt0aGlzLmxheW91dC5pZF9maWVsZF07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgZWxlbWVudHMsIGFwcGx5IGNsYXNzLCBJRCwgYW5kIGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgY29uc3QgaW5pdGlhbF95ID0gaXNOYU4odGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodCkgPyAwIDogdGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodDtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBuZXcgdmFsdWVzIChvciBmdW5jdGlvbnMgZm9yIHRoZW0pIGZvciBwb3NpdGlvbiwgY29sb3IsIHNpemUsIGFuZCBzaGFwZVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSAoZCkgPT4ge1xuICAgICAgICAgICAgbGV0IHggPSB0aGlzLnBhcmVudFt4X3NjYWxlXShkW3RoaXMubGF5b3V0LnhfYXhpcy5maWVsZF0pO1xuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnBhcmVudFt5X3NjYWxlXShkW3RoaXMubGF5b3V0LnlfYXhpcy5maWVsZF0pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgICAgICAgICAgeCA9IC0xMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKHkpKSB7XG4gICAgICAgICAgICAgICAgeSA9IC0xMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZpbGwgPSAoZCwgaSkgPT4gdGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQuY29sb3IsIGQsIGkpO1xuICAgICAgICBjb25zdCBmaWxsX29wYWNpdHkgPSAoZCwgaSkgPT4gdGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQuZmlsbF9vcGFjaXR5LCBkLCBpKTtcblxuICAgICAgICBjb25zdCBzaGFwZSA9IGQzLnN5bWJvbCgpXG4gICAgICAgICAgICAuc2l6ZSgoZCwgaSkgPT4gdGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQucG9pbnRfc2l6ZSwgZCwgaSkpXG4gICAgICAgICAgICAudHlwZSgoZCwgaSkgPT4gbmFtZVRvU3ltYm9sKHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHRoaXMubGF5b3V0LnBvaW50X3NoYXBlLCBkLCBpKSkpO1xuXG4gICAgICAgIHBvaW50c19zZWxlY3Rpb24uZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1mb3Jlc3QgbHotZGF0YV9sYXllci1mb3Jlc3QtcG9pbnQnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IHRoaXMuZ2V0RWxlbWVudElkKGQpKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtpbml0aWFsX3l9KWApXG4gICAgICAgICAgICAubWVyZ2UocG9pbnRzX3NlbGVjdGlvbilcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGZpbGwpXG4gICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgZmlsbF9vcGFjaXR5KVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBzaGFwZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgcG9pbnRzX3NlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLyBBcHBseSBiZWhhdmlvcnMgdG8gcG9pbnRzXG4gICAgICAgIHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAub24oJ2NsaWNrLmV2ZW50X2VtaXR0ZXInLCAoZWxlbWVudF9kYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZW1pdCgnZWxlbWVudF9jbGlja2VkJywgZWxlbWVudF9kYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcy5hcHBseUJlaGF2aW9ycy5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBBIHktYWxpZ25lZCBmb3Jlc3QgcGxvdCBpbiB3aGljaCB0aGUgeS1heGlzIHJlcHJlc2VudHMgaXRlbSBsYWJlbHMsIHdoaWNoIGFyZSBkeW5hbWljYWxseSBjaG9zZW4gd2hlbiBkYXRhIGlzIGxvYWRlZC5cbiAqICAgRWFjaCBpdGVtIGlzIGFzc3VtZWQgdG8gaW5jbHVkZSBib3RoIGRhdGEgYW5kIGNvbmZpZGVuY2UgaW50ZXJ2YWxzLlxuICogICBUaGlzIGFsbG93cyBnZW5lcmF0aW5nIGZvcmVzdCBwbG90cyB3aXRob3V0IGRlZmluaW5nIHRoZSBsYXlvdXQgaW4gYWR2YW5jZS5cbiAqXG4gKi9cbmNsYXNzIENhdGVnb3J5Rm9yZXN0IGV4dGVuZHMgRm9yZXN0IHtcbiAgICBfZ2V0RGF0YUV4dGVudChkYXRhLCBheGlzX2NvbmZpZykge1xuICAgICAgICAvLyBJbiBhIGZvcmVzdCBwbG90LCB0aGUgZGF0YSByYW5nZSBpcyBkZXRlcm1pbmVkIGJ5ICp0aHJlZSogZmllbGRzIChiZXRhICsgQ0kgc3RhcnQvZW5kKVxuICAgICAgICBjb25zdCBjaV9jb25maWcgPSB0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFscztcbiAgICAgICAgaWYgKGNpX2NvbmZpZ1xuICAgICAgICAgICAgJiYgdGhpcy5sYXlvdXQuZmllbGRzLmluY2x1ZGVzKGNpX2NvbmZpZy5zdGFydF9maWVsZClcbiAgICAgICAgICAgICYmIHRoaXMubGF5b3V0LmZpZWxkcy5pbmNsdWRlcyhjaV9jb25maWcuZW5kX2ZpZWxkKSkge1xuICAgICAgICAgICAgY29uc3QgbWluID0gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmID0gbmV3IEZpZWxkKGNpX2NvbmZpZy5zdGFydF9maWVsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICtmLnJlc29sdmUoZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBtYXggPSAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBuZXcgRmllbGQoY2lfY29uZmlnLmVuZF9maWVsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICtmLnJlc29sdmUoZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gW2QzLm1pbihkYXRhLCBtaW4pLCBkMy5tYXgoZGF0YSwgbWF4KV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY29uZmlkZW5jZSBpbnRlcnZhbHMgc2V0LCB0aGVuIHJhbmdlIG11c3QgZGVwZW5kIG9ubHkgb24gYSBzaW5nbGUgZmllbGRcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXREYXRhRXh0ZW50KGRhdGEsIGF4aXNfY29uZmlnKTtcbiAgICB9XG5cbiAgICBnZXRUaWNrcyhkaW1lbnNpb24sIGNvbmZpZykgeyAvLyBPdmVycmlkZXMgcGFyZW50IG1ldGhvZFxuICAgICAgICBpZiAoIVsneCcsICd5MScsICd5MiddLmluY2x1ZGVzKGRpbWVuc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaW1lbnNpb24gaWRlbnRpZmllciAke2RpbWVuc2lvbn1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2lnbiBhc3N1bXB0aW9uOiBvbmUgYXhpcyAoeTEgb3IgeTIpIGhhcyB0aGUgdGlja3MsIGFuZCB0aGUgbGF5b3V0IHNheXMgd2hpY2ggdG8gdXNlXG4gICAgICAgIC8vIEFsc28gYXNzdW1lcyB0aGF0IGV2ZXJ5IHRpY2sgZ2V0cyBhc3NpZ25lZCBhIHVuaXF1ZSBtYXRjaGluZyBsYWJlbFxuICAgICAgICBjb25zdCBheGlzX251bSA9IHRoaXMubGF5b3V0LnlfYXhpcy5heGlzO1xuICAgICAgICBpZiAoZGltZW5zaW9uID09PSAoYHkke2F4aXNfbnVtfWApKSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeV9maWVsZCA9IHRoaXMubGF5b3V0LnlfYXhpcy5jYXRlZ29yeV9maWVsZDtcbiAgICAgICAgICAgIGlmICghY2F0ZWdvcnlfZmllbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExheW91dCBmb3IgJHt0aGlzLmxheW91dC5pZH0gbXVzdCBzcGVjaWZ5IGNhdGVnb3J5X2ZpZWxkYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKChpdGVtLCBpbmRleCkgPT4gKHsgeTogaW5kZXggKyAxLCB0ZXh0OiBpdGVtW2NhdGVnb3J5X2ZpZWxkXSB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseUN1c3RvbURhdGFNZXRob2RzICgpIHtcbiAgICAgICAgLy8gQWRkIGEgc3ludGhldGljIHlheGlzIGZpZWxkIHRvIGVuc3VyZSBkYXRhIGlzIHNwcmVhZCBvdXQgb24gcGxvdC4gVGhlbiwgc2V0IGF4aXMgZmxvb3IgYW5kIGNlaWxpbmcgdG9cbiAgICAgICAgLy8gIGNvcnJlY3QgZXh0ZW50cy5cbiAgICAgICAgY29uc3QgZmllbGRfdG9fYWRkID0gdGhpcy5sYXlvdXQueV9heGlzLmZpZWxkO1xuICAgICAgICBpZiAoIWZpZWxkX3RvX2FkZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXlvdXQgZm9yICR7dGhpcy5sYXlvdXQuaWR9IG11c3Qgc3BlY2lmeSB5YXhpcy5maWVsZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGl0ZW1bZmllbGRfdG9fYWRkXSA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlIGF4aXMgZXh0ZW50cyBiYXNlZCBvbiBvbmUgbGFiZWwgZm9yIGV2ZXJ5IHBvaW50ICh3aXRoIGEgYml0IG9mIHBhZGRpbmcgYWJvdmUgYW5kIGJlbG93KVxuICAgICAgICB0aGlzLmxheW91dC55X2F4aXMuZmxvb3IgPSAwO1xuICAgICAgICB0aGlzLmxheW91dC55X2F4aXMuY2VpbGluZyA9IHRoaXMuZGF0YS5sZW5ndGggKyAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEZvcmVzdCBhcyBmb3Jlc3QsIENhdGVnb3J5Rm9yZXN0IGFzIGNhdGVnb3J5X2ZvcmVzdCB9O1xuIiwiLyoqIEBtb2R1bGUgKi9cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuaW1wb3J0IEJhc2VEYXRhTGF5ZXIgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7bWVyZ2V9IGZyb20gJy4uLy4uL2hlbHBlcnMvbGF5b3V0cyc7XG5cbmNvbnN0IGRlZmF1bHRfbGF5b3V0ID0ge1xuICAgIC8vIE9wdGlvbmFsbHkgc3BlY2lmeSBkaWZmZXJlbnQgZmlsbCBhbmQgc3Ryb2tlIHByb3BlcnRpZXNcbiAgICBzdHJva2U6ICdyZ2IoNTQsIDU0LCAxNTApJyxcbiAgICBjb2xvcjogJyMzNjM2OTYnLFxuICAgIGxhYmVsX2ZvbnRfc2l6ZTogMTIsXG4gICAgbGFiZWxfZXhvbl9zcGFjaW5nOiAzLFxuICAgIGV4b25faGVpZ2h0OiAxMCxcbiAgICBib3VuZGluZ19ib3hfcGFkZGluZzogMyxcbiAgICB0cmFja192ZXJ0aWNhbF9zcGFjaW5nOiA1LFxuICAgIHRvb2x0aXBfcG9zaXRpb25pbmc6ICd0b3AnLFxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqXG4gKiBHZW5lcyBEYXRhIExheWVyXG4gKiBJbXBsZW1lbnRzIGEgZGF0YSBsYXllciB0aGF0IHdpbGwgcmVuZGVyIGdlbmUgdHJhY2tzXG4qL1xuY2xhc3MgR2VuZXMgZXh0ZW5kcyBCYXNlRGF0YUxheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0ID0gbWVyZ2UobGF5b3V0LCBkZWZhdWx0X2xheW91dCk7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGdlbmUgbWF5IGhhdmUgYXJiaXRyYXJpbHkgbWFueSB0cmFuc2NyaXB0cywgYnV0IHRoaXMgZGF0YSBsYXllciBpc24ndCBzZXQgdXAgdG8gcmVuZGVyIHRoZW0geWV0LlxuICAgICAgICAgKiBTdGFzaCBhIHRyYW5zY3JpcHRfaWR4IHRvIHBvaW50IHRvIHRoZSBmaXJzdCB0cmFuc2NyaXB0IGFuZCB1c2UgdGhhdCBmb3IgYWxsIHRyYW5zY3JpcHQgcmVmcy5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2NyaXB0X2lkeCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIGNvdW50ZXIgZm9yIHRoZSBudW1iZXIgb2YgdHJhY2tzIGluIHRoZSBkYXRhIGxheWVyLiBVc2VkIGFzIGFuIGludGVybmFsIGNvdW50ZXIgZm9yIGxvb3BpbmdcbiAgICAgICAgICogICBvdmVyIHBvc2l0aW9ucyAvIGFzc2lnbm1lbnRzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja3MgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBnZW5lcyBpbiBkYXRhc2V0LCBpbiBhIGhhc2ggaW5kZXhlZCBieSB0cmFjayBudW1iZXI6IHt0cmFja19udW1iZXI6IFtnZW5lX2luZGljZXNdfVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3QuPE51bWJlciwgQXJyYXk+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lX3RyYWNrX2luZGV4ID0geyAxOiBbXSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgc3RhdHVzbm9kZSBJRCBmb3IgYSBnaXZlbiBlbGVtZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50U3RhdHVzTm9kZUlkKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0RWxlbWVudElkKGVsZW1lbnQpfS1zdGF0dXNub2RlYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3VtIGxheW91dCB2YWx1ZXMgdG8gZGVyaXZlIHRvdGFsIGhlaWdodCBmb3IgYSBzaW5nbGUgZ2VuZSB0cmFja1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0VHJhY2tIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiAyICogdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmdcbiAgICAgICAgICAgICsgdGhpcy5sYXlvdXQubGFiZWxfZm9udF9zaXplXG4gICAgICAgICAgICArIHRoaXMubGF5b3V0LmxhYmVsX2V4b25fc3BhY2luZ1xuICAgICAgICAgICAgKyB0aGlzLmxheW91dC5leG9uX2hlaWdodFxuICAgICAgICAgICAgKyB0aGlzLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IGdlbmVzIGluIG92ZXJsYXBwaW5nIGNocm9tb3NvbWUgcmVnaW9ucyBhcmUgcG9zaXRpb25lZCBzbyB0aGF0IHBhcnRzIG9mIGRpZmZlcmVudCBnZW5lcyBkbyBub3RcbiAgICAgKiAgIG92ZXJsYXAgaW4gdGhlIHZpZXcuIEEgdHJhY2sgaXMgYSByb3cgdXNlZCB0byB2ZXJ0aWNhbGx5IHNlcGFyYXRlIG92ZXJsYXBwaW5nIGdlbmVzLlxuICAgICAqIEByZXR1cm5zIHtHZW5lc31cbiAgICAgKi9cbiAgICBhc3NpZ25UcmFja3MoZGF0YSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdG8gZ2V0IHRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgYSBsYWJlbCBnaXZlbiB0aGUgdGV4dCBhbmQgbGF5b3V0IGF0dHJpYnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGdlbmVfbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZvbnRfc2l6ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgX2dldExhYmVsV2lkdGggPSAoZ2VuZV9uYW1lLCBmb250X3NpemUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcF90ZXh0ID0gdGhpcy5zdmcuZ3JvdXAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWdlbmVzIGx6LWxhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBmb250X3NpemUpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGAke2dlbmVfbmFtZX3ihpJgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbF93aWR0aCA9IHRlbXBfdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgIHRlbXBfdGV4dC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxfd2lkdGg7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVpbml0aWFsaXplIHNvbWUgbWV0YWRhdGFcbiAgICAgICAgdGhpcy50cmFja3MgPSAxO1xuICAgICAgICB0aGlzLmdlbmVfdHJhY2tfaW5kZXggPSB7IDE6IFtdIH07XG5cbiAgICAgICAgZGF0YS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIC8vIElmIG5lY2Vzc2FyeSwgc3BsaXQgY29tYmluZWQgZ2VuZSBpZCAvIHZlcnNpb24gZmllbGRzIGludG8gZGlzY3JldGUgZmllbGRzLlxuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBtYXkgYmUgYW4gaXNzdWUgd2l0aCBDU0cncyBnZW5lcyBkYXRhIHNvdXJjZSB0aGF0IG1heSBldmVudHVhbGx5IGJlIHNvbHZlZCB1cHN0cmVhbS5cbiAgICAgICAgICAgIGlmIChpdGVtLmdlbmVfaWQgJiYgaXRlbS5nZW5lX2lkLmluZGV4T2YoJy4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0ID0gaXRlbS5nZW5lX2lkLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgaXRlbS5nZW5lX2lkID0gc3BsaXRbMF07XG4gICAgICAgICAgICAgICAgaXRlbS5nZW5lX3ZlcnNpb24gPSBzcGxpdFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3Rhc2ggdGhlIHRyYW5zY3JpcHQgSUQgb24gdGhlIHBhcmVudCBnZW5lXG4gICAgICAgICAgICBpdGVtLnRyYW5zY3JpcHRfaWQgPSBpdGVtLnRyYW5zY3JpcHRzW3RoaXMudHJhbnNjcmlwdF9pZHhdLnRyYW5zY3JpcHRfaWQ7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBkaXNwbGF5IHJhbmdlIHN0YXJ0IGFuZCBlbmQsIGJhc2VkIG9uIG1pbmltdW0gYWxsb3dhYmxlIGdlbmUgZGlzcGxheSB3aWR0aCwgYm91bmRlZCBieSB3aGF0IHdlIGNhbiBzZWVcbiAgICAgICAgICAgIC8vIChyYW5nZTogdmFsdWVzIGluIHRlcm1zIG9mIHBpeGVscyBvbiB0aGUgc2NyZWVuKVxuICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBhcmVudC54X3NjYWxlKE1hdGgubWF4KGl0ZW0uc3RhcnQsIHRoaXMuc3RhdGUuc3RhcnQpKSxcbiAgICAgICAgICAgICAgICBlbmQ6ICAgdGhpcy5wYXJlbnQueF9zY2FsZShNYXRoLm1pbihpdGVtLmVuZCwgdGhpcy5zdGF0ZS5lbmQpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpdGVtLmRpc3BsYXlfcmFuZ2UubGFiZWxfd2lkdGggPSBfZ2V0TGFiZWxXaWR0aChpdGVtLmdlbmVfbmFtZSwgdGhpcy5sYXlvdXQubGFiZWxfZm9udF9zaXplKTtcbiAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS53aWR0aCA9IGl0ZW0uZGlzcGxheV9yYW5nZS5lbmQgLSBpdGVtLmRpc3BsYXlfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgbGFiZWwgdGV4dCBhbmNob3IgKGRlZmF1bHQgdG8gbWlkZGxlKVxuICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLnRleHRfYW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBpZiAoaXRlbS5kaXNwbGF5X3JhbmdlLndpZHRoIDwgaXRlbS5kaXNwbGF5X3JhbmdlLmxhYmVsX3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnQgPCB0aGlzLnN0YXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS5lbmQgPSBpdGVtLmRpc3BsYXlfcmFuZ2Uuc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICsgaXRlbS5kaXNwbGF5X3JhbmdlLmxhYmVsX3dpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICArIHRoaXMubGF5b3V0LmxhYmVsX2ZvbnRfc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLnRleHRfYW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uZW5kID4gdGhpcy5zdGF0ZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLnN0YXJ0ID0gaXRlbS5kaXNwbGF5X3JhbmdlLmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLSBpdGVtLmRpc3BsYXlfcmFuZ2UubGFiZWxfd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gdGhpcy5sYXlvdXQubGFiZWxfZm9udF9zaXplO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRpc3BsYXlfcmFuZ2UudGV4dF9hbmNob3IgPSAnZW5kJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJlZF9tYXJnaW4gPSAoKGl0ZW0uZGlzcGxheV9yYW5nZS5sYWJlbF93aWR0aCAtIGl0ZW0uZGlzcGxheV9yYW5nZS53aWR0aCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyB0aGlzLmxheW91dC5sYWJlbF9mb250X3NpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaXRlbS5kaXNwbGF5X3JhbmdlLnN0YXJ0IC0gY2VudGVyZWRfbWFyZ2luKSA8IHRoaXMucGFyZW50Lnhfc2NhbGUodGhpcy5zdGF0ZS5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS5zdGFydCA9IHRoaXMucGFyZW50Lnhfc2NhbGUodGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmRpc3BsYXlfcmFuZ2UuZW5kID0gaXRlbS5kaXNwbGF5X3JhbmdlLnN0YXJ0ICsgaXRlbS5kaXNwbGF5X3JhbmdlLmxhYmVsX3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLnRleHRfYW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoaXRlbS5kaXNwbGF5X3JhbmdlLmVuZCArIGNlbnRlcmVkX21hcmdpbikgPiB0aGlzLnBhcmVudC54X3NjYWxlKHRoaXMuc3RhdGUuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLmVuZCA9IHRoaXMucGFyZW50Lnhfc2NhbGUodGhpcy5zdGF0ZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLnN0YXJ0ID0gaXRlbS5kaXNwbGF5X3JhbmdlLmVuZCAtIGl0ZW0uZGlzcGxheV9yYW5nZS5sYWJlbF93aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS50ZXh0X2FuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXNwbGF5X3JhbmdlLnN0YXJ0IC09IGNlbnRlcmVkX21hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS5lbmQgKz0gY2VudGVyZWRfbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS53aWR0aCA9IGl0ZW0uZGlzcGxheV9yYW5nZS5lbmQgLSBpdGVtLmRpc3BsYXlfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYm91bmRpbmcgYm94IHBhZGRpbmcgdG8gdGhlIGNhbGN1bGF0ZWQgZGlzcGxheSByYW5nZSBzdGFydCwgZW5kLCBhbmQgd2lkdGhcbiAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS5zdGFydCAtPSB0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZztcbiAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS5lbmQgICArPSB0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZztcbiAgICAgICAgICAgIGl0ZW0uZGlzcGxheV9yYW5nZS53aWR0aCArPSAyICogdGhpcy5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmc7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGFuZCBzdGFzaCBkaXNwbGF5IHJhbmdlIHZhbHVlcyBpbnRvIGRvbWFpbiB2YWx1ZXNcbiAgICAgICAgICAgIC8vIChkb21haW46IHZhbHVlcyBpbiB0ZXJtcyBvZiB0aGUgZGF0YSBzZXQsIGUuZy4gbWVnYWJhc2VzKVxuICAgICAgICAgICAgaXRlbS5kaXNwbGF5X2RvbWFpbiA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wYXJlbnQueF9zY2FsZS5pbnZlcnQoaXRlbS5kaXNwbGF5X3JhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICBlbmQ6ICAgdGhpcy5wYXJlbnQueF9zY2FsZS5pbnZlcnQoaXRlbS5kaXNwbGF5X3JhbmdlLmVuZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXRlbS5kaXNwbGF5X2RvbWFpbi53aWR0aCA9IGl0ZW0uZGlzcGxheV9kb21haW4uZW5kIC0gaXRlbS5kaXNwbGF5X2RvbWFpbi5zdGFydDtcblxuICAgICAgICAgICAgLy8gVXNpbmcgZGlzcGxheSByYW5nZS9kb21haW4gZGF0YSBnZW5lcmF0ZWQgYWJvdmUgY2FzdCBlYWNoIGdlbmUgdG8gdHJhY2tzIHN1Y2ggdGhhdCBub25lIG92ZXJsYXBcbiAgICAgICAgICAgIGl0ZW0udHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHBvdGVudGlhbF90cmFjayA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoaXRlbS50cmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2xsaXNpb25fb25fcG90ZW50aWFsX3RyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lX3RyYWNrX2luZGV4W3BvdGVudGlhbF90cmFja10ubWFwKChwbGFjZWRfZ2VuZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbl9zdGFydCA9IE1hdGgubWluKHBsYWNlZF9nZW5lLmRpc3BsYXlfcmFuZ2Uuc3RhcnQsIGl0ZW0uZGlzcGxheV9yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhfZW5kID0gTWF0aC5tYXgocGxhY2VkX2dlbmUuZGlzcGxheV9yYW5nZS5lbmQsIGl0ZW0uZGlzcGxheV9yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXhfZW5kIC0gbWluX3N0YXJ0KSA8IChwbGFjZWRfZ2VuZS5kaXNwbGF5X3JhbmdlLndpZHRoICsgaXRlbS5kaXNwbGF5X3JhbmdlLndpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbl9vbl9wb3RlbnRpYWxfdHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25fb25fcG90ZW50aWFsX3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHJhY2sgPSBwb3RlbnRpYWxfdHJhY2s7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZV90cmFja19pbmRleFtwb3RlbnRpYWxfdHJhY2tdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsX3RyYWNrKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxfdHJhY2sgPiB0aGlzLnRyYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja3MgPSBwb3RlbnRpYWxfdHJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVfdHJhY2tfaW5kZXhbcG90ZW50aWFsX3RyYWNrXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFzaCBwYXJlbnQgcmVmZXJlbmNlcyBvbiBhbGwgZ2VuZXMsIHRyYW5zY3JpcHRzLCBhbmQgZXhvbnNcbiAgICAgICAgICAgIGl0ZW0ucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIGl0ZW0udHJhbnNjcmlwdHMubWFwKChkLCB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS50cmFuc2NyaXB0c1t0XS5wYXJlbnQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGl0ZW0udHJhbnNjcmlwdHNbdF0uZXhvbnMubWFwKChkLCBlKSA9PiBpdGVtLnRyYW5zY3JpcHRzW3RdLmV4b25zW2VdLnBhcmVudCA9IGl0ZW0udHJhbnNjcmlwdHNbdF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWluIHJlbmRlciBmdW5jdGlvblxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vIEFwcGx5IGZpbHRlcnMgdG8gb25seSByZW5kZXIgYSBzcGVjaWZpZWQgc2V0IG9mIHBvaW50c1xuICAgICAgICBjb25zdCB0cmFja19kYXRhID0gdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG4gICAgICAgIHRoaXMuYXNzaWduVHJhY2tzKHRyYWNrX2RhdGEpO1xuICAgICAgICBsZXQgaGVpZ2h0O1xuXG4gICAgICAgIC8vIFJlbmRlciBnZW5lIGdyb3Vwc1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnN2Zy5ncm91cC5zZWxlY3RBbGwoJ2cubHotZGF0YV9sYXllci1nZW5lcycpXG4gICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4gZC5nZW5lX25hbWUpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWdlbmVzJylcbiAgICAgICAgICAgIC5tZXJnZShzZWxlY3Rpb24pXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gdGhpcy5nZXRFbGVtZW50SWQoZCkpXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbihnZW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YV9sYXllciA9IGdlbmUucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGdlbmUgYm91bmRpbmcgYm94ZXMgKHN0YXR1cyBub2RlcyB0byBzaG93IHNlbGVjdGVkL2hpZ2hsaWdodGVkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJib3hlcyA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3JlY3QubHotZGF0YV9sYXllci1nZW5lcy5sei1kYXRhX2xheWVyLWdlbmVzLXN0YXR1c25vZGUnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShbZ2VuZV0sIChkKSA9PiBkYXRhX2xheWVyLmdldEVsZW1lbnRTdGF0dXNOb2RlSWQoZCkpO1xuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpIC0gZGF0YV9sYXllci5sYXlvdXQudHJhY2tfdmVydGljYWxfc3BhY2luZztcblxuICAgICAgICAgICAgICAgIGJib3hlcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1nZW5lcyBsei1kYXRhX2xheWVyLWdlbmVzLXN0YXR1c25vZGUnKVxuICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmJveGVzKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gZGF0YV9sYXllci5nZXRFbGVtZW50U3RhdHVzTm9kZUlkKGQpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncngnLCBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J5JywgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2Uud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IGQuZGlzcGxheV9yYW5nZS5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpKTtcblxuICAgICAgICAgICAgICAgIGJib3hlcy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGdlbmUgYm91bmRhcmllc1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdyZWN0Lmx6LWRhdGFfbGF5ZXItZ2VuZXMubHotYm91bmRhcnknKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShbZ2VuZV0sIChkKSA9PiBgJHtkLmdlbmVfbmFtZX1fYm91bmRhcnlgKTtcblxuICAgICAgICAgICAgICAgIGhlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgYm91bmRhcmllcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1nZW5lcyBsei1ib3VuZGFyeScpXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShib3VuZGFyaWVzKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZGF0YV9sYXllci5wYXJlbnQueF9zY2FsZShkLmVuZCkgLSBkYXRhX2xheWVyLnBhcmVudC54X3NjYWxlKGQuc3RhcnQpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkYXRhX2xheWVyLnBhcmVudC54X3NjYWxlKGQuc3RhcnQpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChkLnRyYWNrIC0gMSkgKiBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZGF0YV9sYXllci5sYXlvdXQubGFiZWxfZm9udF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBkYXRhX2xheWVyLmxheW91dC5sYWJlbF9leG9uX3NwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChNYXRoLm1heChkYXRhX2xheWVyLmxheW91dC5leG9uX2hlaWdodCwgMykgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IHNlbGYucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHNlbGYubGF5b3V0LmNvbG9yLCBkLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAoZCwgaSkgPT4gc2VsZi5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIoc2VsZi5sYXlvdXQuc3Ryb2tlLCBkLCBpKSk7XG5cbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZ2VuZSBsYWJlbHNcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbHMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCd0ZXh0Lmx6LWRhdGFfbGF5ZXItZ2VuZXMubHotbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShbZ2VuZV0sIChkKSA9PiBgJHtkLmdlbmVfbmFtZX1fbGFiZWxgKTtcblxuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotZGF0YV9sYXllci1nZW5lcyBsei1sYWJlbCcpXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShsYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2UudGV4dF9hbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiAoZC5zdHJhbmQgPT09ICcrJykgPyBgJHtkLmdlbmVfbmFtZX3ihpJgIDogYOKGkCR7ZC5nZW5lX25hbWV9YClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBnZW5lLnBhcmVudC5sYXlvdXQubGFiZWxfZm9udF9zaXplKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC5kaXNwbGF5X3JhbmdlLnRleHRfYW5jaG9yID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmRpc3BsYXlfcmFuZ2Uuc3RhcnQgKyAoZC5kaXNwbGF5X3JhbmdlLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGQuZGlzcGxheV9yYW5nZS50ZXh0X2FuY2hvciA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmRpc3BsYXlfcmFuZ2Uuc3RhcnQgKyBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5kaXNwbGF5X3JhbmdlLnRleHRfYW5jaG9yID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmRpc3BsYXlfcmFuZ2UuZW5kIC0gZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+ICgoZC50cmFjayAtIDEpICogZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBkYXRhX2xheWVyLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyBkYXRhX2xheWVyLmxheW91dC5sYWJlbF9mb250X3NpemVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGxhYmVscy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGV4b24gcmVjdHMgKGZpcnN0IHRyYW5zY3JpcHQgb25seSwgZm9yIG5vdylcbiAgICAgICAgICAgICAgICAvLyBFeG9uczogYnkgZGVmYXVsdCBjb2xvciBvbiBnZW5lIHByb3BlcnRpZXMgZm9yIGNvbnNpc3RlbmN5IHdpdGggdGhlIGdlbmUgYm91bmRhcnkgdHJhY2stIGhlbmNlIGNvbG9yIHVzZXMgZC5wYXJlbnQucGFyZW50XG4gICAgICAgICAgICAgICAgY29uc3QgZXhvbnMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdyZWN0Lmx6LWRhdGFfbGF5ZXItZ2VuZXMubHotZXhvbicpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGdlbmUudHJhbnNjcmlwdHNbZ2VuZS5wYXJlbnQudHJhbnNjcmlwdF9pZHhdLmV4b25zLCAoZCkgPT4gZC5leG9uX2lkKTtcblxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGRhdGFfbGF5ZXIubGF5b3V0LmV4b25faGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgZXhvbnMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItZ2VuZXMgbHotZXhvbicpXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShleG9ucylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IHNlbGYucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHNlbGYubGF5b3V0LmNvbG9yLCBkLnBhcmVudC5wYXJlbnQsIGkpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIChkLCBpKSA9PiBzZWxmLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcihzZWxmLmxheW91dC5zdHJva2UsIGQucGFyZW50LnBhcmVudCwgaSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkYXRhX2xheWVyLnBhcmVudC54X3NjYWxlKGQuZW5kKSAtIGRhdGFfbGF5ZXIucGFyZW50Lnhfc2NhbGUoZC5zdGFydCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IGRhdGFfbGF5ZXIucGFyZW50Lnhfc2NhbGUoZC5zdGFydCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoZ2VuZS50cmFjayAtIDEpICogZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsX2ZvbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZGF0YV9sYXllci5sYXlvdXQubGFiZWxfZXhvbl9zcGFjaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGV4b25zLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZ2VuZSBjbGljayBhcmVhXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpY2thcmVhcyA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3JlY3QubHotZGF0YV9sYXllci1nZW5lcy5sei1jbGlja2FyZWEnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShbZ2VuZV0sIChkKSA9PiBgJHtkLmdlbmVfbmFtZX1fY2xpY2thcmVhYCk7XG5cbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBkYXRhX2xheWVyLmdldFRyYWNrSGVpZ2h0KCkgLSBkYXRhX2xheWVyLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nO1xuICAgICAgICAgICAgICAgIGNsaWNrYXJlYXMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItZ2VuZXMgbHotY2xpY2thcmVhJylcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGNsaWNrYXJlYXMpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiBgJHtkYXRhX2xheWVyLmdldEVsZW1lbnRJZChkKX1fY2xpY2thcmVhYClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgZGF0YV9sYXllci5sYXlvdXQuYm91bmRpbmdfYm94X3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeScsIGRhdGFfbGF5ZXIubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCkgPT4gZC5kaXNwbGF5X3JhbmdlLndpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkLmRpc3BsYXlfcmFuZ2Uuc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQpID0+ICgoZC50cmFjayAtIDEpICogZGF0YV9sYXllci5nZXRUcmFja0hlaWdodCgpKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIGNsaWNrYXJlYXMgYXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgY2xpY2thcmVhcy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgc2VsZWN0aW9uLmV4aXQoKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IG1vdXNlIGJlaGF2aW9ycyAmIGV2ZW50cyB0byBjbGlja2FyZWFzXG4gICAgICAgIHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAub24oJ2NsaWNrLmV2ZW50X2VtaXR0ZXInLCAoZWxlbWVudCkgPT4gdGhpcy5wYXJlbnQuZW1pdCgnZWxlbWVudF9jbGlja2VkJywgZWxlbWVudCwgdHJ1ZSkpXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmFwcGx5QmVoYXZpb3JzLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIF9nZXRUb29sdGlwUG9zaXRpb24odG9vbHRpcCkge1xuICAgICAgICBjb25zdCBnZW5lX2Jib3hfaWQgPSB0aGlzLmdldEVsZW1lbnRTdGF0dXNOb2RlSWQodG9vbHRpcC5kYXRhKTtcbiAgICAgICAgY29uc3QgZ2VuZV9iYm94ID0gZDMuc2VsZWN0KGAjJHtnZW5lX2Jib3hfaWR9YCkubm9kZSgpLmdldEJCb3goKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhfbWluOiB0aGlzLnBhcmVudC54X3NjYWxlKHRvb2x0aXAuZGF0YS5zdGFydCksXG4gICAgICAgICAgICB4X21heDogdGhpcy5wYXJlbnQueF9zY2FsZSh0b29sdGlwLmRhdGEuZW5kKSxcbiAgICAgICAgICAgIHlfbWluOiBnZW5lX2Jib3gueSxcbiAgICAgICAgICAgIHlfbWF4OiBnZW5lX2Jib3gueSArIGdlbmVfYmJveC5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQge0dlbmVzIGFzIGRlZmF1bHR9O1xuIiwiLyoqXG4gKiBSb2xsdXAgbW9kdWxlIHRoYXQgZGVmaW5lcyBhbGwga25vd24gZGF0YWxheWVycy4gVXNlZCB0byBjcmVhdGUgdGhlIHJlZ2lzdHJ5LlxuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VEYXRhTGF5ZXIgfSBmcm9tICcuL2Jhc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhbm5vdGF0aW9uX3RyYWNrIH0gZnJvbSAnLi9hbm5vdGF0aW9uX3RyYWNrJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJjcyB9IGZyb20gJy4vYXJjcyc7XG5leHBvcnQgKiBmcm9tICcuL2ZvcmVzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdlbmVzIH0gZnJvbSAnLi9nZW5lcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpbmUnO1xuZXhwb3J0ICogZnJvbSAnLi9zY2F0dGVyJztcbiIsIi8qKiBAbW9kdWxlICovXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cbmltcG9ydCBCYXNlRGF0YUxheWVyIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQge21lcmdlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2xheW91dHMnO1xuaW1wb3J0IHtTVEFUVVNFU30gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7YXBwbHlTdHlsZXN9IGZyb20gJy4uLy4uL2hlbHBlcnMvY29tbW9uJztcblxuY29uc3QgZGVmYXVsdF9sYXlvdXQgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogJzJweCcsXG4gICAgfSxcbiAgICBpbnRlcnBvbGF0ZTogJ2N1cnZlTGluZWFyJyxcbiAgICB4X2F4aXM6IHsgZmllbGQ6ICd4JyB9LFxuICAgIHlfYXhpczogeyBmaWVsZDogJ3knLCBheGlzOiAxIH0sXG4gICAgaGl0YXJlYV93aWR0aDogNSxcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKipcbiAqIExpbmUgRGF0YSBMYXllclxuICogSW1wbGVtZW50cyBhIHN0YW5kYXJkIGxpbmUgcGxvdCwgcmVwcmVzZW50aW5nIGVpdGhlciBhIHRyYWNlIG9yIGEgZmlsbGVkIGN1cnZlLlxuKi9cbmNsYXNzIExpbmUgZXh0ZW5kcyBCYXNlRGF0YUxheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0ID0gbWVyZ2UobGF5b3V0LCBkZWZhdWx0X2xheW91dCk7XG4gICAgICAgIGlmIChsYXlvdXQudG9vbHRpcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGluZSAvIGZpbGxlZCBjdXJ2ZSBsYXllciBkb2VzIG5vdCBzdXBwb3J0IHRvb2x0aXBzJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdGhlIG1haW4gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBTZXZlcmFsIHZhcnMgbmVlZGVkIHRvIGJlIGluIHNjb3BlXG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IHhfZmllbGQgPSB0aGlzLmxheW91dC54X2F4aXMuZmllbGQ7XG4gICAgICAgIGNvbnN0IHlfZmllbGQgPSB0aGlzLmxheW91dC55X2F4aXMuZmllbGQ7XG5cbiAgICAgICAgLy8gSm9pbiBkYXRhIHRvIHRoZSBsaW5lIHNlbGVjdGlvblxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnN2Zy5ncm91cFxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aC5sei1kYXRhX2xheWVyLWxpbmUnKVxuICAgICAgICAgICAgLmRhdGEoW3RoaXMuZGF0YV0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIGVsZW1lbnQsIGFwcGx5IGNsYXNzXG4gICAgICAgIHRoaXMucGF0aCA9IHNlbGVjdGlvbi5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWxpbmUnKTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgbGluZVxuICAgICAgICBsZXQgbGluZTtcbiAgICAgICAgY29uc3QgeF9zY2FsZSA9IHBhbmVsWyd4X3NjYWxlJ107XG4gICAgICAgIGNvbnN0IHlfc2NhbGUgPSBwYW5lbFtgeSR7dGhpcy5sYXlvdXQueV9heGlzLmF4aXN9X3NjYWxlYF07XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5zdHlsZS5maWxsICYmIHRoaXMubGF5b3V0LnN0eWxlLmZpbGwgIT09ICdub25lJykge1xuICAgICAgICAgICAgLy8gRmlsbGVkIGN1cnZlOiBkZWZpbmUgdGhlIGxpbmUgYXMgYSBmaWxsZWQgYm91bmRhcnlcbiAgICAgICAgICAgIGxpbmUgPSBkMy5hcmVhKClcbiAgICAgICAgICAgICAgICAueCgoZCkgPT4gK3hfc2NhbGUoZFt4X2ZpZWxkXSkpXG4gICAgICAgICAgICAgICAgLnkwKCt5X3NjYWxlKDApKVxuICAgICAgICAgICAgICAgIC55MSgoZCkgPT4gK3lfc2NhbGUoZFt5X2ZpZWxkXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQmFzaWMgbGluZVxuICAgICAgICAgICAgbGluZSA9IGQzLmxpbmUoKVxuICAgICAgICAgICAgICAgIC54KChkKSA9PiAreF9zY2FsZShkW3hfZmllbGRdKSlcbiAgICAgICAgICAgICAgICAueSgoZCkgPT4gK3lfc2NhbGUoZFt5X2ZpZWxkXSkpXG4gICAgICAgICAgICAgICAgLmN1cnZlKGQzW3RoaXMubGF5b3V0LmludGVycG9sYXRlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBsaW5lIGFuZCBzdHlsZVxuICAgICAgICBzZWxlY3Rpb24ubWVyZ2UodGhpcy5wYXRoKVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBsaW5lKVxuICAgICAgICAgICAgLmNhbGwoYXBwbHlTdHlsZXMsIHRoaXMubGF5b3V0LnN0eWxlKTtcblxuICAgICAgICAvLyBSZW1vdmUgb2xkIGVsZW1lbnRzIGFzIG5lZWRlZFxuICAgICAgICBzZWxlY3Rpb24uZXhpdCgpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRlZmluZSBzZXRFbGVtZW50U3RhdHVzIGZhbWlseSBvZiBtZXRob2RzIGFzIGxpbmUgZGF0YSBsYXllcnMgd2lsbCBvbmx5IGV2ZXIgaGF2ZSBhIHNpbmdsZSBwYXRoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzIEEgbWVtYmVyIG9mIGBMb2N1c1pvb20uRGF0YUxheWVyLlN0YXR1c2VzLmFkamVjdGl2ZXNgXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0b2dnbGVcbiAgICAgKiBAcmV0dXJucyB7TGluZX1cbiAgICAgKi9cbiAgICBzZXRFbGVtZW50U3RhdHVzKHN0YXR1cywgZWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEFsbEVsZW1lbnRTdGF0dXMoc3RhdHVzLCB0b2dnbGUpO1xuICAgIH1cblxuICAgIHNldEFsbEVsZW1lbnRTdGF0dXMoc3RhdHVzLCB0b2dnbGUpIHtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09ICd1bmRlZmluZWQnIHx8ICFTVEFUVVNFUy5hZGplY3RpdmVzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0dXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF5ZXJfc3RhdGUuc3RhdHVzX2ZsYWdzW3N0YXR1c10gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0b2dnbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0dXMgZmxhZ1xuICAgICAgICB0aGlzLmdsb2JhbF9zdGF0dXNlc1tzdGF0dXNdID0gdG9nZ2xlO1xuXG4gICAgICAgIC8vIEFwcGx5IGNsYXNzIHRvIHBhdGggYmFzZWQgb24gZ2xvYmFsIHN0YXR1cyBmbGFnc1xuICAgICAgICBsZXQgcGF0aF9jbGFzcyA9ICdsei1kYXRhX2xheWVyLWxpbmUnO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmdsb2JhbF9zdGF0dXNlcykuZm9yRWFjaCgoZ2xvYmFsX3N0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsX3N0YXR1c2VzW2dsb2JhbF9zdGF0dXNdKSB7XG4gICAgICAgICAgICAgICAgcGF0aF9jbGFzcyArPSBgIGx6LWRhdGFfbGF5ZXItbGluZS0ke2dsb2JhbF9zdGF0dXN9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGF0aC5hdHRyKCdjbGFzcycsIHBhdGhfY2xhc3MpO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgbGF5b3V0IGNoYW5nZWQgZXZlbnQgaG9va1xuICAgICAgICB0aGlzLnBhcmVudC5lbWl0KCdsYXlvdXRfY2hhbmdlZCcsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRfb3J0aG9nb25hbF9sYXlvdXQgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgJ3N0cm9rZSc6ICcjRDNEM0QzJyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICczcHgnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcxMHB4IDEwcHgnLFxuICAgIH0sXG4gICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICB4X2F4aXM6IHtcbiAgICAgICAgYXhpczogMSxcbiAgICAgICAgZGVjb3VwbGVkOiB0cnVlLFxuICAgIH0sXG4gICAgeV9heGlzOiB7XG4gICAgICAgIGF4aXM6IDEsXG4gICAgICAgIGRlY291cGxlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHRvb2x0aXBfcG9zaXRpb25pbmc6ICd2ZXJ0aWNhbCcsXG4gICAgb2Zmc2V0OiAwLFxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgT3J0aG9nb25hbCBMaW5lIERhdGEgTGF5ZXJcbiAqICBJbXBsZW1lbnRzIGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBsaW5lIGdpdmVuIGFuIG9yaWVudGF0aW9uIGFuZCBhbiBvZmZzZXQgaW4gdGhlIGxheW91dFxuICogIERvZXMgbm90IHJlcXVpcmUgYSBkYXRhIHNvdXJjZVxuKi9cbmNsYXNzIE9ydGhvZ29uYWxMaW5lIGV4dGVuZHMgQmFzZURhdGFMYXllciB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIGxheW91dCA9IG1lcmdlKGxheW91dCwgZGVmYXVsdF9vcnRob2dvbmFsX2xheW91dCk7XG4gICAgICAgIC8vIFJlcXVpcmUgdGhhdCBvcmllbnRhdGlvbiBiZSBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIgb25seVxuICAgICAgICBpZiAoIVsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLmluY2x1ZGVzKGxheW91dC5vcmllbnRhdGlvbikpIHtcbiAgICAgICAgICAgIGxheW91dC5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgfVxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIFZhcnMgZm9yIHN0b3JpbmcgdGhlIGRhdGEgZ2VuZXJhdGVkIGxpbmVcbiAgICAgICAgLyoqIEBtZW1iZXIge0FycmF5fSAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50SWQoZWxlbWVudCkge1xuICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSBsaW5lIHBlciBkYXRhbGF5ZXIsIHNvIHRoaXMgaXMgc3VmZmljaWVudC5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzZUlkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRoZSBtYWluIHJlbmRlciBmdW5jdGlvblxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcblxuICAgICAgICAvLyBTZXZlcmFsIHZhcnMgbmVlZGVkIHRvIGJlIGluIHNjb3BlXG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IHhfc2NhbGUgPSAneF9zY2FsZSc7XG4gICAgICAgIGNvbnN0IHlfc2NhbGUgPSBgeSR7dGhpcy5sYXlvdXQueV9heGlzLmF4aXN9X3NjYWxlYDtcbiAgICAgICAgY29uc3QgeF9leHRlbnQgPSAneF9leHRlbnQnO1xuICAgICAgICBjb25zdCB5X2V4dGVudCA9IGB5JHt0aGlzLmxheW91dC55X2F4aXMuYXhpc31fZXh0ZW50YDtcbiAgICAgICAgY29uc3QgeF9yYW5nZSA9ICd4X3JhbmdlJztcblxuICAgICAgICAvLyBHZW5lcmF0ZSBkYXRhIHVzaW5nIGV4dGVudHMgZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLmxheW91dC5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXG4gICAgICAgICAgICAgICAgeyB4OiBwYW5lbFt4X2V4dGVudF1bMF0sIHk6IHRoaXMubGF5b3V0Lm9mZnNldCB9LFxuICAgICAgICAgICAgICAgIHsgeDogcGFuZWxbeF9leHRlbnRdWzFdLCB5OiB0aGlzLmxheW91dC5vZmZzZXQgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXQub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7IHg6IHRoaXMubGF5b3V0Lm9mZnNldCwgeTogcGFuZWxbeV9leHRlbnRdWzBdIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0aGlzLmxheW91dC5vZmZzZXQsIHk6IHBhbmVsW3lfZXh0ZW50XVsxXSB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHZlcnRpY2FsIGxpbmUgdHlwZS4gTXVzdCBiZSBcInZlcnRpY2FsXCIgb3IgXCJob3Jpem9udGFsXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpvaW4gZGF0YSB0byB0aGUgbGluZSBzZWxlY3Rpb25cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zdmcuZ3JvdXBcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgubHotZGF0YV9sYXllci1saW5lJylcbiAgICAgICAgICAgIC5kYXRhKFt0aGlzLmRhdGFdKTtcblxuICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHZlcnRpY2FsIGxpbmUgbWF5IG92ZXJsYXkgYSB0cmFjayB0aGF0IGhhcyBubyBpbmhlcmVudCB5LXZhbHVlcyAoZXh0ZW50KVxuICAgICAgICAvLyAgV2hlbiB0aGF0IGhhcHBlbnMsIHByb3ZpZGUgYSBkZWZhdWx0IGhlaWdodCBiYXNlZCBvbiB0aGUgY3VycmVudCBwYW5lbCBkaW1lbnNpb25zIChhY2NvdW50aW5nXG4gICAgICAgIC8vICAgICAgZm9yIGFueSByZXNpemluZyB0aGF0IGhhcHBlbmVkIGFmdGVyIHRoZSBwYW5lbCB3YXMgY3JlYXRlZClcbiAgICAgICAgY29uc3QgZGVmYXVsdF95ID0gW3BhbmVsLmxheW91dC5jbGlwYXJlYS5oZWlnaHQsIDBdO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBsaW5lXG4gICAgICAgIGNvbnN0IGxpbmUgPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9ICtwYW5lbFt4X3NjYWxlXShkWyd4J10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05hTih4KSA/IHBhbmVsW3hfcmFuZ2VdW2ldIDogeDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAueSgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSArcGFuZWxbeV9zY2FsZV0oZFsneSddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOYU4oeSkgPyBkZWZhdWx0X3lbaV0gOiB5O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHBhdGggZWxlbWVudCwgYXBwbHkgY2xhc3NcbiAgICAgICAgdGhpcy5wYXRoID0gc2VsZWN0aW9uLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItbGluZScpXG4gICAgICAgICAgICAubWVyZ2Uoc2VsZWN0aW9uKVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBsaW5lKVxuICAgICAgICAgICAgLmNhbGwoYXBwbHlTdHlsZXMsIHRoaXMubGF5b3V0LnN0eWxlKVxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGxheWVyIHRvIHJlc3BvbmQgdG8gbW91c2VvdmVyIGV2ZW50cyBhbmQgc2hvdyBhIHRvb2x0aXAuXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmFwcGx5QmVoYXZpb3JzLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBvbGQgZWxlbWVudHMgYXMgbmVlZGVkXG4gICAgICAgIHNlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBfZ2V0VG9vbHRpcFBvc2l0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGQzLm1vdXNlKHRoaXMuc3ZnLmNvbnRhaW5lci5ub2RlKCkpO1xuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBjb29yZHNbMV07XG4gICAgICAgICAgICByZXR1cm4geyB4X21pbjogeCAtIDEsIHhfbWF4OiB4ICsgMSwgeV9taW46IHkgLSAxLCB5X21heDogeSArIDEgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gT24gcmVkcmF3LCB0aGVyZSB3b24ndCBiZSBhIG1vdXNlIGV2ZW50LCBzbyBza2lwIHRvb2x0aXAgcmVwb3NpdGlvbmluZy5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuZXhwb3J0IHsgTGluZSBhcyBsaW5lLCBPcnRob2dvbmFsTGluZSBhcyBvcnRob2dvbmFsX2xpbmUgfTtcbiIsIi8qKiBAbW9kdWxlICovXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgQmFzZURhdGFMYXllciBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHthcHBseVN0eWxlc30gZnJvbSAnLi4vLi4vaGVscGVycy9jb21tb24nO1xuaW1wb3J0IHtwYXJzZUZpZWxkc30gZnJvbSAnLi4vLi4vaGVscGVycy9kaXNwbGF5JztcbmltcG9ydCB7bWVyZ2UsIG5hbWVUb1N5bWJvbH0gZnJvbSAnLi4vLi4vaGVscGVycy9sYXlvdXRzJztcbmltcG9ydCB7Y29hbGVzY2Vfc2NhdHRlcl9wb2ludHN9IGZyb20gJy4uLy4uL2hlbHBlcnMvcmVuZGVyJztcblxuXG5jb25zdCBkZWZhdWx0X2xheW91dCA9IHtcbiAgICBwb2ludF9zaXplOiA0MCxcbiAgICBwb2ludF9zaGFwZTogJ2NpcmNsZScsXG4gICAgdG9vbHRpcF9wb3NpdGlvbmluZzogJ2hvcml6b250YWwnLFxuICAgIGNvbG9yOiAnIzg4ODg4OCcsXG4gICAgY29hbGVzY2U6IHtcbiAgICAgICAgLy8gT3B0aW9ucyB0byBjb250cm9sIHdoZXRoZXIgYW5kIGhvdyB0byBjb21iaW5lIGFkamFjZW50IGluc2lnbmlmaWNhbnQgKFwid2l0aGluIHJlZ2lvbiBvZiBpbnRlcmVzdFwiKSBwb2ludHNcbiAgICAgICAgLy8gIHRvIGltcHJvdmUgcmVuZGVyaW5nIHBlcmZvcm1hbmNlP1xuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBtYXhfcG9pbnRzOiA4MDAsIC8vIE1hbnkgcGxvdHMgYXJlIDgwMC0yNDAwIHB4IHdpZGUsIHNvLCBtb3JlIHRoYW4gMSBkYXR1bSBwZXIgcGl4ZWwgb2YgYXZlcmFnZSByZWdpb24gd2lkdGhcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBcInJlZ2lvbiBvZiBpbnRlcmVzdFwiLCBsaWtlIFwiYm90dG9tIGhhbGYgb2YgcGxvdFwiOyBhbnkgcG9pbnRzIG91dHNpZGUgdGhpcyByZWdpb24gYXJlIHRha2VuIGFzIGlzXG4gICAgICAgIC8vICAgVmFsdWVzIGFyZSBleHByZXNzZWQgaW4gdGVybXMgb2YgZGF0YSB2YWx1ZSBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gcGl4ZWxzIGludGVybmFsbHkuXG4gICAgICAgIHhfbWluOiAnLUluZmluaXR5JywgIC8vIEpTT04gZG9lc24ndCBoYW5kbGUgc29tZSB2YWxpZCBKUyBudW1iZXJzLiBLaWRzLCBkb24ndCBnZXQgYSBjYXJlZXIgaW4gY29tcHV0ZXJzLlxuICAgICAgICB4X21heDogJ0luZmluaXR5JyxcbiAgICAgICAgeV9taW46IDAsXG4gICAgICAgIHlfbWF4OiAzLjAsXG4gICAgICAgIC8vIEV4cHJlc3NlZCBpbiB1bml0cyBvZiBweCBhcGFydC4gRm9yIGNpcmNsZXMsIGFyZWEgNDAgPSByYWRpdXMgfjMuNTsgYWltIGZvciB+MSBkaWFtZXRlciBkaXN0YW5jZS5cbiAgICAgICAgeF9nYXA6IDcsXG4gICAgICAgIHlfZ2FwOiA3LFxuICAgIH0sXG4gICAgZmlsbF9vcGFjaXR5OiAxLFxuICAgIHlfYXhpczoge1xuICAgICAgICBheGlzOiAxLFxuICAgIH0sXG4gICAgaWRfZmllbGQ6ICdpZCcsXG59O1xuLyoqXG4gKiBTY2F0dGVyIERhdGEgTGF5ZXJcbiAqIEltcGxlbWVudHMgYSBzdGFuZGFyZCBzY2F0dGVyIHBsb3RcbiAqL1xuY2xhc3MgU2NhdHRlciBleHRlbmRzIEJhc2VEYXRhTGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICBsYXlvdXQgPSBtZXJnZShsYXlvdXQsIGRlZmF1bHRfbGF5b3V0KTtcblxuICAgICAgICAvLyBFeHRyYSBkZWZhdWx0IGZvciBsYXlvdXQgc3BhY2luZ1xuICAgICAgICAvLyBOb3QgaW4gZGVmYXVsdCBsYXlvdXQgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBsYWJlbCBhdHRyaWJ1dGUgYWx3YXlzIHByZXNlbnRcbiAgICAgICAgaWYgKGxheW91dC5sYWJlbCAmJiBpc05hTihsYXlvdXQubGFiZWwuc3BhY2luZykpIHtcbiAgICAgICAgICAgIGxheW91dC5sYWJlbC5zcGFjaW5nID0gNDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIEltcGxlbWVudCB0b29sdGlwIHBvc2l0aW9uIHRvIGJlIGxheWVyLXNwZWNpZmljXG4gICAgX2dldFRvb2x0aXBQb3NpdGlvbih0b29sdGlwKSB7XG4gICAgICAgIGNvbnN0IHhfY2VudGVyID0gdGhpcy5wYXJlbnQueF9zY2FsZSh0b29sdGlwLmRhdGFbdGhpcy5sYXlvdXQueF9heGlzLmZpZWxkXSk7XG4gICAgICAgIGNvbnN0IHlfc2NhbGUgPSBgeSR7dGhpcy5sYXlvdXQueV9heGlzLmF4aXN9X3NjYWxlYDtcbiAgICAgICAgY29uc3QgeV9jZW50ZXIgPSB0aGlzLnBhcmVudFt5X3NjYWxlXSh0b29sdGlwLmRhdGFbdGhpcy5sYXlvdXQueV9heGlzLmZpZWxkXSk7XG4gICAgICAgIGNvbnN0IHBvaW50X3NpemUgPSB0aGlzLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcih0aGlzLmxheW91dC5wb2ludF9zaXplLCB0b29sdGlwLmRhdGEpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLnNxcnQocG9pbnRfc2l6ZSAvIE1hdGguUEkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4X21pbjogeF9jZW50ZXIgLSBvZmZzZXQsIHhfbWF4OiB4X2NlbnRlciArIG9mZnNldCxcbiAgICAgICAgICAgIHlfbWluOiB5X2NlbnRlciAtIG9mZnNldCwgeV9tYXg6IHlfY2VudGVyICsgb2Zmc2V0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uIHRvIGZsaXAgbGFiZWxzIGZyb20gYmVpbmcgYW5jaG9yZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IHRvIHRoZSBlbmRcbiAgICAvLyBCb3RoIHRvIGtlZXAgbGFiZWxzIGZyb20gcnVubmluZyBvdXRzaWRlIHRoZSBkYXRhIGxheWVyIGFuZCAgYWxzbyBhcyBhIGZpcnN0XG4gICAgLy8gcGFzcyBvbiByZWN1cnNpdmUgc2VwYXJhdGlvblxuICAgIGZsaXBfbGFiZWxzKCkge1xuICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gdGhpcztcbiAgICAgICAgLy8gQmFzZSBwb3NpdGlvbnMgb24gdGhlIGRlZmF1bHQgcG9pbnQgc2l6ZSAod2hpY2ggaXMgd2hhdCByZXNvbHZlIHNjYWxhYmxlIHBhcmFtIHJldHVybnMgaWYgbm8gZGF0YSBwcm92aWRlZClcbiAgICAgICAgY29uc3QgcG9pbnRfc2l6ZSA9IGRhdGFfbGF5ZXIucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKGRhdGFfbGF5ZXIubGF5b3V0LnBvaW50X3NpemUsIHt9KTtcbiAgICAgICAgY29uc3Qgc3BhY2luZyA9IGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsLnNwYWNpbmc7XG4gICAgICAgIGNvbnN0IGhhbmRsZV9saW5lcyA9IEJvb2xlYW4oZGF0YV9sYXllci5sYXlvdXQubGFiZWwubGluZXMpO1xuICAgICAgICBjb25zdCBtaW5feCA9IDIgKiBzcGFjaW5nO1xuICAgICAgICBjb25zdCBtYXhfeCA9IHRoaXMucGFyZW50LmxheW91dC53aWR0aCAtIHRoaXMucGFyZW50LmxheW91dC5tYXJnaW4ubGVmdCAtIHRoaXMucGFyZW50LmxheW91dC5tYXJnaW4ucmlnaHQgLSAoMiAqIHNwYWNpbmcpO1xuXG4gICAgICAgIGNvbnN0IGZsaXAgPSAoZG4sIGRubCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG54ID0gK2RuLmF0dHIoJ3gnKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRfc3dpbmcgPSAoMiAqIHNwYWNpbmcpICsgKDIgKiBNYXRoLnNxcnQocG9pbnRfc2l6ZSkpO1xuICAgICAgICAgICAgbGV0IGRubHgyO1xuICAgICAgICAgICAgbGV0IGxpbmVfc3dpbmc7XG4gICAgICAgICAgICBpZiAoaGFuZGxlX2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgZG5seDIgPSArZG5sLmF0dHIoJ3gyJyk7XG4gICAgICAgICAgICAgICAgbGluZV9zd2luZyA9IHNwYWNpbmcgKyAoMiAqIE1hdGguc3FydChwb2ludF9zaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG4uc3R5bGUoJ3RleHQtYW5jaG9yJykgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBkbi5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgZG4uYXR0cigneCcsIGRueCAtIHRleHRfc3dpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVfbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG5sLmF0dHIoJ3gyJywgZG5seDIgLSBsaW5lX3N3aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRuLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGRuLmF0dHIoJ3gnLCBkbnggKyB0ZXh0X3N3aW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlX2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRubC5hdHRyKCd4MicsIGRubHgyICsgbGluZV9zd2luZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBGbGlwIGFueSBnb2luZyBvdmVyIHRoZSByaWdodCBlZGdlIGZyb20gdGhlIHJpZ2h0IHNpZGUgdG8gdGhlIGxlZnQgc2lkZVxuICAgICAgICAvLyAoYWxsIGxhYmVscyBzdGFydCBvbiB0aGUgcmlnaHQgc2lkZSlcbiAgICAgICAgZGF0YV9sYXllci5sYWJlbF90ZXh0cy5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGRhID0gZDMuc2VsZWN0KGEpO1xuICAgICAgICAgICAgY29uc3QgZGF4ID0gK2RhLmF0dHIoJ3gnKTtcbiAgICAgICAgICAgIGNvbnN0IGFib3VuZCA9IGRhLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChkYXggKyBhYm91bmQud2lkdGggKyBzcGFjaW5nID4gbWF4X3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYWwgPSBoYW5kbGVfbGluZXMgPyBkMy5zZWxlY3QoZGF0YV9sYXllci5sYWJlbF9saW5lcy5ub2RlcygpW2ldKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZmxpcChkYSwgZGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNlY29uZCBwYXNzIHRvIGZsaXAgYW55IG90aGVycyB0aGF0IGhhdmVuJ3QgZmxpcHBlZCB5ZXQgaWYgdGhleSBjb2xsaWRlIHdpdGggYW5vdGhlciBsYWJlbFxuICAgICAgICBkYXRhX2xheWVyLmxhYmVsX3RleHRzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZGEgPSBkMy5zZWxlY3QoYSk7XG4gICAgICAgICAgICBpZiAoZGEuc3R5bGUoJ3RleHQtYW5jaG9yJykgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRheCA9ICtkYS5hdHRyKCd4Jyk7XG4gICAgICAgICAgICBjb25zdCBhYm91bmQgPSBkYS5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBkYWwgPSBoYW5kbGVfbGluZXMgPyBkMy5zZWxlY3QoZGF0YV9sYXllci5sYWJlbF9saW5lcy5ub2RlcygpW2ldKSA6IG51bGw7XG4gICAgICAgICAgICBkYXRhX2xheWVyLmxhYmVsX3RleHRzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gZDMuc2VsZWN0KGIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJib3VuZCA9IGRiLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBhYm91bmQubGVmdCA8IGJib3VuZC5sZWZ0ICsgYmJvdW5kLndpZHRoICsgKDIgKiBzcGFjaW5nKSAmJlxuICAgICAgICAgICAgICAgICAgICBhYm91bmQubGVmdCArIGFib3VuZC53aWR0aCArICgyICogc3BhY2luZykgPiBiYm91bmQubGVmdCAmJlxuICAgICAgICAgICAgICAgICAgICBhYm91bmQudG9wIDwgYmJvdW5kLnRvcCArIGJib3VuZC5oZWlnaHQgKyAoMiAqIHNwYWNpbmcpICYmXG4gICAgICAgICAgICAgICAgICAgIGFib3VuZC5oZWlnaHQgKyBhYm91bmQudG9wICsgKDIgKiBzcGFjaW5nKSA+IGJib3VuZC50b3A7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBmbGlwKGRhLCBkYWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCB0aGlzIGZsaXAgZGlkbid0IHB1c2ggdGhlIGxhYmVsIHBhc3QgbWluX3guIElmIGl0IGRpZCwgaW1tZWRpYXRlbHkgZmxpcCBiYWNrLlxuICAgICAgICAgICAgICAgICAgICBkYXggPSArZGEuYXR0cigneCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF4IC0gYWJvdW5kLndpZHRoIC0gc3BhY2luZyA8IG1pbl94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGlwKGRhLCBkYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0byBzcGFjZSBsYWJlbHMgYXBhcnQgaW1tZWRpYXRlbHkgYWZ0ZXIgaW5pdGlhbCByZW5kZXJcbiAgICAvLyBBZGFwdGVkIGZyb20gdGh1ZGZhY3RvcidzIGZpZGRsZSBoZXJlOiBodHRwczovL2pzZmlkZGxlLm5ldC90aHVkZmFjdG9yL0hkd1RIL1xuICAgIC8vIFRPRE86IE1ha2UgbGFiZWxzIGFsc28gYXdhcmUgb2YgZGF0YSBlbGVtZW50c1xuICAgIHNlcGFyYXRlX2xhYmVscygpIHtcbiAgICAgICAgdGhpcy5zZXBlcmF0ZV9pdGVyYXRpb25zKys7XG4gICAgICAgIGNvbnN0IGRhdGFfbGF5ZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBhbHBoYSA9IDAuNTtcbiAgICAgICAgaWYgKCF0aGlzLmxheW91dC5sYWJlbCkge1xuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBsYXlvdXQgY2hhbmdpbmcgaW4gdGhlIG1pZHN0IG9mIGl0ZXJhdGl2ZSByZXJlbmRlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmxheW91dC5sYWJlbC5zcGFjaW5nO1xuICAgICAgICBsZXQgYWdhaW4gPSBmYWxzZTtcbiAgICAgICAgZGF0YV9sYXllci5sYWJlbF90ZXh0cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE8objIpIGFsZ29yaXRobTsgcmV2aXNpdCBwZXJmb3JtYW5jZT9cbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZGEgPSBkMy5zZWxlY3QoYSk7XG4gICAgICAgICAgICBjb25zdCB5MSA9IGRhLmF0dHIoJ3knKTtcbiAgICAgICAgICAgIGRhdGFfbGF5ZXIubGFiZWxfdGV4dHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgLy8gYSAmIGIgYXJlIHRoZSBzYW1lIGVsZW1lbnQgYW5kIGRvbid0IGNvbGxpZGUuXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYiA9IGQzLnNlbGVjdChiKTtcbiAgICAgICAgICAgICAgICAvLyBhICYgYiBhcmUgb24gb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGNoYXJ0IGFuZFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNvbGxpZGVcbiAgICAgICAgICAgICAgICBpZiAoZGEuYXR0cigndGV4dC1hbmNob3InKSAhPT0gZGIuYXR0cigndGV4dC1hbmNob3InKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgIGJvdW5kaW5nIHJlY3RzIGZvciB0aGUgdHdvIHRleHQgZWxlbWVudHMgY29sbGlkZVxuICAgICAgICAgICAgICAgIGNvbnN0IGFib3VuZCA9IGRhLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYm91bmQgPSBkYi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uID0gYWJvdW5kLmxlZnQgPCBiYm91bmQubGVmdCArIGJib3VuZC53aWR0aCArICgyICogc3BhY2luZykgJiZcbiAgICAgICAgICAgICAgICAgICAgYWJvdW5kLmxlZnQgKyBhYm91bmQud2lkdGggKyAoMiAqIHNwYWNpbmcpID4gYmJvdW5kLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYWJvdW5kLnRvcCA8IGJib3VuZC50b3AgKyBiYm91bmQuaGVpZ2h0ICsgKDIgKiBzcGFjaW5nKSAmJlxuICAgICAgICAgICAgICAgICAgICBhYm91bmQuaGVpZ2h0ICsgYWJvdW5kLnRvcCArICgyICogc3BhY2luZykgPiBiYm91bmQudG9wO1xuICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYWJlbHMgY29sbGlkZSwgd2UnbGwgcHVzaCBlYWNoXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHR3byBsYWJlbHMgdXAgYW5kIGRvd24gYSBsaXR0bGUgYml0LlxuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gZGIuYXR0cigneScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ24gPSBhYm91bmQudG9wIDwgYmJvdW5kLnRvcCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3QgPSBzaWduICogYWxwaGE7XG4gICAgICAgICAgICAgICAgbGV0IG5ld19hX3kgPSAreTEgLSBhZGp1c3Q7XG4gICAgICAgICAgICAgICAgbGV0IG5ld19iX3kgPSAreTIgKyBhZGp1c3Q7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBuZXcgdmFsdWVzIGZyb20gZXh0ZW5kaW5nIG91dHNpZGUgdGhlIGRhdGEgbGF5ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5feSA9IDIgKiBzcGFjaW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heF95ID0gZGF0YV9sYXllci5wYXJlbnQubGF5b3V0LmhlaWdodCAtIGRhdGFfbGF5ZXIucGFyZW50LmxheW91dC5tYXJnaW4udG9wIC0gZGF0YV9sYXllci5wYXJlbnQubGF5b3V0Lm1hcmdpbi5ib3R0b20gLSAoMiAqIHNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIGxldCBkZWx0YTtcbiAgICAgICAgICAgICAgICBpZiAobmV3X2FfeSAtIChhYm91bmQuaGVpZ2h0IC8gMikgPCBtaW5feSkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9ICt5MSAtIG5ld19hX3k7XG4gICAgICAgICAgICAgICAgICAgIG5ld19hX3kgPSAreTE7XG4gICAgICAgICAgICAgICAgICAgIG5ld19iX3kgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdfYl95IC0gKGJib3VuZC5oZWlnaHQgLyAyKSA8IG1pbl95KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gK3kyIC0gbmV3X2JfeTtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2JfeSA9ICt5MjtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2FfeSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld19hX3kgKyAoYWJvdW5kLmhlaWdodCAvIDIpID4gbWF4X3kpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBuZXdfYV95IC0gK3kxO1xuICAgICAgICAgICAgICAgICAgICBuZXdfYV95ID0gK3kxO1xuICAgICAgICAgICAgICAgICAgICBuZXdfYl95IC09IGRlbHRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3X2JfeSArIChiYm91bmQuaGVpZ2h0IC8gMikgPiBtYXhfeSkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IG5ld19iX3kgLSAreTI7XG4gICAgICAgICAgICAgICAgICAgIG5ld19iX3kgPSAreTI7XG4gICAgICAgICAgICAgICAgICAgIG5ld19hX3kgLT0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhLmF0dHIoJ3knLCBuZXdfYV95KTtcbiAgICAgICAgICAgICAgICBkYi5hdHRyKCd5JywgbmV3X2JfeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZ2Fpbikge1xuICAgICAgICAgICAgLy8gQWRqdXN0IGxpbmVzIHRvIGZvbGxvdyB0aGUgbGFiZWxzXG4gICAgICAgICAgICBpZiAoZGF0YV9sYXllci5sYXlvdXQubGFiZWwubGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbF9lbGVtZW50cyA9IGRhdGFfbGF5ZXIubGFiZWxfdGV4dHMubm9kZXMoKTtcbiAgICAgICAgICAgICAgICBkYXRhX2xheWVyLmxhYmVsX2xpbmVzLmF0dHIoJ3kyJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxfbGluZSA9IGQzLnNlbGVjdChsYWJlbF9lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbF9saW5lLmF0dHIoJ3knKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFmdGVyIH4xNTAgaXRlcmF0aW9ucyB3ZSdyZSBwcm9iYWJseSBiZXlvbmQgZGltaW5pc2luZyByZXR1cm5zLCBzbyBzdG9wIHJlY3Vyc2luZ1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VwZXJhdGVfaXRlcmF0aW9ucyA8IDE1MCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcGFyYXRlX2xhYmVscygpO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW1wbGVtZW50IHRoZSBtYWluIHJlbmRlciBmdW5jdGlvblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgZGF0YV9sYXllciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHhfc2NhbGUgPSB0aGlzLnBhcmVudFsneF9zY2FsZSddO1xuICAgICAgICBjb25zdCB5X3NjYWxlID0gdGhpcy5wYXJlbnRbYHkke3RoaXMubGF5b3V0LnlfYXhpcy5heGlzfV9zY2FsZWBdO1xuXG4gICAgICAgIGNvbnN0IHhjcyA9IFN5bWJvbC5mb3IoJ2x6WCcpO1xuICAgICAgICBjb25zdCB5Y3MgPSBTeW1ib2wuZm9yKCdselknKTtcblxuICAgICAgICAvLyBBcHBseSBmaWx0ZXJzIHRvIG9ubHkgcmVuZGVyIGEgc3BlY2lmaWVkIHNldCBvZiBwb2ludHNcbiAgICAgICAgbGV0IHRyYWNrX2RhdGEgPSB0aGlzLl9hcHBseUZpbHRlcnMoKTtcblxuICAgICAgICAvLyBBZGQgY29vcmRpbmF0ZXMgYmVmb3JlIHJlbmRlcmluZywgc28gd2UgY2FuIGNvYWxlc2NlXG4gICAgICAgIHRyYWNrX2RhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgbGV0IHggPSB4X3NjYWxlKGl0ZW1bdGhpcy5sYXlvdXQueF9heGlzLmZpZWxkXSk7XG4gICAgICAgICAgICBsZXQgeSA9IHlfc2NhbGUoaXRlbVt0aGlzLmxheW91dC55X2F4aXMuZmllbGRdKTtcbiAgICAgICAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICAgICAgICAgIHggPSAtMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICAgICAgICAgIHkgPSAtMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1beGNzXSA9IHg7XG4gICAgICAgICAgICBpdGVtW3ljc10gPSB5O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5sYXlvdXQuY29hbGVzY2UuYWN0aXZlICYmIHRyYWNrX2RhdGEubGVuZ3RoID4gdGhpcy5sYXlvdXQuY29hbGVzY2UubWF4X3BvaW50cykge1xuICAgICAgICAgICAgbGV0IHsgeF9taW4sIHhfbWF4LCB5X21pbiwgeV9tYXgsIHhfZ2FwLCB5X2dhcCB9ID0gdGhpcy5sYXlvdXQuY29hbGVzY2U7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHggYW5kIHkgXCJzaWduaWZpY2FudCByZWdpb25cIiByYW5nZSBmcm9tIGRhdGEgdmFsdWVzIHRvIHBpeGVsc1xuICAgICAgICAgICAgY29uc3QgeF9taW5fcHggPSBpc0Zpbml0ZSh4X21pbikgPyB4X3NjYWxlKCt4X21pbikgOiAtSW5maW5pdHk7XG4gICAgICAgICAgICBjb25zdCB4X21heF9weCA9IGlzRmluaXRlKHhfbWF4KSA/IHhfc2NhbGUoK3hfbWF4KSA6IEluZmluaXR5O1xuICAgICAgICAgICAgLy8gRm9yIHkgcHgsIHdlIGZsaXAgdGhlIGRhdGEgbWluL21heCBiL2MgaW4gU1ZHIGNvb3JkIHN5c3RlbSAreSBpcyBkb3duOiBzbWFsbGVyIGRhdGEgeSA9IGxhcmdlciBweCB5XG4gICAgICAgICAgICBjb25zdCB5X21pbl9weCA9IGlzRmluaXRlKHlfbWF4KSA/IHlfc2NhbGUoK3lfbWF4KSA6IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGNvbnN0IHlfbWF4X3B4ID0gaXNGaW5pdGUoeV9taW4pID8geV9zY2FsZSgreV9taW4pIDogSW5maW5pdHk7XG4gICAgICAgICAgICB0cmFja19kYXRhID0gY29hbGVzY2Vfc2NhdHRlcl9wb2ludHModHJhY2tfZGF0YSwgeF9taW5fcHgsIHhfbWF4X3B4LCB4X2dhcCwgeV9taW5fcHgsIHlfbWF4X3B4LCB5X2dhcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYXlvdXQubGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbF9kYXRhO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsLmZpbHRlcnMgfHwgW107XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxfZGF0YSA9IHRyYWNrX2RhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmZpbHRlci5iaW5kKHRoaXMsIGZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIGxhYmVsX2RhdGEgPSB0cmFja19kYXRhLmZpbHRlcihmdW5jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVuZGVyIGxhYmVsIGdyb3Vwc1xuICAgICAgICAgICAgdGhpcy5sYWJlbF9ncm91cHMgPSB0aGlzLnN2Zy5ncm91cFxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoYGcubHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9LWxhYmVsYClcbiAgICAgICAgICAgICAgICAuZGF0YShsYWJlbF9kYXRhLCAoZCkgPT4gYCR7ZFt0aGlzLmxheW91dC5pZF9maWVsZF19X2xhYmVsYCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0eWxlX2NsYXNzID0gYGx6LWRhdGFfbGF5ZXItJHt0aGlzLmxheW91dC50eXBlfS1sYWJlbGA7XG4gICAgICAgICAgICBjb25zdCBncm91cHNfZW50ZXIgPSB0aGlzLmxhYmVsX2dyb3Vwcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgc3R5bGVfY2xhc3MpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbF90ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxfdGV4dHMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGFiZWxfdGV4dHMgPSB0aGlzLmxhYmVsX2dyb3Vwcy5tZXJnZShncm91cHNfZW50ZXIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLnRleHQoKGQpID0+IHBhcnNlRmllbGRzKGQsIGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsLnRleHQgfHwgJycpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbeGNzXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBNYXRoLnNxcnQoZGF0YV9sYXllci5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIoZGF0YV9sYXllci5sYXlvdXQucG9pbnRfc2l6ZSwgZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsLnNwYWNpbmc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiBkW3ljc10pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAuY2FsbChhcHBseVN0eWxlcywgZGF0YV9sYXllci5sYXlvdXQubGFiZWwuc3R5bGUgfHwge30pO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgbGFiZWwgbGluZXNcbiAgICAgICAgICAgIGlmIChkYXRhX2xheWVyLmxheW91dC5sYWJlbC5saW5lcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsX2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWxfbGluZXMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxfbGluZXMgPSB0aGlzLmxhYmVsX2dyb3Vwcy5tZXJnZShncm91cHNfZW50ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAoZCkgPT4gZFt4Y3NdKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoZCkgPT4gZFt5Y3NdKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbeGNzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgTWF0aC5zcXJ0KGRhdGFfbGF5ZXIucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKGRhdGFfbGF5ZXIubGF5b3V0LnBvaW50X3NpemUsIGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgKGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsLnNwYWNpbmcgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQpID0+IGRbeWNzXSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXBwbHlTdHlsZXMsIGRhdGFfbGF5ZXIubGF5b3V0LmxhYmVsLmxpbmVzLnN0eWxlIHx8IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBsYWJlbHMgd2hlbiB0aGV5J3JlIG5vIGxvbmdlciBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXRcbiAgICAgICAgICAgIHRoaXMubGFiZWxfZ3JvdXBzLmV4aXQoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXlvdXQgZGVmaW5pdGlvbiBoYXMgY2hhbmdlZCAoJiBubyBsb25nZXIgc3BlY2lmaWVzIGxhYmVscyksIHN0cmlwIGFueSBwcmV2aW91c2x5IHJlbmRlcmVkXG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbF90ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxfdGV4dHMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbF9saW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxfbGluZXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbF9ncm91cHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsX2dyb3Vwcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIG1haW4gc2NhdHRlciBkYXRhIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAuc2VsZWN0QWxsKGBwYXRoLmx6LWRhdGFfbGF5ZXItJHt0aGlzLmxheW91dC50eXBlfWApXG4gICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4gZFt0aGlzLmxheW91dC5pZF9maWVsZF0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBlbGVtZW50cywgYXBwbHkgY2xhc3MsIElELCBhbmQgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICAvLyBHZW5lcmF0ZSBuZXcgdmFsdWVzIChvciBmdW5jdGlvbnMgZm9yIHRoZW0pIGZvciBwb3NpdGlvbiwgY29sb3IsIHNpemUsIGFuZCBzaGFwZVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSAoZCkgPT4gYHRyYW5zbGF0ZSgke2RbeGNzXX0sICR7ZFt5Y3NdfSlgO1xuXG4gICAgICAgIGNvbnN0IHNoYXBlID0gZDMuc3ltYm9sKClcbiAgICAgICAgICAgIC5zaXplKChkLCBpKSA9PiB0aGlzLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcih0aGlzLmxheW91dC5wb2ludF9zaXplLCBkLCBpKSlcbiAgICAgICAgICAgIC50eXBlKChkLCBpKSA9PiBuYW1lVG9TeW1ib2wodGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQucG9pbnRfc2hhcGUsIGQsIGkpKSk7XG5cbiAgICAgICAgY29uc3Qgc3R5bGVfY2xhc3MgPSBgbHotZGF0YV9sYXllci0ke3RoaXMubGF5b3V0LnR5cGV9YDtcbiAgICAgICAgc2VsZWN0aW9uLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgc3R5bGVfY2xhc3MpXG4gICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gdGhpcy5nZXRFbGVtZW50SWQoZCkpXG4gICAgICAgICAgICAubWVyZ2Uoc2VsZWN0aW9uKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSlcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgKGQsIGkpID0+IHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHRoaXMubGF5b3V0LmNvbG9yLCBkLCBpKSlcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAoZCwgaSkgPT4gdGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQuZmlsbF9vcGFjaXR5LCBkLCBpKSlcbiAgICAgICAgICAgIC5hdHRyKCdkJywgc2hhcGUpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBvbGQgZWxlbWVudHMgYXMgbmVlZGVkXG4gICAgICAgIHNlbGVjdGlvbi5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLyBBcHBseSBtZXRob2QgdG8ga2VlcCBsYWJlbHMgZnJvbSBvdmVybGFwcGluZyBlYWNoIG90aGVyXG4gICAgICAgIGlmICh0aGlzLmxheW91dC5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5mbGlwX2xhYmVscygpO1xuICAgICAgICAgICAgdGhpcy5zZXBlcmF0ZV9pdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2VwYXJhdGVfbGFiZWxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBkZWZhdWx0IGV2ZW50IGVtaXR0ZXJzICYgbW91c2UgYmVoYXZpb3JzLiBBcHBseSB0byB0aGUgY29udGFpbmVyLCBub3QgcGVyIGVsZW1lbnQsXG4gICAgICAgIC8vIHRvIHJlZHVjZSBudW1iZXIgb2YgZXZlbnQgbGlzdGVuZXJzLiBUaGVzZSBldmVudHMgd2lsbCBhcHBseSB0byBib3RoIHNjYXR0ZXIgcG9pbnRzIGFuZCBsYWJlbHMuXG4gICAgICAgIHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAub24oJ2NsaWNrLmV2ZW50X2VtaXR0ZXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRDMgZG9lc24ndCBuYXRpdmVseSBzdXBwb3J0IGJ1YmJsaW5nIHZlcnkgd2VsbDsgd2UgbmVlZCB0byBmaW5kIHRoZSBkYXRhIGZvciB0aGUgYnViYmxlZCBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1fZGF0YSA9IGQzLnNlbGVjdChkMy5ldmVudC50YXJnZXQpLmRhdHVtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZW1pdCgnZWxlbWVudF9jbGlja2VkJywgaXRlbV9kYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmFwcGx5QmVoYXZpb3JzLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIE1ldGhvZCB0byBzZXQgYSBwYXNzZWQgZWxlbWVudCBhcyB0aGUgTEQgcmVmZXJlbmNlIGluIHRoZSBwbG90LWxldmVsIHN0YXRlXG4gICAgbWFrZUxEUmVmZXJlbmNlKGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHJlZiA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWtlTERSZWZlcmVuY2UgcmVxdWlyZXMgb25lIGFyZ3VtZW50IG9mIGFueSB0eXBlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5pZF9maWVsZCAmJiB0eXBlb2YgZWxlbWVudFt0aGlzLmxheW91dC5pZF9maWVsZF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBlbGVtZW50W3RoaXMubGF5b3V0LmlkX2ZpZWxkXS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudFsnaWQnXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlZiA9IGVsZW1lbnRbJ2lkJ10udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmID0gZWxlbWVudC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmID0gZWxlbWVudC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50X3Bsb3QuYXBwbHlTdGF0ZSh7IGxkcmVmdmFyOiByZWYgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgc2NhdHRlciBwbG90IGluIHdoaWNoIHRoZSB4LWF4aXMgcmVwcmVzZW50cyBjYXRlZ29yaWVzLCByYXRoZXIgdGhhbiBpbmRpdmlkdWFsIHBvc2l0aW9ucy5cbiAqIEZvciBleGFtcGxlLCB0aGlzIGNhbiBiZSB1c2VkIGJ5IFBoZVdBUyBwbG90cyB0byBzaG93IHJlbGF0ZWQgZ3JvdXBzLiBUaGlzIHBsb3QgYWxsb3dzIHRoZSBjYXRlZ29yaWVzIHRvIGJlXG4gKiAgIGRldGVybWluZWQgZHluYW1pY2FsbHkgd2hlbiBkYXRhIGlzIGZpcnN0IGxvYWRlZC5cbiAqXG4gKi9cbmNsYXNzIENhdGVnb3J5U2NhdHRlciBleHRlbmRzIFNjYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGNhdGVnb3J5IG5hbWVzIGFuZCBleHRlbnRzIChib3VuZGFyaWVzKSBmb3IgcGxvdHRpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdC48U3RyaW5nLCBOdW1iZXJbXT59IENhdGVnb3J5IG5hbWVzIGFuZCBleHRlbnRzLCBpbiB0aGUgZm9ybSB7Y2F0ZWdvcnlfbmFtZTogW21pbl94LCBtYXhfeF19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYXRlZ29yaWVzID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBwbG90IGxheWVyIG1ha2VzIGNlcnRhaW4gYXNzdW1wdGlvbnMgYWJvdXQgdGhlIGRhdGEgcGFzc2VkIGluLiBUcmFuc2Zvcm0gdGhlIHJhdyBhcnJheSBvZiByZWNvcmRzIGZyb21cbiAgICAgKiAgIHRoZSBkYXRhc291cmNlIHRvIHByZXBhcmUgaXQgZm9yIHBsb3R0aW5nLCBhcyBmb2xsb3dzOlxuICAgICAqIDEuIFRoZSBzY2F0dGVyIHBsb3QgYXNzdW1lcyB0aGF0IGFsbCByZWNvcmRzIGFyZSBnaXZlbiBpbiBzZXF1ZW5jZSAocHJlLWdyb3VwZWQgYnkgYGNhdGVnb3J5X2ZpZWxkYClcbiAgICAgKiAyLiBJdCBhc3N1bWVzIHRoYXQgYWxsIHJlY29yZHMgaGF2ZSBhbiB4IGNvb3JkaW5hdGUgZm9yIGluZGl2aWR1YWwgcGxvdHRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcmVwYXJlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgeEZpZWxkID0gdGhpcy5sYXlvdXQueF9heGlzLmZpZWxkIHx8ICd4JztcbiAgICAgICAgLy8gVGhlIChuYW1lc3BhY2VkKSBmaWVsZCBmcm9tIGB0aGlzLmRhdGFgIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFzc2lnbiBkYXRhcG9pbnRzIHRvIGEgZ2l2ZW4gY2F0ZWdvcnkgJiBjb2xvclxuICAgICAgICBjb25zdCBjYXRlZ29yeV9maWVsZCA9IHRoaXMubGF5b3V0LnhfYXhpcy5jYXRlZ29yeV9maWVsZDtcbiAgICAgICAgaWYgKCFjYXRlZ29yeV9maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXlvdXQgZm9yICR7dGhpcy5sYXlvdXQuaWR9IG11c3Qgc3BlY2lmeSBjYXRlZ29yeV9maWVsZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgdGhlIGRhdGEgc28gdGhhdCB0aGluZ3MgaW4gdGhlIHNhbWUgY2F0ZWdvcnkgYXJlIGFkamFjZW50IChjYXNlLWluc2Vuc2l0aXZlIGJ5IHNwZWNpZmllZCBmaWVsZClcbiAgICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuZGF0YVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhayA9IGFbY2F0ZWdvcnlfZmllbGRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJrID0gYltjYXRlZ29yeV9maWVsZF07XG4gICAgICAgICAgICAgICAgY29uc3QgYXYgPSAodHlwZW9mIGFrID09PSAnc3RyaW5nJykgPyBhay50b0xvd2VyQ2FzZSgpIDogYWs7XG4gICAgICAgICAgICAgICAgY29uc3QgYnYgPSAodHlwZW9mIGJrID09PSAnc3RyaW5nJykgPyBiay50b0xvd2VyQ2FzZSgpIDogYms7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhdiA9PT0gYnYpID8gMCA6IChhdiA8IGJ2ID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBzb3VyY2VEYXRhLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgIC8vIEltcGxlbWVudGF0aW9uIGRldGFpbDogU2NhdHRlciBwbG90IHJlcXVpcmVzIHNwZWNpZnlpbmcgYW4geC1heGlzIHZhbHVlLCBhbmQgbW9zdCBkYXRhc291cmNlcyBkbyBub3RcbiAgICAgICAgICAgIC8vICAgc3BlY2lmeSBwbG90dGluZyBwb3NpdGlvbnMuIElmIGEgcG9pbnQgaXMgbWlzc2luZyB0aGlzIGZpZWxkLCBmaWxsIGluIGEgc3ludGhldGljIHZhbHVlLlxuICAgICAgICAgICAgZFt4RmllbGRdID0gZFt4RmllbGRdIHx8IGk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc291cmNlRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSB0aGUgdW5pcXVlIGNhdGVnb3JpZXMgb24gdGhlIHBsb3QsIGFuZCB1cGRhdGUgdGhlIGxheW91dCB3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbG9yIHNjaGVtZS5cbiAgICAgKiBBbHNvIGlkZW50aWZ5IHRoZSBtaW4gYW5kIG1heCB4IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2F0ZWdvcnksIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aWNrc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge09iamVjdC48U3RyaW5nLCBOdW1iZXJbXT59IFNlcmllcyBvZiBlbnRyaWVzIHVzZWQgdG8gYnVpbGQgY2F0ZWdvcnkgbmFtZSB0aWNrcyB7Y2F0ZWdvcnlfbmFtZTogW21pbl94LCBtYXhfeF19XG4gICAgICovXG4gICAgX2dlbmVyYXRlQ2F0ZWdvcnlCb3VuZHMoKSB7XG4gICAgICAgIC8vIFRPRE86IEFQSSBtYXkgcmV0dXJuIG51bGwgdmFsdWVzIGluIGNhdGVnb3J5X2ZpZWxkOyBzaG91bGQgd2UgYWRkIHBsYWNlaG9sZGVyIGNhdGVnb3J5IGxhYmVsP1xuICAgICAgICAvLyBUaGUgKG5hbWVzcGFjZWQpIGZpZWxkIGZyb20gYHRoaXMuZGF0YWAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXNzaWduIGRhdGFwb2ludHMgdG8gYSBnaXZlbiBjYXRlZ29yeSAmIGNvbG9yXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5X2ZpZWxkID0gdGhpcy5sYXlvdXQueF9heGlzLmNhdGVnb3J5X2ZpZWxkO1xuICAgICAgICBjb25zdCB4RmllbGQgPSB0aGlzLmxheW91dC54X2F4aXMuZmllbGQgfHwgJ3gnO1xuICAgICAgICBjb25zdCB1bmlxdWVDYXRlZ29yaWVzID0ge307XG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGl0ZW1bY2F0ZWdvcnlfZmllbGRdO1xuICAgICAgICAgICAgY29uc3QgeCA9IGl0ZW1beEZpZWxkXTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHVuaXF1ZUNhdGVnb3JpZXNbY2F0ZWdvcnldIHx8IFt4LCB4XTtcbiAgICAgICAgICAgIHVuaXF1ZUNhdGVnb3JpZXNbY2F0ZWdvcnldID0gW01hdGgubWluKGJvdW5kc1swXSwgeCksIE1hdGgubWF4KGJvdW5kc1sxXSwgeCldO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjYXRlZ29yeU5hbWVzID0gT2JqZWN0LmtleXModW5pcXVlQ2F0ZWdvcmllcyk7XG4gICAgICAgIHRoaXMuX3NldER5bmFtaWNDb2xvclNjaGVtZShjYXRlZ29yeU5hbWVzKTtcblxuICAgICAgICByZXR1cm4gdW5pcXVlQ2F0ZWdvcmllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGxheWVyIHJlbGllcyBvbiBkZWZpbmluZyBpdHMgb3duIGNhdGVnb3J5LWJhc2VkIGNvbG9yIHNjaGVtZS4gRmluZCB0aGUgY29ycmVjdCBjb2xvciBjb25maWcgb2JqZWN0IHRvXG4gICAgICogIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSBbZnJvbV9zb3VyY2VdXG4gICAgICogQHJldHVybnMge09iamVjdH0gQSBtdXRhYmxlIHJlZmVyZW5jZSB0byB0aGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29sb3JTY2FsZShmcm9tX3NvdXJjZSkge1xuICAgICAgICBmcm9tX3NvdXJjZSA9IGZyb21fc291cmNlIHx8IHRoaXMubGF5b3V0O1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGRvZXMgbm90IHVzZSBhIHN1cHBvcnRlZCBjb2xvcmluZyBzY2hlbWUsIG9yIGlzIGFscmVhZHkgY29tcGxldGUsIHRoaXMgbWV0aG9kIHNob3VsZCBkbyBub3RoaW5nXG5cbiAgICAgICAgLy8gRm9yIGxlZ2FjeSByZWFzb25zLCBsYXlvdXRzIGNhbiBzcGVjaWZ5IGNvbG9yIGFzIGFuIG9iamVjdCAob25seSBvbmUgd2F5IHRvIHNldCBjb2xvciksIGFzIG9wcG9zZWQgdG8gdGhlXG4gICAgICAgIC8vICBwcmVmZXJyZWQgbWVjaGFuaXNtIG9mIGFycmF5IChtdWx0aXBsZSBjb2xvcmluZyBvcHRpb25zKVxuICAgICAgICBsZXQgY29sb3JfcGFyYW1zID0gZnJvbV9zb3VyY2UuY29sb3IgfHwgW107IC8vIE9iamVjdCBvciBzY2FsYXIsIG5vIG90aGVyIG9wdGlvbnMgYWxsb3dlZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcl9wYXJhbXMpKSB7XG4gICAgICAgICAgICBjb2xvcl9wYXJhbXMgPSBjb2xvcl9wYXJhbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5zY2FsZV9mdW5jdGlvbiA9PT0gJ2NhdGVnb3JpY2FsX2JpbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sb3JfcGFyYW1zIHx8IGNvbG9yX3BhcmFtcy5zY2FsZV9mdW5jdGlvbiAhPT0gJ2NhdGVnb3JpY2FsX2JpbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBsYXllciByZXF1aXJlcyB0aGF0IGNvbG9yIG9wdGlvbnMgYmUgcHJvdmlkZWQgYXMgYSBgY2F0ZWdvcmljYWxfYmluYCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcl9wYXJhbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBkZWZpbmUgYSBjb2xvciBzY2hlbWUgZm9yIHRoZSBsYXllciBiYXNlZCBvbiBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiAgIElmIHBhcnQgb2YgdGhlIGNvbG9yIHNjaGVtZSBoYXMgYmVlbiBzcGVjaWZpZWQsIGl0IHdpbGwgZmlsbCBpbiByZW1haW5pbmcgbWlzc2luZyBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0aHJlZSBzY2VuYXJpb3M6XG4gICAgICogMS4gVGhlIGxheW91dCBkb2VzIG5vdCBzcGVjaWZ5IGVpdGhlciBjYXRlZ29yeSBuYW1lcyBvciAoY29sb3IpIHZhbHVlcy4gRHluYW1pY2FsbHkgYnVpbGQgYm90aCBiYXNlZCBvblxuICAgICAqICAgIHRoZSBkYXRhIGFuZCB1cGRhdGUgdGhlIGxheW91dC5cbiAgICAgKiAyLiBUaGUgbGF5b3V0IHNwZWNpZmllcyBjb2xvcnMsIGJ1dCBub3QgY2F0ZWdvcmllcy4gVXNlIHRoYXQgZXhhY3QgY29sb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQsIGFuZCBkeW5hbWljYWxseVxuICAgICAqICAgICBkZXRlcm1pbmUgd2hhdCBjYXRlZ29yaWVzIGFyZSBwcmVzZW50IGluIHRoZSBkYXRhLiAoY3ljbGUgdGhyb3VnaCB0aGUgYXZhaWxhYmxlIGNvbG9ycywgcmV1c2luZyBpZiB0aGVyZVxuICAgICAqICAgICBhcmUgYSBsb3Qgb2YgY2F0ZWdvcmllcylcbiAgICAgKiAzLiBUaGUgbGF5b3V0IHNwZWNpZmllcyBleGFjdGx5IHdoYXQgY29sb3JzIGFuZCBjYXRlZ29yaWVzIHRvIHVzZSAoYW5kIHRoZXkgbWF0Y2ggdGhlIGRhdGEhKS4gVGhpcyBpcyB1c2VmdWwgdG9cbiAgICAgKiAgICBzcGVjaWZ5IGFuIGV4cGxpY2l0IG1hcHBpbmcgYmV0d2VlbiBjb2xvciBzY2hlbWUgYW5kIGNhdGVnb3J5IG5hbWVzLCB3aGVuIHlvdSB3YW50IHRvIGJlIHN1cmUgdGhhdCB0aGVcbiAgICAgKiAgICBwbG90IG1hdGNoZXMgYSBzdGFuZGFyZCBjb2xvciBzY2hlbWUuXG4gICAgICogICAgKElmIHRoZSBsYXlvdXQgc3BlY2lmaWVzIGNhdGVnb3JpZXMgdGhhdCBkbyBub3QgbWF0Y2ggdGhlIGRhdGEsIHRoZSB1c2VyIHNwZWNpZmllZCBjYXRlZ29yaWVzIHdpbGwgYmUgaWdub3JlZClcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgb25seSBhY3QgaWYgdGhlIGxheW91dCBkZWZpbmVzIGEgYGNhdGVnb3JpY2FsX2JpbmAgc2NhbGUgZnVuY3Rpb24gZm9yIGNvbG9yaW5nLiBJdCBtYXkgYmVcbiAgICAgKiAgIG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0byBzdWl0IG90aGVyIHR5cGVzIG9mIGNvbG9yaW5nIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjYXRlZ29yeU5hbWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RHluYW1pY0NvbG9yU2NoZW1lKGNhdGVnb3J5TmFtZXMpIHtcbiAgICAgICAgY29uc3QgY29sb3JQYXJhbXMgPSB0aGlzLl9nZXRDb2xvclNjYWxlKHRoaXMubGF5b3V0KS5wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBiYXNlUGFyYW1zID0gdGhpcy5fZ2V0Q29sb3JTY2FsZSh0aGlzLl9iYXNlX2xheW91dCkucGFyYW1ldGVycztcblxuICAgICAgICBpZiAoYmFzZVBhcmFtcy5jYXRlZ29yaWVzLmxlbmd0aCAmJiBiYXNlUGFyYW1zLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBwcmVzZXQgY2F0ZWdvcnkvY29sb3IgY29tYm9zLCBtYWtlIHN1cmUgdGhhdCB0aGV5IGFwcGx5IHRvIHRoZSBhY3R1YWwgZGF0YXNldFxuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyc19jYXRlZ29yaWVzX2hhc2ggPSB7fTtcbiAgICAgICAgICAgIGJhc2VQYXJhbXMuY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfY2F0ZWdvcmllc19oYXNoW2NhdGVnb3J5XSA9IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeU5hbWVzLmV2ZXJ5KChuYW1lKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1ldGVyc19jYXRlZ29yaWVzX2hhc2gsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYXlvdXQgZG9lc24ndCBoYXZlIHRvIHNwZWNpZnkgY2F0ZWdvcmllcyBpbiBvcmRlciwgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZSBhbGwgdGhlcmVcbiAgICAgICAgICAgICAgICBjb2xvclBhcmFtcy5jYXRlZ29yaWVzID0gYmFzZVBhcmFtcy5jYXRlZ29yaWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvclBhcmFtcy5jYXRlZ29yaWVzID0gY2F0ZWdvcnlOYW1lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbG9yUGFyYW1zLmNhdGVnb3JpZXMgPSBjYXRlZ29yeU5hbWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZlciB1c2VyLXNwZWNpZmllZCBjb2xvcnMgaWYgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBlbm91Z2ggY29sb3JzIGZvciBhbGwgdGhlIGNhdGVnb3JpZXMuXG4gICAgICAgIGxldCBjb2xvcnM7XG4gICAgICAgIGlmIChiYXNlUGFyYW1zLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbG9ycyA9IGJhc2VQYXJhbXMudmFsdWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWxseSBmcm9tIGQzdjMgY2F0ZWdvcnkyMFxuICAgICAgICAgICAgY29sb3JzID0gWycjMWY3N2I0JywgJyNhZWM3ZTgnLCAnI2ZmN2YwZScsICcjZmZiYjc4JywgJyMyY2EwMmMnLCAnIzk4ZGY4YScsICcjZDYyNzI4JywgJyNmZjk4OTYnLCAnIzk0NjdiZCcsICcjYzViMGQ1JywgJyM4YzU2NGInLCAnI2M0OWM5NCcsICcjZTM3N2MyJywgJyNmN2I2ZDInLCAnIzdmN2Y3ZicsICcjYzdjN2M3JywgJyNiY2JkMjInLCAnI2RiZGI4ZCcsICcjMTdiZWNmJywgJyM5ZWRhZTUnXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29sb3JzLmxlbmd0aCA8IGNhdGVnb3J5TmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb2xvcnMgPSBjb2xvcnMuY29uY2F0KGNvbG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDAsIGNhdGVnb3J5TmFtZXMubGVuZ3RoKTsgIC8vIExpc3Qgb2YgaGV4IHZhbHVlcywgc2hvdWxkIGJlIG9mIHNhbWUgbGVuZ3RoIGFzIGNhdGVnb3JpZXMgYXJyYXlcbiAgICAgICAgY29sb3JQYXJhbXMudmFsdWVzID0gY29sb3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBQYXJhbWV0ZXJzIHRoYXQgY3VzdG9taXplIGhvdyB0aWNrcyBhcmUgY2FsY3VsYXRlZCAobm90IHN0eWxlKVxuICAgICAqIEBwYXJhbSB7KCdsZWZ0J3wnY2VudGVyJ3wncmlnaHQnKX0gW2NvbmZpZy5wb3NpdGlvbj0nbGVmdCddIEFsaWduIHRpY2tzIHdpdGggdGhlIGNlbnRlciBvciBlZGdlIG9mIGNhdGVnb3J5XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFRpY2tzKGRpbWVuc2lvbiwgY29uZmlnKSB7IC8vIE92ZXJyaWRlcyBwYXJlbnQgbWV0aG9kXG4gICAgICAgIGlmICghWyd4JywgJ3kxJywgJ3kyJ10uaW5jbHVkZXMoZGltZW5zaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpbWVuc2lvbiBpZGVudGlmaWVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBjb25maWcucG9zaXRpb24gfHwgJ2xlZnQnO1xuICAgICAgICBpZiAoIVsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXS5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0aWNrIHBvc2l0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYXRlZ29yeUJvdW5kcyA9IHRoaXMuX2NhdGVnb3JpZXM7XG4gICAgICAgIGlmICghY2F0ZWdvcnlCb3VuZHMgfHwgIU9iamVjdC5rZXlzKGNhdGVnb3J5Qm91bmRzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW1lbnNpb24gPT09ICd5Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAvLyBJZiBjb2xvcnMgaGF2ZSBiZWVuIGRlZmluZWQgYnkgdGhpcyBsYXllciwgdXNlIHRoZW0gdG8gbWFrZSB0aWNrIGNvbG9ycyBtYXRjaCBzY2F0dGVycGxvdCBwb2ludCBjb2xvcnNcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX2dldENvbG9yU2NhbGUodGhpcy5sYXlvdXQpO1xuICAgICAgICAgICAgY29uc3Qga25vd25DYXRlZ29yaWVzID0gY29sb3JzLnBhcmFtZXRlcnMuY2F0ZWdvcmllcyB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IGtub3duQ29sb3JzID0gY29sb3JzLnBhcmFtZXRlcnMudmFsdWVzIHx8IFtdO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY2F0ZWdvcnlCb3VuZHMpLm1hcCgoY2F0ZWdvcnksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gY2F0ZWdvcnlCb3VuZHNbY2F0ZWdvcnldO1xuICAgICAgICAgICAgICAgIGxldCB4UG9zO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB4UG9zID0gYm91bmRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGljayB1bmRlciBvbmUgb3IgbWFueSBlbGVtZW50cyBhcyBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IGJvdW5kc1sxXSAtIGJvdW5kc1swXTtcbiAgICAgICAgICAgICAgICAgICAgeFBvcyA9IGJvdW5kc1swXSArIChkaWZmICE9PSAwID8gZGlmZiA6IGJvdW5kc1swXSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHhQb3MgPSBib3VuZHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiB4UG9zLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsJzoga25vd25Db2xvcnNba25vd25DYXRlZ29yaWVzLmluZGV4T2YoY2F0ZWdvcnkpXSB8fCAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHlDdXN0b21EYXRhTWV0aG9kcygpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fcHJlcGFyZURhdGEoKTtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IHRoaXMuX2dlbmVyYXRlQ2F0ZWdvcnlCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7IFNjYXR0ZXIgYXMgc2NhdHRlciwgQ2F0ZWdvcnlTY2F0dGVyIGFzIGNhdGVnb3J5X3NjYXR0ZXIgfTtcbiIsIi8qKiBAbW9kdWxlICovXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQge2FwcGx5U3R5bGVzfSBmcm9tICcuLi9oZWxwZXJzL2NvbW1vbic7XG5pbXBvcnQge21lcmdlLCBuYW1lVG9TeW1ib2x9IGZyb20gJy4uL2hlbHBlcnMvbGF5b3V0cyc7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbGF5b3V0IHVzZWQgYnkgbGVnZW5kcyAodXNlZCBpbnRlcm5hbGx5KVxuICogQHByb3RlY3RlZFxuICogQG1lbWJlciB7T2JqZWN0fVxuICovXG5jb25zdCBkZWZhdWx0X2xheW91dCA9IHtcbiAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICBvcmlnaW46IHsgeDogMCwgeTogMCB9LFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgbGFiZWxfc2l6ZTogMTIsXG4gICAgaGlkZGVuOiBmYWxzZSxcbn07XG5cbi8qKlxuICogQW4gU1ZHIG9iamVjdCB1c2VkIHRvIGRpc3BsYXkgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCBhIHBhbmVsLlxuICogUGFuZWwgbGF5b3V0cyBkZXRlcm1pbmUgYmFzaWMgZmVhdHVyZXMgb2YgYSBsZWdlbmQgLSBpdHMgcG9zaXRpb24gaW4gdGhlIHBhbmVsLCBvcmllbnRhdGlvbiwgdGl0bGUsIGV0Yy5cbiAqIExheW91dHMgb2YgY2hpbGQgZGF0YSBsYXllcnMgb2YgdGhlIHBhbmVsIGRldGVybWluZSB0aGUgYWN0dWFsIGNvbnRlbnQgb2YgdGhlIGxlZ2VuZC5cbiAqXG4gKiBAcGFyYW0ge1BhbmVsfSBwYXJlbnRcbiovXG5jbGFzcyBMZWdlbmQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICAvLyBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBMb2N1c1pvb20uUGFuZWwpKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgbGVnZW5kLCBwYXJlbnQgbXVzdCBiZSBhIGxvY3Vzem9vbSBwYW5lbCcpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKiBAbWVtYmVyIHtQYW5lbH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtTdHJpbmd9ICovXG4gICAgICAgIHRoaXMuaWQgPSBgJHt0aGlzLnBhcmVudC5nZXRCYXNlSWQoKX0ubGVnZW5kYDtcblxuICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQubGVnZW5kID0gbWVyZ2UodGhpcy5wYXJlbnQubGF5b3V0LmxlZ2VuZCB8fCB7fSwgZGVmYXVsdF9sYXlvdXQpO1xuICAgICAgICAvKiogQG1lbWJlciB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IHRoaXMucGFyZW50LmxheW91dC5sZWdlbmQ7XG5cbiAgICAgICAgLyoqIEBtZW1iZXIge2QzLnNlbGVjdGlvbn0gKi9cbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IG51bGw7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtkMy5zZWxlY3Rpb259ICovXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZF9yZWN0ID0gbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge2QzLnNlbGVjdGlvbltdfSAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTVkcgc2VsZWN0b3IgZm9yIHRoZSBncm91cCBjb250YWluaW5nIGFsbCBlbGVtZW50cyBpbiB0aGUgbGVnZW5kXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7ZDMuc2VsZWN0aW9ufG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRzX2dyb3VwID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogTm90IHN1cmUgaWYgdGhpcyBwcm9wZXJ0eSBpcyB1c2VkOyB0aGUgZXh0ZXJuYWwtZmFjaW5nIG1ldGhvZHMgYXJlIHNldHRpbmcgYGxheW91dC5oaWRkZW5gIGluc3RlYWQuIFRlbnRhdGl2ZWx5IG1hcmsgZGVwcmVjYXRlZC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGxlZ2VuZCBpbiB0aGUgcGFyZW50IHBhbmVsXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBHZXQgYSBsZWdlbmQgZ3JvdXAgc2VsZWN0b3IgaWYgbm90IHlldCBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMucGFyZW50LnN2Zy5ncm91cC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIGAke3RoaXMucGFyZW50LmdldEJhc2VJZCgpfS5sZWdlbmRgKS5hdHRyKCdjbGFzcycsICdsei1sZWdlbmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhIGxlZ2VuZCBiYWNrZ3JvdW5kIHJlY3Qgc2VsZWN0b3IgaWYgbm90IHlldCBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy5iYWNrZ3JvdW5kX3JlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZF9yZWN0ID0gdGhpcy5zZWxlY3Rvci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDEwMClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1sZWdlbmQtYmFja2dyb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGEgbGVnZW5kIGVsZW1lbnRzIGdyb3VwIHNlbGVjdG9yIGlmIG5vdCB5ZXQgZGVmaW5lZFxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudHNfZ3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNfZ3JvdXAgPSB0aGlzLnNlbGVjdG9yLmFwcGVuZCgnZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBkb2N1bWVudCBhbmQgcmUtcmVuZGVyIGZyb20gc2NyYXRjaFxuICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IGVsZW1lbnQucmVtb3ZlKCkpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG5cbiAgICAgICAgLy8gR2F0aGVyIGFsbCBlbGVtZW50cyBmcm9tIGRhdGEgbGF5ZXJzIGluIG9yZGVyICh0b3AgdG8gYm90dG9tKSBhbmQgcmVuZGVyIHRoZW1cbiAgICAgICAgY29uc3QgcGFkZGluZyA9ICt0aGlzLmxheW91dC5wYWRkaW5nIHx8IDE7XG4gICAgICAgIGxldCB4ID0gcGFkZGluZztcbiAgICAgICAgbGV0IHkgPSBwYWRkaW5nO1xuICAgICAgICBsZXQgbGluZV9oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnBhcmVudC5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnBhcmVudC5kYXRhX2xheWVyc1tpZF0ubGF5b3V0LmxlZ2VuZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5kYXRhX2xheWVyc1tpZF0ubGF5b3V0LmxlZ2VuZC5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5lbGVtZW50c19ncm91cC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxfc2l6ZSA9ICtlbGVtZW50LmxhYmVsX3NpemUgfHwgK3RoaXMubGF5b3V0LmxhYmVsX3NpemUgfHwgMTI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbF94ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsX3kgPSAobGFiZWxfc2l6ZSAvIDIpICsgKHBhZGRpbmcgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZV9oZWlnaHQgPSBNYXRoLm1heChsaW5lX2hlaWdodCwgbGFiZWxfc2l6ZSArIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBsZWdlbmQgZWxlbWVudCBzeW1ib2wgKGxpbmUsIHJlY3QsIHNoYXBlLCBldGMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gZWxlbWVudC5zaGFwZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcGVfZmFjdG9yeSA9IG5hbWVUb1N5bWJvbChzaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gK2VsZW1lbnQubGVuZ3RoIHx8IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aF95ID0gKGxhYmVsX3NpemUgLyA0KSArIChwYWRkaW5nIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGVsZW1lbnQuY2xhc3MgfHwgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBgTTAsJHtwYXRoX3l9TCR7bGVuZ3RofSwke3BhdGhfeX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5U3R5bGVzLCBlbGVtZW50LnN0eWxlIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsX3ggPSBsZW5ndGggKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAncmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Qgc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9ICtlbGVtZW50LndpZHRoIHx8IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gK2VsZW1lbnQuaGVpZ2h0IHx8IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBlbGVtZW50LmNsYXNzIHx8ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBlbGVtZW50LmNvbG9yIHx8IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5U3R5bGVzLCBlbGVtZW50LnN0eWxlIHx8IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxfeCA9IHdpZHRoICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfaGVpZ2h0ID0gTWF0aC5tYXgobGluZV9oZWlnaHQsIGhlaWdodCArIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlX2ZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYXBlIHN5bWJvbCBpcyBhIHJlY29nbml6ZWQgZDMgdHlwZSwgc28gd2UgY2FuIGRyYXcgaXQgaW4gdGhlIGxlZ2VuZCAoY2lyY2xlLCBkaWFtb25kLCBldGMuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9ICtlbGVtZW50LnNpemUgfHwgNDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNpemUgLyBNYXRoLlBJKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGVsZW1lbnQuY2xhc3MgfHwgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5zeW1ib2woKS5zaXplKHNpemUpLnR5cGUoc2hhcGVfZmFjdG9yeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtyYWRpdXN9LCAke3JhZGl1cyArIChwYWRkaW5nIC8gMil9KWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBlbGVtZW50LmNvbG9yIHx8IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGFwcGx5U3R5bGVzLCBlbGVtZW50LnN0eWxlIHx8IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxfeCA9ICgyICogcmFkaXVzKSArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbF95ID0gTWF0aC5tYXgoKDIgKiByYWRpdXMpICsgKHBhZGRpbmcgLyAyKSwgbGFiZWxfeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lX2hlaWdodCA9IE1hdGgubWF4KGxpbmVfaGVpZ2h0LCAoMiAqIHJhZGl1cykgKyBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBsZWdlbmQgZWxlbWVudCBsYWJlbFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbGVmdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBsYWJlbF94KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBsYWJlbF95KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBsYWJlbF9zaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZWxlbWVudC5sYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gdGhlIGxlZ2VuZCBlbGVtZW50IGdyb3VwIGJhc2VkIG9uIGxlZ2VuZCBsYXlvdXQgb3JpZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmNyID0gc2VsZWN0b3Iubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gYmNyLmhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lX2hlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBlbGVtZW50IGRvZXMgbm90IGV4Y2VlZCB0aGUgcGFuZWwgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChFLmcuIGRyb3AgdG8gdGhlIG5leHQgbGluZSBpZiBpdCBkb2VzLCBidXQgb25seSBpZiBpdCdzIG5vdCB0aGUgb25seSBlbGVtZW50IG9uIHRoaXMgbGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0X3ggPSB0aGlzLmxheW91dC5vcmlnaW4ueCArIHggKyBiY3Iud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IHBhZGRpbmcgJiYgcmlnaHRfeCA+IHRoaXMucGFyZW50LmxheW91dC53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gbGluZV9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCAke3l9KWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBiY3Iud2lkdGggKyAoMyAqIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNjYWxlIHRoZSBiYWNrZ3JvdW5kIHJlY3QgdG8gdGhlIGVsZW1lbnRzIGluIHRoZSBsZWdlbmRcbiAgICAgICAgY29uc3QgYmNyID0gdGhpcy5lbGVtZW50c19ncm91cC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMubGF5b3V0LndpZHRoID0gYmNyLndpZHRoICsgKDIgKiB0aGlzLmxheW91dC5wYWRkaW5nKTtcbiAgICAgICAgdGhpcy5sYXlvdXQuaGVpZ2h0ID0gYmNyLmhlaWdodCArICgyICogdGhpcy5sYXlvdXQucGFkZGluZyk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZF9yZWN0XG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLmxheW91dC53aWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmxheW91dC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdmlzaWJpbGl0eSBvbiB0aGUgbGVnZW5kIGZyb20gdGhlIFwiaGlkZGVuXCIgZmxhZ1xuICAgICAgICAvLyBUT0RPOiBgc2hvdygpYCBhbmQgYGhpZGUoKWAgY2FsbCBhIGZ1bGwgcmVyZW5kZXI7IG1pZ2h0IGJlIGFibGUgdG8gbWFrZSB0aGlzIG1vcmUgbGlnaHR3ZWlnaHQ/XG4gICAgICAgIHRoaXMuc2VsZWN0b3JcbiAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsIHRoaXMubGF5b3V0LmhpZGRlbiA/ICdoaWRkZW4nIDogJ3Zpc2libGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlIHRoZSBsZWdlbmQgaW4gcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhbmVsLCBhcyBzcGVjaWZpZWQgaW4gdGhlIGxheW91dCBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMge0xlZ2VuZCB8IG51bGx9XG4gICAgICogVE9ETzogc2hvdWxkIHRoaXMgYWx3YXlzIGJlIGNoYWluYWJsZT9cbiAgICAgKi9cbiAgICBwb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiY3IgPSB0aGlzLnNlbGVjdG9yLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFpc05hTigrdGhpcy5sYXlvdXQucGFkX2Zyb21fYm90dG9tKSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQub3JpZ2luLnkgPSB0aGlzLnBhcmVudC5sYXlvdXQuaGVpZ2h0IC0gYmNyLmhlaWdodCAtICt0aGlzLmxheW91dC5wYWRfZnJvbV9ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTigrdGhpcy5sYXlvdXQucGFkX2Zyb21fcmlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5vcmlnaW4ueCA9IHRoaXMucGFyZW50LmxheW91dC53aWR0aCAtIGJjci53aWR0aCAtICt0aGlzLmxheW91dC5wYWRfZnJvbV9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdG9yLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLmxheW91dC5vcmlnaW4ueH0sICR7dGhpcy5sYXlvdXQub3JpZ2luLnl9KWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGxlZ2VuZCAodHJpZ2dlcnMgYSByZS1yZW5kZXIpXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgbGVnZW5kICh0cmlnZ2VycyBhIHJlLXJlbmRlcilcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxufVxuXG5leHBvcnQge0xlZ2VuZCBhcyBkZWZhdWx0fTtcbiIsIi8qKiBAbW9kdWxlICovXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cbmltcG9ydCB7U1RBVFVTRVN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4vdG9vbGJhcic7XG5pbXBvcnQge2FwcGx5U3R5bGVzLCBnZW5lcmF0ZUN1cnRhaW4sIGdlbmVyYXRlTG9hZGVyfSBmcm9tICcuLi9oZWxwZXJzL2NvbW1vbic7XG5pbXBvcnQge3BhcnNlRmllbGRzLCBwb3NpdGlvbkludFRvU3RyaW5nLCBwcmV0dHlUaWNrc30gZnJvbSAnLi4vaGVscGVycy9kaXNwbGF5JztcbmltcG9ydCB7bWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvbGF5b3V0cyc7XG5pbXBvcnQgTGVnZW5kIGZyb20gJy4vbGVnZW5kJztcbmltcG9ydCBkYXRhX2xheWVycyBmcm9tICcuLi9yZWdpc3RyeS9kYXRhX2xheWVycyc7XG5cblxuLyoqXG4gKiBEZWZhdWx0IHBhbmVsIGxheW91dFxuICogQHN0YXRpY1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgZGVmYXVsdF9sYXlvdXQgPSB7XG4gICAgdGl0bGU6IHsgdGV4dDogJycsIHN0eWxlOiB7fSwgeDogMTAsIHk6IDIyIH0sXG4gICAgeV9pbmRleDogbnVsbCxcbiAgICB3aWR0aDogIDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIG9yaWdpbjogeyB4OiAwLCB5OiBudWxsIH0sXG4gICAgbWluX3dpZHRoOiAxLFxuICAgIG1pbl9oZWlnaHQ6IDEsXG4gICAgcHJvcG9ydGlvbmFsX3dpZHRoOiBudWxsLFxuICAgIHByb3BvcnRpb25hbF9oZWlnaHQ6IG51bGwsXG4gICAgcHJvcG9ydGlvbmFsX29yaWdpbjogeyB4OiAwLCB5OiBudWxsIH0sXG4gICAgbWFyZ2luOiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9LFxuICAgIGJhY2tncm91bmRfY2xpY2s6ICdjbGVhcl9zZWxlY3Rpb25zJyxcbiAgICB0b29sYmFyOiB7XG4gICAgICAgIHdpZGdldHM6IFtdLFxuICAgIH0sXG4gICAgY2xpcGFyZWE6IHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgb3JpZ2luOiB7IHg6IDAsIHk6IDAgfSxcbiAgICB9LFxuICAgIGF4ZXM6IHsgIC8vIFRoZXNlIGFyZSB0aGUgb25seSBheGVzIHN1cHBvcnRlZCEhXG4gICAgICAgIHg6ICB7fSxcbiAgICAgICAgeTE6IHt9LFxuICAgICAgICB5Mjoge30sXG4gICAgfSxcbiAgICBsZWdlbmQ6IG51bGwsXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgZHJhZ19iYWNrZ3JvdW5kX3RvX3BhbjogZmFsc2UsXG4gICAgICAgIGRyYWdfeF90aWNrc190b19zY2FsZTogZmFsc2UsXG4gICAgICAgIGRyYWdfeTFfdGlja3NfdG9fc2NhbGU6IGZhbHNlLFxuICAgICAgICBkcmFnX3kyX3RpY2tzX3RvX3NjYWxlOiBmYWxzZSxcbiAgICAgICAgc2Nyb2xsX3RvX3pvb206IGZhbHNlLFxuICAgICAgICB4X2xpbmtlZDogZmFsc2UsXG4gICAgICAgIHkxX2xpbmtlZDogZmFsc2UsXG4gICAgICAgIHkyX2xpbmtlZDogZmFsc2UsXG4gICAgfSxcbiAgICBkYXRhX2xheWVyczogW10sXG59O1xuXG4vKipcbiAqIEEgcGFuZWwgaXMgYW4gYWJzdHJhY3QgY2xhc3MgcmVwcmVzZW50aW5nIGEgc3ViZGl2aXNpb24gb2YgdGhlIExvY3VzWm9vbSBzdGFnZVxuICogICB0byBkaXNwbGF5IGEgZGlzdGluY3QgZGF0YSByZXByZXNlbnRhdGlvbiBhcyBhIGNvbGxlY3Rpb24gb2YgZGF0YSBsYXllcnMuXG4gKi9cbmNsYXNzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtQbG90fG51bGx9IHBhcmVudFxuICAgICovXG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXlvdXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgcGFuZWwsIGludmFsaWQgbGF5b3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtQbG90fG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogIEBwcm90ZWN0ZWRcbiAgICAgICAgICogIEBtZW1iZXIge1Bsb3R8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50X3Bsb3QgPSBwYXJlbnQ7XG5cbiAgICAgICAgLy8gRW5zdXJlIGEgdmFsaWQgSUQgaXMgcHJlc2VudC4gSWYgdGhlcmUgaXMgbm8gdmFsaWQgSUQgdGhlbiBnZW5lcmF0ZSBvbmVcbiAgICAgICAgaWYgKHR5cGVvZiBsYXlvdXQuaWQgIT09ICdzdHJpbmcnIHx8ICFsYXlvdXQuaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0LmlkID0gYHAke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDEwLCA4KSl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVJRCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gYHAke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDEwLCA4KSl9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLnBhcmVudC5wYW5lbHNbaWRdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGdlbmVyYXRlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsYXlvdXQuaWQgPSBnZW5lcmF0ZUlEKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJlbnQucGFuZWxzW2xheW91dC5pZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIHBhbmVsIHdpdGggaWQgWyR7bGF5b3V0LmlkfV07IHBhbmVsIHdpdGggdGhhdCBpZCBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBsYXlvdXQuaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhpcyBwYW5lbCBpbiB0aGUgcGFyZW50IHBsb3QncyBgbGF5b3V0LnBhbmVsc2BcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmxheW91dF9pZHggPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmcgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgdXNlZCB0byBkZXNjcmliZSB0aGUgY29tcG9zaXRpb24gb2YgdGhlIFBhbmVsXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBtZXJnZShsYXlvdXQgfHwge30sIGRlZmF1bHRfbGF5b3V0KTtcblxuICAgICAgICAvLyBEZWZpbmUgc3RhdGUgcGFyYW1ldGVycyBzcGVjaWZpYyB0byB0aGlzIHBhbmVsXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wYXJlbnQuc3RhdGU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogIEBwcml2YXRlXG4gICAgICAgICAgICAgKiAgQG1lbWJlciB7U3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN0YXRlX2lkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVbdGhpcy5zdGF0ZV9pZF0gPSB0aGlzLnN0YXRlW3RoaXMuc3RhdGVfaWRdIHx8IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXRlX2lkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YV9sYXllcnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIGRhdGEgcmVxdWVzdHMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZVtdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhX3Byb21pc2VzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge2QzLnNjYWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54X3NjYWxlICA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtkMy5zY2FsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueTFfc2NhbGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogIEBwcml2YXRlXG4gICAgICAgICAqICBAbWVtYmVyIHtkMy5zY2FsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueTJfc2NhbGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtkMy5leHRlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnhfZXh0ZW50ICA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgQHByaXZhdGVcbiAgICAgICAgICogIEBtZW1iZXIge2QzLmV4dGVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueTFfZXh0ZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBAcHJpdmF0ZVxuICAgICAgICAgKiAgQG1lbWJlciB7ZDMuZXh0ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55Ml9leHRlbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueF90aWNrcyAgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBAcHJpdmF0ZVxuICAgICAgICAgKiAgQG1lbWJlciB7TnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkxX3RpY2tzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueTJfdGlja3MgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lb3V0IElEIGFzIHJldHVybmVkIGJ5IHNldFRpbWVvdXRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56b29tX3RpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLbm93biBldmVudCBob29rcyB0aGF0IHRoZSBwYW5lbCBjYW4gcmVzcG9uZCB0b1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRfaG9va3MgPSB7XG4gICAgICAgICAgICAnbGF5b3V0X2NoYW5nZWQnOiBbXSxcbiAgICAgICAgICAgICdkYXRhX3JlcXVlc3RlZCc6IFtdLFxuICAgICAgICAgICAgJ2RhdGFfcmVuZGVyZWQnOiBbXSxcbiAgICAgICAgICAgICdlbGVtZW50X2NsaWNrZWQnOiBbXSxcbiAgICAgICAgICAgICdlbGVtZW50X3NlbGVjdGlvbic6IFtdLFxuICAgICAgICAgICAgJ21hdGNoX3JlcXVlc3RlZCc6IFtdLCAvLyBBIGRhdGEgbGF5ZXIgaXMgYXR0ZW1wdGluZyB0byBoaWdobGlnaHQgbWF0Y2hpbmcgcG9pbnRzIChpbnRlcm5hbCB1c2Ugb25seSlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBsYXlvdXRcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTGF5b3V0KCk7XG4gICAgfVxuXG4gICAgLyoqKioqKiogUHVibGljIG1ldGhvZHM6IGludGVuZGVkIGZvciBkaXJlY3QgZXh0ZXJuYWwgbWFuaXB1bGF0aW9uIG9mIHBhbmVsIGludGVybmFscyAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIHNldmVyYWwgZXZlbnRzIHRoYXQgYSBMb2N1c1pvb20gcGFuZWwgY2FuIFwiZW1pdFwiIHdoZW4gYXBwcm9wcmlhdGUsIGFuZCBMb2N1c1pvb20gc3VwcG9ydHMgcmVnaXN0ZXJpbmdcbiAgICAgKiAgIFwiaG9va3NcIiBmb3IgdGhlc2UgZXZlbnRzIHdoaWNoIGFyZSBlc3NlbnRpYWxseSBjdXN0b20gZnVuY3Rpb25zIGludGVuZGVkIHRvIGZpcmUgYXQgY2VydGFpbiB0aW1lcy5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgcGFuZWwtbGV2ZWwgZXZlbnRzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOlxuICAgICAqICAgLSBgbGF5b3V0X2NoYW5nZWRgIC0gY29udGV4dDogcGFuZWwgLSBBbnkgYXNwZWN0IG9mIHRoZSBwYW5lbCdzIGxheW91dCAoaW5jbHVkaW5nIGRpbWVuc2lvbnMgb3Igc3RhdGUpIGhhcyBjaGFuZ2VkLlxuICAgICAqICAgLSBgZGF0YV9yZXF1ZXN0ZWRgIC0gY29udGV4dDogcGFuZWwgLSBBIHJlcXVlc3QgZm9yIG5ldyBkYXRhIGZyb20gYW55IGRhdGEgc291cmNlIHVzZWQgaW4gdGhlIHBhbmVsIGhhcyBiZWVuIG1hZGUuXG4gICAgICogICAtIGBkYXRhX3JlbmRlcmVkYCAtIGNvbnRleHQ6IHBhbmVsIC0gRGF0YSBmcm9tIGEgcmVxdWVzdCBoYXMgYmVlbiByZWNlaXZlZCBhbmQgcmVuZGVyZWQgaW4gdGhlIHBhbmVsLlxuICAgICAqICAgLSBgZWxlbWVudF9jbGlja2VkYCAtIGNvbnRleHQ6IHBhbmVsIC0gQSBkYXRhIGVsZW1lbnQgaW4gYW55IG9mIHRoZSBwYW5lbCdzIGRhdGEgbGF5ZXJzIGhhcyBiZWVuIGNsaWNrZWQuXG4gICAgICogICAtIGBlbGVtZW50X3NlbGVjdGlvbmAgLSBjb250ZXh0OiBwYW5lbCAtIFRyaWdnZXJlZCB3aGVuIGFuIGVsZW1lbnQgY2hhbmdlcyBcInNlbGVjdGlvblwiIHN0YXR1cywgYW5kIGlkZW50aWZpZXNcbiAgICAgKiAgICAgICAgd2hldGhlciB0aGUgZWxlbWVudCBpcyBiZWluZyBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLlxuICAgICAqXG4gICAgICogVG8gcmVnaXN0ZXIgYSBob29rIGZvciBhbnkgb2YgdGhlc2UgZXZlbnRzIHVzZSBgcGFuZWwub24oJ2V2ZW50X25hbWUnLCBmdW5jdGlvbigpIHt9KWAuXG4gICAgICpcbiAgICAgKiBUaGVyZSBjYW4gYmUgYXJiaXRyYXJpbHkgbWFueSBmdW5jdGlvbnMgcmVnaXN0ZXJlZCB0byB0aGUgc2FtZSBldmVudC4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogICB3ZXJlIHJlZ2lzdGVyZWQuIFRoZSB0aGlzIGNvbnRleHQgYm91bmQgdG8gZWFjaCBldmVudCBob29rIGZ1bmN0aW9uIGlzIGRlcGVuZGVudCBvbiB0aGUgdHlwZSBvZiBldmVudCwgYXNcbiAgICAgKiAgIGRlbm90ZWQgYWJvdmUuIEZvciBleGFtcGxlLCB3aGVuIGRhdGFfcmVxdWVzdGVkIGlzIGVtaXR0ZWQgdGhlIGNvbnRleHQgZm9yIHRoaXMgaW4gdGhlIGV2ZW50IGhvb2sgd2lsbCBiZSB0aGVcbiAgICAgKiAgIHBhbmVsIGl0c2VsZiwgYnV0IHdoZW4gZWxlbWVudF9jbGlja2VkIGlzIGVtaXR0ZWQgdGhlIGNvbnRleHQgZm9yIHRoaXMgaW4gdGhlIGV2ZW50IGhvb2sgd2lsbCBiZSB0aGUgZWxlbWVudFxuICAgICAqICAgdGhhdCB3YXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChhcyBkZWZpbmVkIGluIGBldmVudF9ob29rc2ApXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaG9va1xuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbihldmVudCwgaG9vaykge1xuICAgICAgICAvLyBUT0RPOiBEcnkgcGxvdCBhbmQgcGFuZWwgZXZlbnQgY29kZSBpbnRvIGEgc2hhcmVkIG1peGluXG4gICAgICAgIGlmICh0eXBlb2YgJ2V2ZW50JyAhPSAnc3RyaW5nJyB8fCAhQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50X2hvb2tzW2V2ZW50XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlZ2lzdGVyIGV2ZW50IGhvb2ssIGludmFsaWQgZXZlbnQ6ICR7ZXZlbnQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhvb2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVnaXN0ZXIgZXZlbnQgaG9vaywgaW52YWxpZCBob29rIGZ1bmN0aW9uIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRfaG9va3NbZXZlbnRdLnB1c2goaG9vayk7XG4gICAgICAgIHJldHVybiBob29rO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBvbmUgb3IgbW9yZSBwcmV2aW91c2x5IGRlZmluZWQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiBhbiBldmVudCAoYXMgZGVmaW5lZCBpbiBgZXZlbnRfaG9va3NgKVxuICAgICAqIEBwYXJhbSB7ZXZlbnRDYWxsYmFja30gW2hvb2tdIFRoZSBjYWxsYmFjayB0byBkZXJlZ2lzdGVyXG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIG9mZihldmVudCwgaG9vaykge1xuICAgICAgICBjb25zdCB0aGVzZUhvb2tzID0gdGhpcy5ldmVudF9ob29rc1tldmVudF07XG4gICAgICAgIGlmICh0eXBlb2YgJ2V2ZW50JyAhPSAnc3RyaW5nJyB8fCAhQXJyYXkuaXNBcnJheSh0aGVzZUhvb2tzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIGV2ZW50IGhvb2ssIGludmFsaWQgZXZlbnQ6ICR7ZXZlbnQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9vayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBEZXJlZ2lzdGVyaW5nIGFsbCBob29rcyBmb3IgdGhpcyBldmVudCBtYXkgYnJlYWsgYmFzaWMgZnVuY3Rpb25hbGl0eSwgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgZHVyaW5nXG4gICAgICAgICAgICAvLyAgY2xlYW51cCBvcGVyYXRpb25zIChlZyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcylcbiAgICAgICAgICAgIHRoaXMuZXZlbnRfaG9va3NbZXZlbnRdID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBob29rTWF0Y2ggPSB0aGVzZUhvb2tzLmluZGV4T2YoaG9vayk7XG4gICAgICAgICAgICBpZiAoaG9va01hdGNoICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoZXNlSG9va3Muc3BsaWNlKGhvb2tNYXRjaCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lciBpcyBub3QgcmVnaXN0ZXJlZCBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSByZW1vdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJ1bm5pbmcgb2YgZXZlbnQgaG9va3Mgd2hlbiBhbiBldmVudCBpcyBlbWl0dGVkXG4gICAgICpcbiAgICAgKiBUaGVyZSBpcyBhIHNob3J0ZXIgb3ZlcmxvYWRlZCBmb3JtIG9mIHRoaXMgbWV0aG9kOiBpZiB0aGUgZXZlbnQgZG9lcyBub3QgaGF2ZSBhbnkgZGF0YSwgdGhlIHNlY29uZFxuICAgICAqICAgYXJndW1lbnQgY2FuIGJlIGEgYm9vbGVhbiB0byBjb250cm9sIGJ1YmJsaW5nXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IEEga25vd24gZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gW2V2ZW50RGF0YV0gRGF0YSBvciBldmVudCBkZXNjcmlwdGlvbiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBldmVudCBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZT1mYWxzZV0gV2hldGhlciB0byBidWJibGUgdGhlIGV2ZW50IHRvIHRoZSBwYXJlbnRcbiAgICAgKiBAcmV0dXJucyB7UGFuZWx9XG4gICAgICovXG4gICAgZW1pdChldmVudCwgZXZlbnREYXRhLCBidWJibGUpICB7XG4gICAgICAgIGJ1YmJsZSA9IGJ1YmJsZSB8fCBmYWxzZTtcblxuICAgICAgICAvLyBUT0RPOiBEUlkgdGhpcyB3aXRoIHRoZSBwYXJlbnQgcGxvdCBpbXBsZW1lbnRhdGlvbi4gRW5zdXJlIGludGVyZmFjZXMgcmVtYWluIGNvbXBhdGlibGUuXG4gICAgICAgIC8vIFRPRE86IEltcHJvdmUgZG9jdW1lbnRhdGlvbiBmb3Igb3ZlcmxvYWRlZCBtZXRob2Qgc2lnbmF0dXJlIChKU0RvYyBtYXkgaGF2ZSB0cm91YmxlIGhlcmUpXG4gICAgICAgIGlmICh0eXBlb2YgJ2V2ZW50JyAhPSAnc3RyaW5nJyB8fCAhQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50X2hvb2tzW2V2ZW50XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9jdXNab29tIGF0dGVtcHRlZCB0byB0aHJvdyBhbiBpbnZhbGlkIGV2ZW50OiAke2V2ZW50LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudERhdGEgPT09ICdib29sZWFuJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBPdmVybG9hZGVkIG1ldGhvZCBzaWduYXR1cmU6IGVtaXQoZXZlbnQsIGJ1YmJsZSlcbiAgICAgICAgICAgIGJ1YmJsZSA9IGV2ZW50RGF0YTtcbiAgICAgICAgICAgIGV2ZW50RGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlSUQgPSB0aGlzLmdldEJhc2VJZCgpO1xuICAgICAgICBjb25zdCBldmVudENvbnRleHQgPSB7IHNvdXJjZUlEOiBzb3VyY2VJRCwgdGFyZ2V0OiB0aGlzLCBkYXRhOiBldmVudERhdGEgfHwgbnVsbCB9O1xuICAgICAgICB0aGlzLmV2ZW50X2hvb2tzW2V2ZW50XS5mb3JFYWNoKChob29rVG9SdW4pID0+IHtcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIGFueSBoYW5kbGVycyBmaXJlZCBoZXJlIHdpbGwgc2VlIHRoZSBwYW5lbCBhcyB0aGUgdmFsdWUgb2YgYHRoaXNgLiBJZiBhIGJvdW5kIGZ1bmN0aW9uIGlzXG4gICAgICAgICAgICAvLyByZWdpc3RlcmVkIGFzIGEgaGFuZGxlciwgdGhlIHByZXZpb3VzbHkgYm91bmQgYHRoaXNgIHdpbGwgb3ZlcnJpZGUgYW55dGhpbmcgcHJvdmlkZWQgdG8gYGNhbGxgIGJlbG93LlxuICAgICAgICAgICAgaG9va1RvUnVuLmNhbGwodGhpcywgZXZlbnRDb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChidWJibGUgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmVtaXQoZXZlbnQsIGV2ZW50Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0aXRsZSBmb3IgdGhlIHBhbmVsLiBJZiBwYXNzZWQgYW4gb2JqZWN0LCB3aWxsIG1lcmdlIHRoZSBvYmplY3Qgd2l0aCB0aGUgZXhpc3RpbmcgbGF5b3V0IGNvbmZpZ3VyYXRpb24sIHNvXG4gICAgICogICB0aGF0IGFsbCBvciBvbmx5IHNvbWUgb2YgdGhlIHRpdGxlIGxheW91dCBvYmplY3QncyBwYXJhbWV0ZXJzIGNhbiBiZSBjdXN0b21pemVkLiBJZiBwYXNzZWQgbnVsbCwgZmFsc2UsIG9yIGFuIGVtcHR5XG4gICAgICogICBzdHJpbmcsIHRoZSB0aXRsZSBET00gZWxlbWVudCB3aWxsIGJlIHNldCB0byBkaXNwbGF5OiBub25lLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdHxudWxsfSB0aXRsZSBUaGUgdGl0bGUgdGV4dCwgb3IgYW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlLnRleHQgVGV4dCB0byBkaXNwbGF5LiBTaW5jZSB0aXRsZXMgYXJlIHJlbmRlcmVkIGFzIFNWRyB0ZXh0LCBIVE1MIGFuZCBuZXdsaW5lcyB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGl0bGUueCBYLW9mZnNldCwgaW4gcGl4ZWxzLCBmb3IgdGhlIHRpdGxlJ3MgdGV4dCBhbmNob3IgKGRlZmF1bHQgbGVmdCkgcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcGFuZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpdGxlLnkgWS1vZmZzZXQsIGluIHBpeGVscywgZm9yIHRoZSB0aXRsZSdzIHRleHQgYW5jaG9yIChkZWZhdWx0IGxlZnQpIHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHBhbmVsLlxuICAgICAgICBOT1RFOiBTVkcgeSB2YWx1ZXMgZ28gZnJvbSB0aGUgdG9wIGRvd24sIHNvIHRoZSBTVkcgb3JpZ2luIG9mICgwLDApIGlzIGluIHRoZSB0b3AgbGVmdCBjb3JuZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRpdGxlLnN0eWxlIENTUyBzdHlsZXMgb2JqZWN0IHRvIGJlIGFwcGxpZWQgdG8gdGhlIHRpdGxlJ3MgRE9NIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXlvdXQudGl0bGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmxheW91dC50aXRsZTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnRpdGxlID0geyB0ZXh0OiB0ZXh0LCB4OiAwLCB5OiAwLCBzdHlsZToge30gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpdGxlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC50aXRsZS50ZXh0ID0gdGl0bGU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRpdGxlID09ICdvYmplY3QnICYmIHRpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC50aXRsZSA9IG1lcmdlKHRpdGxlLCB0aGlzLmxheW91dC50aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LnRpdGxlLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCBudWxsKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgcGFyc2VGbG9hdCh0aGlzLmxheW91dC50aXRsZS54KSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHBhcnNlRmxvYXQodGhpcy5sYXlvdXQudGl0bGUueSkpXG4gICAgICAgICAgICAgICAgLnRleHQodGhpcy5sYXlvdXQudGl0bGUudGV4dClcbiAgICAgICAgICAgICAgICAuY2FsbChhcHBseVN0eWxlcywgdGhpcy5sYXlvdXQudGl0bGUuc3R5bGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlLmF0dHIoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBkYXRhIGxheWVyIGZyb20gYSBwcm92aWRlZCBsYXlvdXQgb2JqZWN0LiBTaG91bGQgaGF2ZSB0aGUga2V5cyBzcGVjaWZpZWQgaW4gYERlZmF1bHRMYXlvdXRgXG4gICAgICogV2lsbCBhdXRvbWF0aWNhbGx5IGFkZCBhdCB0aGUgdG9wIChkZXB0aC96LWluZGV4KSBvZiB0aGUgcGFuZWwgdW5sZXNzIGV4cGxpY2l0bHkgZGlyZWN0ZWQgZGlmZmVyZW50bHlcbiAgICAgKiAgIGluIHRoZSBsYXlvdXQgcHJvdmlkZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBhZGREYXRhTGF5ZXIobGF5b3V0KSB7XG5cbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICBpZiAodHlwZW9mIGxheW91dCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGxheW91dC5pZCAhPT0gJ3N0cmluZycgfHwgIWxheW91dC5pZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIGxheWVyIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhX2xheWVyc1tsYXlvdXQuaWRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGRhdGFfbGF5ZXIgd2l0aCBpZCBbJHtsYXlvdXQuaWR9XTsgZGF0YSBsYXllciB3aXRoIHRoYXQgaWQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHBhbmVsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYXlvdXQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIGxheWVyIHR5cGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBsYXlvdXQgZGVmaW5lcyBhIHkgYXhpcyBtYWtlIHN1cmUgdGhlIGF4aXMgbnVtYmVyIGlzIHNldCBhbmQgaXMgMSBvciAyIChkZWZhdWx0IHRvIDEpXG4gICAgICAgIGlmICh0eXBlb2YgbGF5b3V0LnlfYXhpcyA9PSAnb2JqZWN0JyAmJiAodHlwZW9mIGxheW91dC55X2F4aXMuYXhpcyA9PSAndW5kZWZpbmVkJyB8fCAhWzEsIDJdLmluY2x1ZGVzKGxheW91dC55X2F4aXMuYXhpcykpKSB7XG4gICAgICAgICAgICBsYXlvdXQueV9heGlzLmF4aXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBEYXRhIExheWVyXG4gICAgICAgIGNvbnN0IGRhdGFfbGF5ZXIgPSBkYXRhX2xheWVycy5jcmVhdGUobGF5b3V0LnR5cGUsIGxheW91dCwgdGhpcyk7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIERhdGEgTGF5ZXIgb24gdGhlIFBhbmVsXG4gICAgICAgIHRoaXMuZGF0YV9sYXllcnNbZGF0YV9sYXllci5pZF0gPSBkYXRhX2xheWVyO1xuXG4gICAgICAgIC8vIElmIGEgZGlzY3JldGUgel9pbmRleCB3YXMgc2V0IGluIHRoZSBsYXlvdXQgdGhlbiBhZGp1c3Qgb3RoZXIgZGF0YSBsYXllciB6X2luZGV4IHZhbHVlcyB0byBhY2NvbW1vZGF0ZSB0aGlzIG9uZVxuICAgICAgICBpZiAoZGF0YV9sYXllci5sYXlvdXQuel9pbmRleCAhPT0gbnVsbCAmJiAhaXNOYU4oZGF0YV9sYXllci5sYXlvdXQuel9pbmRleClcbiAgICAgICAgICAgICYmIHRoaXMuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBOZWdhdGl2ZSB6X2luZGV4IHZhbHVlcyBzaG91bGQgY291bnQgYmFja3dhcmRzIGZyb20gdGhlIGVuZCwgc28gY29udmVydCBuZWdhdGl2ZXMgdG8gYXBwcm9wcmlhdGUgdmFsdWVzIGhlcmVcbiAgICAgICAgICAgIGlmIChkYXRhX2xheWVyLmxheW91dC56X2luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGRhdGFfbGF5ZXIubGF5b3V0LnpfaW5kZXggPSBNYXRoLm1heCh0aGlzLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXgubGVuZ3RoICsgZGF0YV9sYXllci5sYXlvdXQuel9pbmRleCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXguc3BsaWNlKGRhdGFfbGF5ZXIubGF5b3V0LnpfaW5kZXgsIDAsIGRhdGFfbGF5ZXIuaWQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LmZvckVhY2goKGRsaWQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV9sYXllcnNbZGxpZF0ubGF5b3V0LnpfaW5kZXggPSBpZHg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5wdXNoKGRhdGFfbGF5ZXIuaWQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhX2xheWVyc1tkYXRhX2xheWVyLmlkXS5sYXlvdXQuel9pbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBkYXRhIGxheWVyIHdhcyBhbHJlYWR5IGluIHRoZSBsYXlvdXQuZGF0YV9sYXllcnMgYXJyYXkuXG4gICAgICAgIC8vIElmIGl0IHdhc24ndCwgYWRkIGl0LiBFaXRoZXIgd2F5IHN0b3JlIHRoZSBsYXlvdXQuZGF0YV9sYXllcnMgYXJyYXkgaW5kZXggb24gdGhlIGRhdGFfbGF5ZXIuXG4gICAgICAgIGxldCBsYXlvdXRfaWR4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXlvdXQuZGF0YV9sYXllcnMuZm9yRWFjaCgoZGF0YV9sYXllcl9sYXlvdXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGFfbGF5ZXJfbGF5b3V0LmlkID09PSBkYXRhX2xheWVyLmlkKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0X2lkeCA9IGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsYXlvdXRfaWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgICBsYXlvdXRfaWR4ID0gdGhpcy5sYXlvdXQuZGF0YV9sYXllcnMucHVzaCh0aGlzLmRhdGFfbGF5ZXJzW2RhdGFfbGF5ZXIuaWRdLmxheW91dCkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YV9sYXllcnNbZGF0YV9sYXllci5pZF0ubGF5b3V0X2lkeCA9IGxheW91dF9pZHg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV9sYXllcnNbZGF0YV9sYXllci5pZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZGF0YSBsYXllciBieSBpZFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7UGFuZWx9XG4gICAgICovXG4gICAgcmVtb3ZlRGF0YUxheWVyKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhX2xheWVyc1tpZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlbW92ZSBkYXRhIGxheWVyLCBJRCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXN0cm95IGFsbCB0b29sdGlwcyBmb3IgdGhlIGRhdGEgbGF5ZXJcbiAgICAgICAgdGhpcy5kYXRhX2xheWVyc1tpZF0uZGVzdHJveUFsbFRvb2x0aXBzKCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdmcgY29udGFpbmVyIGZvciB0aGUgZGF0YSBsYXllciBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuZGF0YV9sYXllcnNbaWRdLnN2Zy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YV9sYXllcnNbaWRdLnN2Zy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGUgdGhlIGRhdGEgbGF5ZXIgYW5kIGl0cyBwcmVzZW5jZSBpbiB0aGUgcGFuZWwgbGF5b3V0IGFuZCBzdGF0ZVxuICAgICAgICB0aGlzLmxheW91dC5kYXRhX2xheWVycy5zcGxpY2UodGhpcy5kYXRhX2xheWVyc1tpZF0ubGF5b3V0X2lkeCwgMSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0YXRlW3RoaXMuZGF0YV9sYXllcnNbaWRdLnN0YXRlX2lkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YV9sYXllcnNbaWRdO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZGF0YV9sYXllciBpZCBmcm9tIHRoZSB6X2luZGV4IGFycmF5XG4gICAgICAgIHRoaXMuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5zcGxpY2UodGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LmluZGV4T2YoaWQpLCAxKTtcblxuICAgICAgICAvLyBVcGRhdGUgbGF5b3V0X2lkeCBhbmQgbGF5b3V0LnpfaW5kZXggdmFsdWVzIGZvciBhbGwgcmVtYWluaW5nIGRhdGFfbGF5ZXJzXG4gICAgICAgIHRoaXMuYXBwbHlEYXRhTGF5ZXJaSW5kZXhlc1RvRGF0YUxheWVyTGF5b3V0cygpO1xuICAgICAgICB0aGlzLmxheW91dC5kYXRhX2xheWVycy5mb3JFYWNoKChkYXRhX2xheWVyX2xheW91dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGFfbGF5ZXJzW2RhdGFfbGF5ZXJfbGF5b3V0LmlkXS5sYXlvdXRfaWR4ID0gaWR4O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgc2VsZWN0aW9ucyBvbiBhbGwgZGF0YSBsYXllcnNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIGNsZWFyU2VsZWN0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGFfbGF5ZXJzW2lkXS5zZXRBbGxFbGVtZW50U3RhdHVzKCdzZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByZW5kZXJpbmcgb2YgdGhpcyBwYW5lbCB3aGVuZXZlciBhbiBldmVudCB0cmlnZ2VycyBhIHJlZHJhdy4gQXNzdW1lcyB0aGF0IHRoZSBwYW5lbCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICogICBwcmVwYXJlZCB0aGUgZmlyc3QgdGltZSB2aWEgYGluaXRpYWxpemVgXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtQYW5lbH1cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHBhbmVsIGNvbnRhaW5lclxuICAgICAgICB0aGlzLnN2Zy5jb250YWluZXIuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubGF5b3V0Lm9yaWdpbi54fSwgJHt0aGlzLmxheW91dC5vcmlnaW4ueX0pYCk7XG5cbiAgICAgICAgLy8gU2V0IHNpemUgb24gdGhlIGNsaXAgcmVjdFxuICAgICAgICB0aGlzLnN2Zy5jbGlwUmVjdFxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5sYXlvdXQud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5sYXlvdXQuaGVpZ2h0KTtcblxuICAgICAgICAvLyBTZXQgYW5kIHBvc2l0aW9uIHRoZSBpbm5lciBib3JkZXIsIHN0eWxlIGlmIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLmlubmVyX2JvcmRlclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLmxheW91dC5tYXJnaW4ubGVmdClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy5sYXlvdXQubWFyZ2luLnRvcClcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMubGF5b3V0LndpZHRoIC0gKHRoaXMubGF5b3V0Lm1hcmdpbi5sZWZ0ICsgdGhpcy5sYXlvdXQubWFyZ2luLnJpZ2h0KSlcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmxheW91dC5oZWlnaHQgLSAodGhpcy5sYXlvdXQubWFyZ2luLnRvcCArIHRoaXMubGF5b3V0Lm1hcmdpbi5ib3R0b20pKTtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LmlubmVyX2JvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lcl9ib3JkZXJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLmxheW91dC5pbm5lcl9ib3JkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0L3VwZGF0ZSBwYW5lbCB0aXRsZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5zZXRUaXRsZSgpO1xuXG4gICAgICAgIC8vIFJlZ2VuZXJhdGUgYWxsIGV4dGVudHNcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV4dGVudHMoKTtcblxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGFueSBwcm9jZWR1cmFsbHkgZ2VuZXJhdGVkIHZlY3RvcnMgKGUuZy4gcmFuZ2VzLCBleHRlbnRzKVxuICAgICAgICAvLyBDb25zdHJhaW50cyBhcHBsaWVkIGhlcmUga2VlcCB2ZWN0b3JzIGZyb20gZ29pbmcgdG8gaW5maW5pdHkgb3IgYmV5b25kIGEgZGVmaW5hYmxlIHBvd2VyIG9mIHRlblxuICAgICAgICBjb25zdCBjb25zdHJhaW4gPSBmdW5jdGlvbiAodmFsdWUsIGxpbWl0X2V4cG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBuZWdfbWluID0gTWF0aC5wb3coLTEwLCBsaW1pdF9leHBvbmVudCk7XG4gICAgICAgICAgICBjb25zdCBuZWdfbWF4ID0gTWF0aC5wb3coLTEwLCAtbGltaXRfZXhwb25lbnQpO1xuICAgICAgICAgICAgY29uc3QgcG9zX21pbiA9IE1hdGgucG93KDEwLCAtbGltaXRfZXhwb25lbnQpO1xuICAgICAgICAgICAgY29uc3QgcG9zX21heCA9IE1hdGgucG93KDEwLCBsaW1pdF9leHBvbmVudCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwb3NfbWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ19taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBvc19taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgcG9zX21heCksIHBvc19taW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG5lZ19tYXgpLCBuZWdfbWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWZpbmUgZGVmYXVsdCBhbmQgc2hpZnRlZCByYW5nZXMgZm9yIGFsbCBheGVzXG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy54X2V4dGVudCkge1xuICAgICAgICAgICAgY29uc3QgYmFzZV94X3JhbmdlID0geyBzdGFydDogMCwgZW5kOiB0aGlzLmxheW91dC5jbGlwYXJlYS53aWR0aCB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LmF4ZXMueC5yYW5nZSkge1xuICAgICAgICAgICAgICAgIGJhc2VfeF9yYW5nZS5zdGFydCA9IHRoaXMubGF5b3V0LmF4ZXMueC5yYW5nZS5zdGFydCB8fCBiYXNlX3hfcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgYmFzZV94X3JhbmdlLmVuZCA9IHRoaXMubGF5b3V0LmF4ZXMueC5yYW5nZS5lbmQgfHwgYmFzZV94X3JhbmdlLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlcy54ID0gW2Jhc2VfeF9yYW5nZS5zdGFydCwgYmFzZV94X3JhbmdlLmVuZF07XG4gICAgICAgICAgICByYW5nZXMueF9zaGlmdGVkID0gW2Jhc2VfeF9yYW5nZS5zdGFydCwgYmFzZV94X3JhbmdlLmVuZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueTFfZXh0ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlX3kxX3JhbmdlID0geyBzdGFydDogdGhpcy5sYXlvdXQuY2xpcGFyZWEuaGVpZ2h0LCBlbmQ6IDAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5heGVzLnkxLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgYmFzZV95MV9yYW5nZS5zdGFydCA9IHRoaXMubGF5b3V0LmF4ZXMueTEucmFuZ2Uuc3RhcnQgfHwgYmFzZV95MV9yYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICBiYXNlX3kxX3JhbmdlLmVuZCA9IHRoaXMubGF5b3V0LmF4ZXMueTEucmFuZ2UuZW5kIHx8IGJhc2VfeTFfcmFuZ2UuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2VzLnkxID0gW2Jhc2VfeTFfcmFuZ2Uuc3RhcnQsIGJhc2VfeTFfcmFuZ2UuZW5kXTtcbiAgICAgICAgICAgIHJhbmdlcy55MV9zaGlmdGVkID0gW2Jhc2VfeTFfcmFuZ2Uuc3RhcnQsIGJhc2VfeTFfcmFuZ2UuZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy55Ml9leHRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VfeTJfcmFuZ2UgPSB7IHN0YXJ0OiB0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQsIGVuZDogMCB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LmF4ZXMueTIucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBiYXNlX3kyX3JhbmdlLnN0YXJ0ID0gdGhpcy5sYXlvdXQuYXhlcy55Mi5yYW5nZS5zdGFydCB8fCBiYXNlX3kyX3JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGJhc2VfeTJfcmFuZ2UuZW5kID0gdGhpcy5sYXlvdXQuYXhlcy55Mi5yYW5nZS5lbmQgfHwgYmFzZV95Ml9yYW5nZS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZXMueTIgPSBbYmFzZV95Ml9yYW5nZS5zdGFydCwgYmFzZV95Ml9yYW5nZS5lbmRdO1xuICAgICAgICAgICAgcmFuZ2VzLnkyX3NoaWZ0ZWQgPSBbYmFzZV95Ml9yYW5nZS5zdGFydCwgYmFzZV95Ml9yYW5nZS5lbmRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hpZnQgcmFuZ2VzIGJhc2VkIG9uIGFueSBkcmFnIG9yIHpvb20gaW50ZXJhY3Rpb25zIGN1cnJlbnRseSB1bmRlcndheVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24ucGFuZWxfaWQgJiYgKHRoaXMucGFyZW50LmludGVyYWN0aW9uLnBhbmVsX2lkID09PSB0aGlzLmlkIHx8IHRoaXMucGFyZW50LmludGVyYWN0aW9uLmxpbmtlZF9wYW5lbF9pZHMuaW5jbHVkZXModGhpcy5pZCkpKSB7XG4gICAgICAgICAgICBsZXQgYW5jaG9yLCBzY2FsYXIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmludGVyYWN0aW9uLnpvb21pbmcgJiYgdHlwZW9mIHRoaXMueF9zY2FsZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudF9leHRlbnRfc2l6ZSA9IE1hdGguYWJzKHRoaXMueF9leHRlbnRbMV0gLSB0aGlzLnhfZXh0ZW50WzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50X3NjYWxlZF9leHRlbnRfc2l6ZSA9IE1hdGgucm91bmQodGhpcy54X3NjYWxlLmludmVydChyYW5nZXMueF9zaGlmdGVkWzFdKSkgLSBNYXRoLnJvdW5kKHRoaXMueF9zY2FsZS5pbnZlcnQocmFuZ2VzLnhfc2hpZnRlZFswXSkpO1xuICAgICAgICAgICAgICAgIGxldCB6b29tX2ZhY3RvciA9IHRoaXMucGFyZW50LmludGVyYWN0aW9uLnpvb21pbmcuc2NhbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsX2V4dGVudF9zaXplID0gTWF0aC5mbG9vcihjdXJyZW50X3NjYWxlZF9leHRlbnRfc2l6ZSAqICgxIC8gem9vbV9mYWN0b3IpKTtcbiAgICAgICAgICAgICAgICBpZiAoem9vbV9mYWN0b3IgPCAxICYmICFpc05hTih0aGlzLnBhcmVudC5sYXlvdXQubWF4X3JlZ2lvbl9zY2FsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbV9mYWN0b3IgPSAxIC8gKE1hdGgubWluKHBvdGVudGlhbF9leHRlbnRfc2l6ZSwgdGhpcy5wYXJlbnQubGF5b3V0Lm1heF9yZWdpb25fc2NhbGUpIC8gY3VycmVudF9zY2FsZWRfZXh0ZW50X3NpemUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoem9vbV9mYWN0b3IgPiAxICYmICFpc05hTih0aGlzLnBhcmVudC5sYXlvdXQubWluX3JlZ2lvbl9zY2FsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbV9mYWN0b3IgPSAxIC8gKE1hdGgubWF4KHBvdGVudGlhbF9leHRlbnRfc2l6ZSwgdGhpcy5wYXJlbnQubGF5b3V0Lm1pbl9yZWdpb25fc2NhbGUpIC8gY3VycmVudF9zY2FsZWRfZXh0ZW50X3NpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdfZXh0ZW50X3NpemUgPSBNYXRoLmZsb29yKGN1cnJlbnRfZXh0ZW50X3NpemUgKiB6b29tX2ZhY3Rvcik7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24uem9vbWluZy5jZW50ZXIgLSB0aGlzLmxheW91dC5tYXJnaW4ubGVmdCAtIHRoaXMubGF5b3V0Lm9yaWdpbi54O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldF9yYXRpbyA9IGFuY2hvciAvIHRoaXMubGF5b3V0LmNsaXBhcmVhLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld194X2V4dGVudF9zdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy54X3NjYWxlLmludmVydChyYW5nZXMueF9zaGlmdGVkWzBdKSAtICgobmV3X2V4dGVudF9zaXplIC0gY3VycmVudF9zY2FsZWRfZXh0ZW50X3NpemUpICogb2Zmc2V0X3JhdGlvKSksIDEpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy54X3NoaWZ0ZWQgPSBbIHRoaXMueF9zY2FsZShuZXdfeF9leHRlbnRfc3RhcnQpLCB0aGlzLnhfc2NhbGUobmV3X3hfZXh0ZW50X3N0YXJ0ICsgbmV3X2V4dGVudF9zaXplKSBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24uZHJhZ2dpbmcubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcy54X3NoaWZ0ZWRbMF0gPSArdGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24uZHJhZ2dpbmcuZHJhZ2dlZF94O1xuICAgICAgICAgICAgICAgICAgICByYW5nZXMueF9zaGlmdGVkWzFdID0gdGhpcy5sYXlvdXQuY2xpcGFyZWEud2lkdGggKyB0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZy5kcmFnZ2VkX3g7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3hfdGljayc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudCAmJiBkMy5ldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnhfc2hpZnRlZFswXSA9ICt0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZy5kcmFnZ2VkX3g7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMueF9zaGlmdGVkWzFdID0gdGhpcy5sYXlvdXQuY2xpcGFyZWEud2lkdGggKyB0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZy5kcmFnZ2VkX3g7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZy5zdGFydF94IC0gdGhpcy5sYXlvdXQubWFyZ2luLmxlZnQgLSB0aGlzLmxheW91dC5vcmlnaW4ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxhciA9IGNvbnN0cmFpbihhbmNob3IgLyAoYW5jaG9yICsgdGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24uZHJhZ2dpbmcuZHJhZ2dlZF94KSwgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMueF9zaGlmdGVkWzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy54X3NoaWZ0ZWRbMV0gPSBNYXRoLm1heCh0aGlzLmxheW91dC5jbGlwYXJlYS53aWR0aCAqICgxIC8gc2NhbGFyKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneTFfdGljayc6XG4gICAgICAgICAgICAgICAgY2FzZSAneTJfdGljayc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeV9zaGlmdGVkID0gYHkke3RoaXMucGFyZW50LmludGVyYWN0aW9uLmRyYWdnaW5nLm1ldGhvZFsxXX1fc2hpZnRlZGA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudCAmJiBkMy5ldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzW3lfc2hpZnRlZF1bMF0gPSB0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQgKyB0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZy5kcmFnZ2VkX3k7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXNbeV9zaGlmdGVkXVsxXSA9ICt0aGlzLnBhcmVudC5pbnRlcmFjdGlvbi5kcmFnZ2luZy5kcmFnZ2VkX3k7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQgLSAodGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24uZHJhZ2dpbmcuc3RhcnRfeSAtIHRoaXMubGF5b3V0Lm1hcmdpbi50b3AgLSB0aGlzLmxheW91dC5vcmlnaW4ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsYXIgPSBjb25zdHJhaW4oYW5jaG9yIC8gKGFuY2hvciAtIHRoaXMucGFyZW50LmludGVyYWN0aW9uLmRyYWdnaW5nLmRyYWdnZWRfeSksIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzW3lfc2hpZnRlZF1bMF0gPSB0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXNbeV9zaGlmdGVkXVsxXSA9IHRoaXMubGF5b3V0LmNsaXBhcmVhLmhlaWdodCAtICh0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQgKiAoMSAvIHNjYWxhcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHNjYWxlcyBhbmQgdGlja3MgZm9yIGFsbCBheGVzLCB0aGVuIHJlbmRlciB0aGVtXG4gICAgICAgIFsneCcsICd5MScsICd5MiddLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpc1tgJHtheGlzfV9leHRlbnRgXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmFzZSBTY2FsZVxuICAgICAgICAgICAgdGhpc1tgJHtheGlzfV9zY2FsZWBdID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgIC5kb21haW4odGhpc1tgJHtheGlzfV9leHRlbnRgXSlcbiAgICAgICAgICAgICAgICAucmFuZ2UocmFuZ2VzW2Ake2F4aXN9X3NoaWZ0ZWRgXSk7XG5cbiAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSBleHRlbnRcbiAgICAgICAgICAgIHRoaXNbYCR7YXhpc31fZXh0ZW50YF0gPSBbXG4gICAgICAgICAgICAgICAgdGhpc1tgJHtheGlzfV9zY2FsZWBdLmludmVydChyYW5nZXNbYXhpc11bMF0pLFxuICAgICAgICAgICAgICAgIHRoaXNbYCR7YXhpc31fc2NhbGVgXS5pbnZlcnQocmFuZ2VzW2F4aXNdWzFdKSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIEZpbmFsaXplIFNjYWxlXG4gICAgICAgICAgICB0aGlzW2Ake2F4aXN9X3NjYWxlYF0gPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbih0aGlzW2Ake2F4aXN9X2V4dGVudGBdKS5yYW5nZShyYW5nZXNbYXhpc10pO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgYXhpcyAoYW5kIGdlbmVyYXRlIHRpY2tzIGFzIG5lZWRlZClcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQXhpcyhheGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRXN0YWJsaXNoIG1vdXNld2hlZWwgem9vbSBldmVudCBoYW5kZXJzIG9uIHRoZSBwYW5lbCAobmFtZXNwYWNpbmcgbm90IHBhc3NlZCB0aHJvdWdoIGJ5IGQzLCBzbyBub3QgdXNlZCBoZXJlKVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQuaW50ZXJhY3Rpb24uc2Nyb2xsX3RvX3pvb20pIHtcbiAgICAgICAgICAgIGNvbnN0IHpvb21faGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBhIHNoaWZ0IGtleSBwcmVzcyB3aGlsZSBzY3JvbGxpbmcgdG8gZXhlY3V0ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgcHJlc2VudCwgZ3JhY2VmdWxseSByYWlzZSBhIG5vdGlmaWNhdGlvbiBhbmQgYWxsb3cgY29udmVudGlvbmFsIHNjcm9sbGluZ1xuICAgICAgICAgICAgICAgIGlmICghKGQzLmV2ZW50LnNoaWZ0S2V5IHx8IGQzLmV2ZW50LmFsdEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Ll9jYW5JbnRlcmFjdCh0aGlzLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZXIuc2hvdygnUHJlc3MgPHR0PltTSElGVF08L3R0PiBvciA8dHQ+W0FMVF08L3R0PiB3aGlsZSBzY3JvbGxpbmcgdG8gem9vbScpLmhpZGUoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQuX2NhbkludGVyYWN0KHRoaXMuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZDMubW91c2UodGhpcy5zdmcuY29udGFpbmVyLm5vZGUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgKGQzLmV2ZW50LndoZWVsRGVsdGEgfHwgLWQzLmV2ZW50LmRldGFpbCB8fCAtZDMuZXZlbnQuZGVsdGFZKSkpO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbF9pZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkX3BhbmVsX2lkczogdGhpcy5nZXRMaW5rZWRQYW5lbElkcygneCcpLFxuICAgICAgICAgICAgICAgICAgICB6b29taW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogKGRlbHRhIDwgMSkgPyAwLjkgOiAxLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IGNvb3Jkc1swXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW50ZXJhY3Rpb24ubGlua2VkX3BhbmVsX2lkcy5mb3JFYWNoKChwYW5lbF9pZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wYW5lbHNbcGFuZWxfaWRdLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnpvb21fdGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy56b29tX3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnpvb21fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnRlcmFjdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBseVN0YXRlKHsgc3RhcnQ6IHRoaXMueF9leHRlbnRbMF0sIGVuZDogdGhpcy54X2V4dGVudFsxXSB9KTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBDb25zaWRlciBtb3ZpbmcgYmFjayB0byBkMy56b29tIGFuZCByZXdyaXRpbmcgZHJhZyArIHpvb20gdG8gdXNlIGJlaGF2aW9ycy5cbiAgICAgICAgICAgIHRoaXMuc3ZnLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5vbignd2hlZWwuem9vbScsIHpvb21faGFuZGxlcilcbiAgICAgICAgICAgICAgICAub24oJ21vdXNld2hlZWwuem9vbScsIHpvb21faGFuZGxlcilcbiAgICAgICAgICAgICAgICAub24oJ0RPTU1vdXNlU2Nyb2xsLnpvb20nLCB6b29tX2hhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGRhdGEgbGF5ZXJzIGluIG9yZGVyIGJ5IHotaW5kZXhcbiAgICAgICAgdGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LmZvckVhY2goKGRhdGFfbGF5ZXJfaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YV9sYXllcnNbZGF0YV9sYXllcl9pZF0uZHJhdygpLnJlbmRlcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBcImJhc2ljXCIgbG9hZGVyIHRvIGEgcGFuZWxcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBqdXN0IGEgc2hvcnRjdXQgZm9yIGFkZGluZyB0aGUgbW9zdCBjb21tb25seSB1c2VkIHR5cGUgb2YgbG9hZGluZyBpbmRpY2F0b3IsIHdoaWNoIGFwcGVhcnMgd2hlblxuICAgICAqICAgZGF0YSBpcyByZXF1ZXN0ZWQsIGFuaW1hdGVzIChlLmcuIHNob3dzIGFuIGluZmluaXRlbHkgY3ljbGluZyBwcm9ncmVzcyBiYXIgYXMgb3Bwb3NlZCB0byBvbmUgdGhhdCBsb2FkcyBmcm9tXG4gICAgICogICAwLTEwMCUgYmFzZWQgb24gYWN0dWFsIGxvYWQgcHJvZ3Jlc3MpLCBhbmQgZGlzYXBwZWFycyB3aGVuIG5ldyBkYXRhIGlzIGxvYWRlZCBhbmQgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG93X2ltbWVkaWF0ZWx5XG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIGFkZEJhc2ljTG9hZGVyKHNob3dfaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaG93X2ltbWVkaWF0ZWx5ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaG93X2ltbWVkaWF0ZWx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd19pbW1lZGlhdGVseSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuc2hvdygnTG9hZGluZy4uLicpLmFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKCdkYXRhX3JlcXVlc3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLnNob3coJ0xvYWRpbmcuLi4nKS5hbmltYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdkYXRhX3JlbmRlcmVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuaGlkZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKiogUHJpdmF0ZSBpbnRlcmZhY2U6IG9ubHkgdXNlZCBpbnRlcm5hbGx5ICovXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgYXBwbHlEYXRhTGF5ZXJaSW5kZXhlc1RvRGF0YUxheWVyTGF5b3V0cyAoKSB7XG4gICAgICAgIHRoaXMuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5mb3JFYWNoKChkbGlkLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YV9sYXllcnNbZGxpZF0ubGF5b3V0LnpfaW5kZXggPSBpZHg7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCYXNlSWQgKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5wYXJlbnQuaWR9LiR7dGhpcy5pZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgcGFuZWwncyBvcmlnaW4gaW4gdGVybXMgb2YgdGhlIGVudGlyZSBwYWdlXG4gICAgICogTmVjZXNzYXJ5IGZvciBwb3NpdGlvbmluZyBhbnkgSFRNTCBlbGVtZW50cyBvdmVyIHRoZSBwYW5lbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19XG4gICAgICovXG4gICAgX2dldFBhZ2VPcmlnaW4oKSB7XG4gICAgICAgIGNvbnN0IHBsb3Rfb3JpZ2luID0gdGhpcy5wYXJlbnQuX2dldFBhZ2VPcmlnaW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBsb3Rfb3JpZ2luLnggKyB0aGlzLmxheW91dC5vcmlnaW4ueCxcbiAgICAgICAgICAgIHk6IHBsb3Rfb3JpZ2luLnkgKyB0aGlzLmxheW91dC5vcmlnaW4ueSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBwYW5lbCBmb3IgZmlyc3QgdXNlIGJ5IHBlcmZvcm1pbmcgcGFyYW1ldGVyIHZhbGlkYXRpb24sIGNyZWF0aW5nIGF4ZXMsIHNldHRpbmcgZGVmYXVsdCBkaW1lbnNpb25zLFxuICAgICAqICAgYW5kIHByZXBhcmluZyAvIHBvc2l0aW9uaW5nIGRhdGEgbGF5ZXJzIGFzIGFwcHJvcHJpYXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIGluaXRpYWxpemVMYXlvdXQoKSB7XG5cbiAgICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBtaXNzaW5nIEJPVEggd2lkdGggYW5kIHByb3BvcnRpb25hbCB3aWR0aCB0aGVuIHNldCB0aGUgcHJvcG9ydGlvbmFsIHdpZHRoIHRvIDEuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBkZWZhdWx0IHRoZSBwYW5lbCB0byB0YWtpbmcgdXAgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIHBsb3QuXG4gICAgICAgIGlmICh0aGlzLmxheW91dC53aWR0aCA9PT0gMCAmJiB0aGlzLmxheW91dC5wcm9wb3J0aW9uYWxfd2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnByb3BvcnRpb25hbF93aWR0aCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGlzIG1pc3NpbmcgQk9USCBoZWlnaHQgYW5kIHByb3BvcnRpb25hbCBoZWlnaHQgdGhlbiBzZXQgdGhlIHByb3BvcnRpb25hbCBoZWlnaHQgdG9cbiAgICAgICAgLy8gYW4gZXF1YWwgc2hhcmUgb2YgdGhlIHBsb3QncyBjdXJyZW50IGhlaWdodC5cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LmhlaWdodCA9PT0gMCAmJiB0aGlzLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwYW5lbF9jb3VudCA9IE9iamVjdC5rZXlzKHRoaXMucGFyZW50LnBhbmVscykubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhbmVsX2NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnByb3BvcnRpb25hbF9oZWlnaHQgPSAoMSAvIHBhbmVsX2NvdW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQucHJvcG9ydGlvbmFsX2hlaWdodCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgcGFuZWwgZGltZW5zaW9ucywgb3JpZ2luLCBhbmQgbWFyZ2luXG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldE9yaWdpbigpO1xuICAgICAgICB0aGlzLnNldE1hcmdpbigpO1xuXG4gICAgICAgIC8vIFNldCByYW5nZXNcbiAgICAgICAgLy8gVE9ETzogRGVmaW5lIHN0dWIgdmFsdWVzIGluIGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMueF9yYW5nZSA9IFswLCB0aGlzLmxheW91dC5jbGlwYXJlYS53aWR0aF07XG4gICAgICAgIHRoaXMueTFfcmFuZ2UgPSBbdGhpcy5sYXlvdXQuY2xpcGFyZWEuaGVpZ2h0LCAwXTtcbiAgICAgICAgdGhpcy55Ml9yYW5nZSA9IFt0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQsIDBdO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgcGFuZWwgYXhlc1xuICAgICAgICBbJ3gnLCAneTEnLCAneTInXS5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubGF5b3V0LmF4ZXNbYXhpc10pLmxlbmd0aCB8fCB0aGlzLmxheW91dC5heGVzW2F4aXNdLnJlbmRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBsYXlvdXQgc2V0cyB0aGUgYXhpcyB0byBhbiBlbXB0eSBvYmplY3QsIHNvIHNldCBpdHMgcmVuZGVyIGJvb2xlYW4gaGVyZVxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmF4ZXNbYXhpc10ucmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmF4ZXNbYXhpc10ucmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5heGVzW2F4aXNdLmxhYmVsID0gdGhpcy5sYXlvdXQuYXhlc1theGlzXS5sYWJlbCB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgZGF0YSBsYXllcnMgKHdoaWNoIGRlZmluZSB4IGFuZCB5IGV4dGVudHMpXG4gICAgICAgIHRoaXMubGF5b3V0LmRhdGFfbGF5ZXJzLmZvckVhY2goKGRhdGFfbGF5ZXJfbGF5b3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGFMYXllcihkYXRhX2xheWVyX2xheW91dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGltZW5zaW9ucyBmb3IgdGhlIHBhbmVsLiBJZiBwYXNzZWQgd2l0aCBubyBhcmd1bWVudHMgd2lsbCBjYWxjdWxhdGUgb3B0aW1hbCBzaXplIGJhc2VkIG9uIGxheW91dFxuICAgICAqICAgZGlyZWN0aXZlcyBhbmQgdGhlIGF2YWlsYWJsZSBhcmVhIHdpdGhpbiB0aGUgcGxvdC4gSWYgcGFzc2VkIGRpc2NyZXRlIHdpZHRoIChudW1iZXIpIGFuZCBoZWlnaHQgKG51bWJlcikgd2lsbFxuICAgICAqICAgYXR0ZW1wdCB0byByZXNpemUgdGhlIHBhbmVsIHRvIHRoZW0sIGJ1dCBtYXkgYmUgbGltaXRlZCBieSBtaW5pbXVtIGRpbWVuc2lvbnMgZGVmaW5lZCBvbiB0aGUgcGxvdCBvciBwYW5lbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF1cbiAgICAgKiBAcmV0dXJucyB7UGFuZWx9XG4gICAgICovXG4gICAgc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGhlaWdodCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKCFpc05hTih3aWR0aCkgJiYgd2lkdGggPj0gMCAmJiAhaXNOYU4oaGVpZ2h0KSAmJiBoZWlnaHQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LndpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZCgrd2lkdGgpLCB0aGlzLmxheW91dC5taW5fd2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmhlaWdodCA9IE1hdGgubWF4KE1hdGgucm91bmQoK2hlaWdodCksIHRoaXMubGF5b3V0Lm1pbl9oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnByb3BvcnRpb25hbF93aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LndpZHRoID0gTWF0aC5tYXgodGhpcy5sYXlvdXQucHJvcG9ydGlvbmFsX3dpZHRoICogdGhpcy5wYXJlbnQubGF5b3V0LndpZHRoLCB0aGlzLmxheW91dC5taW5fd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnByb3BvcnRpb25hbF9oZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ICogdGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodCwgdGhpcy5sYXlvdXQubWluX2hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXlvdXQuY2xpcGFyZWEud2lkdGggPSBNYXRoLm1heCh0aGlzLmxheW91dC53aWR0aCAtICh0aGlzLmxheW91dC5tYXJnaW4ubGVmdCArIHRoaXMubGF5b3V0Lm1hcmdpbi5yaWdodCksIDApO1xuICAgICAgICB0aGlzLmxheW91dC5jbGlwYXJlYS5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmxheW91dC5oZWlnaHQgLSAodGhpcy5sYXlvdXQubWFyZ2luLnRvcCArIHRoaXMubGF5b3V0Lm1hcmdpbi5ib3R0b20pLCAwKTtcbiAgICAgICAgaWYgKHRoaXMuc3ZnLmNsaXBSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnN2Zy5jbGlwUmVjdFxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMubGF5b3V0LndpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmxheW91dC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5jdXJ0YWluLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2xiYXIudXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5wb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBwYW5lbCBvcmlnaW4gb24gdGhlIHBsb3QsIGFuZCByZS1yZW5kZXIgYXMgYXBwcm9wcmlhdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtQYW5lbH1cbiAgICAgKi9cbiAgICBzZXRPcmlnaW4oeCwgeSkge1xuICAgICAgICBpZiAoIWlzTmFOKHgpICYmIHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQub3JpZ2luLnggPSBNYXRoLm1heChNYXRoLnJvdW5kKCt4KSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTih5KSAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm9yaWdpbi55ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCgreSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBtYXJnaW5zIGFyb3VuZCB0aGlzIHBhbmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIHNldE1hcmdpbih0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpIHtcbiAgICAgICAgbGV0IGV4dHJhO1xuICAgICAgICBpZiAoIWlzTmFOKHRvcCkgICAgJiYgdG9wICAgID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm1hcmdpbi50b3AgPSBNYXRoLm1heChNYXRoLnJvdW5kKCt0b3ApLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKHJpZ2h0KSAgJiYgcmlnaHQgID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm1hcmdpbi5yaWdodCA9IE1hdGgubWF4KE1hdGgucm91bmQoK3JpZ2h0KSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihib3R0b20pICYmIGJvdHRvbSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5tYXJnaW4uYm90dG9tID0gTWF0aC5tYXgoTWF0aC5yb3VuZCgrYm90dG9tKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihsZWZ0KSAgICYmIGxlZnQgICA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5tYXJnaW4ubGVmdCA9IE1hdGgubWF4KE1hdGgucm91bmQoK2xlZnQpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQubWFyZ2luLnRvcCArIHRoaXMubGF5b3V0Lm1hcmdpbi5ib3R0b20gPiB0aGlzLmxheW91dC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGV4dHJhID0gTWF0aC5mbG9vcigoKHRoaXMubGF5b3V0Lm1hcmdpbi50b3AgKyB0aGlzLmxheW91dC5tYXJnaW4uYm90dG9tKSAtIHRoaXMubGF5b3V0LmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm1hcmdpbi50b3AgLT0gZXh0cmE7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5tYXJnaW4uYm90dG9tIC09IGV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5tYXJnaW4ubGVmdCArIHRoaXMubGF5b3V0Lm1hcmdpbi5yaWdodCA+IHRoaXMubGF5b3V0LndpZHRoKSB7XG4gICAgICAgICAgICBleHRyYSA9IE1hdGguZmxvb3IoKCh0aGlzLmxheW91dC5tYXJnaW4ubGVmdCArIHRoaXMubGF5b3V0Lm1hcmdpbi5yaWdodCkgLSB0aGlzLmxheW91dC53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm1hcmdpbi5sZWZ0IC09IGV4dHJhO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQubWFyZ2luLnJpZ2h0IC09IGV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQubWFyZ2luW21dID0gTWF0aC5tYXgodGhpcy5sYXlvdXQubWFyZ2luW21dLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGF5b3V0LmNsaXBhcmVhLndpZHRoID0gTWF0aC5tYXgodGhpcy5sYXlvdXQud2lkdGggLSAodGhpcy5sYXlvdXQubWFyZ2luLmxlZnQgKyB0aGlzLmxheW91dC5tYXJnaW4ucmlnaHQpLCAwKTtcbiAgICAgICAgdGhpcy5sYXlvdXQuY2xpcGFyZWEuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5sYXlvdXQuaGVpZ2h0IC0gKHRoaXMubGF5b3V0Lm1hcmdpbi50b3AgKyB0aGlzLmxheW91dC5tYXJnaW4uYm90dG9tKSwgMCk7XG4gICAgICAgIHRoaXMubGF5b3V0LmNsaXBhcmVhLm9yaWdpbi54ID0gdGhpcy5sYXlvdXQubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMubGF5b3V0LmNsaXBhcmVhLm9yaWdpbi55ID0gdGhpcy5sYXlvdXQubWFyZ2luLnRvcDtcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBmaXJzdCByZW5kZXJpbmcgb2YgdGhlIHBhbmVsLiBUaGlzIGluY2x1ZGVzIGRyYXdpbmcgdGhlIGluZGl2aWR1YWwgZGF0YSBsYXllcnMsIGJ1dCBhbHNvIGNyZWF0ZXMgc2hhcmVkXG4gICAgICogICBlbGVtZW50cyBzdWNoIGFzIGF4ZXMsICB0aXRsZSwgYW5kIGxvYWRlci9jdXJ0YWluLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKSB7XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgY29udGFpbmVyIGdyb3VwIGVsZW1lbnQgdG8gaG91c2UgdGhlIG1haW4gcGFuZWwgZ3JvdXAgZWxlbWVudCBhbmQgdGhlIGNsaXAgcGF0aFxuICAgICAgICAvLyBQb3NpdGlvbiB3aXRoIGluaXRpYWwgbGF5b3V0IHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgYmFzZV9pZCA9IHRoaXMuZ2V0QmFzZUlkKCk7XG4gICAgICAgIHRoaXMuc3ZnLmNvbnRhaW5lciA9IHRoaXMucGFyZW50LnN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7YmFzZV9pZH0ucGFuZWxfY29udGFpbmVyYClcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5sYXlvdXQub3JpZ2luLnggfHwgMH0sICR7dGhpcy5sYXlvdXQub3JpZ2luLnkgfHwgMH0pYCk7XG5cbiAgICAgICAgLy8gQXBwZW5kIGNsaXAgcGF0aCB0byB0aGUgcGFyZW50IHN2ZyBlbGVtZW50LCBzaXplIHdpdGggaW5pdGlhbCBsYXlvdXQgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBjbGlwUGF0aCA9IHRoaXMuc3ZnLmNvbnRhaW5lci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGAke2Jhc2VfaWR9LmNsaXBgKTtcbiAgICAgICAgdGhpcy5zdmcuY2xpcFJlY3QgPSBjbGlwUGF0aC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5sYXlvdXQud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5sYXlvdXQuaGVpZ2h0KTtcblxuICAgICAgICAvLyBBcHBlbmQgc3ZnIGdyb3VwIGZvciByZW5kZXJpbmcgYWxsIHBhbmVsIGNoaWxkIGVsZW1lbnRzLCBjbGlwcGVkIGJ5IHRoZSBjbGlwIHBhdGhcbiAgICAgICAgdGhpcy5zdmcuZ3JvdXAgPSB0aGlzLnN2Zy5jb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGAke2Jhc2VfaWR9LnBhbmVsYClcbiAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCBgdXJsKCMke2Jhc2VfaWR9LmNsaXApYCk7XG5cbiAgICAgICAgLy8gQWRkIGN1cnRhaW4gYW5kIGxvYWRlciBwcm90b3R5cGVzIHRvIHRoZSBwYW5lbFxuICAgICAgICAvKiogQG1lbWJlciB7T2JqZWN0fSAqL1xuICAgICAgICB0aGlzLmN1cnRhaW4gPSBnZW5lcmF0ZUN1cnRhaW4uY2FsbCh0aGlzKTtcbiAgICAgICAgLyoqIEBtZW1iZXIge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5sb2FkZXIgPSBnZW5lcmF0ZUxvYWRlci5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIHRvb2xiYXIgb2JqZWN0IGFuZCBoYW5nIHdpZGdldHMgb24gaXQgYXMgZGVmaW5lZCBieSBwYW5lbCBsYXlvdXRcbiAgICAgICAgICogQG1lbWJlciB7VG9vbGJhcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyBUb29sYmFyKHRoaXMpO1xuXG4gICAgICAgIC8vIElubmVyIGJvcmRlclxuICAgICAgICB0aGlzLmlubmVyX2JvcmRlciA9IHRoaXMuc3ZnLmdyb3VwLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotcGFuZWwtYmFja2dyb3VuZCcpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5iYWNrZ3JvdW5kX2NsaWNrID09PSAnY2xlYXJfc2VsZWN0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIHRpdGxlXG4gICAgICAgIC8qKiBAbWVtYmVyIHtFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gdGhpcy5zdmcuZ3JvdXAuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbHotcGFuZWwtdGl0bGUnKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxheW91dC50aXRsZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zZXRUaXRsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBBeGVzXG4gICAgICAgIHRoaXMuc3ZnLnhfYXhpcyA9IHRoaXMuc3ZnLmdyb3VwLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignaWQnLCBgJHtiYXNlX2lkfS54X2F4aXNgKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LXggbHotYXhpcycpO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQuYXhlcy54LnJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5zdmcueF9heGlzX2xhYmVsID0gdGhpcy5zdmcueF9heGlzLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LXggbHotYXhpcyBsei1sYWJlbCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnLnkxX2F4aXMgPSB0aGlzLnN2Zy5ncm91cC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7YmFzZV9pZH0ueTFfYXhpc2ApLmF0dHIoJ2NsYXNzJywgJ2x6LXkgbHoteTEgbHotYXhpcycpO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQuYXhlcy55MS5yZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnkxX2F4aXNfbGFiZWwgPSB0aGlzLnN2Zy55MV9heGlzLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LXkxIGx6LWF4aXMgbHotbGFiZWwnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN2Zy55Ml9heGlzID0gdGhpcy5zdmcuZ3JvdXAuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGAke2Jhc2VfaWR9LnkyX2F4aXNgKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LXkgbHoteTIgbHotYXhpcycpO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQuYXhlcy55Mi5yZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnkyX2F4aXNfbGFiZWwgPSB0aGlzLnN2Zy55Ml9heGlzLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LXkyIGx6LWF4aXMgbHotbGFiZWwnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgY2hpbGQgRGF0YSBMYXllcnNcbiAgICAgICAgdGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGFfbGF5ZXJzW2lkXS5pbml0aWFsaXplKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdlbmQgb2JqZWN0LCBhcyBkZWZpbmVkIGJ5IHBhbmVsIGxheW91dCBhbmQgY2hpbGQgZGF0YSBsYXllciBsYXlvdXRzXG4gICAgICAgICAqIEBtZW1iZXIge0xlZ2VuZH1cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5sZWdlbmQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQubGVnZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFc3RhYmxpc2ggcGFuZWwgYmFja2dyb3VuZCBkcmFnIGludGVyYWN0aW9uIG1vdXNlZG93biBldmVudCBoYW5kbGVyIChvbiB0aGUgcGFuZWwgYmFja2dyb3VuZClcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LmludGVyYWN0aW9uLmRyYWdfYmFja2dyb3VuZF90b19wYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IGAuJHt0aGlzLnBhcmVudC5pZH0uJHt0aGlzLmlkfS5pbnRlcmFjdGlvbi5kcmFnYDtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlZG93biA9ICgpID0+IHRoaXMucGFyZW50LnN0YXJ0RHJhZyh0aGlzLCAnYmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgdGhpcy5zdmcuY29udGFpbmVyLnNlbGVjdCgnLmx6LXBhbmVsLWJhY2tncm91bmQnKVxuICAgICAgICAgICAgICAgIC5vbihgbW91c2Vkb3duJHtuYW1lc3BhY2V9LmJhY2tncm91bmRgLCBtb3VzZWRvd24pXG4gICAgICAgICAgICAgICAgLm9uKGB0b3VjaHN0YXJ0JHtuYW1lc3BhY2V9LmJhY2tncm91bmRgLCBtb3VzZWRvd24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaCB0aGUgc29ydCBvcmRlciBvZiBhbGwgZGF0YSBsYXllcnMgKGNhbGxlZCBieSBkYXRhIGxheWVyIG1vdmVGb3J3YXJkIGFuZCBtb3ZlQmFjayBtZXRob2RzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVzb3J0RGF0YUxheWVycygpIHtcbiAgICAgICAgY29uc3Qgc29ydCA9IFtdO1xuICAgICAgICB0aGlzLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXguZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIHNvcnQucHVzaCh0aGlzLmRhdGFfbGF5ZXJzW2lkXS5sYXlvdXQuel9pbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN2Zy5ncm91cFxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnZy5sei1kYXRhX2xheWVyLWNvbnRhaW5lcicpXG4gICAgICAgICAgICAuZGF0YShzb3J0KVxuICAgICAgICAgICAgLnNvcnQoZDMuYXNjZW5kaW5nKTtcbiAgICAgICAgdGhpcy5hcHBseURhdGFMYXllclpJbmRleGVzVG9EYXRhTGF5ZXJMYXlvdXRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGFycmF5IG9mIHBhbmVsIElEcyB0aGF0IGFyZSBheGlzLWxpbmtlZCB0byB0aGlzIHBhbmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geygneCd8J3kxJ3wneTInKX0gYXhpc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRMaW5rZWRQYW5lbElkcyhheGlzKSB7XG4gICAgICAgIGF4aXMgPSBheGlzIHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGxpbmtlZF9wYW5lbF9pZHMgPSBbXTtcbiAgICAgICAgaWYgKCFbJ3gnLCAneTEnLCAneTInXS5pbmNsdWRlcyhheGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmtlZF9wYW5lbF9pZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmxheW91dC5pbnRlcmFjdGlvbltgJHtheGlzfV9saW5rZWRgXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmtlZF9wYW5lbF9pZHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQucGFuZWxfaWRzX2J5X3lfaW5kZXguZm9yRWFjaCgocGFuZWxfaWQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYW5lbF9pZCAhPT0gdGhpcy5pZCAmJiB0aGlzLnBhcmVudC5wYW5lbHNbcGFuZWxfaWRdLmxheW91dC5pbnRlcmFjdGlvbltgJHtheGlzfV9saW5rZWRgXSkge1xuICAgICAgICAgICAgICAgIGxpbmtlZF9wYW5lbF9pZHMucHVzaChwYW5lbF9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlua2VkX3BhbmVsX2lkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgcGFuZWwgdXAgcmVsYXRpdmUgdG8gb3RoZXJzIGJ5IHktaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtQYW5lbH1cbiAgICAgKi9cbiAgICBtb3ZlVXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5wYW5lbF9pZHNfYnlfeV9pbmRleFt0aGlzLmxheW91dC55X2luZGV4IC0gMV0pIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnBhbmVsX2lkc19ieV95X2luZGV4W3RoaXMubGF5b3V0LnlfaW5kZXhdID0gdGhpcy5wYXJlbnQucGFuZWxfaWRzX2J5X3lfaW5kZXhbdGhpcy5sYXlvdXQueV9pbmRleCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucGFuZWxfaWRzX2J5X3lfaW5kZXhbdGhpcy5sYXlvdXQueV9pbmRleCAtIDFdID0gdGhpcy5pZDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwcGx5UGFuZWxZSW5kZXhlc1RvUGFuZWxMYXlvdXRzKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBwYW5lbCBkb3duICh5LWF4aXMpIHJlbGF0aXZlIHRvIG90aGVycyBpbiB0aGUgcGxvdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1BhbmVsfVxuICAgICAqL1xuICAgIG1vdmVEb3duKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQucGFuZWxfaWRzX2J5X3lfaW5kZXhbdGhpcy5sYXlvdXQueV9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5wYW5lbF9pZHNfYnlfeV9pbmRleFt0aGlzLmxheW91dC55X2luZGV4XSA9IHRoaXMucGFyZW50LnBhbmVsX2lkc19ieV95X2luZGV4W3RoaXMubGF5b3V0LnlfaW5kZXggKyAxXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnBhbmVsX2lkc19ieV95X2luZGV4W3RoaXMubGF5b3V0LnlfaW5kZXggKyAxXSA9IHRoaXMuaWQ7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBseVBhbmVsWUluZGV4ZXNUb1BhbmVsTGF5b3V0cygpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucG9zaXRpb25QYW5lbHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwYXJlbnQgcGxvdCBjaGFuZ2VzIHN0YXRlLCBhZGp1c3QgdGhlIHBhbmVsIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgdGhpcyBtYXkgaW5jbHVkZSBmZXRjaGluZyBuZXcgZGF0YVxuICAgICAqICAgZnJvbSB0aGUgQVBJIGFzIHRoZSB2aWV3aW5nIHJlZ2lvbiBjaGFuZ2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICByZU1hcCgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhX3JlcXVlc3RlZCcpO1xuICAgICAgICB0aGlzLmRhdGFfcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAvLyBSZW1vdmUgYW55IHByZXZpb3VzIGVycm9yIG1lc3NhZ2VzIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGxvYWQgbmV3IGRhdGFcbiAgICAgICAgdGhpcy5jdXJ0YWluLmhpZGUoKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZU1hcCBvbiBlYWNoIERhdGEgTGF5ZXJcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5kYXRhX2xheWVycykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfcHJvbWlzZXMucHVzaCh0aGlzLmRhdGFfbGF5ZXJzW2lkXS5yZU1hcCgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJ0YWluLnNob3coZXJyb3IubWVzc2FnZSB8fCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiBhbGwgZmluaXNoZWQgdHJpZ2dlciBhIHJlbmRlclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5kYXRhX3Byb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsYXlvdXRfY2hhbmdlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YV9yZW5kZXJlZCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnRhaW4uc2hvdyhlcnJvci5tZXNzYWdlIHx8IGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBkYXRhIGxheWVycyB0byBnZW5lcmF0ZSBwYW5lbCBheGlzIGV4dGVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtQYW5lbH1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUV4dGVudHMoKSB7XG5cbiAgICAgICAgLy8gUmVzZXQgZXh0ZW50c1xuICAgICAgICBbJ3gnLCAneTEnLCAneTInXS5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICAgICAgICB0aGlzW2Ake2F4aXN9X2V4dGVudGBdID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBkYXRhIGxheWVyc1xuICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmRhdGFfbGF5ZXJzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFfbGF5ZXIgPSB0aGlzLmRhdGFfbGF5ZXJzW2lkXTtcblxuICAgICAgICAgICAgLy8gSWYgZGVmaW5lZCBhbmQgbm90IGRlY291cGxlZCwgbWVyZ2UgdGhlIHggZXh0ZW50IG9mIHRoZSBkYXRhIGxheWVyIHdpdGggdGhlIHBhbmVsJ3MgeCBleHRlbnRcbiAgICAgICAgICAgIGlmIChkYXRhX2xheWVyLmxheW91dC54X2F4aXMgJiYgIWRhdGFfbGF5ZXIubGF5b3V0LnhfYXhpcy5kZWNvdXBsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhfZXh0ZW50ID0gZDMuZXh0ZW50KCh0aGlzLnhfZXh0ZW50IHx8IFtdKS5jb25jYXQoZGF0YV9sYXllci5nZXRBeGlzRXh0ZW50KCd4JykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgZGVmaW5lZCBhbmQgbm90IGRlY291cGxlZCwgbWVyZ2UgdGhlIHkgZXh0ZW50IG9mIHRoZSBkYXRhIGxheWVyIHdpdGggdGhlIHBhbmVsJ3MgYXBwcm9wcmlhdGUgeSBleHRlbnRcbiAgICAgICAgICAgIGlmIChkYXRhX2xheWVyLmxheW91dC55X2F4aXMgJiYgIWRhdGFfbGF5ZXIubGF5b3V0LnlfYXhpcy5kZWNvdXBsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5X2F4aXMgPSBgeSR7ZGF0YV9sYXllci5sYXlvdXQueV9heGlzLmF4aXN9YDtcbiAgICAgICAgICAgICAgICB0aGlzW2Ake3lfYXhpc31fZXh0ZW50YF0gPSBkMy5leHRlbnQoKHRoaXNbYCR7eV9heGlzfV9leHRlbnRgXSB8fCBbXSkuY29uY2F0KGRhdGFfbGF5ZXIuZ2V0QXhpc0V4dGVudCgneScpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJyaWRlIHhfZXh0ZW50IGZyb20gc3RhdGUgaWYgZXhwbGljaXRseSBkZWZpbmVkIHRvIGRvIHNvXG4gICAgICAgIGlmICh0aGlzLmxheW91dC5heGVzLnggJiYgdGhpcy5sYXlvdXQuYXhlcy54LmV4dGVudCA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgdGhpcy54X2V4dGVudCA9IFsgdGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5lbmQgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgdGlja3MgZm9yIGFuIGF4aXMuIFRoZXNlIHRpY2tzIGFyZSBnZW5lcmF0ZWQgaW4gb25lIG9mIHRocmVlIHdheXMgKGhpZ2hlc3Qgd2lucyk6XG4gICAgICogICAxLiBBbiBhcnJheSBvZiBzcGVjaWZpYyB0aWNrIG1hcmtzXG4gICAgICogICAyLiBRdWVyeSBlYWNoIGRhdGEgbGF5ZXIgZm9yIHdoYXQgdGlja3MgYXJlIGFwcHJvcHJpYXRlLCBhbmQgYWxsb3cgYSBwYW5lbC1sZXZlbCB0aWNrIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAgICogICAgIG9iamVjdCB0byBvdmVycmlkZSB0aGUgbGF5ZXIncyBkZWZhdWx0IHByZXNlbnRhdGlvbiBzZXR0aW5nc1xuICAgICAqICAgMy4gR2VuZXJhdGUgZ2VuZXJpYyB0aWNrIG1hcmtzIGJhc2VkIG9uIHRoZSBleHRlbnQgb2YgdGhlIGRhdGFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsoJ3gnfCd5MSd8J3kyJyl9IGF4aXMgVGhlIHN0cmluZyBpZGVudGlmaWVyIG9mIHRoZSBheGlzXG4gICAgICogQHJldHVybnMge051bWJlcltdfE9iamVjdFtdfSAgVE9ETzogbnVtYmVyIGZvcm1hdD9cbiAgICAgKiAgIEFuIGFycmF5IG9mIG51bWJlcnM6IGludGVycHJldGVkIGFzIGFuIGFycmF5IG9mIGF4aXMgdmFsdWUgb2Zmc2V0cyBmb3IgcG9zaXRpb25pbmcuXG4gICAgICogICBBbiBhcnJheSBvZiBvYmplY3RzOiBlYWNoIG9iamVjdCBtdXN0IGhhdmUgYW4gJ3gnIGF0dHJpYnV0ZSB0byBwb3NpdGlvbiB0aGUgdGljay5cbiAgICAgKiAgIE90aGVyIHN1cHBvcnRlZCBvYmplY3Qga2V5czpcbiAgICAgKiAgICAgKiB0ZXh0OiBzdHJpbmcgdG8gcmVuZGVyIGZvciBhIGdpdmVuIHRpY2tcbiAgICAgKiAgICAgKiBzdHlsZTogZDMtY29tcGF0aWJsZSBDU1Mgc3R5bGUgb2JqZWN0XG4gICAgICogICAgICogdHJhbnNmb3JtOiBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBzdHJpbmdcbiAgICAgKiAgICAgKiBjb2xvcjogc3RyaW5nIG9yIExvY3VzWm9vbSBzY2FsYWJsZSBwYXJhbWV0ZXIgb2JqZWN0XG4gICAgICovXG4gICAgZ2VuZXJhdGVUaWNrcyhheGlzKSB7XG5cbiAgICAgICAgLy8gUGFyc2UgYW4gZXhwbGljaXQgJ3RpY2tzJyBhdHRyaWJ1dGUgaW4gdGhlIGF4aXMgbGF5b3V0XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5heGVzW2F4aXNdLnRpY2tzKSB7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dC5heGVzW2F4aXNdO1xuXG4gICAgICAgICAgICBjb25zdCBiYXNlVGlja0NvbmZpZyA9IGxheW91dC50aWNrcztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJhc2VUaWNrQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIC8vIEFycmF5IG9mIHNwZWNpZmljIHRpY2tzIGhhcmQtY29kZWQgaW50byBhIHBhbmVsIHdpbGwgb3ZlcnJpZGUgYW55IHRpY2tzIHRoYXQgYW4gaW5kaXZpZHVhbCBsYXllciBtaWdodCBzcGVjaWZ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VUaWNrQ29uZmlnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJhc2VUaWNrQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYXlvdXQgc3BlY2lmaWVzIGJhc2UgY29uZmlndXJhdGlvbiBmb3IgdGlja3MtIGJ1dCB3aXRob3V0IHNwZWNpZmljIHBvc2l0aW9ucy0gdGhlbiBhc2sgZWFjaFxuICAgICAgICAgICAgICAgIC8vICAgZGF0YSBsYXllciB0byByZXBvcnQgdGhlIHRpY2sgbWFya3MgdGhhdCBpdCB0aGlua3MgaXQgbmVlZHNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGZXcgbGF5ZXJzIGN1cnJlbnRseSBuZWVkIHRvIHNwZWNpZnkgY3VzdG9tIHRpY2tzICh3aGljaCBpcyBvayEpLiBCdXQgaWYgaXQgYmVjb21lcyBjb21tb24sIGNvbnNpZGVyIGFkZGluZyBtZWNoYW5pc21zIHRvIGRlZHVwbGljYXRlIHRpY2tzIGFjcm9zcyBsYXllcnNcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIC8vIFBhc3MgYW55IGxheWVyLXNwZWNpZmljIGN1c3RvbWl6YXRpb25zIGZvciBob3cgdGlja3MgYXJlIGNhbGN1bGF0ZWQuIChzdHlsZXMgYXJlIG92ZXJyaWRkZW4gc2VwYXJhdGVseSlcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSB7IHBvc2l0aW9uOiBiYXNlVGlja0NvbmZpZy5wb3NpdGlvbiB9O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRUaWNrcyA9IHRoaXMuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5yZWR1Y2UoKGFjYywgZGF0YV9sYXllcl9pZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGF5ZXIgPSBzZWxmLmRhdGFfbGF5ZXJzW2RhdGFfbGF5ZXJfaWRdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChuZXh0TGF5ZXIuZ2V0VGlja3MoYXhpcywgY29uZmlnKSk7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkVGlja3MubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXllciBtYWtlcyBzdWdnZXN0aW9ucywgYnV0IHRpY2sgY29uZmlndXJhdGlvbiBwYXJhbXMgc3BlY2lmaWVkIG9uIHRoZSBwYW5lbCB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1Db25maWcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbmZpZyA9IG1lcmdlKGl0ZW1Db25maWcsIGJhc2VUaWNrQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlKGl0ZW1Db25maWcsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgY29uZmlndXJhdGlvbiBpcyBwcm92aWRlZCwgYXR0ZW1wdCB0byBnZW5lcmF0ZSB0aWNrcyBmcm9tIHRoZSBleHRlbnRcbiAgICAgICAgaWYgKHRoaXNbYCR7YXhpc31fZXh0ZW50YF0pIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlUaWNrcyh0aGlzW2Ake2F4aXN9X2V4dGVudGBdLCAnYm90aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGlja3MgZm9yIGEgcGFydGljdWxhciBheGlzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geygneCd8J3kxJ3wneTInKX0gYXhpcyBUaGUgaWRlbnRpZmllciBvZiB0aGUgYXhlc1xuICAgICAqIEByZXR1cm5zIHtQYW5lbH1cbiAgICAgKi9cbiAgICByZW5kZXJBeGlzKGF4aXMpIHtcblxuICAgICAgICBpZiAoIVsneCcsICd5MScsICd5MiddLmluY2x1ZGVzKGF4aXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZW5kZXIgYXhpczsgaW52YWxpZCBheGlzIGlkZW50aWZpZXI6ICR7YXhpc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhblJlbmRlciA9IHRoaXMubGF5b3V0LmF4ZXNbYXhpc10ucmVuZGVyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpc1tgJHtheGlzfV9zY2FsZWBdID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICYmICFpc05hTih0aGlzW2Ake2F4aXN9X3NjYWxlYF0oMCkpO1xuXG4gICAgICAgIC8vIElmIHRoZSBheGlzIGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgdGhlbiBjaGVjayBpZiB3ZSBjYW4vY2FuJ3QgcmVuZGVyIGl0XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXhpcyBlbGVtZW50IGlzIHNob3duL2hpZGRlbiB0byBzdWl0XG4gICAgICAgIGlmICh0aGlzW2Ake2F4aXN9X2F4aXNgXSkge1xuICAgICAgICAgICAgdGhpcy5zdmcuY29udGFpbmVyLnNlbGVjdChgZy5sei1heGlzLmx6LSR7YXhpc31gKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsIGNhblJlbmRlciA/IG51bGwgOiAnbm9uZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYW5SZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXhpcy1zcGVjaWZpYyB2YWx1ZXMgdG8gcGx1ZyBpbiB3aGVyZSBuZWVkZWRcbiAgICAgICAgY29uc3QgYXhpc19wYXJhbXMgPSB7XG4gICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGB0cmFuc2xhdGUoJHt0aGlzLmxheW91dC5tYXJnaW4ubGVmdH0sICR7dGhpcy5sYXlvdXQuaGVpZ2h0IC0gdGhpcy5sYXlvdXQubWFyZ2luLmJvdHRvbX0pYCxcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgbGFiZWxfeDogdGhpcy5sYXlvdXQuY2xpcGFyZWEud2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIGxhYmVsX3k6ICh0aGlzLmxheW91dC5heGVzW2F4aXNdLmxhYmVsX29mZnNldCB8fCAwKSxcbiAgICAgICAgICAgICAgICBsYWJlbF9yb3RhdGU6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeTE6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYHRyYW5zbGF0ZSgke3RoaXMubGF5b3V0Lm1hcmdpbi5sZWZ0fSwgJHt0aGlzLmxheW91dC5tYXJnaW4udG9wfSlgLFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgbGFiZWxfeDogLTEgKiAodGhpcy5sYXlvdXQuYXhlc1theGlzXS5sYWJlbF9vZmZzZXQgfHwgMCksXG4gICAgICAgICAgICAgICAgbGFiZWxfeTogdGhpcy5sYXlvdXQuY2xpcGFyZWEuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgICAgICBsYWJlbF9yb3RhdGU6IC05MCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5Mjoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBgdHJhbnNsYXRlKCR7dGhpcy5sYXlvdXQud2lkdGggLSB0aGlzLmxheW91dC5tYXJnaW4ucmlnaHR9LCAke3RoaXMubGF5b3V0Lm1hcmdpbi50b3B9KWAsXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgbGFiZWxfeDogKHRoaXMubGF5b3V0LmF4ZXNbYXhpc10ubGFiZWxfb2Zmc2V0IHx8IDApLFxuICAgICAgICAgICAgICAgIGxhYmVsX3k6IHRoaXMubGF5b3V0LmNsaXBhcmVhLmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgbGFiZWxfcm90YXRlOiAtOTAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIFRpY2tzXG4gICAgICAgIHRoaXNbYCR7YXhpc31fdGlja3NgXSA9IHRoaXMuZ2VuZXJhdGVUaWNrcyhheGlzKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHRpY2tzIGFyZSBhbGwgbnVtYmVycyAoZDMtYXV0b21hdGVkIHRpY2sgcmVuZGVyaW5nKSBvciBub3QgKG1hbnVhbCB0aWNrIHJlbmRlcmluZylcbiAgICAgICAgY29uc3QgdGlja3NBcmVBbGxOdW1iZXJzID0gKCh0aWNrcykgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih0aWNrc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSh0aGlzW2Ake2F4aXN9X3RpY2tzYF0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGF4aXM7IHNldCBzY2FsZSBhbmQgb3JpZW50YXRpb25cbiAgICAgICAgbGV0IGF4aXNfZmFjdG9yeTtcbiAgICAgICAgc3dpdGNoIChheGlzX3BhcmFtc1theGlzXS5vcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBheGlzX2ZhY3RvcnkgPSBkMy5heGlzUmlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBheGlzX2ZhY3RvcnkgPSBkMy5heGlzTGVmdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgYXhpc19mYWN0b3J5ID0gZDMuYXhpc0JvdHRvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgYXhpcyBvcmllbnRhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tgJHtheGlzfV9heGlzYF0gPSBheGlzX2ZhY3RvcnkodGhpc1tgJHtheGlzfV9zY2FsZWBdKVxuICAgICAgICAgICAgLnRpY2tQYWRkaW5nKDMpO1xuXG4gICAgICAgIC8vIFNldCB0aWNrIHZhbHVlcyBhbmQgZm9ybWF0XG4gICAgICAgIGlmICh0aWNrc0FyZUFsbE51bWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXNbYCR7YXhpc31fYXhpc2BdLnRpY2tWYWx1ZXModGhpc1tgJHtheGlzfV90aWNrc2BdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5heGVzW2F4aXNdLnRpY2tfZm9ybWF0ID09PSAncmVnaW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXNbYCR7YXhpc31fYXhpc2BdLnRpY2tGb3JtYXQoKGQpID0+IHBvc2l0aW9uSW50VG9TdHJpbmcoZCwgNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRpY2tzID0gdGhpc1tgJHtheGlzfV90aWNrc2BdLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAodFtheGlzLnN1YnN0cigwLCAxKV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzW2Ake2F4aXN9X2F4aXNgXS50aWNrVmFsdWVzKHRpY2tzKVxuICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2Ake2F4aXN9X3RpY2tzYF1baV0udGV4dDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBheGlzIGluIHRoZSBTVkcgYW5kIGFwcGx5IHRoZSBheGlzIGNvbnN0cnVjdFxuICAgICAgICB0aGlzLnN2Z1tgJHtheGlzfV9heGlzYF1cbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBheGlzX3BhcmFtc1theGlzXS5wb3NpdGlvbilcbiAgICAgICAgICAgIC5jYWxsKHRoaXNbYCR7YXhpc31fYXhpc2BdKTtcblxuICAgICAgICAvLyBJZiBuZWNlc3NhcnkgbWFudWFsbHkgYXBwbHkgc3R5bGVzIGFuZCB0cmFuc2Zvcm1zIHRvIHRpY2tzIGFzIHNwZWNpZmllZCBieSB0aGUgbGF5b3V0XG4gICAgICAgIGlmICghdGlja3NBcmVBbGxOdW1iZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB0aWNrX3NlbGVjdG9yID0gZDMuc2VsZWN0QWxsKGBnIyR7dGhpcy5nZXRCYXNlSWQoKS5yZXBsYWNlKCcuJywgJ1xcXFwuJyl9XFxcXC4ke2F4aXN9X2F4aXMgZy50aWNrYCk7XG4gICAgICAgICAgICBjb25zdCBwYW5lbCA9IHRoaXM7XG4gICAgICAgICAgICB0aWNrX3NlbGVjdG9yLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZWxbYCR7YXhpc31fdGlja3NgXVtpXS5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN0eWxlcyhzZWxlY3RvciwgcGFuZWxbYCR7YXhpc31fdGlja3NgXVtpXS5zdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYW5lbFtgJHtheGlzfV90aWNrc2BdW2ldLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5hdHRyKCd0cmFuc2Zvcm0nLCBwYW5lbFtgJHtheGlzfV90aWNrc2BdW2ldLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGF4aXMgbGFiZWwgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYXlvdXQuYXhlc1theGlzXS5sYWJlbCB8fCBudWxsO1xuICAgICAgICBpZiAobGFiZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3ZnW2Ake2F4aXN9X2F4aXNfbGFiZWxgXVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgYXhpc19wYXJhbXNbYXhpc10ubGFiZWxfeClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGF4aXNfcGFyYW1zW2F4aXNdLmxhYmVsX3kpXG4gICAgICAgICAgICAgICAgLnRleHQocGFyc2VGaWVsZHModGhpcy5zdGF0ZSwgbGFiZWwpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ2N1cnJlbnRDb2xvcicpO1xuICAgICAgICAgICAgaWYgKGF4aXNfcGFyYW1zW2F4aXNdLmxhYmVsX3JvdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ZnW2Ake2F4aXN9X2F4aXNfbGFiZWxgXVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHJvdGF0ZSgke2F4aXNfcGFyYW1zW2F4aXNdLmxhYmVsX3JvdGF0ZX0gJHtheGlzX3BhcmFtc1theGlzXS5sYWJlbF94fSwgJHtheGlzX3BhcmFtc1theGlzXS5sYWJlbF95fSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBpbnRlcmFjdGl2ZSBoYW5kbGVycyB0byB0aWNrcyBhcyBuZWVkZWRcbiAgICAgICAgWyd4JywgJ3kxJywgJ3kyJ10uZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LmludGVyYWN0aW9uW2BkcmFnXyR7YXhpc31fdGlja3NfdG9fc2NhbGVgXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IGAuJHt0aGlzLnBhcmVudC5pZH0uJHt0aGlzLmlkfS5pbnRlcmFjdGlvbi5kcmFnYDtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrX21vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGQzLnNlbGVjdCh0aGlzKS5ub2RlKCkuZm9jdXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLm5vZGUoKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSAoYXhpcyA9PT0gJ3gnKSA/ICdldy1yZXNpemUnIDogJ25zLXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudCAmJiBkMy5ldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gJ21vdmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsICdib2xkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnY3Vyc29yJywgY3Vyc29yIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihga2V5ZG93biR7bmFtZXNwYWNlfWAsIHRpY2tfbW91c2VvdmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKGBrZXl1cCR7bmFtZXNwYWNlfWAsIHRpY2tfbW91c2VvdmVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuc3ZnLmNvbnRhaW5lci5zZWxlY3RBbGwoYC5sei1heGlzLmx6LSR7YXhpc30gLnRpY2sgdGV4dGApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIDApIC8vIG5lY2Vzc2FyeSB0byBtYWtlIHRoZSB0aWNrIGZvY3VzYWJsZSBzbyBrZXlwcmVzcyBldmVudHMgY2FuIGJlIGNhcHR1cmVkXG4gICAgICAgICAgICAgICAgICAgIC5vbihgbW91c2VvdmVyJHtuYW1lc3BhY2V9YCwgdGlja19tb3VzZW92ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5vbihgbW91c2VvdXQke25hbWVzcGFjZX1gLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC13ZWlnaHQnLCAnbm9ybWFsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oYGtleWRvd24ke25hbWVzcGFjZX1gLCBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihga2V5dXAke25hbWVzcGFjZX1gLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKGBtb3VzZWRvd24ke25hbWVzcGFjZX1gLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zdGFydERyYWcodGhpcywgYCR7YXhpc31fdGlja2ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIGhlaWdodCBvZiB0aGlzIHBhbmVsIHRvIHRoZSBsYXJnZXN0IGFic29sdXRlIGhlaWdodCBvZiB0aGUgZGF0YSBpblxuICAgICAqICAgYWxsIGNoaWxkIGRhdGEgbGF5ZXJzIChpZiBub3QgbnVsbCBmb3IgYW55IGNoaWxkIGRhdGEgbGF5ZXJzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW3RhcmdldF9oZWlnaHRdIEEgdGFyZ2V0IGhlaWdodCwgd2hpY2ggd2lsbCBiZSB1c2VkIGluIHNpdHVhdGlvbnMgd2hlbiB0aGUgZXhwZWN0ZWQgaGVpZ2h0IGNhbiBiZVxuICAgICAqICAgcHJlLWNhbGN1bGF0ZWQgKGVnIHdoZW4gdGhlIGxheWVycyBhcmUgdHJhbnNpdGlvbmluZylcbiAgICAgKi9cbiAgICBzY2FsZUhlaWdodFRvRGF0YSh0YXJnZXRfaGVpZ2h0KSB7XG4gICAgICAgIHRhcmdldF9oZWlnaHQgPSArdGFyZ2V0X2hlaWdodCB8fCBudWxsO1xuICAgICAgICBpZiAodGFyZ2V0X2hlaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhX2xheWVyX2lkc19ieV96X2luZGV4LmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGggPSB0aGlzLmRhdGFfbGF5ZXJzW2lkXS5nZXRBYnNvbHV0ZURhdGFIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoK2RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRfaGVpZ2h0ID0gK2RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X2hlaWdodCA9IE1hdGgubWF4KHRhcmdldF9oZWlnaHQsICtkaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoK3RhcmdldF9oZWlnaHQpIHtcbiAgICAgICAgICAgIHRhcmdldF9oZWlnaHQgKz0gK3RoaXMubGF5b3V0Lm1hcmdpbi50b3AgKyArdGhpcy5sYXlvdXQubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyh0aGlzLmxheW91dC53aWR0aCwgdGFyZ2V0X2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5wYW5lbF9pZHNfYnlfeV9pbmRleC5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBhbmVsc1tpZF0ubGF5b3V0LnByb3BvcnRpb25hbF9oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0L3Vuc2V0IGVsZW1lbnQgc3RhdHVzZXMgYWNyb3NzIGFsbCBkYXRhIGxheWVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdG9nZ2xlXG4gICAgICovXG4gICAgc2V0QWxsRWxlbWVudFN0YXR1cyhzdGF0dXMsIHRvZ2dsZSkge1xuICAgICAgICB0aGlzLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXguZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YV9sYXllcnNbaWRdLnNldEFsbEVsZW1lbnRTdGF0dXMoc3RhdHVzLCB0b2dnbGUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblNUQVRVU0VTLnZlcmJzLmZvckVhY2goKHZlcmIsIGlkeCkgPT4ge1xuICAgIGNvbnN0IGFkamVjdGl2ZSA9IFNUQVRVU0VTLmFkamVjdGl2ZXNbaWR4XTtcbiAgICBjb25zdCBhbnRpdmVyYiA9IGB1biR7dmVyYn1gO1xuXG4gICAgLy8gU2V0L3Vuc2V0IHN0YXR1cyBmb3IgYWxsIGVsZW1lbnRzXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gaGlnaGxpZ2h0QWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIHNlbGVjdEFsbEVsZW1lbnRzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICogIEBmdW5jdGlvbiBmYWRlQWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIGhpZGVBbGxFbGVtZW50c1xuICAgICAqL1xuICAgIFBhbmVsLnByb3RvdHlwZVtgJHt2ZXJifUFsbEVsZW1lbnRzYF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRBbGxFbGVtZW50U3RhdHVzKGFkamVjdGl2ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiB1bmhpZ2hsaWdodEFsbEVsZW1lbnRzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICogIEBmdW5jdGlvbiB1bnNlbGVjdEFsbEVsZW1lbnRzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gdW5mYWRlQWxsRWxlbWVudHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQGZ1bmN0aW9uIHVuaGlkZUFsbEVsZW1lbnRzXG4gICAgICovXG4gICAgUGFuZWwucHJvdG90eXBlW2Ake2FudGl2ZXJifUFsbEVsZW1lbnRzYF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRBbGxFbGVtZW50U3RhdHVzKGFkamVjdGl2ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbmV4cG9ydCB7UGFuZWwgYXMgZGVmYXVsdH07XG4iLCIvKiogQG1vZHVsZSAqL1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuXG5pbXBvcnQge2RlZXBDb3B5LCBtZXJnZX0gZnJvbSAnLi4vaGVscGVycy9sYXlvdXRzJztcbmltcG9ydCBSZXF1ZXN0ZXIgZnJvbSAnLi4vZGF0YS9yZXF1ZXN0ZXInO1xuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi90b29sYmFyJztcbmltcG9ydCBQYW5lbCBmcm9tICcuL3BhbmVsJztcbmltcG9ydCB7Z2VuZXJhdGVDdXJ0YWluLCBnZW5lcmF0ZUxvYWRlcn0gZnJvbSAnLi4vaGVscGVycy9jb21tb24nO1xuXG4vKipcbiAqIERlZmF1bHQvIGV4cGVjdGVkIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBmb3IgYmFzaWMgcGxvdHRpbmc7IG1vc3QgcGxvdHMgd2lsbCBvdmVycmlkZVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlZmF1bHRfbGF5b3V0ID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWluX3dpZHRoOiAxLFxuICAgIG1pbl9oZWlnaHQ6IDEsXG4gICAgcmVzcG9uc2l2ZV9yZXNpemU6IGZhbHNlLCAvLyBBbGxvd2VkIHZhbHVlczogZmFsc2UsIFwid2lkdGhfb25seVwiIChzeW5vbnltIGZvciB0cnVlKVxuICAgIHBhbmVsczogW10sXG4gICAgdG9vbGJhcjoge1xuICAgICAgICB3aWRnZXRzOiBbXSxcbiAgICB9LFxuICAgIHBhbmVsX2JvdW5kYXJpZXM6IHRydWUsXG4gICAgbW91c2VfZ3VpZGU6IHRydWUsXG59O1xuXG4vKipcbiAqIENoZWNrIHRoYXQgcG9zaXRpb24gZmllbGRzIChjaHIsIHN0YXJ0LCBlbmQpIGFyZSBwcm92aWRlZCB3aGVyZSBhcHByb3ByaWF0ZSwgYW5kIGVuc3VyZSB0aGF0IHRoZSBwbG90IGZpdHMgd2l0aGluXG4gKiAgYW55IGNvbnN0cmFpbnRzIHNwZWNpZmllZCBieSB0aGUgbGF5b3V0XG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgc2lkZSBlZmZlY3RzOyBpdCBtdXRhdGVzIHRoZSBwcm9wb3NlZCBzdGF0ZSBpbiBvcmRlciB0byBtZWV0IGNlcnRhaW4gYm91bmRzIGNoZWNrcyBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3X3N0YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gbmV3X3N0YXRlLmNoclxuICogQHBhcmFtIHtOdW1iZXJ9IG5ld19zdGF0ZS5zdGFydFxuICogQHBhcmFtIHtOdW1iZXJ9IG5ld19zdGF0ZS5lbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAqIEByZXR1cm5zIHsqfHt9fVxuICovXG5mdW5jdGlvbiBfdXBkYXRlU3RhdGVQb3NpdGlvbihuZXdfc3RhdGUsIGxheW91dCkge1xuXG4gICAgbmV3X3N0YXRlID0gbmV3X3N0YXRlIHx8IHt9O1xuICAgIGxheW91dCA9IGxheW91dCB8fCB7fTtcblxuICAgIC8vIElmIGEgXCJjaHJcIiwgXCJzdGFydFwiLCBhbmQgXCJlbmRcIiBhcmUgcHJlc2VudCB0aGVuIHJlc29sdmUgc3RhcnQgYW5kIGVuZFxuICAgIC8vIHRvIG51bWVyaWMgdmFsdWVzIHRoYXQgYXJlIG5vdCBkZWNpbWFsLCBuZWdhdGl2ZSwgb3IgZmxpcHBlZFxuICAgIGxldCB2YWxpZGF0ZWRfcmVnaW9uID0gZmFsc2U7XG4gICAgbGV0IGF0dGVtcHRlZF9taWRwb2ludCA9IG51bGw7XG4gICAgbGV0IGF0dGVtcHRlZF9zY2FsZTtcbiAgICBpZiAodHlwZW9mIG5ld19zdGF0ZS5jaHIgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5ld19zdGF0ZS5zdGFydCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmV3X3N0YXRlLmVuZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBEZXRlcm1pbmUgYSBudW1lcmljIHNjYWxlIGFuZCBtaWRwb2ludCBmb3IgdGhlIGF0dGVtcHRlZCByZWdpb24sXG4gICAgICAgIG5ld19zdGF0ZS5zdGFydCA9IE1hdGgubWF4KHBhcnNlSW50KG5ld19zdGF0ZS5zdGFydCksIDEpO1xuICAgICAgICBuZXdfc3RhdGUuZW5kID0gTWF0aC5tYXgocGFyc2VJbnQobmV3X3N0YXRlLmVuZCksIDEpO1xuICAgICAgICBpZiAoaXNOYU4obmV3X3N0YXRlLnN0YXJ0KSAmJiBpc05hTihuZXdfc3RhdGUuZW5kKSkge1xuICAgICAgICAgICAgbmV3X3N0YXRlLnN0YXJ0ID0gMTtcbiAgICAgICAgICAgIG5ld19zdGF0ZS5lbmQgPSAxO1xuICAgICAgICAgICAgYXR0ZW1wdGVkX21pZHBvaW50ID0gMC41O1xuICAgICAgICAgICAgYXR0ZW1wdGVkX3NjYWxlID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTihuZXdfc3RhdGUuc3RhcnQpIHx8IGlzTmFOKG5ld19zdGF0ZS5lbmQpKSB7XG4gICAgICAgICAgICBhdHRlbXB0ZWRfbWlkcG9pbnQgPSBuZXdfc3RhdGUuc3RhcnQgfHwgbmV3X3N0YXRlLmVuZDtcbiAgICAgICAgICAgIGF0dGVtcHRlZF9zY2FsZSA9IDA7XG4gICAgICAgICAgICBuZXdfc3RhdGUuc3RhcnQgPSAoaXNOYU4obmV3X3N0YXRlLnN0YXJ0KSA/IG5ld19zdGF0ZS5lbmQgOiBuZXdfc3RhdGUuc3RhcnQpO1xuICAgICAgICAgICAgbmV3X3N0YXRlLmVuZCA9IChpc05hTihuZXdfc3RhdGUuZW5kKSA/IG5ld19zdGF0ZS5zdGFydCA6IG5ld19zdGF0ZS5lbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0ZW1wdGVkX21pZHBvaW50ID0gTWF0aC5yb3VuZCgobmV3X3N0YXRlLnN0YXJ0ICsgbmV3X3N0YXRlLmVuZCkgLyAyKTtcbiAgICAgICAgICAgIGF0dGVtcHRlZF9zY2FsZSA9IG5ld19zdGF0ZS5lbmQgLSBuZXdfc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdGVkX3NjYWxlIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBuZXdfc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICAgICAgbmV3X3N0YXRlLmVuZCA9IG5ld19zdGF0ZS5zdGFydDtcbiAgICAgICAgICAgICAgICBuZXdfc3RhdGUuc3RhcnQgPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGF0dGVtcHRlZF9zY2FsZSA9IG5ld19zdGF0ZS5lbmQgLSBuZXdfc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdGVkX21pZHBvaW50IDwgMCkge1xuICAgICAgICAgICAgICAgIG5ld19zdGF0ZS5zdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgbmV3X3N0YXRlLmVuZCA9IDE7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdGVkX3NjYWxlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZWRfcmVnaW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJhaW4gdy9yL3QgbGF5b3V0LWRlZmluZWQgbWluaW11bSByZWdpb24gc2NhbGVcbiAgICBpZiAoIWlzTmFOKGxheW91dC5taW5fcmVnaW9uX3NjYWxlKSAmJiB2YWxpZGF0ZWRfcmVnaW9uICYmIGF0dGVtcHRlZF9zY2FsZSA8IGxheW91dC5taW5fcmVnaW9uX3NjYWxlKSB7XG4gICAgICAgIG5ld19zdGF0ZS5zdGFydCA9IE1hdGgubWF4KGF0dGVtcHRlZF9taWRwb2ludCAtIE1hdGguZmxvb3IobGF5b3V0Lm1pbl9yZWdpb25fc2NhbGUgLyAyKSwgMSk7XG4gICAgICAgIG5ld19zdGF0ZS5lbmQgPSBuZXdfc3RhdGUuc3RhcnQgKyBsYXlvdXQubWluX3JlZ2lvbl9zY2FsZTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJhaW4gdy9yL3QgbGF5b3V0LWRlZmluZWQgbWF4aW11bSByZWdpb24gc2NhbGVcbiAgICBpZiAoIWlzTmFOKGxheW91dC5tYXhfcmVnaW9uX3NjYWxlKSAmJiB2YWxpZGF0ZWRfcmVnaW9uICYmIGF0dGVtcHRlZF9zY2FsZSA+IGxheW91dC5tYXhfcmVnaW9uX3NjYWxlKSB7XG4gICAgICAgIG5ld19zdGF0ZS5zdGFydCA9IE1hdGgubWF4KGF0dGVtcHRlZF9taWRwb2ludCAtIE1hdGguZmxvb3IobGF5b3V0Lm1heF9yZWdpb25fc2NhbGUgLyAyKSwgMSk7XG4gICAgICAgIG5ld19zdGF0ZS5lbmQgPSBuZXdfc3RhdGUuc3RhcnQgKyBsYXlvdXQubWF4X3JlZ2lvbl9zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3X3N0YXRlO1xufVxuXG5cbmNsYXNzIFBsb3Qge1xuICAgIC8qKlxuICAgICAqIEFuIGluZGVwZW5kZW50IExvY3VzWm9vbSBvYmplY3QgdGhhdCByZW5kZXJzIGEgdW5pcXVlIHNldCBvZiBkYXRhIGFuZCBzdWJwYW5lbHMuXG4gICAgICogTWFueSBzdWNoIExvY3VzWm9vbSBvYmplY3RzIGNhbiBleGlzdCBzaW11bHRhbmVvdXNseSBvbiBhIHNpbmdsZSBwYWdlLCBlYWNoIGhhdmluZyBpdHMgb3duIGxheW91dC5cbiAgICAgKlxuICAgICAqIFRoaXMgY3JlYXRlcyBhIG5ldyBwbG90IGluc3RhbmNlLCBidXQgZG9lcyBub3QgaW1tZWRpYXRlbHkgcmVuZGVyIGl0LiBGb3IgcHJhY3RpY2FsIHVzZSwgaXQgbWF5IGJlIG1vcmUgY29udmVuaWVudFxuICAgICAqIHRvIHVzZSB0aGUgYExvY3VzWm9vbS5wb3B1bGF0ZWAgaGVscGVyIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHBsb3QuIE9mdGVuIGNvcnJlc3BvbmRzIHRvIHRoZSBJRCBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQgb24gdGhlIHBhZ2VcbiAgICAgKiAgIHdoZXJlIHRoZSBwbG90IGlzIHJlbmRlcmVkLi5cbiAgICAgKiBAcGFyYW0ge0RhdGFTb3VyY2VzfSBkYXRhc291cmNlIEVuc2VtYmxlIG9mIGRhdGEgcHJvdmlkZXJzIHVzZWQgYnkgdGhlIHBsb3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0IEEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IG9mIGxheW91dCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlkLCBkYXRhc291cmNlLCBsYXlvdXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIgQm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEBwcml2YXRlXG4gICAgICAgICAqICBAbWVtYmVyIHtQbG90fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRfcGxvdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBAcHVibGljXG4gICAgICAgICAqICBAbWVtYmVyIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RvciBmb3IgYSBub2RlIHRoYXQgd2lsbCBjb250YWluIHRoZSBwbG90LiAoc2V0IGV4dGVybmFsbHkgYnkgcG9wdWxhdGUgbWV0aG9kcylcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZDMuc2VsZWN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmcgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXJlY3QgYWNjZXNzIHRvIHBhbmVsIGluc3RhbmNlcywga2V5ZWQgYnkgcGFuZWwgSUQuIFVzZWQgcHJpbWFyaWx5IGZvciBpbnRyb3NwZWN0aW9uLyBkZXZlbG9wbWVudC5cbiAgICAgICAgICogIEBwdWJsaWNcbiAgICAgICAgICogIEBtZW1iZXIge09iamVjdC48U3RyaW5nLCBOdW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYW5lbHMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHVzZWQgYnkgZXh0ZXJuYWwgY2xhc3NlcyB0aGF0IG1hbmlwdWxhdGUgdGhlIHBhcmVudCBhbmQgbWF5IGluZGljYXRlIHJvb20gZm9yIGEgaGVscGVyIG1ldGhvZCBpbiB0aGUgYXBpIHRvIGNvb3JkaW5hdGUgYm9pbGVycGxhdGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHVwZGF0ZSBvcGVyYXRpb25zIChyZU1hcCkgcGVyZm9ybWVkIG9uIGFsbCBjaGlsZCBwYW5lbHMsIGFuZCBub3RpZnkgdGhlIHBhcmVudCBwbG90IHdoZW4gY29tcGxldGVcbiAgICAgICAgICogVE9ETzogUmVjb25zaWRlciB3aGV0aGVyIHdlIG5lZWQgdG8gYmUgdHJhY2tpbmcgdGhpcyBhcyBnbG9iYWwgc3RhdGUgb3V0c2lkZSBvZiBjb250ZXh0IG9mIHNwZWNpZmljIG9wZXJhdGlvbnNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbWFwX3Byb21pc2VzID0gW107XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgbGF5b3V0IG9wdGlvbnMgZm9yIHRoZSBwbG90LCBpbmNsdWRpbmcgdGhlIGVmZmVjdCBvZiBhbnkgcmVzaXppbmcgZXZlbnRzIG9yIGR5bmFtaWNhbGx5XG4gICAgICAgICAqICBnZW5lcmF0ZWQgY29uZmlnIHByb2R1Y2VkIGR1cmluZyByZW5kZXJpbmcgb3B0aW9ucy5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIG1lcmdlKHRoaXMubGF5b3V0LCBkZWZhdWx0X2xheW91dCk7IC8vIFRPRE86IGV2YWx1YXRlIGhvdyB0aGUgZGVmYXVsdCBsYXlvdXQgaXMgYXBwbGllZFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZXMgaW4gdGhlIGxheW91dCBvYmplY3QgbWF5IGNoYW5nZSBkdXJpbmcgcmVuZGVyaW5nIGV0Yy4gUmV0YWluIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgcGxvdCBvcHRpb25zXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmFzZV9sYXlvdXQgPSBkZWVwQ29weSh0aGlzLmxheW91dCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHNob3J0Y3V0IHRvIHRoZSBzdGF0ZSBpbiB0aGUgbGF5b3V0IG9uIHRoZSBQbG90LiBUcmFja2luZyBpbiB0aGUgbGF5b3V0IGFsbG93cyB0aGUgcGxvdCB0byBiZSBjcmVhdGVkXG4gICAgICAgICAqICAgd2l0aCBpbml0aWFsIHN0YXRlL3NldHVwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUcmFja3Mgc3RhdGUgb2YgdGhlIHBsb3QsIGVnIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5sYXlvdXQuc3RhdGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1JlcXVlc3Rlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubHpkID0gbmV3IFJlcXVlc3RlcihkYXRhc291cmNlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2sgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyB0aGF0IGFyZSB1c2VkIGJ5IExaLiBUaGlzIGFsbG93cyBjbGVhbnVwIG9mIGxpc3RlbmVycyB3aGVuIHBsb3QgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IEEgbmVzdGVkIGhhc2ggb2YgZW50cmllczogeyBwYXJlbnQ6IHtldmVudF9uYW1lOiBbbGlzdGVuZXJzXSB9IH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVybmFsX2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogS25vd24gZXZlbnQgaG9va3MgdGhhdCB0aGUgcGFuZWwgY2FuIHJlc3BvbmQgdG9cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50X2hvb2tzID0ge1xuICAgICAgICAgICAgJ2xheW91dF9jaGFuZ2VkJzogW10sICAvLyBNYW55IHJlcmVuZGVyaW5nIG9wZXJhdGlvbnMsIGluY2x1ZGluZyBkaW1lbnNpb25zIGNoYW5nZWQsIGVsZW1lbnQgaGlnaGxpZ2h0ZWQsIG9yIHJlcmVuZGVyIG9uIGNoYW5lZ2QgZGF0YS4gQ2F1dGlvbjogRGlyZWN0IGxheW91dCBtdXRhdGlvbnMgbWlnaHQgbm90IGJlIGNhcHR1cmVkIGJ5IHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAnZGF0YV9yZXF1ZXN0ZWQnOiBbXSwgLy8gQSByZXF1ZXN0IGhhcyBiZWVuIG1hZGUgZm9yIG5ldyBkYXRhIGZyb20gYW55IGRhdGEgc291cmNlIHVzZWQgaW4gdGhlIHBsb3RcbiAgICAgICAgICAgICdkYXRhX3JlbmRlcmVkJzogW10sICAvLyBEYXRhIGZyb20gYSByZXF1ZXN0IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCByZW5kZXJlZCBpbiB0aGUgcGxvdFxuICAgICAgICAgICAgJ2VsZW1lbnRfY2xpY2tlZCc6IFtdLCAvLyBTZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgICAgICdlbGVtZW50X3NlbGVjdGlvbic6IFtdLCAvLyBFbGVtZW50IGJlY29tZXMgYWN0aXZlIChvbmx5KVxuICAgICAgICAgICAgJ21hdGNoX3JlcXVlc3RlZCc6IFtdLCAvLyBBIGRhdGEgbGF5ZXIgaXMgYXR0ZW1wdGluZyB0byBoaWdobGlnaHQgbWF0Y2hpbmcgcG9pbnRzIChpbnRlcm5hbCB1c2Ugb25seSlcbiAgICAgICAgICAgICdwYW5lbF9yZW1vdmVkJzogW10sICAvLyBBIHBhbmVsIGhhcyBiZWVuIHJlbW92ZWQgKGVnIHZpYSB0aGUgXCJ4XCIgYnV0dG9uIGluIHBsb3QpXG4gICAgICAgICAgICAncmVnaW9uX2NoYW5nZWQnOiBbXSwgLy8gVGhlIHZpZXdpbmcgcmVnaW9uIChjaHIvc3RhcnQvZW5kKSBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgICAgICAgICAnc3RhdGVfY2hhbmdlZCc6IFtdLCAgLy8gT25seSB0cmlnZ2VyZWQgd2hlbiBhIHN0YXRlIGNoYW5nZSBjYXVzZXMgcmVyZW5kZXJcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNhbGxiYWNrIGV2ZW50Q2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50RGF0YSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBldmVudERhdGEuc291cmNlSUQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIChlZyBwbG90IG9yIHBhcmVudCBuYW1lKSBvZiB0aGUgZWxlbWVudCB0aGF0XG4gICAgICAgICAqICB0cmlnZ2VyZWQgdGhlIGV2ZW50LiBXaWxsIGJlIGF1dG9tYXRpY2FsbHkgZmlsbGVkIGluIGlmIG5vdCBleHBsaWNpdGx5IHByb3ZpZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBldmVudERhdGEuY29udGV4dCBBbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCBlZyB0aGUgZGF0YVxuICAgICAgICAgKiAgIGFzc29jaWF0ZWQgd2l0aCBhIGNsaWNrZWQgcGxvdCBlbGVtZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIGludGVyYWN0aW9uIChlLmcuIHBhbm5pbmcgYW5kIHpvb21pbmcpIGlzIHN0b3JlZCBvbiB0aGUgcGxvdFxuICAgICAgICAgKiBUT0RPOiBBZGQvIGRvY3VtZW50IGRldGFpbHMgb2YgaW50ZXJhY3Rpb24gc3RydWN0dXJlIGFzIHdlIGV4cGFuZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHt7cGFuZWxfaWQ6IFN0cmluZywgbGlua2VkX3BhbmVsX2lkczogQXJyYXksIHhfbGlua2VkOiAqLCBkcmFnZ2luZzogKiwgem9vbWluZzogKn19XG4gICAgICAgICAqIEByZXR1cm5zIHtQbG90fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IHt9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGxheW91dFxuICAgICAgICB0aGlzLmluaXRpYWxpemVMYXlvdXQoKTtcbiAgICB9XG5cbiAgICAvKioqKioqKiBVc2VyLWZhY2luZyBtZXRob2RzIHRoYXQgYWxsb3cgbWFuaXB1bGF0aW9uIG9mIHRoZSBwbG90IGluc3RhbmNlOiB0aGUgcHVibGljIGludGVyZmFjZSAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIHNldmVyYWwgZXZlbnRzIHRoYXQgYSBMb2N1c1pvb20gcGxvdCBjYW4gXCJlbWl0XCIgd2hlbiBhcHByb3ByaWF0ZSwgYW5kIExvY3VzWm9vbSBzdXBwb3J0cyByZWdpc3RlcmluZ1xuICAgICAqICAgXCJob29rc1wiIGZvciB0aGVzZSBldmVudHMgd2hpY2ggYXJlIGVzc2VudGlhbGx5IGN1c3RvbSBmdW5jdGlvbnMgaW50ZW5kZWQgdG8gZmlyZSBhdCBjZXJ0YWluIHRpbWVzLlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbG90LWxldmVsIGV2ZW50cyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDpcbiAgICAgKiAgIC0gYGxheW91dF9jaGFuZ2VkYCAtIGNvbnRleHQ6IHBsb3QgLSBBbnkgYXNwZWN0IG9mIHRoZSBwbG90J3MgbGF5b3V0IChpbmNsdWRpbmcgZGltZW5zaW9ucyBvciBzdGF0ZSkgaGFzIGNoYW5nZWQuXG4gICAgICogICAtIGBkYXRhX3JlcXVlc3RlZGAgLSBjb250ZXh0OiBwbG90IC0gQSByZXF1ZXN0IGZvciBuZXcgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSB1c2VkIGluIHRoZSBwbG90IGhhcyBiZWVuIG1hZGUuXG4gICAgICogICAtIGBkYXRhX3JlbmRlcmVkYCAtIGNvbnRleHQ6IHBsb3QgLSBEYXRhIGZyb20gYSByZXF1ZXN0IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCByZW5kZXJlZCBpbiB0aGUgcGxvdC5cbiAgICAgKiAgIC0gYGVsZW1lbnRfY2xpY2tlZGAgLSBjb250ZXh0OiBwbG90IC0gQSBkYXRhIGVsZW1lbnQgaW4gYW55IG9mIHRoZSBwbG90J3MgZGF0YSBsYXllcnMgaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiAgIC0gYGVsZW1lbnRfc2VsZWN0aW9uYCAtIGNvbnRleHQ6IHBsb3QgLSBUcmlnZ2VyZWQgd2hlbiBhbiBlbGVtZW50IGNoYW5nZXMgXCJzZWxlY3Rpb25cIiBzdGF0dXMsIGFuZCBpZGVudGlmaWVzXG4gICAgICogICAgICAgIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYmVpbmcgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIFRvIHJlZ2lzdGVyIGEgaG9vayBmb3IgYW55IG9mIHRoZXNlIGV2ZW50cyB1c2UgYHBsb3Qub24oJ2V2ZW50X25hbWUnLCBmdW5jdGlvbigpIHt9KWAuXG4gICAgICpcbiAgICAgKiBUaGVyZSBjYW4gYmUgYXJiaXRyYXJpbHkgbWFueSBmdW5jdGlvbnMgcmVnaXN0ZXJlZCB0byB0aGUgc2FtZSBldmVudC4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5XG4gICAgICogICB3ZXJlIHJlZ2lzdGVyZWQuIFRoZSB0aGlzIGNvbnRleHQgYm91bmQgdG8gZWFjaCBldmVudCBob29rIGZ1bmN0aW9uIGlzIGRlcGVuZGVudCBvbiB0aGUgdHlwZSBvZiBldmVudCwgYXNcbiAgICAgKiAgIGRlbm90ZWQgYWJvdmUuIEZvciBleGFtcGxlLCB3aGVuIGRhdGFfcmVxdWVzdGVkIGlzIGVtaXR0ZWQgdGhlIGNvbnRleHQgZm9yIHRoaXMgaW4gdGhlIGV2ZW50IGhvb2sgd2lsbCBiZSB0aGVcbiAgICAgKiAgIHBsb3QgaXRzZWxmLCBidXQgd2hlbiBlbGVtZW50X2NsaWNrZWQgaXMgZW1pdHRlZCB0aGUgY29udGV4dCBmb3IgdGhpcyBpbiB0aGUgZXZlbnQgaG9vayB3aWxsIGJlIHRoZSBlbGVtZW50XG4gICAgICogICB0aGF0IHdhcyBjbGlja2VkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiBhbiBldmVudCAoYXMgZGVmaW5lZCBpbiBgZXZlbnRfaG9va3NgKVxuICAgICAqIEBwYXJhbSB7ZXZlbnRDYWxsYmFja30gaG9va1xuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbihldmVudCwgaG9vaykge1xuICAgICAgICBpZiAodHlwZW9mICdldmVudCcgIT0gJ3N0cmluZycgfHwgIUFycmF5LmlzQXJyYXkodGhpcy5ldmVudF9ob29rc1tldmVudF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZWdpc3RlciBldmVudCBob29rLCBpbnZhbGlkIGV2ZW50OiAke2V2ZW50LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBob29rICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlZ2lzdGVyIGV2ZW50IGhvb2ssIGludmFsaWQgaG9vayBmdW5jdGlvbiBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50X2hvb2tzW2V2ZW50XS5wdXNoKGhvb2spO1xuICAgICAgICByZXR1cm4gaG9vaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgb25lIG9yIG1vcmUgcHJldmlvdXNseSBkZWZpbmVkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgKGFzIGRlZmluZWQgaW4gYGV2ZW50X2hvb2tzYClcbiAgICAgKiBAcGFyYW0ge2V2ZW50Q2FsbGJhY2t9IFtob29rXSBUaGUgY2FsbGJhY2sgdG8gZGVyZWdpc3RlclxuICAgICAqIEByZXR1cm5zIHtQbG90fVxuICAgICAqL1xuICAgIG9mZihldmVudCwgaG9vaykge1xuICAgICAgICBjb25zdCB0aGVzZUhvb2tzID0gdGhpcy5ldmVudF9ob29rc1tldmVudF07XG4gICAgICAgIGlmICh0eXBlb2YgJ2V2ZW50JyAhPSAnc3RyaW5nJyB8fCAhQXJyYXkuaXNBcnJheSh0aGVzZUhvb2tzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIGV2ZW50IGhvb2ssIGludmFsaWQgZXZlbnQ6ICR7ZXZlbnQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9vayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBEZXJlZ2lzdGVyaW5nIGFsbCBob29rcyBmb3IgdGhpcyBldmVudCBtYXkgYnJlYWsgYmFzaWMgZnVuY3Rpb25hbGl0eSwgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgZHVyaW5nXG4gICAgICAgICAgICAvLyAgY2xlYW51cCBvcGVyYXRpb25zIChlZyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcylcbiAgICAgICAgICAgIHRoaXMuZXZlbnRfaG9va3NbZXZlbnRdID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBob29rTWF0Y2ggPSB0aGVzZUhvb2tzLmluZGV4T2YoaG9vayk7XG4gICAgICAgICAgICBpZiAoaG9va01hdGNoICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoZXNlSG9va3Muc3BsaWNlKGhvb2tNYXRjaCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lciBpcyBub3QgcmVnaXN0ZXJlZCBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSByZW1vdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJ1bm5pbmcgb2YgZXZlbnQgaG9va3Mgd2hlbiBhbiBldmVudCBpcyBlbWl0dGVkXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBBIGtub3duIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IGV2ZW50RGF0YSBEYXRhIG9yIGV2ZW50IGRlc2NyaXB0aW9uIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQHJldHVybnMge1Bsb3R9XG4gICAgICovXG4gICAgZW1pdChldmVudCwgZXZlbnREYXRhKSB7XG4gICAgICAgIC8vIFRPRE86IHRoZXJlIGFyZSBzbWFsbCBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBlbWl0IGltcGxlbWVudGF0aW9uIGJldHdlZW4gcGxvdHMgYW5kIHBhbmVscy4gSW4gdGhlIGZ1dHVyZSxcbiAgICAgICAgLy8gIERSWSB0aGlzIGNvZGUgdmlhIG1peGlucywgYW5kIG1ha2Ugc3VyZSB0byBrZWVwIHRoZSBpbnRlcmZhY2VzIGNvbXBhdGlibGUgd2hlbiByZWZhY3RvcmluZy5cbiAgICAgICAgaWYgKHR5cGVvZiAnZXZlbnQnICE9ICdzdHJpbmcnIHx8ICFBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRfaG9va3NbZXZlbnRdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2N1c1pvb20gYXR0ZW1wdGVkIHRvIHRocm93IGFuIGludmFsaWQgZXZlbnQ6ICR7ZXZlbnQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VJRCA9IHRoaXMuZ2V0QmFzZUlkKCk7XG4gICAgICAgIHRoaXMuZXZlbnRfaG9va3NbZXZlbnRdLmZvckVhY2goKGhvb2tUb1J1bikgPT4ge1xuICAgICAgICAgICAgbGV0IGV2ZW50Q29udGV4dDtcbiAgICAgICAgICAgIGlmIChldmVudERhdGEgJiYgZXZlbnREYXRhLnNvdXJjZUlEKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGV0ZWN0IHRoYXQgYW4gZXZlbnQgb3JpZ2luYXRlZCBlbHNld2hlcmUgKHZpYSBidWJibGluZyBvciBleHRlcm5hbGx5KSwgcHJlc2VydmUgdGhlIGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyAgd2hlbiByZS1lbWl0dGluZyB0aGUgZXZlbnQgdG8gcGxvdC1sZXZlbCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBldmVudENvbnRleHQgPSBldmVudERhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50Q29udGV4dCA9IHtzb3VyY2VJRDogc291cmNlSUQsIHRhcmdldDogdGhpcywgZGF0YTogZXZlbnREYXRhIHx8IG51bGx9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgYW55IGhhbmRsZXJzIGZpcmVkIGhlcmUgKGVpdGhlciBkaXJlY3RseSwgb3IgYnViYmxlZCkgd2lsbCBzZWUgdGhlIHBsb3QgYXMgdGhlXG4gICAgICAgICAgICAvLyAgdmFsdWUgb2YgYHRoaXNgLiBJZiBhIGJvdW5kIGZ1bmN0aW9uIGlzIHJlZ2lzdGVyZWQgYXMgYSBoYW5kbGVyLCB0aGUgcHJldmlvdXNseSBib3VuZCBgdGhpc2Agd2lsbFxuICAgICAgICAgICAgLy8gIG92ZXJyaWRlIGFueXRoaW5nIHByb3ZpZGVkIHRvIGBjYWxsYCBiZWxvdy5cbiAgICAgICAgICAgIGhvb2tUb1J1bi5jYWxsKHRoaXMsIGV2ZW50Q29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcGFuZWwgZnJvbSBhIGxheW91dCwgYW5kIGhhbmRsZSB0aGUgd29yayBvZiBpbml0aWFsaXppbmcgYW5kIHBsYWNpbmcgdGhlIHBhbmVsIG9uIHRoZSBwbG90XG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcmV0dXJucyB7UGFuZWx9XG4gICAgICovXG4gICAgYWRkUGFuZWwobGF5b3V0KSB7XG4gICAgICAgIC8vIFNhbml0eSBjaGVja3NcbiAgICAgICAgaWYgKHR5cGVvZiBsYXlvdXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFuZWwgbGF5b3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIFBhbmVsIGFuZCBzZXQgaXRzIHBhcmVudFxuICAgICAgICBjb25zdCBwYW5lbCA9IG5ldyBQYW5lbChsYXlvdXQsIHRoaXMpO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBQYW5lbCBvbiB0aGUgUGxvdFxuICAgICAgICB0aGlzLnBhbmVsc1twYW5lbC5pZF0gPSBwYW5lbDtcblxuICAgICAgICAvLyBJZiBhIGRpc2NyZXRlIHlfaW5kZXggd2FzIHNldCBpbiB0aGUgbGF5b3V0IHRoZW4gYWRqdXN0IG90aGVyIHBhbmVsIHlfaW5kZXggdmFsdWVzIHRvIGFjY29tbW9kYXRlIHRoaXMgb25lXG4gICAgICAgIGlmIChwYW5lbC5sYXlvdXQueV9pbmRleCAhPT0gbnVsbCAmJiAhaXNOYU4ocGFuZWwubGF5b3V0LnlfaW5kZXgpXG4gICAgICAgICAgICAmJiB0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIHlfaW5kZXggdmFsdWVzIHNob3VsZCBjb3VudCBiYWNrd2FyZHMgZnJvbSB0aGUgZW5kLCBzbyBjb252ZXJ0IG5lZ2F0aXZlcyB0byBhcHByb3ByaWF0ZSB2YWx1ZXMgaGVyZVxuICAgICAgICAgICAgaWYgKHBhbmVsLmxheW91dC55X2luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHBhbmVsLmxheW91dC55X2luZGV4ID0gTWF0aC5tYXgodGhpcy5wYW5lbF9pZHNfYnlfeV9pbmRleC5sZW5ndGggKyBwYW5lbC5sYXlvdXQueV9pbmRleCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4LnNwbGljZShwYW5lbC5sYXlvdXQueV9pbmRleCwgMCwgcGFuZWwuaWQpO1xuICAgICAgICAgICAgdGhpcy5hcHBseVBhbmVsWUluZGV4ZXNUb1BhbmVsTGF5b3V0cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wYW5lbF9pZHNfYnlfeV9pbmRleC5wdXNoKHBhbmVsLmlkKTtcbiAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsLmlkXS5sYXlvdXQueV9pbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBwYW5lbCB3YXMgYWxyZWFkeSBpbiB0aGUgbGF5b3V0LnBhbmVscyBhcnJheS5cbiAgICAgICAgLy8gSWYgaXQgd2Fzbid0LCBhZGQgaXQuIEVpdGhlciB3YXkgc3RvcmUgdGhlIGxheW91dC5wYW5lbHMgYXJyYXkgaW5kZXggb24gdGhlIHBhbmVsLlxuICAgICAgICBsZXQgbGF5b3V0X2lkeCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF5b3V0LnBhbmVscy5mb3JFYWNoKChwYW5lbF9sYXlvdXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhbmVsX2xheW91dC5pZCA9PT0gcGFuZWwuaWQpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRfaWR4ID0gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxheW91dF9pZHggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxheW91dF9pZHggPSB0aGlzLmxheW91dC5wYW5lbHMucHVzaCh0aGlzLnBhbmVsc1twYW5lbC5pZF0ubGF5b3V0KSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5lbHNbcGFuZWwuaWRdLmxheW91dF9pZHggPSBsYXlvdXRfaWR4O1xuXG4gICAgICAgIC8vIENhbGwgcG9zaXRpb25QYW5lbHMoKSB0byBrZWVwIHBhbmVscyBmcm9tIG92ZXJsYXBwaW5nIGFuZCBlbnN1cmUgZmlsbGluZyBhbGwgYXZhaWxhYmxlIHZlcnRpY2FsIHNwYWNlXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uUGFuZWxzKCk7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBsb2FkIGRhdGEgaW50byB0aGUgbmV3IHBhbmVsXG4gICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbC5pZF0uaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYW5lbHNbcGFuZWwuaWRdLnJlTWFwKCk7XG4gICAgICAgICAgICAvLyBBbiBleHRyYSBjYWxsIHRvIHNldERpbWVuc2lvbnMgd2l0aCBleGlzdGluZyBkaXNjcmV0ZSBkaW1lbnNpb25zIGZpeGVzIHNvbWUgcm91bmRpbmcgZXJyb3JzIHdpdGggdG9vbHRpcFxuICAgICAgICAgICAgLy8gcG9zaXRpb25pbmcuIFRPRE86IG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGwgdW5uZWNlc3NhcnkuXG4gICAgICAgICAgICB0aGlzLnNldERpbWVuc2lvbnModGhpcy5sYXlvdXQud2lkdGgsIHRoaXMubGF5b3V0LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFuZWxzW3BhbmVsLmlkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgc3RhdGUsIHRvb2x0aXBzLCBhbmQgb3RoZXIgcGVyc2lzdGVkIGRhdGEgYXNzb2NpYXRlZCB3aXRoIG9uZSAob3IgYWxsKSBwYW5lbChzKSBpbiB0aGUgcGxvdFxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiByZWxvYWRpbmcgYW4gZXhpc3RpbmcgcGxvdCB3aXRoIG5ldyBkYXRhLCBlZyBcImNsaWNrIGZvciBnZW5vbWUgcmVnaW9uXCIgbGlua3MuXG4gICAgICogICBUaGlzIGlzIGEgdXRpbGl0eSBtZXRob2QgZm9yIGN1c3RvbSB1c2FnZS4gSXQgaXMgbm90IGZpcmVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIG5vcm1hbCByZXJlbmRlciBvZiBleGlzdGluZyBwYW5lbHNcbiAgICAgKiAgIEBwdWJsaWNcbiAgICAgKiAgIEBwYXJhbSB7U3RyaW5nfSBbcGFuZWxJZF0gSWYgcHJvdmlkZWQsIGNsZWFyIHN0YXRlIGZvciBvbmx5IHRoaXMgcGFuZWwuIE90aGVyd2lzZSwgY2xlYXIgc3RhdGUgZm9yIGFsbCBwYW5lbHMuXG4gICAgICogICBAcGFyYW0geygnd2lwZSd8J3Jlc2V0Jyl9IFttb2RlPSd3aXBlJ10gT3B0aW9uYWxseSBzcGVjaWZ5IGhvdyBzdGF0ZSBzaG91bGQgYmUgY2xlYXJlZC4gYHdpcGVgIGRlbGV0ZXMgYWxsIGRhdGFcbiAgICAgKiAgICAgYW5kIGlzIHVzZWZ1bCBmb3Igd2hlbiB0aGUgcGFuZWwgaXMgYmVpbmcgcmVtb3ZlZDsgYHJlc2V0YCBpcyBiZXN0IHdoZW4gdGhlIHBhbmVsIHdpbGwgYmUgcmV1c2VkIGluIHBsYWNlLlxuICAgICAqIEByZXR1cm5zIHtQbG90fVxuICAgICAqL1xuICAgIGNsZWFyUGFuZWxEYXRhKHBhbmVsSWQsIG1vZGUpIHtcbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgJ3dpcGUnO1xuXG4gICAgICAgIC8vIFRPRE86IEFkZCB1bml0IHRlc3RzIGZvciB0aGlzIG1ldGhvZFxuICAgICAgICBsZXQgcGFuZWxzTGlzdDtcbiAgICAgICAgaWYgKHBhbmVsSWQpIHtcbiAgICAgICAgICAgIHBhbmVsc0xpc3QgPSBbcGFuZWxJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYW5lbHNMaXN0ID0gT2JqZWN0LmtleXModGhpcy5wYW5lbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFuZWxzTGlzdC5mb3JFYWNoKChwaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFuZWxzW3BpZF0uZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5mb3JFYWNoKChkbGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLnBhbmVsc1twaWRdLmRhdGFfbGF5ZXJzW2RsaWRdO1xuICAgICAgICAgICAgICAgIGxheWVyLmRlc3Ryb3lBbGxUb29sdGlwcygpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxheWVyLmxheWVyX3N0YXRlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxheW91dC5zdGF0ZVtsYXllci5zdGF0ZV9pZF07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX3NldERlZmF1bHRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwYW5lbCBmcm9tIHRoZSBwbG90LCBhbmQgY2xlYXIgYW55IHN0YXRlLCB0b29sdGlwcywgb3Igb3RoZXIgdmlzdWFsIGVsZW1lbnRzIGJlbG9uZ2luZyB0byBuZXN0ZWQgY29udGVudFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7UGxvdH1cbiAgICAgKi9cbiAgICByZW1vdmVQYW5lbChpZCkge1xuICAgICAgICBpZiAoIXRoaXMucGFuZWxzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIHBhbmVsLCBJRCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIGFsbCBwYW5lbCBib3VuZGFyaWVzXG4gICAgICAgIHRoaXMucGFuZWxfYm91bmRhcmllcy5oaWRlKCk7XG5cbiAgICAgICAgLy8gRGVzdHJveSBhbGwgdG9vbHRpcHMgYW5kIHN0YXRlIHZhcnMgZm9yIGFsbCBkYXRhIGxheWVycyBvbiB0aGUgcGFuZWxcbiAgICAgICAgdGhpcy5jbGVhclBhbmVsRGF0YShpZCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBwYW5lbC1sZXZlbCBIVE1MIG92ZXJsYXkgZWxlbWVudHNcbiAgICAgICAgdGhpcy5wYW5lbHNbaWRdLmxvYWRlci5oaWRlKCk7XG4gICAgICAgIHRoaXMucGFuZWxzW2lkXS50b29sYmFyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIHRoaXMucGFuZWxzW2lkXS5jdXJ0YWluLmhpZGUoKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHN2ZyBjb250YWluZXIgZm9yIHRoZSBwYW5lbCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzW2lkXS5zdmcuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsc1tpZF0uc3ZnLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcGFuZWwgYW5kIGl0cyBwcmVzZW5jZSBpbiB0aGUgcGxvdCBsYXlvdXQgYW5kIHN0YXRlXG4gICAgICAgIHRoaXMubGF5b3V0LnBhbmVscy5zcGxpY2UodGhpcy5wYW5lbHNbaWRdLmxheW91dF9pZHgsIDEpO1xuICAgICAgICBkZWxldGUgdGhpcy5wYW5lbHNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5sYXlvdXQuc3RhdGVbaWRdO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBsYXlvdXRfaWR4IHZhbHVlcyBmb3IgYWxsIHJlbWFpbmluZyBwYW5lbHNcbiAgICAgICAgdGhpcy5sYXlvdXQucGFuZWxzLmZvckVhY2goKHBhbmVsX2xheW91dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbF9sYXlvdXQuaWRdLmxheW91dF9pZHggPSBpZHg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcGFuZWwgaWQgZnJvbSB0aGUgeV9pbmRleCBhcnJheVxuICAgICAgICB0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4LnNwbGljZSh0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4LmluZGV4T2YoaWQpLCAxKTtcbiAgICAgICAgdGhpcy5hcHBseVBhbmVsWUluZGV4ZXNUb1BhbmVsTGF5b3V0cygpO1xuXG4gICAgICAgIC8vIENhbGwgcG9zaXRpb25QYW5lbHMoKSB0byBrZWVwIHBhbmVscyBmcm9tIG92ZXJsYXBwaW5nIGFuZCBlbnN1cmUgZmlsbGluZyBhbGwgYXZhaWxhYmxlIHZlcnRpY2FsIHNwYWNlXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgcGxvdCB0byBzaHJpbmsgd2hlbiBwYW5lbHMgYXJlIHJlbW92ZWQsIGJ5IGZvcmNpbmcgaXQgdG8gcmVjYWxjdWxhdGUgbWluIGRpbWVuc2lvbnMgZnJvbSBzY3JhdGNoXG4gICAgICAgICAgICB0aGlzLmxheW91dC5taW5faGVpZ2h0ID0gdGhpcy5fYmFzZV9sYXlvdXQubWluX2hlaWdodDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm1pbl93aWR0aCA9IHRoaXMuX2Jhc2VfbGF5b3V0Lm1pbl93aWR0aDtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICAgICAgLy8gQW4gZXh0cmEgY2FsbCB0byBzZXREaW1lbnNpb25zIHdpdGggZXhpc3RpbmcgZGlzY3JldGUgZGltZW5zaW9ucyBmaXhlcyBzb21lIHJvdW5kaW5nIGVycm9ycyB3aXRoIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uaW5nLiBUT0RPOiBtYWtlIHRoaXMgYWRkaXRpb25hbCBjYWxsIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHRoaXMubGF5b3V0LndpZHRoLCB0aGlzLmxheW91dC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwYW5lbF9yZW1vdmVkJywgaWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggKG9yIGZldGNoKSBhIHBsb3QncyBkYXRhIGZyb20gc291cmNlcywgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHBvc2l0aW9uIG9yIHN0YXRlIGhhcyBjaGFuZ2VkXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5U3RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHVzZXItZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNhbiByZWNlaXZlIChhbmQgcG90ZW50aWFsbHkgYWN0IG9uKSBuZXcgcGxvdCBkYXRhLlxuICAgICAqIEBjYWxsYmFjayBleHRlcm5hbERhdGFDYWxsYmFja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdfZGF0YSBUaGUgYm9keSByZXN1bHRpbmcgZnJvbSBhIGRhdGEgcmVxdWVzdC4gVGhpcyByZXByZXNlbnRzIHRoZSBzYW1lIGluZm9ybWF0aW9uIHRoYXQgd291bGQgYmUgcGFzc2VkIHRvXG4gICAgICogIGEgZGF0YSBsYXllciBtYWtpbmcgYW4gZXF1aXZhbGVudCByZXF1ZXN0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyLWRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjYW4gcmVzcG9uZCB0byBlcnJvcnMgcmVjZWl2ZWQgZHVyaW5nIGEgcHJldmlvdXMgb3BlcmF0aW9uXG4gICAgICogQGNhbGxiYWNrIGV4dGVybmFsRXJyb3JDYWxsYmFja1xuICAgICAqIEBwYXJhbSBlcnIgQSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQWxsb3cgbmV3bHkgZmV0Y2hlZCBkYXRhIHRvIGJlIG1hZGUgYXZhaWxhYmxlIG91dHNpZGUgdGhlIExvY3VzWm9vbSBwbG90LiBGb3IgZXhhbXBsZSwgYSBjYWxsYmFjayBjb3VsZCBiZVxuICAgICAqICByZWdpc3RlcmVkIHRvIGRyYXcgYW4gSFRNTCB0YWJsZSBvZiB0b3AgR1dBUyBoaXRzLCBhbmQgdXBkYXRlIHRoYXQgdGFibGUgd2hlbmV2ZXIgdGhlIHBsb3QgcmVnaW9uIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBleHRlcm5hbCBob29rcy4gSXQgcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGFuZCByZXR1cm5zIHBhcnNlZCBkYXRhLFxuICAgICAqICB1c2luZyB0aGUgc2FtZSBmaWVsZHMgc3ludGF4IGFuZCB1bmRlcmx5aW5nIG1ldGhvZHMgYXMgZGF0YSBsYXllcnMuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIEFuIGFycmF5IG9mIGZpZWxkIG5hbWVzIGFuZCB0cmFuc2Zvcm1zLCBpbiB0aGUgc2FtZSBzeW50YXggdXNlZCBieSBhIGRhdGEgbGF5ZXIuXG4gICAgICogIERpZmZlcmVudCBkYXRhIHNvdXJjZXMgc2hvdWxkIGJlIHByZWZpeGVkIGJ5IHRoZSBzb3VyY2UgbmFtZS5cbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsRGF0YUNhbGxiYWNrfSBzdWNjZXNzX2NhbGxiYWNrIFVzZWQgZGVmaW5lZCBmdW5jdGlvbiB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGFueSB0aW1lIHRoYXRcbiAgICAgKiAgbmV3IGRhdGEgaXMgcmVjZWl2ZWQgYnkgdGhlIHBsb3QuIFJlY2VpdmVzIHR3byBhcmd1bWVudHM6IChkYXRhLCBwbG90KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2V4dGVybmFsRXJyb3JDYWxsYmFja30gW29wdHMub25lcnJvcl0gVXNlciBkZWZpbmVkIGZ1bmN0aW9uIHRoYXQgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgaWYgYSBwcm9ibGVtXG4gICAgICogIG9jY3VycyBkdXJpbmcgdGhlIGRhdGEgcmVxdWVzdCBvciBzdWJzZXF1ZW50IGNhbGxiYWNrIG9wZXJhdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRpc2NyZXRlPWZhbHNlXSBOb3JtYWxseSB0aGUgY2FsbGJhY2sgd2lsbCBzdWJzY3JpYmUgdG8gdGhlIGNvbWJpbmVkIGJvZHkgZnJvbSB0aGUgY2hhaW4sXG4gICAgICogIHdoaWNoIG1heSBub3QgYmUgaW4gYSBmb3JtYXQgdGhhdCBtYXRjaGVzIHdoYXQgdGhlIGV4dGVybmFsIGNhbGxiYWNrIHdhbnRzIHRvIGRvLiBJZiBkaXNjcmV0ZT10cnVlLCByZXR1cm5zIHRoZVxuICAgICAqICB1bmNvbWJpbmVkIHJlY29yZCBpbmZvXG4gICAgICogIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgbmV3bHkgY3JlYXRlZCBldmVudCBsaXN0ZW5lciwgdG8gYWxsb3cgZm9yIGxhdGVyIGNsZWFudXAvcmVtb3ZhbFxuICAgICAqL1xuICAgIHN1YnNjcmliZVRvRGF0YShmaWVsZHMsIHN1Y2Nlc3NfY2FsbGJhY2ssIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBub3RpZmllZCB3aGVuZXZlciBuZXcgZGF0YSBoYXMgYmVlbiByZW5kZXJlZFxuICAgICAgICBjb25zdCBlcnJvcl9jYWxsYmFjayA9IG9wdHMub25lcnJvciB8fCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYWN0aW5nIG9uIGFuIGV4dGVybmFsIGNhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5semQuZ2V0RGF0YSh0aGlzLnN0YXRlLCBmaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChuZXdfZGF0YSkgPT4gc3VjY2Vzc19jYWxsYmFjayhvcHRzLmRpc2NyZXRlID8gbmV3X2RhdGEuZGlzY3JldGUgOiBuZXdfZGF0YS5ib2R5LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2VydGFpbiBjYXNlcywgZXJyb3JzIGFyZSB0aHJvd24gYmVmb3JlIGEgcHJvbWlzZSBjYW4gYmUgZ2VuZXJhdGVkLCBhbmQgTFogZXJyb3IgZGlzcGxheSBzZWVtcyB0byByZWx5IG9uIHRoZXNlIGVycm9ycyBidWJibGluZyB1cFxuICAgICAgICAgICAgICAgIGVycm9yX2NhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbignZGF0YV9yZW5kZXJlZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdGF0ZSB2YWx1ZXMgYW5kIHRyaWdnZXIgYSBwdWxsIGZvciBmcmVzaCBkYXRhIG9uIGFsbCBkYXRhIHNvdXJjZXMgZm9yIGFsbCBkYXRhIGxheWVyc1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0gc3RhdGVfY2hhbmdlc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBkYXRhIGZldGNoIGFuZCB1cGRhdGUgb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAgICAgKi9cbiAgICBhcHBseVN0YXRlKHN0YXRlX2NoYW5nZXMpIHtcbiAgICAgICAgc3RhdGVfY2hhbmdlcyA9IHN0YXRlX2NoYW5nZXMgfHwge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfY2hhbmdlcyAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcHBseVN0YXRlIG9ubHkgYWNjZXB0cyBhbiBvYmplY3Q7ICR7dHlwZW9mIHN0YXRlX2NoYW5nZXN9IGdpdmVuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjayB3aGF0IHBhcmFtZXRlcnMgd2lsbCBiZSBtb2RpZmllZC4gRm9yIGJvdW5kcyBjaGVja2luZywgd2UgbXVzdCB0YWtlIHNvbWUgcHJlc2V0IHZhbHVlcyBpbnRvIGFjY291bnQuXG4gICAgICAgIGxldCBtb2RzID0geyBjaHI6IHRoaXMuc3RhdGUuY2hyLCBzdGFydDogdGhpcy5zdGF0ZS5zdGFydCwgZW5kOiB0aGlzLnN0YXRlLmVuZCB9O1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBzdGF0ZV9jaGFuZ2VzKSB7XG4gICAgICAgICAgICBtb2RzW3Byb3BlcnR5XSA9IHN0YXRlX2NoYW5nZXNbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIG1vZHMgPSBfdXBkYXRlU3RhdGVQb3NpdGlvbihtb2RzLCB0aGlzLmxheW91dCk7XG5cbiAgICAgICAgLy8gQXBwbHkgbmV3IHN0YXRlIHRvIHRoZSBhY3R1YWwgc3RhdGVcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gbW9kcykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVtwcm9wZXJ0eV0gPSBtb2RzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHJlcXVlc3RzIGZvciBhbGwgcGFuZWxzIGdpdmVuIG5ldyBzdGF0ZVxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGFfcmVxdWVzdGVkJyk7XG4gICAgICAgIHRoaXMucmVtYXBfcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sb2FkaW5nX2RhdGEgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgdGhpcy5yZW1hcF9wcm9taXNlcy5wdXNoKHRoaXMucGFuZWxzW2lkXS5yZU1hcCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnJlbWFwX3Byb21pc2VzKVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VydGFpbi5zaG93KGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ19kYXRhID0gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0b29sYmFyIC8gd2lkZ2V0c1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhbmVsLWxldmVsIHN0YXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxfaWRzX2J5X3lfaW5kZXguZm9yRWFjaCgocGFuZWxfaWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLnBhbmVsc1twYW5lbF9pZF07XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLnRvb2xiYXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGRhdGEtbGF5ZXItbGV2ZWwgc3RhdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXguZm9yRWFjaCgoZGF0YV9sYXllcl9pZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwuZGF0YV9sYXllcnNbZGF0YV9sYXllcl9pZF0uYXBwbHlBbGxFbGVtZW50U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRW1pdCBldmVudHNcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xheW91dF9jaGFuZ2VkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhX3JlbmRlcmVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZV9jaGFuZ2VkJywgc3RhdGVfY2hhbmdlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbiBpbnRlcmVzdGluZyBxdWlyayBvZiByZWdpb24gY2hhbmdpbmcgaW4gTFo6IHRoZSBmaW5hbCByZWdpb24gaXMgbm90IGFsd2F5cyB0aGUgc2FtZSBhcyB0aGUgcmVxdWVzdGVkIHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vICAgKGV4YW1wbGU6IHpvb20gb3V0IGJleW9uZCBtYXgsIG9yIHJlcXVlc3Qgbm9uLWludGVnZXIgcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLy8gRWNobyB0aGUgYWN0dWFsIHBsb3QgcmVnaW9uIGFzIHRoZSBmaW5hbCBzb3VyY2Ugb2YgdHJ1dGhcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNociwgc3RhcnQsIGVuZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbl9jaGFuZ2VkID0gT2JqZWN0LmtleXMoc3RhdGVfY2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgLnNvbWUoKGtleSkgPT4gWydjaHInLCAnc3RhcnQnLCAnZW5kJ10uaW5jbHVkZXMoa2V5KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25fY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlZ2lvbl9jaGFuZ2VkJywgeyBjaHIsIHN0YXJ0LCBlbmQgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nX2RhdGEgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2VlcCBhIHJlY29yZCBvZiBldmVudCBsaXN0ZW5lcnMgdGhhdCBhcmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBMb2N1c1pvb20gYm91bmRhcnkgKGFuZCB0aGVyZWZvcmUgd291bGQgbm90XG4gICAgICogIGdldCBjbGVhbmVkIHVwIHdoZW4gdGhlIHBsb3Qgd2FzIHJlbW92ZWQgZnJvbSB0aGUgRE9NKS4gRm9yIGV4YW1wbGUsIHdpbmRvdyByZXNpemUgb3IgbW91c2UgZXZlbnRzLlxuICAgICAqIFRoaXMgYWxsb3dzIHNhZmUgY2xlYW51cCBvZiB0aGUgcGxvdCBvbiByZW1vdmFsIGZyb20gdGhlIHBhZ2VcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBUaGUgbm9kZSBvbiB3aGljaCB0aGUgbGlzdGVuZXIgaGFzIGJlZW4gZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGhhbmRsZSBmb3IgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGNsZWFuZWQgdXBcbiAgICAgKi9cbiAgICB0cmFja0V4dGVybmFsTGlzdGVuZXIodGFyZ2V0LCBldmVudF9uYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2V4dGVybmFsX2xpc3RlbmVycy5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxfbGlzdGVuZXJzLnNldCh0YXJnZXQsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fZXh0ZXJuYWxfbGlzdGVuZXJzLmdldCh0YXJnZXQpO1xuXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSBjb250YWluZXIuZ2V0KGV2ZW50X25hbWUpIHx8IFtdO1xuICAgICAgICBpZiAoIXRyYWNrZXIuaW5jbHVkZXMobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0cmFja2VyLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5zZXQoZXZlbnRfbmFtZSwgdHJhY2tlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwbG90IGZyb20gdGhlIHBhZ2UsIGFuZCBjbGVhbiB1cCBhbnkgZ2xvYmFsbHkgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoZSBwbG90IHJldGFpbnMgcmVmZXJlbmNlcyB0byBzb21lIG5vZGVzIHZpYSBzZWxlY3RvcnM7IGl0IG1heSBiZSB1c2VmdWwgdG8gZGVsZXRlIHRoZSBwbG90XG4gICAgICogIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2RcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBbdGFyZ2V0LCByZWdpc3RlcmVkX2V2ZW50c10gb2YgdGhpcy5fZXh0ZXJuYWxfbGlzdGVuZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2V2ZW50X25hbWUsIGxpc3RlbmVyc10gb2YgcmVnaXN0ZXJlZF9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyIHRoZSBTVkcsIHBsdXMgb3RoZXIgSFRNTCBub2RlcyAobGlrZSB0b29sYmFyKSB0aGF0IGxpdmUgdW5kZXIgdGhlIHNhbWUgcGFyZW50XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3ZnLm5vZGUoKS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbG90IGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwYXJlbnQubGFzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5sYXN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0b29sYmFyIGV2ZW50IGxpc3RlbmVycyBkZWZpbmVkIG9uIHRoZSBwYXJlbnQgbHotY29udGFpbmVyLiBBcyBvZiAyMDIwIHRoaXMgYXBwZWFycyB0byBiZSB0aGVcbiAgICAgICAgLy8gIHN0YXRlIG9mIHRoZSBhcnQgY3Jvc3MtYnJvd3NlciBET00gQVBJIGZvciB0aGlzIHRhc2suXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICBwYXJlbnQub3V0ZXJIVE1MID0gcGFyZW50Lm91dGVySFRNTDtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zdmcgPSBudWxsO1xuICAgICAgICB0aGlzLnBhbmVscyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqKioqKiogVGhlIHByaXZhdGUgaW50ZXJmYWNlOiBtZXRob2RzIG9ubHkgdXNlZCBieSBMb2N1c1pvb20gaW50ZXJuYWxzICovXG4gICAgLyoqXG4gICAgICogVHJhY2sgd2hldGhlciB0aGUgdGFyZ2V0IHBhbmVsIGNhbiByZXNwb25kIHRvIG1vdXNlIGludGVyYWN0aW9uIGV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhbmVsX2lkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2NhbkludGVyYWN0KHBhbmVsX2lkKSB7XG4gICAgICAgIHBhbmVsX2lkID0gcGFuZWxfaWQgfHwgbnVsbDtcbiAgICAgICAgaWYgKHBhbmVsX2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gKCh0eXBlb2YgdGhpcy5pbnRlcmFjdGlvbi5wYW5lbF9pZCA9PSAndW5kZWZpbmVkJyB8fCB0aGlzLmludGVyYWN0aW9uLnBhbmVsX2lkID09PSBwYW5lbF9pZCkgJiYgIXRoaXMubG9hZGluZ19kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuaW50ZXJhY3Rpb24uZHJhZ2dpbmcgfHwgdGhpcy5pbnRlcmFjdGlvbi56b29taW5nIHx8IHRoaXMubG9hZGluZ19kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgcGxvdCdzIG9yaWdpbiBpbiB0ZXJtcyBvZiB0aGUgZW50aXJlIHBhZ2VcbiAgICAgKiAgVGhpcyByZXR1cm5zIGEgcmVzdWx0IHdpdGggYWJzb2x1dGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhZ2UsIHJlZ2FyZGxlc3Mgb2YgY3VycmVudCBzY3JvbGxpbmdcbiAgICAgKiBOZWNlc3NhcnkgZm9yIHBvc2l0aW9uaW5nIGFueSBIVE1MIGVsZW1lbnRzIG92ZXIgdGhlIHBsb3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eDogTnVtYmVyLCB5OiBOdW1iZXIsIHdpZHRoOiBOdW1iZXIsIGhlaWdodDogTnVtYmVyfX1cbiAgICAgKi9cbiAgICBfZ2V0UGFnZU9yaWdpbigpIHtcbiAgICAgICAgY29uc3QgYm91bmRpbmdfY2xpZW50X3JlY3QgPSB0aGlzLnN2Zy5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCB4X29mZnNldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgbGV0IHlfb2Zmc2V0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuc3ZnLm5vZGUoKTtcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZWN1cnNpdmVseSBzZWVrcyBvZmZzZXRzIGZvciBoaWdoZXN0IG5vbi1zdGF0aWMgcGFyZW50IG5vZGUuIFRoaXMgY2FuIGxlYWQgdG8gaW5jb3JyZWN0XG4gICAgICAgICAgICAvLyAgIGNhbGN1bGF0aW9ucyBvZiwgZm9yIGV4YW1wbGUsIHggY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgcGFnZS4gUmV2aXNpdCB0aGlzIGxvZ2ljLlxuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyICE9PSBkb2N1bWVudCAmJiBkMy5zZWxlY3QoY29udGFpbmVyKS5zdHlsZSgncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICB4X29mZnNldCA9IC0xICogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgeV9vZmZzZXQgPSAtMSAqIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHhfb2Zmc2V0ICsgYm91bmRpbmdfY2xpZW50X3JlY3QubGVmdCxcbiAgICAgICAgICAgIHk6IHlfb2Zmc2V0ICsgYm91bmRpbmdfY2xpZW50X3JlY3QudG9wLFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nX2NsaWVudF9yZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ19jbGllbnRfcmVjdC5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3AgYW5kIGxlZnQgb2Zmc2V0IHZhbHVlcyBmb3IgdGhlIHBsb3QncyBjb250YWluZXIgZWxlbWVudCAodGhlIGRpdiB0aGF0IHdhcyBwb3B1bGF0ZWQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldENvbnRhaW5lck9mZnNldCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvZmZzZXQudG9wICs9IGNvbnRhaW5lci5vZmZzZXRUb3A7XG4gICAgICAgICAgICBvZmZzZXQubGVmdCArPSBjb250YWluZXIub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBlYWNoIGNoaWxkIHBhbmVsIG9mIHRoZSBwbG90IG9mIGNoYW5nZXMgaW4gcGFuZWwgb3JkZXJpbmcvIGFycmFuZ2VtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhcHBseVBhbmVsWUluZGV4ZXNUb1BhbmVsTGF5b3V0cyAoKSB7XG4gICAgICAgIHRoaXMucGFuZWxfaWRzX2J5X3lfaW5kZXguZm9yRWFjaCgocGlkLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFuZWxzW3BpZF0ubGF5b3V0LnlfaW5kZXggPSBpZHg7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcXVhbGlmaWVkIElEIHBhdGhuYW1lIGZvciB0aGUgcGxvdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCYXNlSWQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHN1bSB0aGUgcHJvcG9ydGlvbmFsIGRpbWVuc2lvbnMgb2YgcGFuZWxzLCBhIHZhbHVlIHRoYXQncyBjaGVja2VkIG9mdGVuIGFzIHBhbmVscyBhcmUgYWRkZWQvcmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsoJ0hlaWdodCd8J1dpZHRoJyl9IGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgc3VtUHJvcG9ydGlvbmFsKGRpbWVuc2lvbikge1xuICAgICAgICBpZiAoZGltZW5zaW9uICE9PSAnaGVpZ2h0JyAmJiBkaW1lbnNpb24gIT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGRpbWVuc2lvbiB2YWx1ZSBwYXNzZWQgdG8gc3VtUHJvcG9ydGlvbmFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBldmVyeSBwYW5lbCBjb250cmlidXRpbmcgdG8gdGhlIHN1bSBoYXMgYSBub24temVybyBwcm9wb3J0aW9uYWwgZGltZW5zaW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFuZWxzW2lkXS5sYXlvdXRbYHByb3BvcnRpb25hbF8ke2RpbWVuc2lvbn1gXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW2lkXS5sYXlvdXRbYHByb3BvcnRpb25hbF8ke2RpbWVuc2lvbn1gXSA9IDEgLyBPYmplY3Qua2V5cyh0aGlzLnBhbmVscykubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5wYW5lbHNbaWRdLmxheW91dFtgcHJvcG9ydGlvbmFsXyR7ZGltZW5zaW9ufWBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIHBsb3QgdG8gZml0IHRoZSBib3VuZGluZyBjb250YWluZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtQbG90fVxuICAgICAqL1xuICAgIHJlc2NhbGVTVkcoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSB0aGlzLnN2Zy5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyhjbGllbnRSZWN0LndpZHRoLCBjbGllbnRSZWN0LmhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHBsb3QgZm9yIGZpcnN0IHVzZSBieSBwZXJmb3JtaW5nIHBhcmFtZXRlciB2YWxpZGF0aW9uLCBzZXR0aW5nIHVwIHBhbmVscywgYW5kIGNhbGN1bGF0aW5nIGRpbWVuc2lvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtQbG90fVxuICAgICAqL1xuICAgIGluaXRpYWxpemVMYXlvdXQoKSB7XG5cbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrIGxheW91dCB2YWx1ZXNcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMubGF5b3V0LndpZHRoKSB8fCB0aGlzLmxheW91dC53aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bsb3QgbGF5b3V0IHBhcmFtZXRlciBgd2lkdGhgIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4odGhpcy5sYXlvdXQuaGVpZ2h0KSB8fCB0aGlzLmxheW91dC5oZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbG90IGxheW91dCBwYXJhbWV0ZXIgYHdpZHRoYCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJsZSBjaGVjazogdGhlcmUgd2FzIHByZXZpb3VzbHkgYSB0aGlyZCBvcHRpb24uIEFueXRoaW5nIHRydXRoeSBzaG91bGQgdGh1cyBhY3QgYXMgXCJyZXNwb25zaXZlX3Jlc2l6ZTogdHJ1ZVwiXG4gICAgICAgIHRoaXMubGF5b3V0LnJlc3BvbnNpdmVfcmVzaXplID0gISF0aGlzLmxheW91dC5yZXNwb25zaXZlX3Jlc2l6ZTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcmVzcG9uc2l2ZSBsYXlvdXQgdGhlbiBzZXQgYSBuYW1lc3BhY2VkL3VuaXF1ZSBvbnJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB0aGUgd2luZG93XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5yZXNwb25zaXZlX3Jlc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzaXplX2xpc3RlbmVyID0gKCkgPT4gdGhpcy5yZXNjYWxlU1ZHKCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplX2xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tFeHRlcm5hbExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHJlc2l6ZV9saXN0ZW5lcik7XG5cbiAgICAgICAgICAgIC8vIEZvcmNpbmcgb25lIGFkZGl0aW9uYWwgc2V0RGltZW5zaW9ucygpIGNhbGwgYWZ0ZXIgdGhlIHBhZ2UgaXMgbG9hZGVkIGNsZWFycyB1cFxuICAgICAgICAgICAgLy8gYW55IGRpc2FncmVlbWVudHMgYmV0d2VlbiB0aGUgaW5pdGlhbCBsYXlvdXQgYW5kIHRoZSBsb2FkZWQgcmVzcG9uc2l2ZSBjb250YWluZXIncyBzaXplXG4gICAgICAgICAgICBjb25zdCBsb2FkX2xpc3RlbmVyID0gKCkgPT4gdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRfbGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy50cmFja0V4dGVybmFsTGlzdGVuZXIod2luZG93LCAnbG9hZCcsIGxvYWRfbGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHBhbmVsc1xuICAgICAgICB0aGlzLmxheW91dC5wYW5lbHMuZm9yRWFjaCgocGFuZWxfbGF5b3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFBhbmVsKHBhbmVsX2xheW91dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGltZW5zaW9ucyBmb3IgYSBwbG90LCBhbmQgZW5zdXJlIHRoYXQgcGFuZWxzIGFyZSBzaXplZCBhbmQgcG9zaXRpb25lZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBJZiBkaW1lbnNpb25zIGFyZSBwcm92aWRlZCwgcmVzaXplcyBlYWNoIHBhbmVsIHByb3BvcnRpb25hbGx5IHRvIG1hdGNoIHRoZSBuZXcgcGxvdCBkaW1lbnNpb25zLiBPdGhlcndpc2UsXG4gICAgICogICBjYWxjdWxhdGVzIHRoZSBhcHByb3ByaWF0ZSBwbG90IGRpbWVuc2lvbnMgYmFzZWQgb24gYWxsIHBhbmVscy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGhdIElmIHByb3ZpZGVkIGFuZCBsYXJnZXIgdGhhbiBtaW5pbXVtIHNpemUsIHNldCBwbG90IHRvIHRoaXMgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodF0gSWYgcHJvdmlkZWQgYW5kIGxhcmdlciB0aGFuIG1pbmltdW0gc2l6ZSwgc2V0IHBsb3QgdG8gdGhpcyBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7UGxvdH1cbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICBsZXQgaWQ7XG5cbiAgICAgICAgLy8gVXBkYXRlIG1pbmltdW0gYWxsb3dhYmxlIHdpZHRoIGFuZCBoZWlnaHQgYnkgYWdncmVnYXRpbmcgbWluaW11bXMgZnJvbSBwYW5lbHMsIHRoZW4gYXBwbHkgbWluaW11bXMgdG8gY29udGFpbmluZyBlbGVtZW50LlxuICAgICAgICBsZXQgbWluX3dpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmxheW91dC5taW5fd2lkdGgpIHx8IDA7XG4gICAgICAgIGxldCBtaW5faGVpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmxheW91dC5taW5faGVpZ2h0KSB8fCAwO1xuICAgICAgICBmb3IgKGlkIGluIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBtaW5fd2lkdGggPSBNYXRoLm1heChtaW5fd2lkdGgsIHRoaXMucGFuZWxzW2lkXS5sYXlvdXQubWluX3dpZHRoKTtcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHRoaXMucGFuZWxzW2lkXS5sYXlvdXQubWluX2hlaWdodCkgPiAwICYmIHBhcnNlRmxvYXQodGhpcy5wYW5lbHNbaWRdLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0KSA+IDApIHtcbiAgICAgICAgICAgICAgICBtaW5faGVpZ2h0ID0gTWF0aC5tYXgobWluX2hlaWdodCwgKHRoaXMucGFuZWxzW2lkXS5sYXlvdXQubWluX2hlaWdodCAvIHRoaXMucGFuZWxzW2lkXS5sYXlvdXQucHJvcG9ydGlvbmFsX2hlaWdodCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5b3V0Lm1pbl93aWR0aCA9IE1hdGgubWF4KG1pbl93aWR0aCwgMSk7XG4gICAgICAgIHRoaXMubGF5b3V0Lm1pbl9oZWlnaHQgPSBNYXRoLm1heChtaW5faGVpZ2h0LCAxKTtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMuc3ZnLm5vZGUoKS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgLnN0eWxlKCdtaW4td2lkdGgnLCBgJHt0aGlzLmxheW91dC5taW5fd2lkdGh9cHhgKVxuICAgICAgICAgICAgLnN0eWxlKCdtaW4taGVpZ2h0JywgYCR7dGhpcy5sYXlvdXQubWluX2hlaWdodH1weGApO1xuXG4gICAgICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJndW1lbnRzIHdlcmUgcGFzc2VkIHRoZW4gYWRqdXN0IHRoZW0gYWdhaW5zdCBwbG90IG1pbmltdW1zIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgLy8gVGhlbiByZXNpemUgdGhlIHBsb3QgYW5kIHByb3BvcnRpb25hbGx5IHJlc2l6ZSBwYW5lbHMgdG8gZml0IGluc2lkZSB0aGUgbmV3IHBsb3QgZGltZW5zaW9ucy5cbiAgICAgICAgaWYgKCFpc05hTih3aWR0aCkgJiYgd2lkdGggPj0gMCAmJiAhaXNOYU4oaGVpZ2h0KSAmJiBoZWlnaHQgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQud2lkdGggPSBNYXRoLm1heChNYXRoLnJvdW5kKCt3aWR0aCksIHRoaXMubGF5b3V0Lm1pbl93aWR0aCk7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5oZWlnaHQgPSBNYXRoLm1heChNYXRoLnJvdW5kKCtoZWlnaHQpLCB0aGlzLmxheW91dC5taW5faGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGRpc2NyZXRlIHZhbHVlcyBpZiByZXNpemluZyByZXNwb25zaXZlbHlcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5yZXNwb25zaXZlX3Jlc2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbCByZXNpemUgbW9kZXMgd2lsbCBhZmZlY3Qgd2lkdGhcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQud2lkdGggPSBNYXRoLm1heCh0aGlzLnN2Zy5ub2RlKCkucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCwgdGhpcy5sYXlvdXQubWluX3dpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXNpemUvcmVwb3NpdGlvbiBwYW5lbHMgdG8gZml0LCB1cGRhdGUgcHJvcG9ydGlvbmFsIG9yaWdpbnMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBsZXQgeV9vZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5wYW5lbF9pZHNfYnlfeV9pbmRleC5mb3JFYWNoKChwYW5lbF9pZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsX3dpZHRoID0gdGhpcy5sYXlvdXQud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZWxfaGVpZ2h0ID0gdGhpcy5wYW5lbHNbcGFuZWxfaWRdLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ICogdGhpcy5sYXlvdXQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5zZXREaW1lbnNpb25zKHBhbmVsX3dpZHRoLCBwYW5lbF9oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5zZXRPcmlnaW4oMCwgeV9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQucHJvcG9ydGlvbmFsX29yaWdpbi54ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbF9pZF0ubGF5b3V0LnByb3BvcnRpb25hbF9vcmlnaW4ueSA9IHlfb2Zmc2V0IC8gdGhpcy5sYXlvdXQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHlfb2Zmc2V0ICs9IHBhbmVsX2hlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbF9pZF0udG9vbGJhci51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHRoaXMucGFuZWxzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJndW1lbnRzIHdlcmUgTk9UIHBhc3NlZCAoYW5kIHBhbmVscyBleGlzdCkgdGhlbiBkZXRlcm1pbmUgdGhlIHBsb3QgZGltZW5zaW9uc1xuICAgICAgICAgICAgLy8gYnkgbWFraW5nIGl0IGNvbmZvcm0gdG8gcGFuZWwgZGltZW5zaW9ucywgYXNzdW1pbmcgcGFuZWxzIGFyZSBhbHJlYWR5IHBvc2l0aW9uZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgdGhpcy5sYXlvdXQud2lkdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGZvciAoaWQgaW4gdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC53aWR0aCA9IE1hdGgubWF4KHRoaXMucGFuZWxzW2lkXS5sYXlvdXQud2lkdGgsIHRoaXMubGF5b3V0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5oZWlnaHQgKz0gdGhpcy5wYW5lbHNbaWRdLmxheW91dC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxheW91dC53aWR0aCA9IE1hdGgubWF4KHRoaXMubGF5b3V0LndpZHRoLCB0aGlzLmxheW91dC5taW5fd2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5sYXlvdXQuaGVpZ2h0LCB0aGlzLmxheW91dC5taW5faGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGxheW91dCB3aWR0aCBhbmQgaGVpZ2h0IGFzIGRpc2NyZXRlIHZhbHVlcyBvciB2aWV3Ym94IHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5zdmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2aWV3Qm94IG11c3QgYWx3YXlzIGJlIHNwZWNpZmllZCBpbiBvcmRlciBmb3IgXCJzYXZlIGFzIGltYWdlXCIgYnV0dG9uIHRvIHdvcmtcbiAgICAgICAgICAgIHRoaXMuc3ZnLmF0dHIoJ3ZpZXdCb3gnLCBgMCAwICR7dGhpcy5sYXlvdXQud2lkdGh9ICR7dGhpcy5sYXlvdXQuaGVpZ2h0fWApO1xuXG4gICAgICAgICAgICB0aGlzLnN2Z1xuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMubGF5b3V0LndpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmxheW91dC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHBsb3QgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgdGhlbiB0cmlnZ2VyIHNvbWUgbmVjZXNzYXJ5IHJlbmRlciBmdW5jdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGFuZWxfYm91bmRhcmllcy5wb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy50b29sYmFyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJ0YWluLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdsYXlvdXRfY2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgcG9zaXRpb24gcGFuZWxzIGJhc2VkIG9uIHBhbmVsIHBvc2l0aW9uaW5nIHJ1bGVzIGFuZCB2YWx1ZXMuXG4gICAgICogS2VlcCBwYW5lbHMgZnJvbSBvdmVybGFwcGluZyB2ZXJ0aWNhbGx5IGJ5IGFkanVzdGluZyBvcmlnaW5zLCBhbmQga2VlcCB0aGUgc3VtIG9mIHByb3BvcnRpb25hbCBoZWlnaHRzIGF0IDEuXG4gICAgICpcbiAgICAgKiBMb2N1c1pvb20gcGFuZWxzIGNhbiBvbmx5IGJlIHN0YWNrZWQgdmVydGljYWxseSAobm90IGhvcml6b250YWxseSlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvc2l0aW9uUGFuZWxzKCkge1xuICAgICAgICBsZXQgaWQ7XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBlbmZvcmNlIHRoYXQgYWxsIHgtbGlua2VkIHBhbmVscyBoYXZlIGNvbnNpc3RlbnQgaG9yaXpvbnRhbCBtYXJnaW5zXG4gICAgICAgIC8vICh0byBlbnN1cmUgdGhhdCBhbGlnbmVkIGl0ZW1zIHN0YXkgYWxpZ25lZCBkZXNwaXRlIGluY29uc2lzdGVudCBpbml0aWFsIGxheW91dCBwYXJhbWV0ZXJzKVxuICAgICAgICAvLyBOT1RFOiBUaGlzIGFzc3VtZXMgcGFuZWxzIGhhdmUgY29uc2lzdGVudCB3aWR0aHMgYWxyZWFkeS4gVGhhdCBzaG91bGQgcHJvYmFibHkgYmUgZW5mb3JjZWQgdG9vIVxuICAgICAgICBjb25zdCB4X2xpbmtlZF9tYXJnaW5zID0geyBsZWZ0OiAwLCByaWdodDogMCB9O1xuXG4gICAgICAgIC8vIFByb3BvcnRpb25hbCBoZWlnaHRzIGZvciBuZXdseSBhZGRlZCBwYW5lbHMgZGVmYXVsdCB0byBudWxsIHVubGVzcyBleHBsaWNpdGx5IHNldCwgc28gZGV0ZXJtaW5lIGFwcHJvcHJpYXRlXG4gICAgICAgIC8vIHByb3BvcnRpb25hbCBoZWlnaHRzIGZvciBhbGwgcGFuZWxzIHdpdGggYSBudWxsIHZhbHVlIGZyb20gZGlzY3JldGVseSBzZXQgZGltZW5zaW9ucy5cbiAgICAgICAgLy8gTGlrZXdpc2UgaGFuZGxlIGRlZmF1bHQgbnVsbHMgZm9yIHByb3BvcnRpb25hbCB3aWR0aHMsIGJ1dCBpbnN0ZWFkIGp1c3QgZm9yY2UgYSB2YWx1ZSBvZiAxIChmdWxsIHdpZHRoKVxuICAgICAgICBmb3IgKGlkIGluIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5lbHNbaWRdLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYW5lbHNbaWRdLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ID0gdGhpcy5wYW5lbHNbaWRdLmxheW91dC5oZWlnaHQgLyB0aGlzLmxheW91dC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5lbHNbaWRdLmxheW91dC5wcm9wb3J0aW9uYWxfd2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsc1tpZF0ubGF5b3V0LnByb3BvcnRpb25hbF93aWR0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5lbHNbaWRdLmxheW91dC5pbnRlcmFjdGlvbi54X2xpbmtlZCkge1xuICAgICAgICAgICAgICAgIHhfbGlua2VkX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHhfbGlua2VkX21hcmdpbnMubGVmdCwgdGhpcy5wYW5lbHNbaWRdLmxheW91dC5tYXJnaW4ubGVmdCk7XG4gICAgICAgICAgICAgICAgeF9saW5rZWRfbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHhfbGlua2VkX21hcmdpbnMucmlnaHQsIHRoaXMucGFuZWxzW2lkXS5sYXlvdXQubWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1bSB0aGUgcHJvcG9ydGlvbmFsIGhlaWdodHMgYW5kIHRoZW4gYWRqdXN0IGFsbCBwcm9wb3J0aW9uYWxseSBzbyB0aGF0IHRoZSBzdW0gaXMgZXhhY3RseSAxXG4gICAgICAgIGNvbnN0IHRvdGFsX3Byb3BvcnRpb25hbF9oZWlnaHQgPSB0aGlzLnN1bVByb3BvcnRpb25hbCgnaGVpZ2h0Jyk7XG4gICAgICAgIGlmICghdG90YWxfcHJvcG9ydGlvbmFsX2hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcG9ydGlvbmFsX2FkanVzdG1lbnQgPSAxIC8gdG90YWxfcHJvcG9ydGlvbmFsX2hlaWdodDtcbiAgICAgICAgZm9yIChpZCBpbiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgdGhpcy5wYW5lbHNbaWRdLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ICo9IHByb3BvcnRpb25hbF9hZGp1c3RtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG9yaWdpbnMgb24gYWxsIHBhbmVscyB3aXRob3V0IGNoYW5naW5nIHBsb3QtbGV2ZWwgZGltZW5zaW9ucyB5ZXRcbiAgICAgICAgLy8gQWxzbyBhcHBseSB4LWxpbmtlZCBtYXJnaW5zIHRvIHgtbGlua2VkIHBhbmVscywgdXBkYXRpbmcgd2lkdGhzIGFzIG5lZWRlZFxuICAgICAgICBsZXQgeV9vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4LmZvckVhY2goKHBhbmVsX2lkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbF9pZF0uc2V0T3JpZ2luKDAsIHlfb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQucHJvcG9ydGlvbmFsX29yaWdpbi54ID0gMDtcbiAgICAgICAgICAgIHlfb2Zmc2V0ICs9IHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQuaW50ZXJhY3Rpb24ueF9saW5rZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGgubWF4KHhfbGlua2VkX21hcmdpbnMubGVmdCAtIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQubWFyZ2luLmxlZnQsIDApXG4gICAgICAgICAgICAgICAgICAgICsgTWF0aC5tYXgoeF9saW5rZWRfbWFyZ2lucy5yaWdodCAtIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQubWFyZ2luLnJpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbF9pZF0ubGF5b3V0LndpZHRoICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQubWFyZ2luLmxlZnQgPSB4X2xpbmtlZF9tYXJnaW5zLmxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wYW5lbHNbcGFuZWxfaWRdLmxheW91dC5tYXJnaW4ucmlnaHQgPSB4X2xpbmtlZF9tYXJnaW5zLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQuY2xpcGFyZWEub3JpZ2luLnggPSB4X2xpbmtlZF9tYXJnaW5zLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkX3Bsb3RfaGVpZ2h0ID0geV9vZmZzZXQ7XG4gICAgICAgIHRoaXMucGFuZWxfaWRzX2J5X3lfaW5kZXguZm9yRWFjaCgocGFuZWxfaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQucHJvcG9ydGlvbmFsX29yaWdpbi55ID0gdGhpcy5wYW5lbHNbcGFuZWxfaWRdLmxheW91dC5vcmlnaW4ueSAvIGNhbGN1bGF0ZWRfcGxvdF9oZWlnaHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBkaW1lbnNpb25zIG9uIHRoZSBwbG90IHRvIGFjY29tbW9kYXRlIHJlcG9zaXRpb25lZCBwYW5lbHNcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG5cbiAgICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgb24gYWxsIHBhbmVscyB1c2luZyBuZXdseSBzZXQgcGxvdC1sZXZlbCBkaW1lbnNpb25zIGFuZCBwYW5lbC1sZXZlbCBwcm9wb3J0aW9uYWwgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLnBhbmVsX2lkc19ieV95X2luZGV4LmZvckVhY2goKHBhbmVsX2lkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsc1twYW5lbF9pZF0uc2V0RGltZW5zaW9ucyhcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC53aWR0aCAqIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQucHJvcG9ydGlvbmFsX3dpZHRoLFxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmhlaWdodCAqIHRoaXMucGFuZWxzW3BhbmVsX2lkXS5sYXlvdXQucHJvcG9ydGlvbmFsX2hlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBmaXJzdCByZW5kZXJpbmcgb2YgdGhlIHBsb3QuIFRoaXMgaW5jbHVkZXMgaW5pdGlhbGl6aW5nIHRoZSBpbmRpdmlkdWFsIHBhbmVscywgYnV0IGFsc28gY3JlYXRlcyBzaGFyZWRcbiAgICAgKiAgIGVsZW1lbnRzIHN1Y2ggYXMgbW91c2UgZXZlbnRzLCBwYW5lbCBndWlkZXMvYm91bmRhcmllcywgYW5kIGxvYWRlci9jdXJ0YWluLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1Bsb3R9XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpIHtcblxuICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHJlc3BvbnNpdmUgY2xhc3MgaXMgcHJlc2VudCBvbiB0aGUgY29udGFpbmluZyBub2RlIGlmIGNhbGxlZCBmb3JcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0LnJlc3BvbnNpdmVfcmVzaXplKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpLmNsYXNzZWQoJ2x6LWNvbnRhaW5lci1yZXNwb25zaXZlJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYW4gZWxlbWVudC9sYXllciBmb3IgY29udGFpbmluZyBtb3VzZSBndWlkZXNcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0Lm1vdXNlX2d1aWRlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZV9ndWlkZV9zdmcgPSB0aGlzLnN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1tb3VzZV9ndWlkZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7dGhpcy5pZH0ubW91c2VfZ3VpZGVgKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlX2d1aWRlX3ZlcnRpY2FsX3N2ZyA9IG1vdXNlX2d1aWRlX3N2Zy5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1tb3VzZV9ndWlkZS12ZXJ0aWNhbCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtMSk7XG4gICAgICAgICAgICBjb25zdCBtb3VzZV9ndWlkZV9ob3Jpem9udGFsX3N2ZyA9IG1vdXNlX2d1aWRlX3N2Zy5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1tb3VzZV9ndWlkZS1ob3Jpem9udGFsJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIC0xKTtcbiAgICAgICAgICAgIHRoaXMubW91c2VfZ3VpZGUgPSB7XG4gICAgICAgICAgICAgICAgc3ZnOiBtb3VzZV9ndWlkZV9zdmcsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IG1vdXNlX2d1aWRlX3ZlcnRpY2FsX3N2ZyxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBtb3VzZV9ndWlkZV9ob3Jpem9udGFsX3N2ZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY3VydGFpbiBhbmQgbG9hZGVyIHByb3RvdHB5ZXMgdG8gdGhlIHBsb3RcbiAgICAgICAgdGhpcy5jdXJ0YWluID0gZ2VuZXJhdGVDdXJ0YWluLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gZ2VuZXJhdGVMb2FkZXIuY2FsbCh0aGlzKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBhbmVsX2JvdW5kYXJpZXMgb2JqZWN0IHdpdGggc2hvdy9wb3NpdGlvbi9oaWRlIG1ldGhvZHNcbiAgICAgICAgdGhpcy5wYW5lbF9ib3VuZGFyaWVzID0ge1xuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgaGlkZV90aW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgc2hvd2luZzogZmFsc2UsXG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgY29ybmVyX3NlbGVjdG9yOiBudWxsLFxuICAgICAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgcGFuZWwgYm91bmRhcmllc1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93aW5nICYmICF0aGlzLnBhcmVudC5jdXJ0YWluLnNob3dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBwYW5lbHMgdG8gY3JlYXRlIGEgaG9yaXpvbnRhbCBib3VuZGFyeSBmb3IgZWFjaFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wYW5lbF9pZHNfYnlfeV9pbmRleC5mb3JFYWNoKChwYW5lbF9pZCwgcGFuZWxfaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudC5zdmcubm9kZSgpLnBhcmVudE5vZGUpLmluc2VydCgnZGl2JywgJy5sei1kYXRhX2xheWVyLXRvb2x0aXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1wYW5lbC1ib3VuZGFyeScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RpdGxlJywgJ1Jlc2l6ZSBwYW5lbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYW5lbF9yZXNpemVfZHJhZyA9IGQzLmRyYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsX3Jlc2l6ZV9kcmFnLm9uKCdzdGFydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWxfcmVzaXplX2RyYWcub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsX3Jlc2l6ZV9kcmFnLm9uKCdkcmFnJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHNldCB0aGUgZGltZW5zaW9ucyBvbiB0aGUgcGFuZWwgd2UncmUgcmVzaXppbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzX3BhbmVsID0gdGhpcy5wYXJlbnQucGFuZWxzW3RoaXMucGFyZW50LnBhbmVsX2lkc19ieV95X2luZGV4W3BhbmVsX2lkeF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsX3BhbmVsX2hlaWdodCA9IHRoaXNfcGFuZWwubGF5b3V0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzX3BhbmVsLnNldERpbWVuc2lvbnModGhpc19wYW5lbC5sYXlvdXQud2lkdGgsIHRoaXNfcGFuZWwubGF5b3V0LmhlaWdodCArIGQzLmV2ZW50LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYW5lbF9oZWlnaHRfY2hhbmdlID0gdGhpc19wYW5lbC5sYXlvdXQuaGVpZ2h0IC0gb3JpZ2luYWxfcGFuZWxfaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld19jYWxjdWxhdGVkX3Bsb3RfaGVpZ2h0ID0gdGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodCArIHBhbmVsX2hlaWdodF9jaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCBsb29wIHRocm91Z2ggYWxsIHBhbmVscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcHJvcG9ydGlvbmFsIGRpbWVuc2lvbnMgZm9yIGFsbCBwYW5lbHMgaW5jbHVkaW5nIHRoZSBvbmUgd2UndmUgcmVzaXplZCB1c2luZyBkaXNjcmV0ZSBoZWlnaHRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcG9zaXRpb24gcGFuZWxzIHdpdGggYSBncmVhdGVyIHktaW5kZXggdGhhbiB0aGlzIHBhbmVsIHRvIHRoZWlyIGFwcHJvcHJpYXRlIG5ldyBvcmlnaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucGFuZWxfaWRzX2J5X3lfaW5kZXguZm9yRWFjaCgobG9vcF9wYW5lbF9pZCwgbG9vcF9wYW5lbF9pZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9vcF9wYW5lbCA9IHRoaXMucGFyZW50LnBhbmVsc1t0aGlzLnBhcmVudC5wYW5lbF9pZHNfYnlfeV9pbmRleFtsb29wX3BhbmVsX2lkeF1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wX3BhbmVsLmxheW91dC5wcm9wb3J0aW9uYWxfaGVpZ2h0ID0gbG9vcF9wYW5lbC5sYXlvdXQuaGVpZ2h0IC8gbmV3X2NhbGN1bGF0ZWRfcGxvdF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29wX3BhbmVsX2lkeCA+IHBhbmVsX2lkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcF9wYW5lbC5zZXRPcmlnaW4obG9vcF9wYW5lbC5sYXlvdXQub3JpZ2luLngsIGxvb3BfcGFuZWwubGF5b3V0Lm9yaWdpbi55ICsgcGFuZWxfaGVpZ2h0X2NoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wX3BhbmVsLnRvb2xiYXIucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGRpbWVuc2lvbnMgb24gdGhlIGVudGlyZSBwbG90IGFuZCByZXBvc2l0aW9uIHBhbmVsIGJvdW5kYXJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuY2FsbChwYW5lbF9yZXNpemVfZHJhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wYW5lbF9ib3VuZGFyaWVzLnNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvcm5lciBib3VuZGFyeSAvIHJlc2l6ZSBlbGVtZW50IG9uIHRoZSBib3R0b20tbW9zdCBwYW5lbCB0aGF0IHJlc2l6ZXMgdGhlIGVudGlyZSBwbG90XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcm5lcl9zZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudC5zdmcubm9kZSgpLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KCdkaXYnLCAnLmx6LWRhdGFfbGF5ZXItdG9vbHRpcCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotcGFuZWwtY29ybmVyLWJvdW5kYXJ5JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsICdSZXNpemUgcGxvdCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcl9zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnc3BhbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotcGFuZWwtY29ybmVyLWJvdW5kYXJ5LW91dGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcl9zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnc3BhbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotcGFuZWwtY29ybmVyLWJvdW5kYXJ5LWlubmVyJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ybmVyX2RyYWcgPSBkMy5kcmFnKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcl9kcmFnLm9uKCdzdGFydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29ybmVyX2RyYWcub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcl9kcmFnLm9uKCdkcmFnJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2V0RGltZW5zaW9ucyh0aGlzLnBhcmVudC5sYXlvdXQud2lkdGggKyBkMy5ldmVudC5keCwgdGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodCArIGQzLmV2ZW50LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcm5lcl9zZWxlY3Rvci5jYWxsKGNvcm5lcl9kcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucGFuZWxfYm91bmRhcmllcy5jb3JuZXJfc2VsZWN0b3IgPSBjb3JuZXJfc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiBwYW5lbCBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgY29uc3QgcGxvdF9wYWdlX29yaWdpbiA9IHRoaXMucGFyZW50Ll9nZXRQYWdlT3JpZ2luKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMuZm9yRWFjaCgoc2VsZWN0b3IsIHBhbmVsX2lkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYW5lbF9wYWdlX29yaWdpbiA9IHRoaXMucGFyZW50LnBhbmVsc1t0aGlzLnBhcmVudC5wYW5lbF9pZHNfYnlfeV9pbmRleFtwYW5lbF9pZHhdXS5fZ2V0UGFnZU9yaWdpbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gcGxvdF9wYWdlX29yaWdpbi54O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSBwYW5lbF9wYWdlX29yaWdpbi55ICsgdGhpcy5wYXJlbnQucGFuZWxzW3RoaXMucGFyZW50LnBhbmVsX2lkc19ieV95X2luZGV4W3BhbmVsX2lkeF1dLmxheW91dC5oZWlnaHQgLSAxMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnBhcmVudC5sYXlvdXQud2lkdGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBgJHt0b3B9cHhgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgYCR7bGVmdH1weGApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3dpZHRoJywgYCR7d2lkdGh9cHhgKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3Iuc2VsZWN0KCdzcGFuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCBgJHt3aWR0aH1weGApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIGNvcm5lciBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcm5lcl9wYWRkaW5nID0gMTA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ybmVyX3NpemUgPSAxNjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcm5lcl9zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RvcCcsIGAke3Bsb3RfcGFnZV9vcmlnaW4ueSArIHRoaXMucGFyZW50LmxheW91dC5oZWlnaHQgLSBjb3JuZXJfcGFkZGluZyAtIGNvcm5lcl9zaXplfXB4YClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgYCR7cGxvdF9wYWdlX29yaWdpbi54ICsgdGhpcy5wYXJlbnQubGF5b3V0LndpZHRoIC0gY29ybmVyX3BhZGRpbmcgLSBjb3JuZXJfc2l6ZX1weGApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBQYW5lbCBwYW5lbCBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMuZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY29ybmVyIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JuZXJfc2VsZWN0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JuZXJfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTaG93IHBhbmVsIGJvdW5kYXJpZXMgc3RpcHVsYXRlZCBieSB0aGUgbGF5b3V0IChiYXNpYyB0b2dnbGUsIG9ubHkgc2hvdyBvbiBtb3VzZSBvdmVyIHBsb3QpXG4gICAgICAgIGlmICh0aGlzLmxheW91dC5wYW5lbF9ib3VuZGFyaWVzKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5zdmcubm9kZSgpLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgLm9uKGBtb3VzZW92ZXIuJHt0aGlzLmlkfS5wYW5lbF9ib3VuZGFyaWVzYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYW5lbF9ib3VuZGFyaWVzLmhpZGVfdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuZWxfYm91bmRhcmllcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oYG1vdXNlb3V0LiR7dGhpcy5pZH0ucGFuZWxfYm91bmRhcmllc2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW5lbF9ib3VuZGFyaWVzLmhpZGVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW5lbF9ib3VuZGFyaWVzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdG9vbGJhciBvYmplY3QgYW5kIGltbWVkaWF0ZWx5IHNob3cgaXRcbiAgICAgICAgdGhpcy50b29sYmFyID0gbmV3IFRvb2xiYXIodGhpcykuc2hvdygpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIHBhbmVsc1xuICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgdGhpcy5wYW5lbHNbaWRdLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBwbG90LWxldmVsIG1vdXNlIGV2ZW50c1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBgLiR7dGhpcy5pZH1gO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQubW91c2VfZ3VpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlb3V0X21vdXNlX2d1aWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VfZ3VpZGUudmVydGljYWwuYXR0cigneCcsIC0xKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlX2d1aWRlLmhvcml6b250YWwuYXR0cigneScsIC0xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtb3VzZW1vdmVfbW91c2VfZ3VpZGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZDMubW91c2UodGhpcy5zdmcubm9kZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlX2d1aWRlLnZlcnRpY2FsLmF0dHIoJ3gnLCBjb29yZHNbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VfZ3VpZGUuaG9yaXpvbnRhbC5hdHRyKCd5JywgY29vcmRzWzFdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN2Z1xuICAgICAgICAgICAgICAgIC5vbihgbW91c2VvdXQke25hbWVzcGFjZX0tbW91c2VfZ3VpZGVgLCBtb3VzZW91dF9tb3VzZV9ndWlkZSlcbiAgICAgICAgICAgICAgICAub24oYHRvdWNobGVhdmUke25hbWVzcGFjZX0tbW91c2VfZ3VpZGVgLCBtb3VzZW91dF9tb3VzZV9ndWlkZSlcbiAgICAgICAgICAgICAgICAub24oYG1vdXNlbW92ZSR7bmFtZXNwYWNlfS1tb3VzZV9ndWlkZWAsIG1vdXNlbW92ZV9tb3VzZV9ndWlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW91c2V1cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcERyYWcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW91c2Vtb3ZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3Rpb24uZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZHMgPSBkMy5tb3VzZSh0aGlzLnN2Zy5ub2RlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uLmRyYWdnaW5nLmRyYWdnZWRfeCA9IGNvb3Jkc1swXSAtIHRoaXMuaW50ZXJhY3Rpb24uZHJhZ2dpbmcuc3RhcnRfeDtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uLmRyYWdnaW5nLmRyYWdnZWRfeSA9IGNvb3Jkc1sxXSAtIHRoaXMuaW50ZXJhY3Rpb24uZHJhZ2dpbmcuc3RhcnRfeTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhbmVsc1t0aGlzLmludGVyYWN0aW9uLnBhbmVsX2lkXS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uLmxpbmtlZF9wYW5lbF9pZHMuZm9yRWFjaCgocGFuZWxfaWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW5lbHNbcGFuZWxfaWRdLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN2Z1xuICAgICAgICAgICAgLm9uKGBtb3VzZXVwJHtuYW1lc3BhY2V9YCwgbW91c2V1cClcbiAgICAgICAgICAgIC5vbihgdG91Y2hlbmQke25hbWVzcGFjZX1gLCBtb3VzZXVwKVxuICAgICAgICAgICAgLm9uKGBtb3VzZW1vdmUke25hbWVzcGFjZX1gLCBtb3VzZW1vdmUpXG4gICAgICAgICAgICAub24oYHRvdWNobW92ZSR7bmFtZXNwYWNlfWAsIG1vdXNlbW92ZSk7XG5cbiAgICAgICAgLy8gQWRkIGFuIGV4dHJhIG5hbWVzcGFjZWQgbW91c2V1cCBoYW5kbGVyIHRvIHRoZSBjb250YWluaW5nIGJvZHksIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAvLyBUaGlzIGhlbHBzIHRvIHN0b3AgaW50ZXJhY3Rpb24gZXZlbnRzIGdyYWNlZnVsbHkgd2hlbiBkcmFnZ2luZyBvdXRzaWRlIG9mIHRoZSBwbG90IGVsZW1lbnRcbiAgICAgICAgY29uc3QgYm9keV9zZWxlY3RvciA9IGQzLnNlbGVjdCgnYm9keScpO1xuICAgICAgICBjb25zdCBib2R5X25vZGUgPSBib2R5X3NlbGVjdG9yLm5vZGUoKTtcbiAgICAgICAgaWYgKGJvZHlfbm9kZSkge1xuICAgICAgICAgICAgYm9keV9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZXVwKTtcbiAgICAgICAgICAgIGJvZHlfbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNldXApO1xuXG4gICAgICAgICAgICB0aGlzLnRyYWNrRXh0ZXJuYWxMaXN0ZW5lcihib2R5X25vZGUsICdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrRXh0ZXJuYWxMaXN0ZW5lcihib2R5X25vZGUsICd0b3VjaGVuZCcsIG1vdXNldXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbignbWF0Y2hfcmVxdWVzdGVkJywgKGV2ZW50RGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gTGF5ZXJzIGNhbiBicm9hZGNhc3QgdGhhdCBhIHNwZWNpZmljIHBvaW50IGhhcyBiZWVuIHNlbGVjdGVkLCBhbmQgdGhlIHBsb3Qgd2lsbCB0ZWxsIGV2ZXJ5IG90aGVyIGxheWVyXG4gICAgICAgICAgICAvLyAgdG8gbG9vayBmb3IgdGhhdCB2YWx1ZS4gV2hlbmV2ZXIgYSBwb2ludCBpcyBkZS1zZWxlY3RlZCwgaXQgY2xlYXJzIHRoZSBtYXRjaC5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBldmVudERhdGEuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHRvX3NlbmQgPSAoZGF0YS5hY3RpdmUgPyBkYXRhLnZhbHVlIDogbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5U3RhdGUoeyBsel9tYXRjaF92YWx1ZTogdG9fc2VuZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgLy8gQW4gZXh0cmEgY2FsbCB0byBzZXREaW1lbnNpb25zIHdpdGggZXhpc3RpbmcgZGlzY3JldGUgZGltZW5zaW9ucyBmaXhlcyBzb21lIHJvdW5kaW5nIGVycm9ycyB3aXRoIHRvb2x0aXBcbiAgICAgICAgLy8gcG9zaXRpb25pbmcuIFRPRE86IG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGwgdW5uZWNlc3NhcnkuXG4gICAgICAgIGNvbnN0IGNsaWVudF9yZWN0ID0gdGhpcy5zdmcubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGNsaWVudF9yZWN0LndpZHRoID8gY2xpZW50X3JlY3Qud2lkdGggOiB0aGlzLmxheW91dC53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2xpZW50X3JlY3QuaGVpZ2h0ID8gY2xpZW50X3JlY3QuaGVpZ2h0IDogdGhpcy5sYXlvdXQuaGVpZ2h0O1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBpbnRlcmFjdGlvbnMgYWxvbmcgdGhlIHNwZWNpZmllZCBheGlzLCBwcm92aWRlZCB0aGF0IHRoZSB0YXJnZXQgcGFuZWwgYWxsb3dzIGludGVyYWN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQYW5lbH0gcGFuZWxcbiAgICAgKiBAcGFyYW0geygnYmFja2dyb3VuZCd8J3hfdGljayd8J3kxX3RpY2snfCd5Ml90aWNrJyl9IG1ldGhvZCBUaGUgZGlyZWN0aW9uIChheGlzKSBhbG9uZyB3aGljaCBkcmFnZ2luZyBpcyBiZWluZyBwZXJmb3JtZWQuXG4gICAgICogQHJldHVybnMge1Bsb3R9XG4gICAgICovXG4gICAgc3RhcnREcmFnKHBhbmVsLCBtZXRob2QpIHtcbiAgICAgICAgcGFuZWwgPSBwYW5lbCB8fCBudWxsO1xuICAgICAgICBtZXRob2QgPSBtZXRob2QgfHwgbnVsbDtcblxuICAgICAgICBsZXQgYXhpcyA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ2JhY2tncm91bmQnOlxuICAgICAgICBjYXNlICd4X3RpY2snOlxuICAgICAgICAgICAgYXhpcyA9ICd4JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd5MV90aWNrJzpcbiAgICAgICAgICAgIGF4aXMgPSAneTEnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3kyX3RpY2snOlxuICAgICAgICAgICAgYXhpcyA9ICd5Mic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHBhbmVsIGluc3RhbmNlb2YgUGFuZWwpIHx8ICFheGlzIHx8ICF0aGlzLl9jYW5JbnRlcmFjdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9wRHJhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29vcmRzID0gZDMubW91c2UodGhpcy5zdmcubm9kZSgpKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgIHBhbmVsX2lkOiBwYW5lbC5pZCxcbiAgICAgICAgICAgIGxpbmtlZF9wYW5lbF9pZHM6IHBhbmVsLmdldExpbmtlZFBhbmVsSWRzKGF4aXMpLFxuICAgICAgICAgICAgZHJhZ2dpbmc6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBzdGFydF94OiBjb29yZHNbMF0sXG4gICAgICAgICAgICAgICAgc3RhcnRfeTogY29vcmRzWzFdLFxuICAgICAgICAgICAgICAgIGRyYWdnZWRfeDogMCxcbiAgICAgICAgICAgICAgICBkcmFnZ2VkX3k6IDAsXG4gICAgICAgICAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdmcuc3R5bGUoJ2N1cnNvcicsICdhbGwtc2Nyb2xsJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBkcmFnIGludGVyYWN0aW9ucyBhY3Jvc3MgdGhlIHRhcmdldCBwYW5lbCBhbmQgc3luY2hyb25pemUgcGxvdCBzdGF0ZSBhY3Jvc3Mgb3RoZXIgcGFuZWxzIGluIHN5bmM7XG4gICAgICogICBjbGVhciB0aGUgZXZlbnQgd2hlbiBjb21wbGV0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1Bsb3R9XG4gICAgICovXG4gICAgc3RvcERyYWcoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYW5lbHNbdGhpcy5pbnRlcmFjdGlvbi5wYW5lbF9pZF0gIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYW5lbHNbdGhpcy5pbnRlcmFjdGlvbi5wYW5lbF9pZF07XG5cbiAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGFwcHJvcHJpYXRlIGF4aXMgbGF5b3V0cyBvbiBjaGlsZCBkYXRhIGxheWVyc1xuICAgICAgICAvLyBPbmNlIGZvdW5kLCBhcHBseSB0aGUgZXh0ZW50IGFzIGZsb29yL2NlaWxpbmcgYW5kIHJlbW92ZSBhbGwgb3RoZXIgZGlyZWN0aXZlc1xuICAgICAgICAvLyBUaGlzIGZvcmNlcyBhbGwgYXNzb2NpYXRlZCBheGVzIHRvIGNvbmZvcm0gdG8gdGhlIGV4dGVudCBnZW5lcmF0ZWQgYnkgYSBkcmFnIGFjdGlvblxuICAgICAgICBjb25zdCBvdmVycmlkZUF4aXNMYXlvdXQgPSAoYXhpcywgYXhpc19udW1iZXIsIGV4dGVudCkgPT4ge1xuICAgICAgICAgICAgcGFuZWwuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF4aXNfbGF5b3V0ID0gcGFuZWwuZGF0YV9sYXllcnNbaWRdLmxheW91dFtgJHtheGlzfV9heGlzYF07XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNfbGF5b3V0LmF4aXMgPT09IGF4aXNfbnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNfbGF5b3V0LmZsb29yID0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgICAgICBheGlzX2xheW91dC5jZWlsaW5nID0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXhpc19sYXlvdXQubG93ZXJfYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXhpc19sYXlvdXQudXBwZXJfYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXhpc19sYXlvdXQubWluX2V4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF4aXNfbGF5b3V0LnRpY2tzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnRlcmFjdGlvbi5kcmFnZ2luZy5tZXRob2QpIHtcbiAgICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgIGNhc2UgJ3hfdGljayc6XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcmFjdGlvbi5kcmFnZ2luZy5kcmFnZ2VkX3ggIT09IDApIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZUF4aXNMYXlvdXQoJ3gnLCAxLCBwYW5lbC54X2V4dGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN0YXRlKHsgc3RhcnQ6IHBhbmVsLnhfZXh0ZW50WzBdLCBlbmQ6IHBhbmVsLnhfZXh0ZW50WzFdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3kxX3RpY2snOlxuICAgICAgICBjYXNlICd5Ml90aWNrJzpcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0aW9uLmRyYWdnaW5nLmRyYWdnZWRfeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHlfYXhpc19udW1iZXIgPSBwYXJzZUludCh0aGlzLmludGVyYWN0aW9uLmRyYWdnaW5nLm1ldGhvZFsxXSk7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVBeGlzTGF5b3V0KCd5JywgeV9heGlzX251bWJlciwgcGFuZWxbYHkke3lfYXhpc19udW1iZXJ9X2V4dGVudGBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLnN2Zy5zdHlsZSgnY3Vyc29yJywgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG59XG5cbmV4cG9ydCB7UGxvdCBhcyBkZWZhdWx0fTtcblxuLy8gT25seSBmb3IgdGVzdGluZ1xuZXhwb3J0IHsgX3VwZGF0ZVN0YXRlUG9zaXRpb24gfTtcbiIsIi8qKiBAbW9kdWxlICovXG5pbXBvcnQgd2lkZ2V0cyBmcm9tICcuLi8uLi9yZWdpc3RyeS93aWRnZXRzJztcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuLyoqXG4gKiBBIFRvb2xiYXIgaXMgYW4gSFRNTCBlbGVtZW50IHVzZWQgZm9yIHByZXNlbnRpbmcgYXJiaXRyYXJ5IHVzZXIgaW50ZXJmYWNlIHdpZGdldHMuIFRvb2xiYXJzIGFyZSBhbmNob3JlZFxuICogICB0byBlaXRoZXIgdGhlIGVudGlyZSBQbG90IG9yIHRvIGluZGl2aWR1YWwgUGFuZWxzLlxuICpcbiAqIEVhY2ggdG9vbGJhciBpcyBhbiBIVE1MLWJhc2VkIChyZWFkOiBub3QgU1ZHKSBjb2xsZWN0aW9uIG9mIHdpZGdldHMgdXNlZCB0byBkaXNwbGF5IGluZm9ybWF0aW9uIG9yIHByb3ZpZGVcbiAqICAgdXNlciBpbnRlcmZhY2UuIFRvb2xiYXJzIGNhbiBleGlzdCBvbiBlbnRpcmUgcGxvdHMsIHdoZXJlIHRoZWlyIHZpc2liaWxpdHkgaXMgcGVybWFuZW50IGFuZCB2ZXJ0aWNhbGx5IGFkamFjZW50XG4gKiAgIHRvIHRoZSBwbG90LCBvciBvbiBpbmRpdmlkdWFsIHBhbmVscywgd2hlcmUgdGhlaXIgdmlzaWJpbGl0eSBpcyB0aWVkIHRvIGEgYmVoYXZpb3IgKGUuZy4gYSBtb3VzZW92ZXIpIGFuZCBpcyBhc1xuICogICBhbiBvdmVybGF5LlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciByZW5kZXJpbmcsIGFuZCBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgVG9vbGJhciB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIC8vIHBhcmVudCBtdXN0IGJlIGEgbG9jdXN6b29tIHBsb3Qgb3IgcGFuZWxcbiAgICAgICAgLy8gaWYgKCEocGFyZW50IGluc3RhbmNlb2YgTG9jdXNab29tLlBsb3QpICYmICEocGFyZW50IGluc3RhbmNlb2YgTG9jdXNab29tLlBhbmVsKSkge1xuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIHRvb2xiYXIsIHBhcmVudCBtdXN0IGJlIGEgbG9jdXN6b29tIHBsb3Qgb3IgcGFuZWwnKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKiogQG1lbWJlciB7UGxvdHxQYW5lbH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgLyoqIEBtZW1iZXIge1N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5pZCA9IGAke3RoaXMucGFyZW50LmdldEJhc2VJZCgpfS50b29sYmFyYDtcblxuICAgICAgICAvKiogQG1lbWJlciB7KCdwbG90J3wncGFuZWwnKX0gKi9cbiAgICAgICAgdGhpcy50eXBlID0gKHRoaXMucGFyZW50LnBhcmVudCkgPyAncGFuZWwnIDogJ3Bsb3QnO1xuXG4gICAgICAgIC8qKiBAbWVtYmVyIHtQbG90fSAqL1xuICAgICAgICB0aGlzLnBhcmVudF9wbG90ID0gdGhpcy5wYXJlbnQucGFyZW50X3Bsb3Q7XG5cbiAgICAgICAgLyoqIEBtZW1iZXIge2QzLnNlbGVjdGlvbn0gKi9cbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IG51bGw7XG5cbiAgICAgICAgLyoqIEBtZW1iZXIge0Jhc2VXaWRnZXRbXX0gKi9cbiAgICAgICAgdGhpcy53aWRnZXRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lciBpZGVudGlmaWVyIGFzIHJldHVybmVkIGJ5IHNldFRpbWVvdXRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWRlX3RpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGhpZGUgdGhlIHRvb2xiYXIuIENhbiBiZSBvdmVycmlkZGVuIGJ5IGEgY2hpbGQgd2lkZ2V0LiBDaGVjayB2aWEgYHNob3VsZFBlcnNpc3RgXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVyc2lzdCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHRvb2xiYXIgZm9yIGZpcnN0IHVzZTogZ2VuZXJhdGUgYWxsIHdpZGdldCBpbnN0YW5jZXMgZm9yIHRoaXMgdG9vbGJhciwgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogICBsYXlvdXQgb2YgdGhlIHBhcmVudC4gQ29ubmVjdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBzaG93cy9oaWRlcyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7VG9vbGJhcn1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICAvLyBQYXJzZSBsYXlvdXQgdG8gZ2VuZXJhdGUgd2lkZ2V0IGluc3RhbmNlc1xuICAgICAgICAvLyBJbiBMWiAwLjEyLCBgZGFzaGJvYXJkLmNvbXBvbmVudHNgIHdhcyByZW5hbWVkIHRvIGB0b29sYmFyLndpZGdldHNgLiBQcmVzZXJ2ZSBhIGJhY2t3YXJkcy1jb21wYXRpYmxlIGFsaWFzLlxuICAgICAgICBjb25zdCBvcHRpb25zID0gKHRoaXMucGFyZW50LmxheW91dC5kYXNoYm9hcmQgJiYgdGhpcy5wYXJlbnQubGF5b3V0LmRhc2hib2FyZC5jb21wb25lbnRzKSB8fCB0aGlzLnBhcmVudC5sYXlvdXQudG9vbGJhci53aWRnZXRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKChsYXlvdXQpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWRnZXQgPSB3aWRnZXRzLmNyZWF0ZShsYXlvdXQudHlwZSwgbGF5b3V0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWRnZXRzLnB1c2god2lkZ2V0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNyZWF0ZSB3aWRnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBtb3VzZW92ZXIgZXZlbnQgaGFuZGxlcnMgdG8gc2hvdy9oaWRlIHBhbmVsIHRvb2xiYXJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3BhbmVsJykge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMucGFyZW50LnBhcmVudC5zdmcubm9kZSgpLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgLm9uKGBtb3VzZW92ZXIuJHt0aGlzLmlkfWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZV90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yIHx8IHRoaXMuc2VsZWN0b3Iuc3R5bGUoJ3Zpc2liaWxpdHknKSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkub24oYG1vdXNlb3V0LiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpZGVfdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZV90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcGVyc2lzdCB0aGUgdG9vbGJhci4gUmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSB3aWRnZXQgc2hvdWxkIHBlcnNpc3QsIG9yIGlmIHRoZSBwYW5lbCBpcyBlbmdhZ2VkXG4gICAgICogICBpbiBhbiBhY3RpdmUgZHJhZyBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRQZXJzaXN0KCkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGVyc2lzdCA9IGZhbHNlO1xuICAgICAgICAvLyBQZXJzaXN0IGlmIGF0IGxlYXN0IG9uZSB3aWRnZXQgc2hvdWxkIGFsc28gcGVyc2lzdFxuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCgod2lkZ2V0KSA9PiB7XG4gICAgICAgICAgICBwZXJzaXN0ID0gcGVyc2lzdCB8fCB3aWRnZXQuc2hvdWxkUGVyc2lzdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGVyc2lzdCBpZiBpbiBhIHBhcmVudCBkcmFnIGV2ZW50XG4gICAgICAgIHBlcnNpc3QgPSBwZXJzaXN0IHx8ICh0aGlzLnBhcmVudF9wbG90LnBhbmVsX2JvdW5kYXJpZXMuZHJhZ2dpbmcgfHwgdGhpcy5wYXJlbnRfcGxvdC5pbnRlcmFjdGlvbi5kcmFnZ2luZyk7XG4gICAgICAgIHJldHVybiAhIXBlcnNpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgdG9vbGJhciBhcHBlYXIuIElmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0IGNyZWF0ZSBpdCwgaW5jbHVkaW5nIGNyZWF0aW5nL3Bvc2l0aW9uaW5nIGFsbCB3aWRnZXRzIHdpdGhpbixcbiAgICAgKiAgIGFuZCBtYWtlIHN1cmUgaXQgaXMgc2V0IHRvIGJlIHZpc2libGUuXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncGxvdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudC5zdmcubm9kZSgpLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ2RpdicsICc6Zmlyc3QtY2hpbGQnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhbmVsJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gZDMuc2VsZWN0KHRoaXMucGFyZW50LnBhcmVudC5zdmcubm9kZSgpLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ2RpdicsICcubHotZGF0YV9sYXllci10b29sdGlwLCAubHotdG9vbGJhci1tZW51LCAubHotY3VydGFpbicpLmNsYXNzZWQoJ2x6LXBhbmVsLXRvb2xiYXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sYmFyIGNhbm5vdCBiZSBhIGNoaWxkIG9mICR7dGhpcy50eXBlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2x6LXRvb2xiYXInLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKGBsei0ke3RoaXMudHlwZX0tdG9vbGJhcmAsIHRydWUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goKHdpZGdldCkgPT4gd2lkZ2V0LnNob3coKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdG9vbGJhciBhbmQgcmVyZW5kZXIgYWxsIGNoaWxkIHdpZGdldHMuIFRoaXMgY2FuIGJlIGNhbGxlZCB3aGVuZXZlciBwbG90IHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHJldHVybnMge1Rvb2xiYXJ9XG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKCh3aWRnZXQpID0+IHdpZGdldC51cGRhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgdG9vbGJhciAoYW5kIGNoaWxkIHdpZGdldHMpIHdpdGhpbiB0aGUgcGFuZWxcbiAgICAgKiBAcmV0dXJucyB7VG9vbGJhcn1cbiAgICAgKi9cbiAgICBwb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbGJhciBpdHNlbGYgKHBhbmVsIG9ubHkpXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdwYW5lbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2Vfb3JpZ2luID0gdGhpcy5wYXJlbnQuX2dldFBhZ2VPcmlnaW4oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGAkeyhwYWdlX29yaWdpbi55ICsgMy41KS50b1N0cmluZygpfXB4YDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBgJHtwYWdlX29yaWdpbi54LnRvU3RyaW5nKCl9cHhgO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBgJHsodGhpcy5wYXJlbnQubGF5b3V0LndpZHRoIC0gNCkudG9TdHJpbmcoKX1weGA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCB0b3ApXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgbGVmdClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvc2l0aW9uIHdpZGdldHNcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goKHdpZGdldCkgPT4gd2lkZ2V0LnBvc2l0aW9uKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSB0b29sYmFyIChtYWtlIGludmlzaWJsZSBidXQgZG8gbm90IGRlc3Ryb3kpLiBXaWxsIGRvIG5vdGhpbmcgaWYgYHNob3VsZFBlcnNpc3RgIHJldHVybnMgdHJ1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtUb29sYmFyfVxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RvciB8fCB0aGlzLnNob3VsZFBlcnNpc3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goKHdpZGdldCkgPT4gd2lkZ2V0LmhpZGUoKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JcbiAgICAgICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGxldGVseSByZW1vdmUgdG9vbGJhciBhbmQgYWxsIGNoaWxkIHdpZGdldHMuIChtYXkgYmUgb3ZlcnJpZGRlbiBieSBwZXJzaXN0ZW5jZSBzZXR0aW5ncylcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gSWYgdHJ1ZSwgd2lsbCBpZ25vcmUgcGVyc2lzdGVuY2Ugc2V0dGluZ3MgYW5kIGFsd2F5cyBkZXN0cm95IHRoZSB0b29sYmFyXG4gICAgICogQHJldHVybnMge1Rvb2xiYXJ9XG4gICAgICovXG4gICAgZGVzdHJveShmb3JjZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcmNlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBmb3JjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUGVyc2lzdCgpICYmICFmb3JjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goKHdpZGdldCkgPT4gd2lkZ2V0LmRlc3Ryb3kodHJ1ZSkpO1xuICAgICAgICB0aGlzLndpZGdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuXG5leHBvcnQge1Rvb2xiYXIgYXMgZGVmYXVsdH07XG4iLCIvKiogQG1vZHVsZSAqL1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuXG5pbXBvcnQge3Bvc2l0aW9uSW50VG9TdHJpbmd9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGlzcGxheSc7XG5pbXBvcnQge2FwcGx5U3R5bGVzLCBkZWJvdW5jZX0gZnJvbSAnLi4vLi4vaGVscGVycy9jb21tb24nO1xuaW1wb3J0IHtkZWVwQ29weX0gZnJvbSAnLi4vLi4vaGVscGVycy9sYXlvdXRzJztcblxuLy8gRklYTUU6IEJ1dHRvbiBjcmVhdGlvbiBzaG91bGQgb2NjdXIgaW4gdGhlIGNvbnN0cnVjdG9ycywgbm90IGluIHVwZGF0ZSBmdW5jdGlvbnNcblxuLyoqXG4gKlxuICogQSB3aWRnZXQgaXMgYW4gZW1wdHkgZGl2IHJlbmRlcmVkIG9uIGEgdG9vbGJhciB0aGF0IGNhbiBkaXNwbGF5IGN1c3RvbVxuICogaHRtbCBvZiB1c2VyIGludGVyZmFjZSBlbGVtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXQgQSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgbGF5b3V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHsoJ2xlZnQnfCdyaWdodCcpfSBbbGF5b3V0LnBvc2l0aW9uPSdsZWZ0J10gIFdoZXRoZXIgdG8gZmxvYXQgdGhlIHdpZGdldCBsZWZ0IG9yIHJpZ2h0LlxuICogQHBhcmFtIHsoJ3N0YXJ0J3wnbWlkZGxlJ3wnZW5kJyl9IFtsYXlvdXQuZ3JvdXBfcG9zaXRpb25dIEJ1dHRvbnMgY2FuIG9wdGlvbmFsbHkgYmUgZ2F0aGVyZWQgaW50byBhIHZpc3VhbGx5XG4gKiAgZGlzdGluY3RpdmUgZ3JvdXAgd2hvc2UgZWxlbWVudHMgYXJlIGNsb3NlciB0b2dldGhlci4gSWYgYSBidXR0b24gaXMgaWRlbnRpZmllZCBhcyB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgZ3JvdXAsXG4gKiAgaXQgd2lsbCBiZSBkcmF3biB3aXRoIHJvdW5kZWQgY29ybmVycyBhbmQgYW4gZXh0cmEgbWFyZ2luIG9mIHNwYWNpbmcgZnJvbSBhbnkgYnV0dG9uIG5vdCBwYXJ0IG9mIHRoZSBncm91cC5cbiAqICBGb3IgZXhhbXBsZSwgdGhlIHJlZ2lvbl9uYXZfcGxvdCB0b29sYmFyIGlzIGEgZGVmaW5lZCBhcyBhIGdyb3VwLlxuICogQHBhcmFtIHsoJ2dyYXknfCdyZWQnfCdvcmFuZ2UnfCd5ZWxsb3cnfCdncmVlbid8J2JsdWUnfCdwdXJwbGUnKX0gW2xheW91dC5jb2xvcj0nZ3JheSddICBDb2xvciBzY2hlbWUgZm9yIHRoZVxuICogICB3aWRnZXQuIEFwcGxpZXMgdG8gYnV0dG9ucyBhbmQgbWVudXMuXG4gKiBAcGFyYW0ge1Rvb2xiYXJ9IHBhcmVudCBUaGUgdG9vbGJhciB0aGF0IGNvbnRhaW5zIHRoaXMgd2lkZ2V0XG4gKi9cbmNsYXNzIEJhc2VXaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcGFyZW50KSB7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0IHx8IHt9O1xuICAgICAgICBpZiAoIXRoaXMubGF5b3V0LmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5jb2xvciA9ICdncmF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAbWVtYmVyIHtUb29sYmFyfCp9ICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb21lIHdpZGdldHMgYXJlIGF0dGFjaGVkIHRvIGEgcGFuZWwsIHJhdGhlciB0aGFuIGRpcmVjdGx5IHRvIGEgcGxvdFxuICAgICAgICAgKiBAbWVtYmVyIHtQYW5lbHxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRfcGFuZWwgPSBudWxsO1xuICAgICAgICAvKiogQG1lbWJlciB7UGxvdH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnRfcGxvdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIGVpdGhlciB0aGUgcGFuZWwgb3IgdGhlIHBsb3QsIGRlcGVuZGluZyBvbiB3aGF0IHRoZSB0b29sYmFyIGlzXG4gICAgICAgICAqICAgdGllZCB0by4gVXNlZnVsIHdoZW4gYWJzb2x1dGVseSBwb3NpdGlvbmluZyB0b29sYmFyIHdpZGdldHMgcmVsYXRpdmUgdG8gdGhlaXIgU1ZHIGFuY2hvci5cbiAgICAgICAgICogQG1lbWJlciB7UGxvdHxQYW5lbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50X3N2ZyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09ICdwYW5lbCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wYW5lbCA9IHRoaXMucGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90ID0gdGhpcy5wYXJlbnQucGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9zdmcgPSB0aGlzLnBhcmVudF9wYW5lbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdCA9IHRoaXMucGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9zdmcgPSB0aGlzLnBhcmVudF9wbG90O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAbWVtYmVyIHtkMy5zZWxlY3Rpb259ICovXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB3aWRnZXQsIGl0IHdpbGwgY29udGFpbiBhIGJ1dHRvbiBvciBtZW51IGluc3RhbmNlIHRoYXQgaGFuZGxlcyB0aGUgaW50ZXJhY3Rpdml0eS5cbiAgICAgICAgICogICBUaGVyZSBpcyBhIDEtdG8tMSByZWxhdGlvbnNoaXAgb2YgdG9vbGJhciB3aWRnZXQgdG8gYnV0dG9uXG4gICAgICAgICAqIEBtZW1iZXIge251bGx8QnV0dG9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idXR0b24gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYW55IHNpbmdsZSB3aWRnZXQgaXMgbWFya2VkIHBlcnNpc3RlbnQsIGl0IHdpbGwgYnViYmxlIHVwIHRvIHByZXZlbnQgYXV0b21hdGljIGhpZGUgYmVoYXZpb3Igb24gYVxuICAgICAgICAgKiAgIHdpZGdldCdzIHBhcmVudCB0b29sYmFyLiBDaGVjayB2aWEgYHNob3VsZFBlcnNpc3RgXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVyc2lzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMubGF5b3V0LnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5wb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWxsIHJlbmRlcmluZyBvZiB3aWRnZXQsIGluY2x1ZGluZyB0b2dnbGluZyB2aXNpYmlsaXR5IHRvIHRydWUuIFdpbGwgaW5pdGlhbGl6ZSBhbmQgY3JlYXRlIFNWRyBlbGVtZW50XG4gICAgICogICBpZiBuZWNlc3NhcnksIGFzIHdlbGwgYXMgdXBkYXRpbmcgd2l0aCBuZXcgZGF0YSBhbmQgcGVyZm9ybWluZyBsYXlvdXQgYWN0aW9ucy5cbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8ICF0aGlzLnBhcmVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBfcG9zaXRpb24gPSAoWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJ10uaW5jbHVkZXModGhpcy5sYXlvdXQuZ3JvdXBfcG9zaXRpb24pID8gYCBsei10b29sYmFyLWdyb3VwLSR7dGhpcy5sYXlvdXQuZ3JvdXBfcG9zaXRpb259YCA6ICcnKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnBhcmVudC5zZWxlY3Rvci5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYGx6LXRvb2xiYXItJHt0aGlzLmxheW91dC5wb3NpdGlvbn0ke2dyb3VwX3Bvc2l0aW9ufWApO1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZXModGhpcy5zZWxlY3RvciwgdGhpcy5sYXlvdXQuc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmluaXRpYWxpemUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbiAmJiB0aGlzLmJ1dHRvbi5zdGF0dXMgPT09ICdoaWdobGlnaHRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLm1lbnUuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdG9vbGJhciB3aWRnZXQgd2l0aCBhbnkgbmV3IGRhdGEgb3IgcGxvdCBzdGF0ZSBhcyBhcHByb3ByaWF0ZS4gVGhpcyBtZXRob2QgcGVyZm9ybXMgYWxsXG4gICAgICogIG5lY2Vzc2FyeSByZW5kZXJpbmcgc3RlcHMuXG4gICAgICovXG4gICAgdXBkYXRlKCkgeyAvKiBzdHViICovXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2UgdGhlIHdpZGdldCBjb3JyZWN0bHkgaW4gdGhlIHBsb3RcbiAgICAgKiBAcmV0dXJucyB7QmFzZVdpZGdldH1cbiAgICAgKi9cbiAgICBwb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LnBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHdpZGdldCBzaG91bGQgcGVyc2lzdCAod2lsbCBidWJibGUgdXAgdG8gcGFyZW50IHRvb2xiYXIpXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkUGVyc2lzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKHRoaXMuYnV0dG9uICYmIHRoaXMuYnV0dG9uLnBlcnNpc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB2aXNpYmlsaXR5IHRvIGhpZGRlbiwgdW5sZXNzIG1hcmtlZCBhcyBwZXJzaXN0ZW50XG4gICAgICogQHJldHVybnMge0Jhc2VXaWRnZXR9XG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yIHx8IHRoaXMuc2hvdWxkUGVyc2lzdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uLm1lbnUuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlbHkgcmVtb3ZlIHdpZGdldCBhbmQgYnV0dG9uLiAobWF5IGJlIG92ZXJyaWRkZW4gYnkgcGVyc2lzdGVuY2Ugc2V0dGluZ3MpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2U9ZmFsc2VdIElmIHRydWUsIHdpbGwgaWdub3JlIHBlcnNpc3RlbmNlIHNldHRpbmdzIGFuZCBhbHdheXMgZGVzdHJveSB0aGUgdG9vbGJhclxuICAgICAqIEByZXR1cm5zIHtUb29sYmFyfVxuICAgICAqL1xuICAgIGRlc3Ryb3koZm9yY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JjZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFBlcnNpc3QoKSAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbiAmJiB0aGlzLmJ1dHRvbi5tZW51KSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdG9yLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5idXR0b24gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogUGxvdHMgYW5kIHBhbmVscyBtYXkgaGF2ZSBhIFwidG9vbGJhclwiIGVsZW1lbnQgc3VpdGVkIGZvciBzaG93aW5nIEhUTUwgd2lkZ2V0cyB0aGF0IG1heSBiZSBpbnRlcmFjdGl2ZS5cbiAqICAgV2hlbiB3aWRnZXRzIG5lZWQgdG8gaW5jb3Jwb3JhdGUgYSBnZW5lcmljIGJ1dHRvbiwgb3IgYWRkaXRpb25hbGx5IGEgYnV0dG9uIHRoYXQgZ2VuZXJhdGVzIGEgbWVudSwgdGhpc1xuICogICBjbGFzcyBwcm92aWRlcyBtdWNoIG9mIHRoZSBuZWNlc3NhcnkgZnJhbWV3b3JrLlxuICogQHBhcmFtIHtCYXNlV2lkZ2V0fSBwYXJlbnRcbiAqL1xuY2xhc3MgQnV0dG9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgQmFzZVdpZGdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSB0b29sYmFyIHdpZGdldCBidXR0b24sIGludmFsaWQgcGFyZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBtZW1iZXIge0Jhc2VXaWRnZXR9ICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAvKiogQG1lbWJlciB7UGFuZWx9ICovXG4gICAgICAgIHRoaXMucGFyZW50X3BhbmVsID0gdGhpcy5wYXJlbnQucGFyZW50X3BhbmVsO1xuICAgICAgICAvKiogQG1lbWJlciB7UGxvdH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnRfcGxvdCA9IHRoaXMucGFyZW50LnBhcmVudF9wbG90O1xuICAgICAgICAvKiogQG1lbWJlciB7UGxvdHxQYW5lbH0gKi9cbiAgICAgICAgdGhpcy5wYXJlbnRfc3ZnID0gdGhpcy5wYXJlbnQucGFyZW50X3N2ZztcblxuICAgICAgICAvKiogQG1lbWJlciB7VG9vbGJhcnxudWxsfCp9ICovXG4gICAgICAgIHRoaXMucGFyZW50X3Rvb2xiYXIgPSB0aGlzLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtkMy5zZWxlY3Rpb259ICovXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWcgdG8gdXNlIGZvciB0aGUgYnV0dG9uIChkZWZhdWx0OiBhKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZyA9ICdhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogSFRNTCBmb3IgdGhlIGJ1dHRvbiB0byBzaG93LlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaHRtbCA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZW92ZXIgdGl0bGUgdGV4dCBmb3IgdGhlIGJ1dHRvbiB0byBzaG93XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBvZiB0aGUgYnV0dG9uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSAnZ3JheSc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhc2ggb2YgYXJiaXRyYXJ5IGJ1dHRvbiBzdHlsZXMgdG8gYXBwbHkgYXMge25hbWU6IHZhbHVlfSBlbnRyaWVzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZSA9IHt9O1xuXG4gICAgICAgIC8vIFBlcm1hbmVuY2VcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIGludGVybmFsIHN0YXRlIG9uIHdoZXRoZXIgdG8ga2VlcCBzaG93aW5nIHRoZSBidXR0b24vIG1lbnUgY29udGVudHMgYXQgdGhlIG1vbWVudFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlcnNpc3QgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gd2hlbiBkZWZpbmluZyBhIGJ1dHRvbjogdHJhY2sgd2hldGhlciB0aGlzIHdpZGdldCBzaG91bGQgYmUgYWxsb3dlZCB0byBrZWVwIG9wZW5cbiAgICAgICAgICogICBtZW51L2J1dHRvbiBjb250ZW50cyBpbiByZXNwb25zZSB0byBjZXJ0YWluIGV2ZW50c1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlcm1hbmVudCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdXR0b24gc3RhdHVzIChoaWdobGlnaHRlZCAvIGRpc2FibGVkLyBldGMpXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnV0dG9uIE1lbnUgT2JqZWN0XG4gICAgICAgICAqIFRoZSBtZW51IGlzIGFuIEhUTUwgb3ZlcmxheSB0aGF0IGNhbiBhcHBlYXIgYmVsb3cgYSBidXR0b24uIEl0IGNhbiBjb250YWluIGFyYml0cmFyeSBIVE1MIGFuZFxuICAgICAgICAgKiAgIGhhcyBsb2dpYyB0byBiZSBhdXRvbWF0aWNhbGx5IHBvc2l0aW9uZWQgYW5kIHNpemVkIHRvIGJlaGF2ZSBtb3JlIG9yIGxlc3MgbGlrZSBhIGRyb3Bkb3duIG1lbnUuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWVudSA9IHtcbiAgICAgICAgICAgIG91dGVyX3NlbGVjdG9yOiBudWxsLFxuICAgICAgICAgICAgaW5uZXJfc2VsZWN0b3I6IG51bGwsXG4gICAgICAgICAgICBzY3JvbGxfcG9zaXRpb246IDAsXG4gICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNob3cgdGhlIGJ1dHRvbiBtZW51LCBpbmNsdWRpbmcgc2V0dGluZyB1cCBhbnkgRE9NIGVsZW1lbnRzIG5lZWRlZCBmb3IgZmlyc3QgcmVuZGVyaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWVudS5vdXRlcl9zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnUub3V0ZXJfc2VsZWN0b3IgPSBkMy5zZWxlY3QodGhpcy5wYXJlbnRfcGxvdC5zdmcubm9kZSgpLnBhcmVudE5vZGUpLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLW1lbnUgbHotdG9vbGJhci1tZW51LSR7dGhpcy5jb2xvcn1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7dGhpcy5wYXJlbnRfc3ZnLmdldEJhc2VJZCgpfS50b29sYmFyLm1lbnVgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51LmlubmVyX3NlbGVjdG9yID0gdGhpcy5tZW51Lm91dGVyX3NlbGVjdG9yLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei10b29sYmFyLW1lbnUtY29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnUuaW5uZXJfc2VsZWN0b3Iub24oJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5zY3JvbGxfcG9zaXRpb24gPSB0aGlzLm1lbnUuaW5uZXJfc2VsZWN0b3Iubm9kZSgpLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWVudS5vdXRlcl9zZWxlY3Rvci5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnUudXBkYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHJlbmRlcmluZyBvZiB0aGUgbWVudVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWVudS5vdXRlcl9zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUucG9wdWxhdGUoKTsgLy8gVGhpcyBmdW5jdGlvbiBpcyBzdHViYmVkIGZvciBhbGwgYnV0dG9ucyBieSBkZWZhdWx0IGFuZCBjdXN0b20gaW1wbGVtZW50ZWQgaW4gd2lkZ2V0IGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW51LmlubmVyX3NlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5pbm5lcl9zZWxlY3Rvci5ub2RlKCkuc2Nyb2xsVG9wID0gdGhpcy5tZW51LnNjcm9sbF9wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1lbnUub3V0ZXJfc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5zZXQgYW55IGV4cGxpY2l0bHkgZGVmaW5lZCBvdXRlciBzZWxlY3RvciBoZWlnaHQgc28gdGhhdCBtZW51cyBkeW5hbWljYWxseSBzaHJpbmsgaWYgY29udGVudCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51Lm91dGVyX3NlbGVjdG9yLnN0eWxlKCdoZWlnaHQnLCBudWxsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gMztcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxiYXJfcGFkZGluZyA9IDIwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVfaGVpZ2h0X3BhZGRpbmcgPSAxNDsgLy8gMTQ6IDJ4IDZweCBwYWRkaW5nLCAyeCAxcHggYm9yZGVyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZV9vcmlnaW4gPSB0aGlzLnBhcmVudF9zdmcuX2dldFBhZ2VPcmlnaW4oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlX3Njcm9sbF90b3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcl9vZmZzZXQgPSB0aGlzLnBhcmVudF9wbG90LmdldENvbnRhaW5lck9mZnNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xiYXJfY2xpZW50X3JlY3QgPSB0aGlzLnBhcmVudF90b29sYmFyLnNlbGVjdG9yLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25fY2xpZW50X3JlY3QgPSB0aGlzLnNlbGVjdG9yLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZW51X2NsaWVudF9yZWN0ID0gdGhpcy5tZW51Lm91dGVyX3NlbGVjdG9yLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbF9jb250ZW50X2hlaWdodCA9IHRoaXMubWVudS5pbm5lcl9zZWxlY3Rvci5ub2RlKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3A7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3Rvb2xiYXIudHlwZSA9PT0gJ3BhbmVsJykge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAocGFnZV9vcmlnaW4ueSArIHRvb2xiYXJfY2xpZW50X3JlY3QuaGVpZ2h0ICsgKDIgKiBwYWRkaW5nKSk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChwYWdlX29yaWdpbi54ICsgdGhpcy5wYXJlbnRfc3ZnLmxheW91dC53aWR0aCAtIG1lbnVfY2xpZW50X3JlY3Qud2lkdGggLSBwYWRkaW5nLCBwYWdlX29yaWdpbi54ICsgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYnV0dG9uX2NsaWVudF9yZWN0LmJvdHRvbSArIHBhZ2Vfc2Nyb2xsX3RvcCArIHBhZGRpbmcgLSBjb250YWluZXJfb2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGJ1dHRvbl9jbGllbnRfcmVjdC5sZWZ0ICsgYnV0dG9uX2NsaWVudF9yZWN0LndpZHRoIC0gbWVudV9jbGllbnRfcmVjdC53aWR0aCAtIGNvbnRhaW5lcl9vZmZzZXQubGVmdCwgcGFnZV9vcmlnaW4ueCArIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlX21heF93aWR0aCA9IE1hdGgubWF4KHRoaXMucGFyZW50X3N2Zy5sYXlvdXQud2lkdGggLSAoMiAqIHBhZGRpbmcpIC0gc2Nyb2xsYmFyX3BhZGRpbmcsIHNjcm9sbGJhcl9wYWRkaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJfbWF4X3dpZHRoID0gYmFzZV9tYXhfd2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudF9tYXhfd2lkdGggPSAoYmFzZV9tYXhfd2lkdGggLSAoNCAqIHBhZGRpbmcpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlX21heF9oZWlnaHQgPSBNYXRoLm1heCh0aGlzLnBhcmVudF9zdmcubGF5b3V0LmhlaWdodCAtICgxMCAqIHBhZGRpbmcpIC0gbWVudV9oZWlnaHRfcGFkZGluZywgbWVudV9oZWlnaHRfcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4odG90YWxfY29udGVudF9oZWlnaHQsIGJhc2VfbWF4X2hlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51Lm91dGVyX3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndG9wJywgYCR7dG9wfXB4YClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgYCR7bGVmdH1weGApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWF4LXdpZHRoJywgYCR7Y29udGFpbmVyX21heF93aWR0aH1weGApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWF4LWhlaWdodCcsIGAke2Jhc2VfbWF4X2hlaWdodH1weGApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgYCR7aGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LmlubmVyX3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWF4LXdpZHRoJywgYCR7Y29udGVudF9tYXhfd2lkdGh9cHhgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuaW5uZXJfc2VsZWN0b3Iubm9kZSgpLnNjcm9sbFRvcCA9IHRoaXMubWVudS5zY3JvbGxfcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1lbnUub3V0ZXJfc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51Lm91dGVyX3NlbGVjdG9yLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVudS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tZW51Lm91dGVyX3NlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWVudS5pbm5lcl9zZWxlY3Rvci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUub3V0ZXJfc2VsZWN0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LmlubmVyX3NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUub3V0ZXJfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbnRlcm5hbCBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICAgICAgICogQnkgY29udmVudGlvbiBwb3B1bGF0ZSgpIGRvZXMgbm90aGluZyBhbmQgc2hvdWxkIGJlIHJlaW1wbGVtZW50ZWQgd2l0aCBlYWNoIHRvb2xiYXIgYnV0dG9uIGRlZmluaXRpb25cbiAgICAgICAgICAgICAqICAgUmVpbXBsZW1lbnQgYnkgd2F5IG9mIFRvb2xiYXIuQmFzZVdpZGdldC5CdXR0b24ubWVudS5zZXRQb3B1bGF0ZSB0byBkZWZpbmUgdGhlIHBvcHVsYXRlIG1ldGhvZCBhbmQgaG9va1xuICAgICAgICAgICAgICogICB1cCBzdGFuZGFyZCBtZW51IGNsaWNrLXRvZ2dsZSBiZWhhdmlvciBwcm90b3R5cGUuXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBvcHVsYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVmaW5lIGhvdyB0aGUgbWVudSBpcyBwb3B1bGF0ZWQgd2l0aCBpdGVtcywgYW5kIHNldCB1cCBjbGljayBhbmQgZGlzcGxheSBwcm9wZXJ0aWVzIGFzIGFwcHJvcHJpYXRlXG4gICAgICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFBvcHVsYXRlOiAobWVudV9wb3B1bGF0ZV9mdW5jdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVudV9wb3B1bGF0ZV9mdW5jdGlvbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5wb3B1bGF0ZSA9IG1lbnVfcG9wdWxhdGVfZnVuY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW51LmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoKS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcnNpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnUuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0KGZhbHNlKS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGVybWFuZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyc2lzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPbmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7KCdncmF5J3wncmVkJ3wnb3JhbmdlJ3wneWVsbG93J3wnZ3JlZW4nfCdibHVlJ3wncHVycGxlJyl9IGNvbG9yIEFueSBzZWxlY3Rpb24gbm90IGluIHRoZSBwcmVzZXQgbGlzdFxuICAgICAqICAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGdyYXkuXG4gICAgICogQHJldHVybnMge0J1dHRvbn1cbiAgICAgKi9cbiAgICBzZXRDb2xvciAoY29sb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKFsnZ3JheScsICdyZWQnLCAnb3JhbmdlJywgJ3llbGxvdycsICdncmVlbicsICdibHVlJywgJ3B1cnBsZSddLmluY2x1ZGVzKGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9ICdncmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyBjb2RlIHRvIGNoYW5nZSB3aGV0aGVyIHRoZSBidXR0b24gaXMgYWxsb3dlZCB0byBiZSBgcGVybWFuZW50YFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm9vbFxuICAgICAqIEByZXR1cm5zIHtCdXR0b259XG4gICAgICovXG4gICAgc2V0UGVybWFuZW50IChib29sKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9vbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib29sID0gQm9vbGVhbihib29sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcm1hbmVudCA9IGJvb2w7XG4gICAgICAgIGlmICh0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgYnV0dG9uL21lbnUgY29udGVudHMgc2hvdWxkIHBlcnNpc3QgaW4gcmVzcG9uc2UgdG8gYSBzcGVjaWZpYyBldmVudFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZFBlcnNpc3QgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJtYW5lbnQgfHwgdGhpcy5wZXJzaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICogU2V0IGEgY29sbGVjdGlvbiBvZiBjdXN0b20gc3R5bGVzIHRvIGJlIHVzZWQgYnkgdGhlIGJ1dHRvblxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEhhc2ggb2Yge25hbWU6dmFsdWV9IGVudHJpZXNcbiAqIEByZXR1cm5zIHtCdXR0b259XG4gKi9cbiAgICBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnZW5lcmF0ZSBhIENTUyBjbGFzcyBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldENsYXNzICgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBfcG9zaXRpb24gPSAoWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJ10uaW5jbHVkZXModGhpcy5wYXJlbnQubGF5b3V0Lmdyb3VwX3Bvc2l0aW9uKSA/IGAgbHotdG9vbGJhci1idXR0b24tZ3JvdXAtJHt0aGlzLnBhcmVudC5sYXlvdXQuZ3JvdXBfcG9zaXRpb259YCA6ICcnKTtcbiAgICAgICAgcmV0dXJuIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi0ke3RoaXMuY29sb3J9JHt0aGlzLnN0YXR1cyA/IGAtJHt0aGlzLnN0YXR1c31gIDogJyd9JHtncm91cF9wb3NpdGlvbn1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBidXR0b24gc3RhdGVcbiAgICAgKiBAcGFyYW0geygnaGlnaGxpZ2h0ZWQnfCdkaXNhYmxlZCd8JycpfSBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMgIChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgIT0gJ3VuZGVmaW5lZCcgJiYgWycnLCAnaGlnaGxpZ2h0ZWQnLCAnZGlzYWJsZWQnXS5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgd2hldGhlciB0aGUgYnV0dG9uIGlzIGhpZ2hsaWdodGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBib29sIElmIHByb3ZpZGVkLCBleHBsaWNpdGx5IHNldCBoaWdobGlnaHRlZCBzdGF0ZVxuICAgICAqIEByZXR1cm5zIHtCdXR0b259XG4gICAgICovXG4gICAgaGlnaGxpZ2h0IChib29sKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9vbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib29sID0gQm9vbGVhbihib29sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdHVzKCdoaWdobGlnaHRlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSAnaGlnaGxpZ2h0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0dXMoJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB3aGV0aGVyIHRoZSBidXR0b24gaXMgZGlzYWJsZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2wgSWYgcHJvdmlkZWQsIGV4cGxpY2l0bHkgc2V0IGRpc2FibGVkIHN0YXRlXG4gICAgICogQHJldHVybnMge0J1dHRvbn1cbiAgICAgKi9cbiAgICBkaXNhYmxlIChib29sKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9vbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib29sID0gQm9vbGVhbihib29sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdHVzKCdkaXNhYmxlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0dXMoJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgIC8qKiBAbWVtYmVyIHtmdW5jdGlvbn0gKi9cbiAgICBvbm1vdXNlb3ZlciAoKSB7XG4gICAgfVxuICAgIHNldE9uTW91c2VvdmVyIChvbm1vdXNlb3Zlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ubW91c2VvdmVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZW92ZXIgPSBvbm1vdXNlb3ZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKiogQG1lbWJlciB7ZnVuY3Rpb259ICovXG4gICAgb25tb3VzZW91dCAoKSB7XG4gICAgfVxuICAgIHNldE9uTW91c2VvdXQgKG9ubW91c2VvdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbm1vdXNlb3V0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZW91dCA9IG9ubW91c2VvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKiogQG1lbWJlciB7ZnVuY3Rpb259ICovXG4gICAgb25jbGljayAoKSB7XG4gICAgfVxuICAgIHNldE9uY2xpY2sgKG9uY2xpY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbmNsaWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25jbGljayA9IG9uY2xpY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1vdXNlb3ZlciB0aXRsZSB0ZXh0IGZvciB0aGUgYnV0dG9uIChpZiBhbnkpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIFNpbXBsZSB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgKiBAcmV0dXJucyB7QnV0dG9ufVxuICAgICAqL1xuICAgIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIEhUTUwgY29udGVudCBvZiB0aGlzIGJ1dHRvbi5cbiAgICAgKiBXQVJOSU5HOiBUaGUgc3RyaW5nIHByb3ZpZGVkIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byB0aGUgZG9jdW1lbnQgYXMgcmF3IG1hcmt1cDsgWFNTIG1pdGlnYXRpb24gaXMgdGhlXG4gICAgICogICByZXNwb25zaWJpbGl0eSBvZiBlYWNoIGJ1dHRvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAgICAqIEByZXR1cm5zIHtCdXR0b259XG4gICAgICovXG4gICAgc2V0SHRtbChodG1sKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaHRtbCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5odG1sID0gaHRtbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFByaW1hcnkgYmVoYXZpb3IgZnVuY3Rpb25zXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgYnV0dG9uLCBpbmNsdWRpbmcgY3JlYXRpbmcgRE9NIGVsZW1lbnRzIGlmIG5lY2Vzc2FyeSBmb3IgZmlyc3QgcmVuZGVyXG4gICAgICovXG4gICAgc2hvdyAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnBhcmVudC5zZWxlY3Rvci5hcHBlbmQodGhpcy50YWcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgdGhpcy5nZXRDbGFzcygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb29rIGZvciBhbnkgYWN0aW9ucyBvciBzdGF0ZSBjbGVhbnVwIHRvIGJlIHBlcmZvcm1lZCBiZWZvcmUgcmVyZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7QnV0dG9ufVxuICAgICAqL1xuICAgIHByZVVwZGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBidXR0b24gc3RhdGUgYW5kIGNvbnRlbnRzLCBhbmQgZnVsbHkgcmVyZW5kZXJcbiAgICAgKiBAcmV0dXJucyB7QnV0dG9ufVxuICAgICAqL1xuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVVcGRhdGUoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgdGhpcy5nZXRDbGFzcygpKVxuICAgICAgICAgICAgLmF0dHIoJ3RpdGxlJywgdGhpcy50aXRsZSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgKHRoaXMuc3RhdHVzID09PSAnZGlzYWJsZWQnKSA/IG51bGwgOiB0aGlzLm9ubW91c2VvdmVyKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsICh0aGlzLnN0YXR1cyA9PT0gJ2Rpc2FibGVkJykgPyBudWxsIDogdGhpcy5vbm1vdXNlb3V0KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICh0aGlzLnN0YXR1cyA9PT0gJ2Rpc2FibGVkJykgPyBudWxsIDogdGhpcy5vbmNsaWNrKVxuICAgICAgICAgICAgLmh0bWwodGhpcy5odG1sKVxuICAgICAgICAgICAgLmNhbGwoYXBwbHlTdHlsZXMsIHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMubWVudS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5wb3N0VXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIGFueSBiZWhhdmlvciB0byBiZSBhZGRlZC9jaGFuZ2VkIGFmdGVyIHRoZSBidXR0b24gaGFzIGJlZW4gcmUtcmVuZGVyZWRcbiAgICAgKiBAcmV0dXJucyB7QnV0dG9ufVxuICAgICAqL1xuICAgIHBvc3RVcGRhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBidXR0b24gYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgRE9NIChtYXkgYmUgb3ZlcnJpZGRlbiBieSBjdXJyZW50IHBlcnNpc3RlbmNlIHNldHRpbmcpXG4gICAgICogQHJldHVybnMge0J1dHRvbn1cbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RvciAmJiAhdGhpcy5zaG91bGRQZXJzaXN0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBSZW5kZXJzIGFyYml0cmFyeSB0ZXh0IHdpdGggdGl0bGUgZm9ybWF0dGluZ1xuICogQHBhcmFtIHtvYmplY3R9IGxheW91dFxuICogQHBhcmFtIHtzdHJpbmd9IGxheW91dC50aXRsZSBUZXh0IHRvIHJlbmRlclxuICovXG5jbGFzcyBUaXRsZSBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIHNob3coKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXZfc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2X3NlbGVjdG9yID0gdGhpcy5wYXJlbnQuc2VsZWN0b3IuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLXRpdGxlIGx6LXRvb2xiYXItJHt0aGlzLmxheW91dC5wb3NpdGlvbn1gKTtcbiAgICAgICAgICAgIHRoaXMudGl0bGVfc2VsZWN0b3IgPSB0aGlzLmRpdl9zZWxlY3Rvci5hcHBlbmQoJ2gzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBsZXQgdGl0bGUgPSB0aGlzLmxheW91dC50aXRsZS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQuc3VidGl0bGUpIHtcbiAgICAgICAgICAgIHRpdGxlICs9IGAgPHNtYWxsPiR7dGhpcy5sYXlvdXQuc3VidGl0bGV9PC9zbWFsbD5gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGl0bGVfc2VsZWN0b3IuaHRtbCh0aXRsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRleHQgdG8gZGlzcGxheSB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBwbG90LiBBdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYXMgcGxvdCBkaW1lbnNpb25zIGNoYW5nZVxuICovXG5jbGFzcyBEaW1lbnNpb25zIGV4dGVuZHMgQmFzZVdpZGdldCB7XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBkaXNwbGF5X3dpZHRoID0gIXRoaXMucGFyZW50X3Bsb3QubGF5b3V0LndpZHRoLnRvU3RyaW5nKCkuaW5jbHVkZXMoJy4nKSA/IHRoaXMucGFyZW50X3Bsb3QubGF5b3V0LndpZHRoIDogdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQud2lkdGgudG9GaXhlZCgyKTtcbiAgICAgICAgY29uc3QgZGlzcGxheV9oZWlnaHQgPSAhdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQuaGVpZ2h0LnRvU3RyaW5nKCkuaW5jbHVkZXMoJy4nKSA/IHRoaXMucGFyZW50X3Bsb3QubGF5b3V0LmhlaWdodCA6IHRoaXMucGFyZW50X3Bsb3QubGF5b3V0LmhlaWdodC50b0ZpeGVkKDIpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLmh0bWwoYCR7ZGlzcGxheV93aWR0aH1weCDDlyAke2Rpc3BsYXlfaGVpZ2h0fXB4YCk7XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci5hdHRyKCdjbGFzcycsIHRoaXMubGF5b3V0LmNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQuc3R5bGUpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGVzKHRoaXMuc2VsZWN0b3IsIHRoaXMubGF5b3V0LnN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogRGlzcGxheSB0aGUgY3VycmVudCBzY2FsZSBvZiB0aGUgZ2Vub21lIHJlZ2lvbiBkaXNwbGF5ZWQgaW4gdGhlIHBsb3QsIGFzIGRlZmluZWQgYnkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuICogIGBzdGF0ZS5lbmRgIGFuZCBgc3RhdGUuc3RhcnRgLlxuICovXG5jbGFzcyBSZWdpb25TY2FsZSBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLnBhcmVudF9wbG90LnN0YXRlLnN0YXJ0KSAmJiAhaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5lbmQpXG4gICAgICAgICAgICAmJiB0aGlzLnBhcmVudF9wbG90LnN0YXRlLnN0YXJ0ICE9PSBudWxsICYmIHRoaXMucGFyZW50X3Bsb3Quc3RhdGUuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLnN0eWxlKCdkaXNwbGF5JywgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmh0bWwocG9zaXRpb25JbnRUb1N0cmluZyh0aGlzLnBhcmVudF9wbG90LnN0YXRlLmVuZCAtIHRoaXMucGFyZW50X3Bsb3Quc3RhdGUuc3RhcnQsIG51bGwsIHRydWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3Iuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci5hdHRyKCdjbGFzcycsIHRoaXMubGF5b3V0LmNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQuc3R5bGUpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGVzKHRoaXMuc2VsZWN0b3IsIHRoaXMubGF5b3V0LnN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIEZpbHRlckZpZWxkIGV4dGVuZHMgQmFzZVdpZGdldCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheW91dC5sYXllcl9uYW1lIFRoZSBkYXRhIGxheWVyIHRvIGNvbnRyb2wgd2l0aCBmaWx0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dC5maWx0ZXJfaWQgPSBudWxsXSBTb21ldGltZXMgd2Ugd2FudCB0byBkZWZpbmUgbW9yZSB0aGFuIG9uZSBmaWx0ZXIgd2l0aCB0aGUgc2FtZSBvcGVyYXRvclxuICAgICAqICAoZWcgIT0gbnVsbCwgIT0gYmFjb24pLiBUaGUgYGZpbHRlcl9pZGAgb3B0aW9uIGFsbG93cyB1cyB0byBpZGVudGlmeSB3aGljaCBmaWx0ZXIgaXMgY29udHJvbGxlZCBieSB0aGlzIHdpZGdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5b3V0LmZpZWxkIFRoZSBmaWVsZCB0byBiZSBmaWx0ZXJlZCAoZWcgYGFzc29jOmxvZ19wdmFsdWVgKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQuZmllbGRfZGlzcGxheV9odG1sIEh1bWFuLXJlYWRhYmxlIGxhYmVsIGZvciB0aGUgZmllbGQgdG8gYmUgZmlsdGVyZWQgKGAtbG9nPHN1Yj4xMDwvc3ViPnBgKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQub3BlcmF0b3IgVGhlIG9wZXJhdG9yIHRvIHVzZSB3aGVuIGZpbHRlcmluZy4gVGhpcyBtdXN0IGJlIG9uZSBvZiB0aGUgb3B0aW9ucyBhbGxvd2VkIGJ5IGRhdGFfbGF5ZXIuZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGF5b3V0LmlucHV0X3NpemU9NF0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIHRoZSB0ZXh0IGZpZWxkXG4gICAgICogQHBhcmFtIHsoJ251bWJlcid8J3N0cmluZycpfSBbbGF5b3V0LmRhdGFfdHlwZT0nbnVtYmVyJ10gQ29udmVydCB0aGUgdGV4dCBib3ggaW5wdXQgdG8gdGhlIHNwZWNpZmllZCB0eXBlLCBhbmQgd2FybiB0aGVcbiAgICAgKiAgdXNlciBpZiB0aGUgdmFsdWUgd291bGQgYmUgaW52YWxpZCAoZWcsIG5vdCBudW1lcmljKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKGxheW91dCwgcGFyZW50KTtcblxuICAgICAgICBpZiAoIXRoaXMucGFyZW50X3BhbmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlciB3aWRnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBwYW5lbCB0b29sYmFycycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGF0YV9sYXllciA9IHRoaXMucGFyZW50X3BhbmVsLmRhdGFfbGF5ZXJzW2xheW91dC5sYXllcl9uYW1lXTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhX2xheWVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbHRlciB3aWRnZXQgY291bGQgbm90IGxvY2F0ZSB0aGUgc3BlY2lmaWVkIGxheWVyX25hbWU6ICcke2xheW91dC5sYXllcl9uYW1lfSdgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpZWxkID0gbGF5b3V0LmZpZWxkO1xuICAgICAgICB0aGlzLl9maWVsZF9kaXNwbGF5X2h0bWwgPSBsYXlvdXQuZmllbGRfZGlzcGxheV9odG1sO1xuICAgICAgICB0aGlzLl9vcGVyYXRvciA9IGxheW91dC5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy5fZmlsdGVyX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGF0YV90eXBlID0gbGF5b3V0LmRhdGFfdHlwZSB8fCAnbnVtYmVyJztcbiAgICAgICAgaWYgKCFbJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0aGlzLl9kYXRhX3R5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlciBtdXN0IGJlIGVpdGhlciBzdHJpbmcgb3IgbnVtYmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZV9zZWxlY3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgX2dldFRhcmdldCgpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgc3BlY2lmaWMgZmlsdGVyIGluIGxheWVyLmxheW91dC5maWx0ZXJzLCBhbmQgaWYgbm90IHByZXNlbnQsIGFkZCBvbmVcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhX2xheWVyLmxheW91dC5maWx0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhX2xheWVyLmxheW91dC5maWx0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2RhdGFfbGF5ZXIubGF5b3V0LmZpbHRlcnNcbiAgICAgICAgICAgIC5maW5kKChpdGVtKSA9PiBpdGVtLmZpZWxkID09PSB0aGlzLl9maWVsZCAmJiBpdGVtLm9wZXJhdG9yID09PSB0aGlzLl9vcGVyYXRvciAmJiAoIXRoaXMuX2ZpbHRlcl9pZCB8fCBpdGVtLmlkID09PSB0aGlzLl9maWx0ZXJfaWQpKTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0geyBmaWVsZDogdGhpcy5fZmllbGQsIG9wZXJhdG9yOiB0aGlzLl9vcGVyYXRvciwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9maWx0ZXJfaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbJ2lkJ10gPSB0aGlzLl9maWx0ZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRhX2xheWVyLmxheW91dC5maWx0ZXJzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKiBDbGVhciB0aGUgZmlsdGVyIGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIGxpc3QgKi9cbiAgICBfY2xlYXJGaWx0ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhX2xheWVyLmxheW91dC5maWx0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2RhdGFfbGF5ZXIubGF5b3V0LmZpbHRlcnMuaW5kZXhPZih0aGlzLl9nZXRUYXJnZXQoKSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhX2xheWVyLmxheW91dC5maWx0ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU2V0IHRoZSBmaWx0ZXIgYmFzZWQgb24gYSBwcm92aWRlZCB2YWx1ZSAqL1xuICAgIF9zZXRGaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPbiBibGFuayBvciBpbnZhbGlkIHZhbHVlLCByZW1vdmUgdGhlIGZpbHRlciAmIHdhcm5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlX3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXInLCAnMXB4IHNvbGlkIHJlZCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdjb2xvcicsICdyZWQnKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRmlsdGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9nZXRUYXJnZXQoKTtcbiAgICAgICAgICAgIGZpbHRlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgdXNlci1lbnRlcmVkIHZhbHVlLCBjb2VyY2luZyB0eXBlIGlmIG5lY2Vzc2FyeS4gUmV0dXJucyBudWxsIGZvciBpbnZhbGlkIG9yIG1pc3NpbmcgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge251bGx8bnVtYmVyfHN0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5fdmFsdWVfc2VsZWN0b3IucHJvcGVydHkoJ3ZhbHVlJyk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kYXRhX3R5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlX3NlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rvci5zdHlsZSgncGFkZGluZycsICcwIDZweCcpO1xuXG4gICAgICAgIC8vIExhYmVsXG4gICAgICAgIHRoaXMuc2VsZWN0b3JcbiAgICAgICAgICAgIC5hcHBlbmQoJ3NwYW4nKVxuICAgICAgICAgICAgLmh0bWwodGhpcy5fZmllbGRfZGlzcGxheV9odG1sKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJyNmZmYnKVxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnM3B4Jyk7XG4gICAgICAgIC8vIE9wZXJhdG9yIGxhYmVsXG4gICAgICAgIHRoaXMuc2VsZWN0b3IuYXBwZW5kKCdzcGFuJylcbiAgICAgICAgICAgIC50ZXh0KHRoaXMuX29wZXJhdG9yKVxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nJywgJzAgM3B4JylcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsICcjZmZmJyk7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVfc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yXG4gICAgICAgICAgICAuYXBwZW5kKCdpbnB1dCcpXG4gICAgICAgICAgICAuYXR0cignc2l6ZScsIHRoaXMubGF5b3V0LmlucHV0X3NpemUgfHwgNClcbiAgICAgICAgICAgIC5vbignaW5wdXQnLCBkZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdmFsaWRhdGlvbiBzdGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlX3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyJywgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdjb2xvcicsIG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3BhbmVsLnJlbmRlcigpO1xuICAgICAgICAgICAgfSwgNzUwKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ1dHRvbiB0byBleHBvcnQgY3VycmVudCBwbG90IHRvIGFuIFNWRyBpbWFnZVxuICovXG5jbGFzcyBEb3dubG9hZFNWRyBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0LmJ1dHRvbl9odG1sPVwiRG93bmxvYWQgU1ZHXCJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQuYnV0dG9uX3RpdGxlPVwiRG93bmxvYWQgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgcGxvdCBhcyBsb2N1c3pvb20uc3ZnXCJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQuZmlsZW5hbWU9XCJsb2N1c3pvb20uc3ZnXCJdIFRoZSBkZWZhdWx0IGZpbGVuYW1lIHRvIHVzZSB3aGVuIHNhdmluZyB0aGUgaW1hZ2VcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKGxheW91dCwgcGFyZW50KTtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSB0aGlzLmxheW91dC5maWxlbmFtZSB8fCAnbG9jdXN6b29tLnN2Zyc7XG4gICAgICAgIHRoaXMuX2J1dHRvbl9odG1sID0gdGhpcy5sYXlvdXQuYnV0dG9uX2h0bWwgfHwgJ1NhdmUgU1ZHJztcbiAgICAgICAgdGhpcy5fYnV0dG9uX3RpdGxlID0gdGhpcy5sYXlvdXQuYnV0dG9uX3RpdGxlIHx8ICdEb3dubG9hZCBoaS1yZXMgaW1hZ2UnO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1dHRvbiA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgICAgIC5zZXRDb2xvcih0aGlzLmxheW91dC5jb2xvcilcbiAgICAgICAgICAgIC5zZXRIdG1sKHRoaXMuX2J1dHRvbl9odG1sKVxuICAgICAgICAgICAgLnNldFRpdGxlKHRoaXMuX2J1dHRvbl90aXRsZSlcbiAgICAgICAgICAgIC5zZXRPbk1vdXNlb3ZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2x6LXRvb2xiYXItYnV0dG9uLWdyYXktZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuaHRtbCgnUHJlcGFyaW5nIEltYWdlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0QmxvYlVybCgpLnRoZW4oKHVybCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSB0aGlzLmJ1dHRvbi5zZWxlY3Rvci5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIG9sZCB1cmwgaW5zdGFuY2UgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCB1cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbHotdG9vbGJhci1idXR0b24tZ3JheS1kaXNhYmxlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2x6LXRvb2xiYXItYnV0dG9uLWdyYXktaGlnaGxpZ2h0ZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwodGhpcy5fYnV0dG9uX2h0bWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZXRPbk1vdXNlb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5zZWxlY3Rvci5jbGFzc2VkKCdsei10b29sYmFyLWJ1dHRvbi1ncmF5LWhpZ2hsaWdodGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnV0dG9uLnNob3coKTtcbiAgICAgICAgdGhpcy5idXR0b24uc2VsZWN0b3JcbiAgICAgICAgICAgIC5hdHRyKCdocmVmLWxhbmcnLCAnaW1hZ2Uvc3ZnK3htbCcpXG4gICAgICAgICAgICAuYXR0cignZG93bmxvYWQnLCB0aGlzLl9maWxlbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYWxsIENTUyBydWxlcyB3aG9zZSBzZWxlY3RvcnMgZGlyZWN0bHkgcmVmZXJlbmNlIGVsZW1lbnRzIHVuZGVyIHRoZSByb290IG5vZGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q1NTKHJvb3QpIHtcbiAgICAgICAgLy8gSGFjazogdGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGV4dCBtYXRjaGluZyB0aGUgcnVsZXMgb24gYSBnaXZlbiBub2RlOyBpdCBkb2Vzbid0IGhhbmRsZSwgZWcgYW5jZXN0b3JzLlxuICAgICAgICAvLyBTaW5jZSBhbGwgTFogY3NzUnVsZXMgYXJlIHdyaXR0ZW4gYXMgXCJzdmcgLmNsYXNzbmFtZVwiLCB3ZSBuZWVkIHRvIHN0cmlwIHRoZSBwYXJlbnQgc2VsZWN0b3IgcHJlZml4IGluIG9yZGVyXG4gICAgICAgIC8vIHRvIGV4dHJhY3QgQ1NTLlxuICAgICAgICBjb25zdCBhbmNlc3Rvcl9wYXR0ZXJuID0gL15zdmdcXC5sei1sb2N1c3pvb21cXHMqLztcblxuICAgICAgICAvLyBFeHRyYWN0IGFsbCByZWxldmFudCBDU1MgUnVsZXMgYnkgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGF2YWlsYWJsZSBzdHlsZXNoZWV0c1xuICAgICAgICBsZXQgZXh0cmFjdGVkQ1NTVGV4dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghcy5jc3NSdWxlcykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9IC8vIGZvciBGaXJlZm94XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3NzUnVsZXMgPSBzLmNzc1J1bGVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3NSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBXZSBjb3VsZCB3cml0ZSBzbWFsbGVyIFNWR3MgYnkgZXh0cmFjdGluZyBvbmx5IHRoZSBleGFjdCBDU1MgcnVsZXMgZm9yIHRoaXMgcGxvdC4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyAgIGV4dHJhY3RpbmcgcnVsZXMgKGluY2x1ZGluZyBwYXJlbnQgc2VsZWN0b3JzKSBpcyBhIGZpbmlja3kgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQganVzdCBmZXRjaCBhbGwgTFogcGxvdCBydWxlcywgdW5kZXIgYSBrbm93biBoYXJkY29kZWQgcGFyZW50IHNlbGVjdG9yLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBjc3NSdWxlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc19tYXRjaCA9IChydWxlLnNlbGVjdG9yVGV4dCAmJiBydWxlLnNlbGVjdG9yVGV4dC5tYXRjaChhbmNlc3Rvcl9wYXR0ZXJuKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzX21hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZENTU1RleHQgKz0gcnVsZS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkQ1NTVGV4dDtcbiAgICB9XG5cbiAgICBfYXBwZW5kQ1NTKCBjc3NUZXh0LCBlbGVtZW50ICkge1xuICAgICAgICAvLyBBcHBlbmQgc3R5bGVzIHRvIHRoZSBjb25zdHJ1Y3RlZCBTVkcgRE9NIG5vZGVcbiAgICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzc1RleHQ7XG4gICAgICAgIHZhciByZWZOb2RlID0gZWxlbWVudC5oYXNDaGlsZE5vZGVzKCkgPyBlbGVtZW50LmNoaWxkcmVuWzBdIDogbnVsbDtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoIHN0eWxlRWxlbWVudCwgcmVmTm9kZSApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGFyZ2V0IGRpbWVuc2lvbnMgZm9yIHRoZSByZW5kZXJlZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIEZvciBub24tdmVjdG9yIGRpc3BsYXlzLCB0aGVzZSBkaW1lbnNpb25zIHdpbGwgeWllbGQgfjMwMCBEUEkgaW1hZ2UgZm9yIGFuIDhcIiB3aWRlIHByaW50IGZpZ3VyZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXREaW1lbnNpb25zKCkge1xuICAgICAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnBhcmVudF9wbG90LnN2Zy5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldF93aWR0aCA9IDI0MDA7XG4gICAgICAgIGNvbnN0IHJlc2NhbGUgPSB0YXJnZXRfd2lkdGggLyB3aWR0aDtcbiAgICAgICAgcmV0dXJuIFtyZXNjYWxlICogd2lkdGgsIHJlc2NhbGUgKiBoZWlnaHRdO1xuICAgIH1cblxuICAgIF9nZW5lcmF0ZVNWRyAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gQ29weSB0aGUgRE9NIG5vZGUgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZSBpbWFnZSBmb3IgcHVibGljYXRpb25cbiAgICAgICAgICAgIGxldCBjb3B5ID0gdGhpcy5wYXJlbnRfcGxvdC5zdmcubm9kZSgpLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGNvcHkuc2V0QXR0cmlidXRlKCd4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG4gICAgICAgICAgICBjb3B5ID0gZDMuc2VsZWN0KGNvcHkpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgZWxlbWVudHNcbiAgICAgICAgICAgIGNvcHkuc2VsZWN0QWxsKCdnLmx6LWN1cnRhaW4nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGNvcHkuc2VsZWN0QWxsKCdnLmx6LW1vdXNlX2d1aWRlJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHVuaXRzIG9uIGF4aXMgdGljayBkeSBhdHRyaWJ1dGVzIGZyb20gZW1zIHRvIHBpeGVsc1xuICAgICAgICAgICAgY29weS5zZWxlY3RBbGwoJ2cudGljayB0ZXh0JykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkeSA9ICsoZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2R5Jykuc3Vic3RyaW5nKC0yKS5zbGljZSgwLCAtMikpICogMTA7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2R5JywgZHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQdWxsIHRoZSBzdmcgaW50byBhIHN0cmluZyBhbmQgYWRkIHRoZSBjb250ZW50cyBvZiB0aGUgbG9jdXN6b29tIHN0eWxlc2hlZXRcbiAgICAgICAgICAgIC8vIERvbid0IGFkZCB0aGlzIHdpdGggZDMgYmVjYXVzZSBpdCB3aWxsIGVzY2FwZSB0aGUgQ0RBVEEgZGVjbGFyYXRpb24gaW5jb3JyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuXG4gICAgICAgICAgICBjb3B5ID0gY29weS5ub2RlKCk7XG5cbiAgICAgICAgICAgIC8vIEZpcmVmb3ggaGFzIGlzc3VlcyBzYXZpbmcgdGhlIFNWRyBpbiBjZXJ0YWluIGNvbnRleHRzIChlc3AgcmVuZGVyaW5nIHRvIGNhbnZhcykgdW5sZXNzIGEgd2lkdGggaXMgZ2l2ZW4uXG4gICAgICAgICAgICAvLyAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MDA1MzNcbiAgICAgICAgICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuX2dldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIGNvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgIGNvcHkuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBBZGQgQ1NTIHRvIHRoZSBub2RlXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRDU1ModGhpcy5fZ2V0Q1NTKGNvcHkpLCBjb3B5KTtcbiAgICAgICAgICAgIGxldCBzdmdfbWFya3VwID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhjb3B5KTtcbiAgICAgICAgICAgIHJlc29sdmUoc3ZnX21hcmt1cCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBTVkcgc3RyaW5nIGludG8gYSBkb3dubG9hZGFibGUgYmluYXJ5IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgX2dldEJsb2JVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVNWRygpLnRoZW4oKG1hcmt1cCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFttYXJrdXBdLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sJyB9KTtcbiAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQnV0dG9uIHRvIGV4cG9ydCBjdXJyZW50IHBsb3QgdG8gYSBQTkcgaW1hZ2VcbiAqL1xuY2xhc3MgRG93bmxvYWRQTkcgZXh0ZW5kcyBEb3dubG9hZFNWRyB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSB0aGlzLmxheW91dC5maWxlbmFtZSB8fCAnbG9jdXN6b29tLnBuZyc7XG4gICAgICAgIHRoaXMuX2J1dHRvbl9odG1sID0gdGhpcy5sYXlvdXQuYnV0dG9uX2h0bWwgfHwgJ1NhdmUgUE5HJztcbiAgICAgICAgdGhpcy5fYnV0dG9uX3RpdGxlID0gdGhpcy5sYXlvdXQuYnV0dG9uX3RpdGxlIHx8ICdEb3dubG9hZCBpbWFnZSc7XG4gICAgfVxuXG4gICAgX2dldEJsb2JVcmwoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0QmxvYlVybCgpLnRoZW4oKHN2Z191cmwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLl9nZXREaW1lbnNpb25zKCk7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGNhbnZhcyByZW5kZXJlZCwgcmV2b2tlIHN2ZyBibG9iIHRvIGF2b2lkIG1lbW9yeSBsZWFrcywgYW5kIGNyZWF0ZSBuZXcgdXJsIGZvciB0aGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc3ZnX3VybCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IoKHBuZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShVUkwuY3JlYXRlT2JqZWN0VVJMKHBuZykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHN2Z191cmw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ1dHRvbiB0byByZW1vdmUgcGFuZWwgZnJvbSBwbG90LlxuICogICBOT1RFOiBXaWxsIG9ubHkgd29yayBvbiBwYW5lbCB3aWRnZXRzLlxuICogQHBhcmFtIHtCb29sZWFufSBbbGF5b3V0LnN1cHByZXNzX2NvbmZpcm09ZmFsc2VdIElmIHRydWUsIHJlbW92ZXMgdGhlIHBhbmVsIHdpdGhvdXQgcHJvbXB0aW5nIHVzZXIgZm9yIGNvbmZpcm1hdGlvblxuICovXG5jbGFzcyBSZW1vdmVQYW5lbCBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1dHRvbiA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgICAgIC5zZXRDb2xvcih0aGlzLmxheW91dC5jb2xvcilcbiAgICAgICAgICAgIC5zZXRIdG1sKCfDlycpXG4gICAgICAgICAgICAuc2V0VGl0bGUoJ1JlbW92ZSBwYW5lbCcpXG4gICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxheW91dC5zdXBwcmVzc19jb25maXJtICYmICFjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcmVtb3ZlIHRoaXMgcGFuZWw/IFRoaXMgY2Fubm90IGJlIHVuZG9uZS4nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5wYXJlbnRfcGFuZWw7XG4gICAgICAgICAgICAgICAgcGFuZWwudG9vbGJhci5oaWRlKHRydWUpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChwYW5lbC5wYXJlbnQuc3ZnLm5vZGUoKS5wYXJlbnROb2RlKS5vbihgbW91c2VvdmVyLiR7cGFuZWwuZ2V0QmFzZUlkKCl9LnRvb2xiYXJgLCBudWxsKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QocGFuZWwucGFyZW50LnN2Zy5ub2RlKCkucGFyZW50Tm9kZSkub24oYG1vdXNlb3V0LiR7cGFuZWwuZ2V0QmFzZUlkKCl9LnRvb2xiYXJgLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuZWwucGFyZW50LnJlbW92ZVBhbmVsKHBhbmVsLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdXR0b24gdG8gbW92ZSBwYW5lbCB1cCByZWxhdGl2ZSB0byBvdGhlciBwYW5lbHMgKGluIHRlcm1zIG9mIHktaW5kZXggb24gdGhlIHBhZ2UpXG4gKiAgIE5PVEU6IFdpbGwgb25seSB3b3JrIG9uIHBhbmVsIHdpZGdldHMuXG4gKi9cbmNsYXNzIE1vdmVQYW5lbFVwIGV4dGVuZHMgQmFzZVdpZGdldCB7XG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICBjb25zdCBpc19hdF90b3AgPSAodGhpcy5wYXJlbnRfcGFuZWwubGF5b3V0LnlfaW5kZXggPT09IDApO1xuICAgICAgICAgICAgdGhpcy5idXR0b24uZGlzYWJsZShpc19hdF90b3ApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgQnV0dG9uKHRoaXMpXG4gICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbCgn4pa0JylcbiAgICAgICAgICAgIC5zZXRUaXRsZSgnTW92ZSBwYW5lbCB1cCcpXG4gICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGFuZWwubW92ZVVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdXR0b24gdG8gbW92ZSBwYW5lbCBkb3duIHJlbGF0aXZlIHRvIG90aGVyIHBhbmVscyAoaW4gdGVybXMgb2YgeS1pbmRleCBvbiB0aGUgcGFnZSlcbiAqICAgTk9URTogV2lsbCBvbmx5IHdvcmsgb24gcGFuZWwgd2lkZ2V0cy5cbiAqL1xuY2xhc3MgTW92ZVBhbmVsRG93biBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgY29uc3QgaXNfYXRfYm90dG9tID0gKHRoaXMucGFyZW50X3BhbmVsLmxheW91dC55X2luZGV4ID09PSB0aGlzLnBhcmVudF9wbG90LnBhbmVsX2lkc19ieV95X2luZGV4Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdGhpcy5idXR0b24uZGlzYWJsZShpc19hdF9ib3R0b20pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgQnV0dG9uKHRoaXMpXG4gICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbCgn4pa+JylcbiAgICAgICAgICAgIC5zZXRUaXRsZSgnTW92ZSBwYW5lbCBkb3duJylcbiAgICAgICAgICAgIC5zZXRPbmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wYW5lbC5tb3ZlRG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQnV0dG9uIHRvIHNoaWZ0IHBsb3QgcmVnaW9uIGZvcndhcmRzIG9yIGJhY2sgYnkgYSBgc3RlcGAgaW5jcmVtZW50IHByb3ZpZGVkIGluIHRoZSBsYXlvdXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGF5b3V0LnN0ZXA9NTAwMDBdIFRoZSBzdGVwc2l6ZSB0byBjaGFuZ2UgdGhlIHJlZ2lvbiBieVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQuYnV0dG9uX2h0bWxdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dC5idXR0b25fdGl0bGVdXG4gKi9cbmNsYXNzIFNoaWZ0UmVnaW9uIGV4dGVuZHMgQmFzZVdpZGdldCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKGlzTmFOKGxheW91dC5zdGVwKSB8fCBsYXlvdXQuc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgbGF5b3V0LnN0ZXAgPSA1MDAwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxheW91dC5idXR0b25faHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxheW91dC5idXR0b25faHRtbCA9IGxheW91dC5zdGVwID4gMCA/ICc+JyA6ICc8JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGF5b3V0LmJ1dHRvbl90aXRsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxheW91dC5idXR0b25fdGl0bGUgPSBgU2hpZnQgcmVnaW9uIGJ5ICR7bGF5b3V0LnN0ZXAgPiAwID8gJysnIDogJy0nfSR7cG9zaXRpb25JbnRUb1N0cmluZyhNYXRoLmFicyhsYXlvdXQuc3RlcCksIG51bGwsIHRydWUpfWA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobGF5b3V0LCBwYXJlbnQpO1xuICAgICAgICBpZiAoaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5zdGFydCkgfHwgaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5lbmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBhZGQgc2hpZnRfcmVnaW9uIHRvb2xiYXIgd2lkZ2V0OiBwbG90IHN0YXRlIGRvZXMgbm90IGhhdmUgcmVnaW9uIGJvdW5kcycpO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgQnV0dG9uKHRoaXMpXG4gICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbCh0aGlzLmxheW91dC5idXR0b25faHRtbClcbiAgICAgICAgICAgIC5zZXRUaXRsZSh0aGlzLmxheW91dC5idXR0b25fdGl0bGUpXG4gICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5hcHBseVN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWF4KHRoaXMucGFyZW50X3Bsb3Quc3RhdGUuc3RhcnQgKyB0aGlzLmxheW91dC5zdGVwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBhcmVudF9wbG90LnN0YXRlLmVuZCArIHRoaXMubGF5b3V0LnN0ZXAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogWm9vbSBpbiBvciBvdXQgb24gdGhlIHBsb3QsIGNlbnRlcmVkIG9uIHRoZSBtaWRkbGUgb2YgdGhlIHBsb3QgcmVnaW9uLCBieSB0aGUgc3BlY2lmaWVkIGFtb3VudFxuICogQHBhcmFtIHtvYmplY3R9IGxheW91dFxuICogQHBhcmFtIHtudW1iZXJ9IFtsYXlvdXQuc3RlcD0wLjJdIFRoZSBhbW91bnQgdG8gem9vbSBpbiBieSAod2hlcmUgMSBpbmRpY2F0ZXMgMTAwJSlcbiAqL1xuY2xhc3MgWm9vbVJlZ2lvbiBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcGFyZW50KSB7XG4gICAgICAgIGlmIChpc05hTihsYXlvdXQuc3RlcCkgfHwgbGF5b3V0LnN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIGxheW91dC5zdGVwID0gMC4yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF5b3V0LmJ1dHRvbl9odG1sICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsYXlvdXQuYnV0dG9uX2h0bWwgPSBsYXlvdXQuc3RlcCA+IDAgPyAneuKAkycgOiAneisnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF5b3V0LmJ1dHRvbl90aXRsZSAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGF5b3V0LmJ1dHRvbl90aXRsZSA9IGBab29tIHJlZ2lvbiAke2xheW91dC5zdGVwID4gMCA/ICdvdXQnIDogJ2luJ30gYnkgJHsoTWF0aC5hYnMobGF5b3V0LnN0ZXApICogMTAwKS50b0ZpeGVkKDEpfSVgO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIobGF5b3V0LCBwYXJlbnQpO1xuICAgICAgICBpZiAoaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5zdGFydCkgfHwgaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5lbmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBhZGQgem9vbV9yZWdpb24gdG9vbGJhciB3aWRnZXQ6IHBsb3Qgc3RhdGUgZG9lcyBub3QgaGF2ZSByZWdpb24gYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUgKCkge1xuICAgICAgICBpZiAodGhpcy5idXR0b24pIHtcbiAgICAgICAgICAgIGxldCBjYW5fem9vbSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50X3JlZ2lvbl9zY2FsZSA9IHRoaXMucGFyZW50X3Bsb3Quc3RhdGUuZW5kIC0gdGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5zdGFydDtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5zdGVwID4gMCAmJiAhaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWF4X3JlZ2lvbl9zY2FsZSkgJiYgY3VycmVudF9yZWdpb25fc2NhbGUgPj0gdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWF4X3JlZ2lvbl9zY2FsZSkge1xuICAgICAgICAgICAgICAgIGNhbl96b29tID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQuc3RlcCA8IDAgJiYgIWlzTmFOKHRoaXMucGFyZW50X3Bsb3QubGF5b3V0Lm1pbl9yZWdpb25fc2NhbGUpICYmIGN1cnJlbnRfcmVnaW9uX3NjYWxlIDw9IHRoaXMucGFyZW50X3Bsb3QubGF5b3V0Lm1pbl9yZWdpb25fc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBjYW5fem9vbSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idXR0b24uZGlzYWJsZSghY2FuX3pvb20pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgQnV0dG9uKHRoaXMpXG4gICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbCh0aGlzLmxheW91dC5idXR0b25faHRtbClcbiAgICAgICAgICAgIC5zZXRUaXRsZSh0aGlzLmxheW91dC5idXR0b25fdGl0bGUpXG4gICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudF9yZWdpb25fc2NhbGUgPSB0aGlzLnBhcmVudF9wbG90LnN0YXRlLmVuZCAtIHRoaXMucGFyZW50X3Bsb3Quc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbV9mYWN0b3IgPSAxICsgdGhpcy5sYXlvdXQuc3RlcDtcbiAgICAgICAgICAgICAgICBsZXQgbmV3X3JlZ2lvbl9zY2FsZSA9IGN1cnJlbnRfcmVnaW9uX3NjYWxlICogem9vbV9mYWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih0aGlzLnBhcmVudF9wbG90LmxheW91dC5tYXhfcmVnaW9uX3NjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdfcmVnaW9uX3NjYWxlID0gTWF0aC5taW4obmV3X3JlZ2lvbl9zY2FsZSwgdGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWF4X3JlZ2lvbl9zY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGhpcy5wYXJlbnRfcGxvdC5sYXlvdXQubWluX3JlZ2lvbl9zY2FsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3JlZ2lvbl9zY2FsZSA9IE1hdGgubWF4KG5ld19yZWdpb25fc2NhbGUsIHRoaXMucGFyZW50X3Bsb3QubGF5b3V0Lm1pbl9yZWdpb25fc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGguZmxvb3IoKG5ld19yZWdpb25fc2NhbGUgLSBjdXJyZW50X3JlZ2lvbl9zY2FsZSkgLyAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LmFwcGx5U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5tYXgodGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5zdGFydCAtIGRlbHRhLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBhcmVudF9wbG90LnN0YXRlLmVuZCArIGRlbHRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnV0dG9uLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgYnV0dG9uIHdpdGggYXJiaXRyYXJ5IHRleHQgdGhhdCwgd2hlbiBjbGlja2VkLCBzaG93cyBhIGRyb3Bkb3duIGNvbnRhaW5pbmcgYXJiaXRyYXJ5IEhUTUxcbiAqICBOT1RFOiBUcnVzdHMgY29udGVudCBleGFjdGx5IGFzIGdpdmVuLiBYU1MgcHJldmVudGlvbiBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGltcGxlbWVudGVyLlxuICogQHBhcmFtIHtvYmplY3R9IGxheW91dFxuICogQHBhcmFtIHtzdHJpbmd9IGxheW91dC5idXR0b25faHRtbCBUaGUgSFRNTCB0byByZW5kZXIgaW5zaWRlIHRoZSBidXR0b25cbiAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQuYnV0dG9uX3RpdGxlIFRleHQgdG8gZGlzcGxheSBhcyBhIHRvb2x0aXAgd2hlbiBob3ZlcmluZyBvdmVyIHRoZSBidXR0b25cbiAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQubWVudV9odG1sIFRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGRyb3Bkb3duIG1lbnVcbiAqL1xuY2xhc3MgTWVudSBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1dHRvbiA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgICAgIC5zZXRDb2xvcih0aGlzLmxheW91dC5jb2xvcilcbiAgICAgICAgICAgIC5zZXRIdG1sKHRoaXMubGF5b3V0LmJ1dHRvbl9odG1sKVxuICAgICAgICAgICAgLnNldFRpdGxlKHRoaXMubGF5b3V0LmJ1dHRvbl90aXRsZSk7XG4gICAgICAgIHRoaXMuYnV0dG9uLm1lbnUuc2V0UG9wdWxhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5pbm5lcl9zZWxlY3Rvci5odG1sKHRoaXMubGF5b3V0Lm1lbnVfaHRtbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdXR0b24gdG8gcmVzaXplIHBhbmVsIGhlaWdodCB0byBmaXQgYXZhaWxhYmxlIGRhdGEgKGVnIHdoZW4gc2hvd2luZyBhIGxpc3Qgb2YgdHJhY2tzKVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQuYnV0dG9uX2h0bWw9XCJSZXNpemUgdG8gRGF0YVwiXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQuYnV0dG9uX3RpdGxlXVxuICovXG5jbGFzcyBSZXNpemVUb0RhdGEgZXh0ZW5kcyBCYXNlV2lkZ2V0IHtcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgQnV0dG9uKHRoaXMpXG4gICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbCh0aGlzLmxheW91dC5idXR0b25faHRtbCB8fCAnUmVzaXplIHRvIERhdGEnKVxuICAgICAgICAgICAgLnNldFRpdGxlKHRoaXMubGF5b3V0LmJ1dHRvbl90aXRsZSB8fCAnQXV0b21hdGljYWxseSByZXNpemUgdGhpcyBwYW5lbCB0byBzaG93IGFsbCBkYXRhIGF2YWlsYWJsZScpXG4gICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGFuZWwuc2NhbGVIZWlnaHRUb0RhdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnV0dG9uLnNob3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ1dHRvbiB0byB0b2dnbGUgbGVnZW5kXG4gKi9cbmNsYXNzIFRvZ2dsZUxlZ2VuZCBleHRlbmRzIEJhc2VXaWRnZXQge1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IHRoaXMucGFyZW50X3BhbmVsLmxlZ2VuZC5sYXlvdXQuaGlkZGVuID8gJ1Nob3cgTGVnZW5kJyA6ICdIaWRlIExlZ2VuZCc7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uc2V0SHRtbChodG1sKS5zaG93KCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5wb3NpdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgQnV0dG9uKHRoaXMpXG4gICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0VGl0bGUoJ1Nob3cgb3IgaGlkZSB0aGUgbGVnZW5kIGZvciB0aGlzIHBhbmVsJylcbiAgICAgICAgICAgIC5zZXRPbmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wYW5lbC5sZWdlbmQubGF5b3V0LmhpZGRlbiA9ICF0aGlzLnBhcmVudF9wYW5lbC5sZWdlbmQubGF5b3V0LmhpZGRlbjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wYW5lbC5sZWdlbmQucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogRHJvcGRvd24gbWVudSBhbGxvd2luZyB0aGUgdXNlciB0byBjaG9vc2UgYmV0d2VlbiBkaWZmZXJlbnQgZGlzcGxheSBvcHRpb25zIGZvciBhIHNpbmdsZSBzcGVjaWZpYyBkYXRhIGxheWVyXG4gKiAgd2l0aGluIGEgcGFuZWwuXG4gKlxuICogVGhpcyBhbGxvd3MgY29udHJvbGxpbmcgaG93IHBvaW50cyBvbiBhIGRhdGFsYXllciBjYW4gYmUgZGlzcGxheWVkLSBhbnkgZGlzcGxheSBvcHRpb25zIHN1cHBvcnRlZCB2aWEgdGhlIGxheW91dCBmb3IgdGhlIHRhcmdldCBkYXRhbGF5ZXIuIFRoaXMgaW5jbHVkZXMgcG9pbnRcbiAqICBzaXplL3NoYXBlLCBjb2xvcmluZywgZXRjLlxuICpcbiAqIFRoaXMgYnV0dG9uIGludGVudGlvbmFsbHkgbGltaXRzIGRpc3BsYXkgb3B0aW9ucyBpdCBjYW4gY29udHJvbCB0byB0aG9zZSBhdmFpbGFibGUgb24gY29tbW9uIHBsb3QgdHlwZXMuXG4gKiAgIEFsdGhvdWdoIHRoZSBsaXN0IG9mIG9wdGlvbnMgaXQgc2V0cyBjYW4gYmUgb3ZlcnJpZGRlbiAodG8gY29udHJvbCB2ZXJ5IHNwZWNpYWwgY3VzdG9tIHBsb3QgdHlwZXMpLCB0aGlzXG4gKiAgIGNhcGFiaWxpdHkgc2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5IGlmIGF0IGFsbC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4gKiBAcGFyYW0ge1N0cmluZ30gW2xheW91dC5idXR0b25faHRtbD1cIkRpc3BsYXkgb3B0aW9ucy4uLlwiXSBUZXh0IHRvIGRpc3BsYXkgb24gdGhlIHRvb2xiYXIgYnV0dG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW2xheW91dC5idXR0b25fdGl0bGU9XCJDb250cm9sIGhvdyBwbG90IGl0ZW1zIGFyZSBkaXNwbGF5ZWRcIl0gSG92ZXIgdGV4dCBmb3IgdGhlIHRvb2xiYXIgYnV0dG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5b3V0LmxheWVyX25hbWUgU3BlY2lmeSB0aGUgZGF0YWxheWVyIHRoYXQgdGhpcyBidXR0b24gc2hvdWxkIGFmZmVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQuZGVmYXVsdF9jb25maWdfZGlzcGxheV9uYW1lXSBTdG9yZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciB0aGlzIGRhdGFsYXllclxuICogIGNvbmZpZ3VyYXRpb24sIGFuZCBzaG93IGEgYnV0dG9uIHRvIHJldmVydCB0byB0aGUgXCJkZWZhdWx0XCIgKGxpc3RpbmcgdGhlIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXkgbmFtZSBwcm92aWRlZClcbiAqIEBwYXJhbSB7QXJyYXl9IFtsYXlvdXQuZmllbGRzX3doaXRlbGlzdD0nc2VlIGNvZGUnXSBUaGUgbGlzdCBvZiBwcmVzZW50YXRpb24gZmllbGRzIHRoYXQgdGhpcyBidXR0b24gY2FuIGNvbnRyb2wuXG4gKiAgVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBpZiB0aGlzIGJ1dHRvbiBuZWVkcyB0byBiZSB1c2VkIG9uIGEgY3VzdG9tIGxheWVyIHR5cGUgd2l0aCBzcGVjaWFsIG9wdGlvbnMuXG4gKiBAdHlwZWRlZiB7e2Rpc3BsYXlfbmFtZTogc3RyaW5nLCBkaXNwbGF5OiBPYmplY3R9fSBEaXNwbGF5T3B0aW9uc0J1dHRvbkNvbmZpZ0ZpZWxkXG4gKiBAcGFyYW0ge0Rpc3BsYXlPcHRpb25zQnV0dG9uQ29uZmlnRmllbGRbXX0gbGF5b3V0Lm9wdGlvbnMgU3BlY2lmeSBhIGxhYmVsIGFuZCBzZXQgb2YgbGF5b3V0IGRpcmVjdGl2ZXMgYXNzb2NpYXRlZFxuICogIHdpdGggdGhpcyBgZGlzcGxheWAgb3B0aW9uLiBEaXNwbGF5IGZpZWxkIHNob3VsZCBpbmNsdWRlIGFsbCBjaGFuZ2VzIHRvIGRhdGFsYXllciBwcmVzZW50YXRpb24gb3B0aW9ucy5cbiAqL1xuY2xhc3MgRGlzcGxheU9wdGlvbnMgZXh0ZW5kcyBCYXNlV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHBhcmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGxheW91dC5idXR0b25faHRtbCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGF5b3V0LmJ1dHRvbl9odG1sID0gJ0Rpc3BsYXkgb3B0aW9ucy4uLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYXlvdXQuYnV0dG9uX3RpdGxlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsYXlvdXQuYnV0dG9uX3RpdGxlID0gJ0NvbnRyb2wgaG93IHBsb3QgaXRlbXMgYXJlIGRpc3BsYXllZCc7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBMaXN0IG9mIGxheW91dCBmaWVsZHMgdGhhdCB0aGlzIGJ1dHRvbiBpcyBhbGxvd2VkIHRvIGNvbnRyb2wuIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IG92ZXJyaWRlIGFueSBvdGhlclxuICAgICAgICAvLyAgaW5mb3JtYXRpb24gKGxpa2UgcGxvdCBoZWlnaHQgZXRjKSB3aGlsZSBjaGFuZ2luZyBwb2ludCByZW5kZXJpbmdcbiAgICAgICAgY29uc3QgYWxsb3dlZF9maWVsZHMgPSBsYXlvdXQuZmllbGRzX3doaXRlbGlzdCB8fCBbJ2NvbG9yJywgJ2ZpbGxfb3BhY2l0eScsICdmaWx0ZXJzJywgJ2xhYmVsJywgJ2xlZ2VuZCcsXG4gICAgICAgICAgICAncG9pbnRfc2hhcGUnLCAncG9pbnRfc2l6ZScsICd0b29sdGlwJywgJ3Rvb2x0aXBfcG9zaXRpb25pbmcnXTtcblxuICAgICAgICBjb25zdCBkYXRhTGF5ZXIgPSB0aGlzLnBhcmVudF9wYW5lbC5kYXRhX2xheWVyc1tsYXlvdXQubGF5ZXJfbmFtZV07XG4gICAgICAgIGlmICghZGF0YUxheWVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc3BsYXkgb3B0aW9ucyBjb3VsZCBub3QgbG9jYXRlIHRoZSBzcGVjaWZpZWQgbGF5ZXJfbmFtZTogJyR7bGF5b3V0LmxheWVyX25hbWV9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFMYXllckxheW91dCA9IGRhdGFMYXllci5sYXlvdXQ7XG5cbiAgICAgICAgLy8gU3RvcmUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciB0aGUgbGF5ZXIgYXMgYSBjbGVhbiBkZWVwIGNvcHksIHNvIHdlIG1heSByZXZlcnQgbGF0ZXJcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHt9O1xuICAgICAgICBhbGxvd2VkX2ZpZWxkcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdTbG90ID0gZGF0YUxheWVyTGF5b3V0W25hbWVdO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1Nsb3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25maWdbbmFtZV0gPSAgZGVlcENvcHkoY29uZmlnU2xvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGljaCBpdGVtIGluIHRoZSBtZW51IGlzIGN1cnJlbnRseSBzZWxlY3RlZC4gKHRyYWNrIGZvciByZXJlbmRlcmluZyBtZW51KVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZF9pdGVtID0gJ2RlZmF1bHQnO1xuXG4gICAgICAgIC8vIERlZmluZSB0aGUgYnV0dG9uICsgbWVudSB0aGF0IHByb3ZpZGVzIHRoZSByZWFsIGZ1bmN0aW9uYWxpdHkgZm9yIHRoaXMgdG9vbGJhciB3aWRnZXRcblxuICAgICAgICB0aGlzLmJ1dHRvbiA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgICAgIC5zZXRDb2xvcihsYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbChsYXlvdXQuYnV0dG9uX2h0bWwpXG4gICAgICAgICAgICAuc2V0VGl0bGUobGF5b3V0LmJ1dHRvbl90aXRsZSlcbiAgICAgICAgICAgIC5zZXRPbmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LnBvcHVsYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5idXR0b24ubWVudS5zZXRQb3B1bGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBNdWx0aXBsZSBjb3BpZXMgb2YgdGhpcyBidXR0b24gbWlnaHQgYmUgdXNlZCBvbiBhIHNpbmdsZSBMWiBwYWdlOyBhcHBlbmQgdW5pcXVlIElEcyB3aGVyZSBuZWVkZWRcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUlEID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU0KS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LmlubmVyX3NlbGVjdG9yLmh0bWwoJycpO1xuICAgICAgICAgICAgY29uc3QgdGFibGUgPSB0aGlzLmJ1dHRvbi5tZW51LmlubmVyX3NlbGVjdG9yLmFwcGVuZCgndGFibGUnKTtcblxuICAgICAgICAgICAgY29uc3QgbWVudUxheW91dCA9IHRoaXMubGF5b3V0O1xuXG4gICAgICAgICAgICBjb25zdCByZW5kZXJSb3cgPSAoZGlzcGxheV9uYW1lLCBkaXNwbGF5X29wdGlvbnMsIHJvd19pZCkgPT4geyAvLyBIZWxwZXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuYXBwZW5kKCd0cicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlvSWQgPSBgJHt1bmlxdWVJRH0ke3Jvd19pZH1gO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJ3RkJylcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnaW5wdXQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCByYWRpb0lkKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdyYWRpbycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCduYW1lJywgYGRpc3BsYXktb3B0aW9uLSR7dW5pcXVlSUR9YClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3ZhbHVlJywgcm93X2lkKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmdpbicsIDApIC8vIE92ZXJyaWRlIGNzcyBsaWJyYXJpZXMgKGVnIHNrZWxldG9uKSB0aGF0IHN0eWxlIGZvcm0gaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgIC5wcm9wZXJ0eSgnY2hlY2tlZCcsIChyb3dfaWQgPT09IHRoaXMuX3NlbGVjdGVkX2l0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlc2UgZGlzcGxheSBvcHRpb25zLCB1c2UgdGhlIG9yaWdpbmFsIGRlZmF1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkX2ZpZWxkcy5mb3JFYWNoKChmaWVsZF9uYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzX29wdGlvbiA9IHR5cGVvZiBkaXNwbGF5X29wdGlvbnNbZmllbGRfbmFtZV0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMYXllci5sYXlvdXRbZmllbGRfbmFtZV0gPSBoYXNfb3B0aW9uID8gZGlzcGxheV9vcHRpb25zW2ZpZWxkX25hbWVdIDogZGVmYXVsdENvbmZpZ1tmaWVsZF9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZF9pdGVtID0gcm93X2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGFuZWwucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWdlbmQgPSB0aGlzLnBhcmVudF9wYW5lbC5sZWdlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKCd0ZCcpLmFwcGVuZCgnbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgJ25vcm1hbCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCByYWRpb0lkKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChkaXNwbGF5X25hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgXCJkaXNwbGF5IG9wdGlvbnNcIiBtZW51OiBkZWZhdWx0IGFuZCBzcGVjaWFsIGN1c3RvbSBvcHRpb25zXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0TmFtZSA9IG1lbnVMYXlvdXQuZGVmYXVsdF9jb25maWdfZGlzcGxheV9uYW1lIHx8ICdEZWZhdWx0IHN0eWxlJztcbiAgICAgICAgICAgIHJlbmRlclJvdyhkZWZhdWx0TmFtZSwgZGVmYXVsdENvbmZpZywgJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgIG1lbnVMYXlvdXQub3B0aW9ucy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gcmVuZGVyUm93KGl0ZW0uZGlzcGxheV9uYW1lLCBpdGVtLmRpc3BsYXksIGluZGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEcm9wZG93biBtZW51IGFsbG93aW5nIHRoZSB1c2VyIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBgc3RhdGVfZmllbGRgIGluIHBsb3Quc3RhdGVcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciB0aGluZ3MgKGxpa2UgZGF0YXNvdXJjZXMpIHRoYXQgYWxsb3cgZHluYW1pYyBjb25maWd1cmF0aW9uIGJhc2VkIG9uIGdsb2JhbCBpbmZvcm1hdGlvbiBpbiBzdGF0ZVxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgTERTZXJ2ZXIgZGF0YSBzb3VyY2UgY2FuIHVzZSBpdCB0byBjaGFuZ2UgTEQgcmVmZXJlbmNlIHBvcHVsYXRpb24gKGZvciBhbGwgcGFuZWxzKSBhZnRlciByZW5kZXJcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4gKiBAcGFyYW0ge1N0cmluZ30gW2xheW91dC5idXR0b25faHRtbD1cIlNldCBvcHRpb24uLi5cIl0gVGV4dCB0byBkaXNwbGF5IG9uIHRoZSB0b29sYmFyIGJ1dHRvblxuICogQHBhcmFtIHtTdHJpbmd9IFtsYXlvdXQuYnV0dG9uX3RpdGxlPVwiQ2hvb3NlIGFuIG9wdGlvbiB0byBjdXN0b21pemUgdGhlIHBsb3RcIl0gSG92ZXIgdGV4dCBmb3IgdGhlIHRvb2xiYXIgYnV0dG9uXG4gKiBAcGFyYW0ge2Jvb2x9IFtsYXlvdXQuc2hvd19zZWxlY3RlZD1mYWxzZV0gV2hldGhlciB0byBhcHBlbmQgdGhlIHNlbGVjdGVkIHZhbHVlIHRvIHRoZSBidXR0b24gbGFiZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0LnN0YXRlX2ZpZWxkXSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgaW4gcGxvdC5zdGF0ZSB0aGF0IHdpbGwgYmUgc2V0IGJ5IHRoaXMgYnV0dG9uXG4gKiBAdHlwZWRlZiB7e2Rpc3BsYXlfbmFtZTogc3RyaW5nLCB2YWx1ZTogKn19IFNldFN0YXRlT3B0aW9uc0NvbmZpZ0ZpZWxkXG4gKiBAcGFyYW0ge1NldFN0YXRlT3B0aW9uc0NvbmZpZ0ZpZWxkW119IGxheW91dC5vcHRpb25zIFNwZWNpZnkgaHVtYW4gbGFiZWxzIGFuZCBhc3NvY2lhdGVkIHZhbHVlcyBmb3IgdGhlIGRyb3Bkb3duIG1lbnVcbiAqL1xuY2xhc3MgU2V0U3RhdGUgZXh0ZW5kcyBCYXNlV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHBhcmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGxheW91dC5idXR0b25faHRtbCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGF5b3V0LmJ1dHRvbl9odG1sID0gJ1NldCBvcHRpb24uLi4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF5b3V0LmJ1dHRvbl90aXRsZSAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGF5b3V0LmJ1dHRvbl90aXRsZSA9ICdDaG9vc2UgYW4gb3B0aW9uIHRvIGN1c3RvbWl6ZSB0aGUgcGxvdCc7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcihsYXlvdXQsIHBhcmVudCk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50X3BhbmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgd2lkZ2V0IGlzIGRlc2lnbmVkIHRvIHNldCBnbG9iYWwgb3B0aW9ucywgc28gaXQgY2FuIG9ubHkgYmUgdXNlZCBhdCB0aGUgdG9wIChwbG90KSBsZXZlbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGF5b3V0LnN0YXRlX2ZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSB0aGUgYHN0YXRlX2ZpZWxkYCB0aGF0IHRoaXMgd2lkZ2V0IGNvbnRyb2xzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpY2ggaXRlbSBpbiB0aGUgbWVudSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuICh0cmFjayBmb3IgcmVyZW5kZXJpbmcgbWVudSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVGhlIGZpcnN0IG9wdGlvbiBsaXN0ZWQgaXMgYXV0b21hdGljYWxseSBhc3N1bWVkIHRvIGJlIHRoZSBkZWZhdWx0LCB1bmxlc3MgYSB2YWx1ZSBleGlzdHMgaW4gcGxvdC5zdGF0ZVxuICAgICAgICB0aGlzLl9zZWxlY3RlZF9pdGVtID0gdGhpcy5wYXJlbnRfcGxvdC5zdGF0ZVtsYXlvdXQuc3RhdGVfZmllbGRdIHx8IGxheW91dC5vcHRpb25zWzBdLnZhbHVlO1xuICAgICAgICBpZiAoIWxheW91dC5vcHRpb25zLmZpbmQoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlID09PSB0aGlzLl9zZWxlY3RlZF9pdGVtO1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgb25seSBnZXRzIHJ1biBhdCB3aWRnZXQgY3JlYXRpb24sIGJ1dCBnZW5lcmFsbHkgdGhpcyB3aWRnZXQgaXMgYXNzdW1lZCB0byBiZSBhbiBleGNsdXNpdmUgbGlzdCBvZiBvcHRpb25zXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGFuIGV4aXN0aW5nIHN0YXRlIHZhbHVlIHRoYXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtub3duIHZhbHVlcyBpbiB0aGlzIHdpZGdldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSBidXR0b24gKyBtZW51IHRoYXQgcHJvdmlkZXMgdGhlIHJlYWwgZnVuY3Rpb25hbGl0eSBmb3IgdGhpcyB0b29sYmFyIHdpZGdldFxuICAgICAgICB0aGlzLmJ1dHRvbiA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgICAgIC5zZXRDb2xvcihsYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAuc2V0SHRtbChsYXlvdXQuYnV0dG9uX2h0bWwgKyAobGF5b3V0LnNob3dfc2VsZWN0ZWQgPyB0aGlzLl9zZWxlY3RlZF9pdGVtIDogJycpKVxuICAgICAgICAgICAgLnNldFRpdGxlKGxheW91dC5idXR0b25fdGl0bGUpXG4gICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5wb3B1bGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnV0dG9uLm1lbnUuc2V0UG9wdWxhdGUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTXVsdGlwbGUgY29waWVzIG9mIHRoaXMgYnV0dG9uIG1pZ2h0IGJlIHVzZWQgb24gYSBzaW5nbGUgTFogcGFnZTsgYXBwZW5kIHVuaXF1ZSBJRHMgd2hlcmUgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVJRCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlNCkudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5pbm5lcl9zZWxlY3Rvci5odG1sKCcnKTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5idXR0b24ubWVudS5pbm5lcl9zZWxlY3Rvci5hcHBlbmQoJ3RhYmxlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclJvdyA9IChkaXNwbGF5X25hbWUsIHZhbHVlLCByb3dfaWQpID0+IHsgLy8gSGVscGVyIG1ldGhvZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmFwcGVuZCgndHInKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpb0lkID0gYCR7dW5pcXVlSUR9JHtyb3dfaWR9YDtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKCd0ZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2lucHV0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgcmFkaW9JZClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAncmFkaW8nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignbmFtZScsIGBzZXQtc3RhdGUtJHt1bmlxdWVJRH1gKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndmFsdWUnLCByb3dfaWQpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luJywgMCkgLy8gT3ZlcnJpZGUgY3NzIGxpYnJhcmllcyAoZWcgc2tlbGV0b24pIHRoYXQgc3R5bGUgZm9ybSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgLnByb3BlcnR5KCdjaGVja2VkJywgKHZhbHVlID09PSB0aGlzLl9zZWxlY3RlZF9pdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld19zdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3N0YXRlW2xheW91dC5zdGF0ZV9maWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkX2l0ZW0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QuYXBwbHlTdGF0ZShuZXdfc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2V0SHRtbChsYXlvdXQuYnV0dG9uX2h0bWwgKyAobGF5b3V0LnNob3dfc2VsZWN0ZWQgPyB0aGlzLl9zZWxlY3RlZF9pdGVtIDogJycpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcm93LmFwcGVuZCgndGQnKS5hcHBlbmQoJ2xhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsICdub3JtYWwnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9yJywgcmFkaW9JZClcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZGlzcGxheV9uYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYXlvdXQub3B0aW9ucy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gcmVuZGVyUm93KGl0ZW0uZGlzcGxheV9uYW1lLCBpdGVtLnZhbHVlLCBpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cblxuZXhwb3J0IHtcbiAgICBCYXNlV2lkZ2V0LCAgLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBzdWJjbGFzc2VzXG4gICAgQnV0dG9uIGFzIF9CdXR0b24sIC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgV2lkZ2V0cyB0aGF0IGNvbnRhaW4gYSBidXR0b24uIEl0IGFjdHVhbGx5IHNob3VsZG4ndCBiZSBpbiB0aGUgcmVnaXN0cnkgYmVjYXVzZSBpdCdzIG5vdCB1c2FibGUgZGlyZWN0bHkuLlxuICAgIERpbWVuc2lvbnMgYXMgZGltZW5zaW9ucyxcbiAgICBEaXNwbGF5T3B0aW9ucyBhcyBkaXNwbGF5X29wdGlvbnMsXG4gICAgRG93bmxvYWRTVkcgYXMgZG93bmxvYWQsXG4gICAgRG93bmxvYWRQTkcgYXMgZG93bmxvYWRfcG5nLFxuICAgIEZpbHRlckZpZWxkIGFzIGZpbHRlcl9maWVsZCxcbiAgICBNZW51IGFzIG1lbnUsXG4gICAgTW92ZVBhbmVsRG93biBhcyBtb3ZlX3BhbmVsX2Rvd24sXG4gICAgTW92ZVBhbmVsVXAgYXMgbW92ZV9wYW5lbF91cCxcbiAgICBSZWdpb25TY2FsZSBhcyByZWdpb25fc2NhbGUsXG4gICAgUmVzaXplVG9EYXRhIGFzIHJlc2l6ZV90b19kYXRhLFxuICAgIFNldFN0YXRlIGFzIHNldF9zdGF0ZSxcbiAgICBTaGlmdFJlZ2lvbiBhcyBzaGlmdF9yZWdpb24sXG4gICAgUmVtb3ZlUGFuZWwgYXMgcmVtb3ZlX3BhbmVsLFxuICAgIFRpdGxlIGFzIHRpdGxlLFxuICAgIFRvZ2dsZUxlZ2VuZCBhcyB0b2dnbGVfbGVnZW5kLFxuICAgIFpvb21SZWdpb24gYXMgem9vbV9yZWdpb24sXG59O1xuIiwiLyoqXG4gKiBEZWZpbmUgc3RhbmRhcmQgZGF0YSBhZGFwdGVycyB1c2VkIHRvIHJldHJpZXZlIGRhdGEgKHVzdWFsbHkgZnJvbSBSRVNUIEFQSXMpXG4gKiBAbW9kdWxlXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVCdWlsZFNvdXJjZShjbGFzc19uYW1lLCBidWlsZCwgc291cmNlKSB7XG4gICAgLy8gQnVpbGQgT1IgU291cmNlLCBub3QgYm90aFxuICAgIGlmICgoYnVpbGQgJiYgc291cmNlKSB8fCAhKGJ1aWxkIHx8IHNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NsYXNzX25hbWV9IG11c3QgcHJvdmlkZSBhIHBhcmFtZXRlciBzcGVjaWZ5aW5nIGVpdGhlciBcImJ1aWxkXCIgb3IgXCJzb3VyY2VcIi4gSXQgc2hvdWxkIG5vdCBzcGVjaWZ5IGJvdGguYCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBidWlsZCBpc24ndCByZWNvZ25pemVkLCBvdXIgQVBJcyBjYW4ndCB0cmFuc3BhcmVudGx5IHNlbGVjdCBhIHNvdXJjZSB0byBtYXRjaFxuICAgIGlmIChidWlsZCAmJiAhWydHUkNoMzcnLCAnR1JDaDM4J10uaW5jbHVkZXMoYnVpbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjbGFzc19uYW1lfSBtdXN0IHNwZWNpZnkgYSB2YWxpZCBnZW5vbWUgYnVpbGQgbnVtYmVyYCk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgTG9jdXNab29tIGRhdGEgc291cmNlcyAoYW55KS4gU2VlIGFsc286IEJhc2VBcGlBZGFwdGVyXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEJhc2VBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBzb3VyY2Ugc2hvdWxkIGVuYWJsZSBjYWNoaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbmFibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhY2hlZEtleSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBkYXRhIHNvdXJjZSB0eXBlIGlzIGRlcGVuZGVudCBvbiBwcmV2aW91cyByZXF1ZXN0cy0gZm9yIGV4YW1wbGUsIHRoZSBMRCBzb3VyY2UgY2Fubm90IGFubm90YXRlXG4gICAgICAgICAqICBhc3NvY2lhdGlvbiBkYXRhIGlmIG5vIGRhdGEgd2FzIGZvdW5kIGZvciB0aGF0IHJlZ2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19kZXBlbmRlbnRTb3VyY2UgPSBmYWxzZTtcblxuICAgICAgICAvLyBQYXJzZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgICAgdGhpcy5wYXJzZUluaXQoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjb25maWd1cmF0aW9uIHVzZWQgdG8gY3JlYXRlIHRoZSBkYXRhIHNvdXJjZS4gTWFueSBjdXN0b20gc291cmNlcyB3aWxsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHN1aXQgdGhlaXJcbiAgICAgKiAgbmVlZHMgKGVnIHNwZWNpZmljIGNvbmZpZyBvcHRpb25zLCBvciBmb3Igc291cmNlcyB0aGF0IGRvIG5vdCByZXRyaWV2ZSBkYXRhIGZyb20gYSBVUkwpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnIEJhc2ljIGNvbmZpZ3VyYXRpb24tIGVpdGhlciBhIHVybCwgb3IgYSBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcudXJsXSBUaGUgZGF0YXNvdXJjZSBVUkxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5wYXJhbXNdIEluaXRpYWwgY29uZmlnIHBhcmFtcyBmb3IgdGhlIGRhdGFzb3VyY2VcbiAgICAgKi9cbiAgICBwYXJzZUluaXQoY29uZmlnKSB7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtPYmplY3R9ICovXG4gICAgICAgIHRoaXMucGFyYW1zID0gY29uZmlnLnBhcmFtcyB8fCB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgY2FjaGVkIGRhdGEgaXMgdmFsaWQgZm9yIHRoaXMgcmVxdWVzdC4gRm9yIG1vc3Qgc291cmNlcyB1c2luZyBHRVRcbiAgICAgKiAgcmVxdWVzdHMgdG8gYSBSRVNUIEFQSSwgdGhpcyBpcyB1c3VhbGx5IHRoZSBVUkwuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBJbmZvcm1hdGlvbiBhdmFpbGFibGUgaW4gcGxvdC5zdGF0ZSAoY2hyLCBzdGFydCwgZW5kKS4gU29tZXRpbWVzIHVzZWQgdG8gaW5qZWN0IGdsb2JhbGx5XG4gICAgICogIGF2YWlsYWJsZSBpbmZvcm1hdGlvbiB0aGF0IGluZmx1ZW5jZXMgdGhlIHJlcXVlc3QgYmVpbmcgbWFkZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGRhdGEgY2hhaW4gZnJvbSBwcmV2aW91cyByZXF1ZXN0cyBtYWRlIGluIGEgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3R1YjogYnVpbGQgdGhlIFVSTCBmb3IgYW55IHJlcXVlc3RzIG1hZGUgYnkgdGhpcyBzb3VyY2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy51cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIG5ldHdvcmsgcmVxdWVzdCB0byBmZXRjaCBkYXRhIGZvciB0aGlzIHNvdXJjZS4gVGhpcyBpcyB1c3VhbGx5IHRoZSBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG92ZXJyaWRlXG4gICAgICogIHdoZW4gZGVmaW5pbmcgaG93IHRvIHJldHJpZXZlIGRhdGEuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBUaGUgc3RhdGUgb2YgdGhlIHBhcmVudCBwbG90XG4gICAgICogQHBhcmFtIGNoYWluXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZldGNoUmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IganVzdCB0aGlzIHNvdXJjZSwgdHlwaWNhbGx5IHZpYSBhIG5ldHdvcmsgcmVxdWVzdCAoYnV0IHVzaW5nIGNhY2hlIHdoZXJlIHBvc3NpYmxlKVxuICAgICAqXG4gICAgICogRm9yIG1vc3QgdXNlIGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gb3ZlcnJpZGUgYGZldGNoUmVxdWVzdGAgaW5zdGVhZCwgdG8gYXZvaWQgYnlwYXNzaW5nIHRoZSBjYWNoZSBtZWNoYW5pc21cbiAgICAgKiBieSBhY2NpZGVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0UmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBsZXQgcmVxO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICBpZiAodGhpcy5fZW5hYmxlQ2FjaGUgJiYgdHlwZW9mKGNhY2hlS2V5KSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FjaGVLZXkgPT09IHRoaXMuX2NhY2hlZEtleSkge1xuICAgICAgICAgICAgcmVxID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlZFJlc3BvbnNlKTsgIC8vIFJlc29sdmUgdG8gdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IHByb21pc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcSA9IHRoaXMuZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZEtleSA9IGNhY2hlS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFJlc3BvbnNlID0gcmVxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgaW4gYSBjYW5vbmljYWwgZm9ybSwgYW4gYXJyYXkgb2Ygb25lIG9iamVjdCBwZXIgcmVjb3JkLiBbIHtmaWVsZDogb25ldmFsfSBdLlxuICAgICAqIElmIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29udGFpbnMgY29sdW1ucywgcmVmb3JtYXRzIHRoZSByZXNwb25zZSBmcm9tIHtjb2x1bW4xOiBbXSwgY29sdW1uMjogW119IHRvIHRoZSBhYm92ZS5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IGFwcGx5IG5hbWVzcGFjaW5nLCB0cmFuc2Zvcm1hdGlvbnMsIG9yIGZpZWxkIGV4dHJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBNYXkgYmUgb3ZlcnJpZGRlbiBieSBkYXRhIHNvdXJjZXMgdGhhdCBpbmhlcmVudGx5IHJldHVybiBtb3JlIGNvbXBsZXggcGF5bG9hZHMsIG9yIHRoYXQgZXhpc3QgdG8gYW5ub3RhdGUgb3RoZXJcbiAgICAgKiAgc291cmNlcyAoZWcsIGlmIHRoZSBwYXlsb2FkIHByb3ZpZGVzIGV4dHJhIGRhdGEgcmF0aGVyIHRoYW4gYSBzZXJpZXMgb2YgcmVjb3JkcykuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118T2JqZWN0fSBkYXRhIFRoZSBvcmlnaW5hbCBwYXJzZWQgc2VydmVyIHJlc3BvbnNlXG4gICAgICovXG4gICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBpbiB0aGUgZGVzaXJlZCBmb3JtXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSB0aGUgc2VydmVyIHJlc3BvbnNlIGlzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgY29sdW1ucyBvZiBkYXRhLlxuICAgICAgICAvLyBFYWNoIGFycmF5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aCAodmVyaWZ5KSwgYW5kIGEgZ2l2ZW4gYXJyYXkgaW5kZXggY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgcm93LlxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IE4gPSBkYXRhW2tleXNbMF1dLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2FtZUxlbmd0aCA9IGtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aCA9PT0gTjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2FtZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gZXhwZWN0cyBhIHJlc3BvbnNlIGluIHdoaWNoIGFsbCBhcnJheXMgb2YgZGF0YSBhcmUgdGhlIHNhbWUgbGVuZ3RoYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHbyBkb3duIHRoZSByb3dzLCBhbmQgY3JlYXRlIGFuIG9iamVjdCBmb3IgZWFjaCByZWNvcmRcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZWNvcmRbZmllbGRzW2pdXSA9IGRhdGFbZmllbGRzW2pdXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgdG8gcG9zdC1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGJ5IHRoaXMgc291cmNlIHdpdGggbmV3LCBhZGRpdGlvbmFsIGJlaGF2aW9yLlxuICAgICAqICAgKGVnIGNsZWFuaW5nIHVwIEFQSSB2YWx1ZXMgb3IgcGVyZm9ybWluZyBjb21wbGV4IGNhbGN1bGF0aW9ucyBvbiB0aGUgcmV0dXJuZWQgZGF0YSlcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSByZWNvcmRzIFRoZSBwYXJzZWQgZGF0YSBmcm9tIHRoZSBzb3VyY2UgKGVnIHN0YW5kYXJkaXplZCBhcGkgcmVzcG9uc2UpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYWluIFRoZSBkYXRhIGNoYWluIG9iamVjdC4gRm9yIGV4YW1wbGUsIGNoYWluLmhlYWRlcnMgbWF5IHByb3ZpZGUgdXNlZnVsIGFubm90YXRpb24gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W118UHJvbWlzZX0gVGhlIG1vZGlmaWVkIHNldCBvZiByZWNvcmRzXG4gICAgICovXG4gICAgYW5ub3RhdGVEYXRhKHJlY29yZHMsIGNoYWluKSB7XG4gICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IG5vIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCB0aGUgc2VydmVyIHJlY29yZHMgZm9yIHVzZSBieSBkYXRhbGF5ZXJzOiBleHRyYWN0IG9ubHkgY2VydGFpbiBmaWVsZHMsIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lcy5cbiAgICAgKiAgIEFwcGx5IHBlci1maWVsZCB0cmFuc2Zvcm1hdGlvbnMgYXMgYXBwcm9wcmlhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGhvb2sgY2FuIGJlIG92ZXJyaWRkZW4sIGVnIHRvIGNyZWF0ZSBhIHNvdXJjZSB0aGF0IGFsd2F5cyByZXR1cm5zIGFsbCByZWNvcmRzIGFuZCBpZ25vcmVzIHRoZSBcImZpZWxkc1wiIGFycmF5LlxuICAgICAqICBUaGlzIGlzIHBhcnRpY3VsYXJseSBjb21tb24gZm9yIHNvdXJjZXMgYXQgdGhlIGVuZCBvZiBhIGNoYWluLSBtYW55IFwiZGVwZW5kZW50XCIgc291cmNlcyBkbyBub3QgYWxsb3dcbiAgICAgKiAgY2hlcnJ5LXBpY2tpbmcgaW5kaXZpZHVhbCBmaWVsZHMsIGluIHdoaWNoIGNhc2UgYnkgKipjb252ZW50aW9uKiogdGhlIGZpZWxkcyBhcnJheSBzcGVjaWZpZXMgXCJsYXN0X3NvdXJjZV9uYW1lOmFsbFwiXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YSBPbmUgcmVjb3JkIG9iamVjdCBwZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyBUaGUgbmFtZXMgb2YgZmllbGRzIHRvIGV4dHJhY3QgKGFzIG5hbWVkIGluIHRoZSBzb3VyY2UgZGF0YSkuIEVnIFwiYWZpZWxkXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvdXRuYW1lcyBIb3cgdG8gcmVwcmVzZW50IHRoZSBzb3VyY2UgZmllbGRzIGluIHRoZSBvdXRwdXQuIEVnIFwibmFtZXNwYWNlOmFmaWVsZHxhdHJhbnNmb3JtXCJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uW119IHRyYW5zIEFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyAoaWYgYW55KS4gT25lIGZ1bmN0aW9uIHBlciBkYXRhIGVsZW1lbnQsIG9yIG51bGwuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGV4dHJhY3RGaWVsZHMgKGRhdGEsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIC8vaW50ZW5kZWQgZm9yIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgLy8gIFsge1wiaWRcIjoxLCBcInZhbFwiOjV9LCB7XCJpZFwiOjIsIFwidmFsXCI6MTB9XVxuICAgICAgICAvLyBTaW5jZSBhIG51bWJlciBvZiBzb3VyY2VzIGV4aXN0IHRoYXQgZG8gbm90IG9iZXkgdGhpcyBmb3JtYXQsIHdlIHdpbGwgcHJvdmlkZSBhIGNvbnZlbmllbnQgcGFzcy10aHJvdWdoXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIHJlZ2lvbnMgdGhhdCBqdXN0IGRvbid0IGhhdmUgZGF0YS0gdGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSBtaXNzaW5nIGZpZWxkIGVycm9yIG1lc3NhZ2UhXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpZWxkRm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBmaWVsZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGZpZWxkRm91bmRba10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRfcmVjb3JkID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBpdGVtW2ZpZWxkc1tqXV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRGb3VuZFtqXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFucyAmJiB0cmFuc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB0cmFuc1tqXSh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRfcmVjb3JkW291dG5hbWVzW2pdXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRfcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgZmllbGRGb3VuZC5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmllbGQgJHtmaWVsZHNbaV19IG5vdCBmb3VuZCBpbiByZXNwb25zZSBmb3IgJHtvdXRuYW1lc1tpXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgcmVjb3JkcyBmcm9tIHRoaXMgc291cmNlIHdpdGggb3RoZXJzIGluIHRoZSBjaGFpbiB0byB5aWVsZCBmaW5hbCBjaGFpbiBib2R5LlxuICAgICAqICAgSGFuZGxlcyBtZXJnaW5nIHRoaXMgZGF0YSB3aXRoIG90aGVyIHNvdXJjZXMgKGlmIGFwcGxpY2FibGUpLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEgVGhlIGRhdGEgVGhhdCB3b3VsZCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgc291cmNlIGFsb25lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYWluIFRoZSBkYXRhIGNoYWluIGJ1aWx0IHVwIGR1cmluZyBwcmV2aW91cyByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG91dG5hbWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdHJhbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfE9iamVjdFtdfSBUaGUgbmV3IGNoYWluIGJvZHlcbiAgICAgKi9cbiAgICBjb21iaW5lQ2hhaW5Cb2R5KGRhdGEsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb29yZGluYXRlcyB0aGUgd29yayBvZiBwYXJzaW5nIGEgcmVzcG9uc2UgYW5kIHJldHVybmluZyByZWNvcmRzLiBUaGlzIGlzIGJyb2tlbiBpbnRvIDQgc3RlcHMsIHdoaWNoIG1heSBiZVxuICAgICAqICBvdmVycmlkZGVuIHNlcGFyYXRlbHkgZm9yIGZpbmUtZ3JhaW5lZCBjb250cm9sLiBFYWNoIHN0ZXAgY2FuIHJldHVybiBlaXRoZXIgcmF3IGRhdGEgb3IgYSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSByZXNwIFRoZSByYXcgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYWluIFRoZSBjb21iaW5lZCBwYXJzZWQgcmVzcG9uc2UgZGF0YSBmcm9tIHRoaXMgYW5kIGFsbCBvdGhlciByZXF1ZXN0cyBtYWRlIGluIHRoZSBjaGFpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyBBcnJheSBvZiByZXF1ZXN0ZWQgZmllbGQgbmFtZXMgKGFzIHRoZXkgd291bGQgYXBwZWFyIGluIHRoZSByZXNwb25zZSBwYXlsb2FkKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG91dG5hbWVzICBBcnJheSBvZiBmaWVsZCBuYW1lcyBhcyB0aGV5IHdpbGwgYmUgcmVwcmVzZW50ZWQgaW4gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhpcyBzb3VyY2UsXG4gICAgICogIGluY2x1ZGluZyB0aGUgbmFtZXNwYWNlLiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgYGZpZWxkc2BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IHRyYW5zIFRoZSBjb2xsZWN0aW9uIG9mIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBydW4gb24gc2VsZWN0ZWQgZmllbGRzLlxuICAgICAqICAgICBUaGlzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgYGZpZWxkc2BcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAgICAgKiAgIHJlcXVlc3QgbWV0YWRhdGEgKGBoZWFkZXJzOiB7fWApLCB0aGUgY29uc29saWRhdGVkIGRhdGEgZm9yIHBsb3R0aW5nIChgYm9keTogW11gKSwgYW5kIHRoZSBpbmRpdmlkdWFsIHJlc3BvbnNlcyB0aGF0IHdvdWxkIGJlXG4gICAgICogICByZXR1cm5lZCBieSBlYWNoIHNvdXJjZSBpbiB0aGUgY2hhaW4gaW4gaXNvbGF0aW9uIChgZGlzY3JldGU6IHt9YClcbiAgICAgKi9cbiAgICBwYXJzZVJlc3BvbnNlIChyZXNwLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlX2lkID0gdGhpcy5zb3VyY2VfaWQgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBpZiAoIWNoYWluLmRpc2NyZXRlKSB7XG4gICAgICAgICAgICBjaGFpbi5kaXNjcmV0ZSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QganNvbiA9IHR5cGVvZiByZXNwID09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShyZXNwKSA6IHJlc3A7XG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgNCBzdGVwcyBvZiBwYXJzaW5nIHRoZSBwYXlsb2FkIGFuZCByZXR1cm4gYSBjb21iaW5lZCBjaGFpbiBvYmplY3RcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLm5vcm1hbGl6ZVJlc3BvbnNlKGpzb24uZGF0YSB8fCBqc29uKSlcbiAgICAgICAgICAgIC50aGVuKChzdGFuZGFyZGl6ZWQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNhbGN1bGF0aW9ucyBvbiB0aGUgZGF0YSBmcm9tIGp1c3QgdGhpcyBzb3VyY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYW5ub3RhdGVEYXRhKHN0YW5kYXJkaXplZCwgY2hhaW4pKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXh0cmFjdEZpZWxkcyhkYXRhLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykpO1xuICAgICAgICAgICAgfSkudGhlbigob25lX3NvdXJjZV9ib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgYSBjb3B5IG9mIHRoZSBkYXRhIHRoYXQgd291bGQgYmUgcmV0dXJuZWQgYnkgcGFyc2luZyB0aGlzIHNvdXJjZSBpbiBpc29sYXRpb24gKGFuZCB0YWtpbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBmaWVsZHMgYXJyYXkgaW50byBhY2NvdW50KS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvIHJlLXVzZSB0aGUgc291cmNlIG91dHB1dCBpbiBtYW55IHdheXMuXG4gICAgICAgICAgICAgICAgY2hhaW4uZGlzY3JldGVbc291cmNlX2lkXSA9IG9uZV9zb3VyY2VfYm9keTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tYmluZUNoYWluQm9keShvbmVfc291cmNlX2JvZHksIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykpO1xuICAgICAgICAgICAgfSkudGhlbigobmV3X2JvZHkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFkZXI6IGNoYWluLmhlYWRlciB8fCB7fSwgZGlzY3JldGU6IGNoYWluLmRpc2NyZXRlLCBib2R5OiBuZXdfYm9keSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIGRhdGEgc291cmNlLCBhbmQgYXBwbHkgdHJhbnNmb3JtYXRpb25zIHJlcXVlc3RlZCBieSBhbiBleHRlcm5hbCBjb25zdW1lci5cbiAgICAgKiBUaGlzIGlzIHRoZSBwdWJsaWMtZmFjaW5nIGRhdGFzb3VyY2UgbWV0aG9kIHRoYXQgd2lsbCBtb3N0IGJlIGNhbGxlZCBieSB0aGUgcGxvdCwgYnV0IGN1c3RvbSBkYXRhIHNvdXJjZXMgd2lsbFxuICAgICAqICBhbG1vc3QgbmV2ZXIgd2FudCB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBkaXJlY3RseS0gbW9yZSBzcGVjaWZpYyBob29rcyBhcmUgcHJvdmlkZWQgdG8gY29udHJvbCBpbmRpdmlkdWFsIHBpZWNlc1xuICAgICAqICBvZiB0aGUgcmVxdWVzdCBsaWZlY3ljbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBUaGUgY3VycmVudCBcInN0YXRlXCIgb2YgdGhlIHBsb3QsIHN1Y2ggYXMgY2hyb21vc29tZSBhbmQgc3RhcnQvZW5kIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyBBcnJheSBvZiBmaWVsZCBuYW1lcyB0aGF0IHRoZSBwbG90IGhhcyByZXF1ZXN0ZWQgZnJvbSB0aGlzIGRhdGEgc291cmNlLiAod2l0aG91dCB0aGUgXCJuYW1lc3BhY2VcIiBwcmVmaXgpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3V0bmFtZXMgIEFycmF5IGRlc2NyaWJpbmcgaG93IHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgcmVmZXIgdG8gdGhpcyBmaWVsZC4gVGhpcyByZXByZXNlbnRzIHRoZVxuICAgICAqICAgICBvcmlnaW5hbGx5IHJlcXVlc3RlZCBmaWVsZCBuYW1lLCBpbmNsdWRpbmcgdGhlIG5hbWVzcGFjZS4gVGhpcyBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIGBmaWVsZHNgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSB0cmFucyBUaGUgY29sbGVjdGlvbiBvZiB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYmUgcnVuIG9uIHNlbGVjdGVkIGZpZWxkcy5cbiAgICAgKiAgICAgVGhpcyBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIGBmaWVsZHNgXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBBIGNhbGxhYmxlIG9wZXJhdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGFzIHBhcnQgb2YgdGhlIGRhdGEgY2hhaW5cbiAgICAgKi9cbiAgICBnZXREYXRhKHN0YXRlLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICBpZiAodGhpcy5wcmVHZXREYXRhKSB7IC8vIFRPRE8gdHJ5IHRvIHJlbW92ZSB0aGlzIG1ldGhvZCBpZiBhdCBhbGwgcG9zc2libGVcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHRoaXMucHJlR2V0RGF0YShzdGF0ZSwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBwcmUuc3RhdGUgfHwgc3RhdGU7XG4gICAgICAgICAgICAgICAgZmllbGRzID0gcHJlLmZpZWxkcyB8fCBmaWVsZHM7XG4gICAgICAgICAgICAgICAgb3V0bmFtZXMgPSBwcmUub3V0bmFtZXMgfHwgb3V0bmFtZXM7XG4gICAgICAgICAgICAgICAgdHJhbnMgPSBwcmUudHJhbnMgfHwgdHJhbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGNoYWluKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RlcGVuZGVudFNvdXJjZSAmJiBjaGFpbiAmJiBjaGFpbi5ib2R5ICYmICFjaGFpbi5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEEgXCJkZXBlbmRlbnRcIiBzb3VyY2Ugc2hvdWxkIG5vdCBhdHRlbXB0IHRvIGZpcmUgYSByZXF1ZXN0IGlmIHRoZXJlIGlzIG5vIGRhdGEgZm9yIGl0IHRvIGFjdCBvbi5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIGl0IHNob3VsZCBzaW1wbHkgcmV0dXJuIHRoZSBwcmV2aW91cyBkYXRhIGNoYWluLlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hhaW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZXNwb25zZShyZXNwLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2Ugc291cmNlIGZvciBMb2N1c1pvb20gZGF0YSBzb3VyY2VzIHRoYXQgcmVjZWl2ZSB0aGVpciBkYXRhIG92ZXIgdGhlIHdlYi4gQWRkcyBkZWZhdWx0IGNvbmZpZyBwYXJhbWV0ZXJzXG4gKiAgKGFuZCBwb3RlbnRpYWxseSBvdGhlciBiZWhhdmlvcikgdGhhdCBhcmUgcmVsZXZhbnQgdG8gVVJMLWJhc2VkIHJlcXVlc3RzLlxuICovXG5jbGFzcyBCYXNlQXBpQWRhcHRlciBleHRlbmRzIEJhc2VBZGFwdGVyIHtcbiAgICBwYXJzZUluaXQoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLnBhcnNlSW5pdChjb25maWcpO1xuXG4gICAgICAgIC8qKiBAbWVtYmVyIHtTdHJpbmd9ICovXG4gICAgICAgIHRoaXMudXJsID0gY29uZmlnLnVybDtcbiAgICAgICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2Ugbm90IGluaXRpYWxpemVkIHdpdGggcmVxdWlyZWQgVVJMJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRGF0YSBTb3VyY2UgZm9yIEFzc29jaWF0aW9uIERhdGEgZnJvbSB0aGUgTG9jdXNab29tLyBQb3J0YWxkZXYgQVBJIChvciBjb21wYXRpYmxlKS4gRGVmaW5lcyBob3cgdG8gbWFrZSBhIHJlcXVlc3JcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQXNzb2NpYXRpb25MWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBwcmVHZXREYXRhIChzdGF0ZSwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgLy8gVE9ETzogTW9kaWZ5IGludGVybmFscyB0byBzZWUgaWYgd2UgY2FuIGdvIHdpdGhvdXQgdGhpcyBtZXRob2RcbiAgICAgICAgY29uc3QgaWRfZmllbGQgPSB0aGlzLnBhcmFtcy5pZF9maWVsZCB8fCAnaWQnO1xuICAgICAgICBbaWRfZmllbGQsICdwb3NpdGlvbiddLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZHMuaW5jbHVkZXMoeCkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMudW5zaGlmdCh4KTtcbiAgICAgICAgICAgICAgICBvdXRuYW1lcy51bnNoaWZ0KHgpO1xuICAgICAgICAgICAgICAgIHRyYW5zLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge2ZpZWxkczogZmllbGRzLCBvdXRuYW1lczpvdXRuYW1lcywgdHJhbnM6dHJhbnN9O1xuICAgIH1cblxuICAgIGdldFVSTCAoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBjaGFpbi5oZWFkZXIuYW5hbHlzaXMgfHwgdGhpcy5wYXJhbXMuc291cmNlIHx8IHRoaXMucGFyYW1zLmFuYWx5c2lzOyAgLy8gT2xkIHVzYWdlcyBjYWxsZWQgdGhpcyBwYXJhbSBcImFuYWx5c2lzXCJcbiAgICAgICAgaWYgKHR5cGVvZiBhbmFseXNpcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NvY2lhdGlvbiBzb3VyY2UgbXVzdCBzcGVjaWZ5IGFuIGFuYWx5c2lzIElEIHRvIHBsb3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy51cmx9cmVzdWx0cy8/ZmlsdGVyPWFuYWx5c2lzIGluICR7YW5hbHlzaXN9IGFuZCBjaHJvbW9zb21lIGluICAnJHtzdGF0ZS5jaHJ9JyBhbmQgcG9zaXRpb24gZ2UgJHtzdGF0ZS5zdGFydH0gYW5kIHBvc2l0aW9uIGxlICR7c3RhdGUuZW5kfWA7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UgKGRhdGEpIHtcbiAgICAgICAgLy8gU29tZSBhc3NvY2lhdGlvbiBzb3VyY2VzIGRvIG5vdCBzb3J0IHRoZWlyIGRhdGEgaW4gYSBwcmVkaWN0YWJsZSBvcmRlciwgd2hpY2ggbWFrZXMgaXQgaGFyZCB0byByZWxpYWJseVxuICAgICAgICAvLyAgYWxpZ24gd2l0aCBvdGhlciBzb3VyY2VzIChzdWNoIGFzIExEKS4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHNvcnRpbmcgaXMgYW4gb3B0LWluIGFyZ3VtZW50LlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3JlIGZpbmUgZ3JhaW5lZCBzb3J0aW5nIGNvbnRyb2wgaW4gdGhlIGZ1dHVyZS4gVGhpcyB3YXMgYWRkZWQgYXMgYSB2ZXJ5IHNwZWNpZmljXG4gICAgICAgIC8vICAgd29ya2Fyb3VuZCBmb3IgdGhlIG9yaWdpbmFsIFQyRCBwb3J0YWwuXG4gICAgICAgIGRhdGEgPSBzdXBlci5ub3JtYWxpemVSZXNwb25zZShkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zICYmIHRoaXMucGFyYW1zLnNvcnQgJiYgZGF0YS5sZW5ndGggJiYgZGF0YVswXVsncG9zaXRpb24nXSkge1xuICAgICAgICAgICAgZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbJ3Bvc2l0aW9uJ10gLSBiWydwb3NpdGlvbiddO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG4vKipcbiAqIEZldGNoIGxpbmthZ2UgZGlzZXF1aWxpYnJpdW0gaW5mb3JtYXRpb24gZnJvbSBhIFVNaWNoIExEU2VydmVyLWNvbXBhdGlibGUgQVBJXG4gKlxuICogVGhpcyBzb3VyY2UgaXMgZGVzaWduZWQgdG8gY29ubmVjdCBpdHMgcmVzdWx0cyB0byBhc3NvY2lhdGlvbiBkYXRhLCBhbmQgdGhlcmVmb3JlIGRlcGVuZHMgb24gYXNzb2NpYXRpb24gZGF0YSBoYXZpbmdcbiAqICBiZWVuIGxvYWRlZCBieSBhIHByZXZpb3VzIHJlcXVlc3QgaW4gdGhlIGRhdGEgY2hhaW4uXG4gKlxuICogSW4gb2xkZXIgdmVyc2lvbnMgb2YgTG9jdXNab29tLCB0aGlzIHdhcyBrbm93biBhcyBcIkxEU2VydmVyXCIuIEEgcHJpb3Igc291cmNlICh0YXJnZXRlZCBhdCBvbGRlciBBUElzKSBoYXMgYmVlbiByZW1vdmVkLlxuICovXG5jbGFzcyBMRFNlcnZlciBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fX2RlcGVuZGVudFNvdXJjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcHJlR2V0RGF0YShzdGF0ZSwgZmllbGRzKSB7XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggIT09IDIgfHwgIWZpZWxkcy5pbmNsdWRlcygnaXNyZWZ2YXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTEQgZG9lcyBub3Qga25vdyBob3cgdG8gZ2V0IGFsbCBmaWVsZHM6ICR7ZmllbGRzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5kTWVyZ2VGaWVsZHMoY2hhaW4pIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmllbGRzIChhcyBwcm92aWRlZCBieSBhIHByZXZpb3VzIHN0ZXAgaW4gdGhlIGNoYWluLCBsaWtlIGFuIGFzc29jaWF0aW9uIHNvdXJjZSkgdGhhdCB3aWxsIGJlIG5lZWRlZCB0b1xuICAgICAgICAvLyAgY29tYmluZSBMRCBkYXRhIHdpdGggZXhpc3RpbmcgaW5mb3JtYXRpb25cblxuICAgICAgICAvLyBTaW5jZSBMRCBpbmZvcm1hdGlvbiBtYXkgYmUgc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBhc3NvYyBzb3VyY2VzIHdpdGggZGlmZmVyZW50IG5hbWVzcGFjZXMsXG4gICAgICAgIC8vICAgd2UgdXNlIHJlZ2V4IHRvIGZpbmQgY29sdW1ucyB0byBqb2luIG9uLCByYXRoZXIgdGhhbiByZXF1aXJpbmcgZXhhY3QgbWF0Y2hlc1xuICAgICAgICBjb25zdCBleGFjdE1hdGNoID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleGVzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHJlZ2V4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBhcnIuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGRhdGFGaWVsZHMgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5wYXJhbXMuaWRfZmllbGQsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wYXJhbXMucG9zaXRpb25fZmllbGQsXG4gICAgICAgICAgICBwdmFsdWU6IHRoaXMucGFyYW1zLnB2YWx1ZV9maWVsZCxcbiAgICAgICAgICAgIF9uYW1lc186bnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoYWluICYmIGNoYWluLmJvZHkgJiYgY2hhaW4uYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGNoYWluLmJvZHlbMF0pO1xuICAgICAgICAgICAgY29uc3QgbmFtZU1hdGNoID0gZXhhY3RNYXRjaChuYW1lcyk7XG4gICAgICAgICAgICAvLyBJbnRlcm5hbGx5LCBmaWVsZHMgYXJlIGdlbmVyYWxseSBwcmVmaXhlZCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBzb3VyY2UgdGhleSBjb21lIGZyb20uXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlcyBhbiBpZF9maWVsZCAobGlrZSBgdmFyaWFudGApLCBpdCBzaG91bGQgd29yayBhY3Jvc3MgZGF0YSBzb3VyY2VzKCBgYXNzb2MxOnZhcmlhbnRgLFxuICAgICAgICAgICAgLy8gIGFzc29jMjp2YXJpYW50KSwgYnV0IG5vdCBtYXRjaCBmcmFnbWVudHMgb2Ygb3RoZXIgZmllbGQgbmFtZXMgKGFzc29jMTp2YXJpYW50X3RoaW5nKVxuICAgICAgICAgICAgLy8gTm90ZTogdGhlc2UgbG9va3VwcyBoYXJkLWNvZGUgYSBjb3VwbGUgb2YgY29tbW9uIGZpZWxkcyB0aGF0IHdpbGwgd29yayBiYXNlZCBvbiBrbm93biBBUElzIGluIHRoZSB3aWxkXG4gICAgICAgICAgICBjb25zdCBpZF9tYXRjaCA9IGRhdGFGaWVsZHMuaWQgJiYgbmFtZU1hdGNoKG5ldyBSZWdFeHAoYCR7ZGF0YUZpZWxkcy5pZH1cXFxcYmApKTtcbiAgICAgICAgICAgIGRhdGFGaWVsZHMuaWQgPSBpZF9tYXRjaCB8fCBuYW1lTWF0Y2goL1xcYnZhcmlhbnRcXGIvKSB8fCBuYW1lTWF0Y2goL1xcYmlkXFxiLyk7XG4gICAgICAgICAgICBkYXRhRmllbGRzLnBvc2l0aW9uID0gZGF0YUZpZWxkcy5wb3NpdGlvbiB8fCBuYW1lTWF0Y2goL1xcYnBvc2l0aW9uXFxiL2ksIC9cXGJwb3NcXGIvaSk7XG4gICAgICAgICAgICBkYXRhRmllbGRzLnB2YWx1ZSA9IGRhdGFGaWVsZHMucHZhbHVlIHx8IG5hbWVNYXRjaCgvXFxicHZhbHVlXFxiL2ksIC9cXGJsb2dfcHZhbHVlXFxiL2kpO1xuICAgICAgICAgICAgZGF0YUZpZWxkcy5fbmFtZXNfID0gbmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFGaWVsZHM7XG4gICAgfVxuXG4gICAgZmluZFJlcXVlc3RlZEZpZWxkcyAoZmllbGRzLCBvdXRuYW1lcykge1xuICAgICAgICAvLyBBc3N1bXB0aW9uOiBhbGwgdXNhZ2VzIG9mIHRoaXMgc291cmNlIHdpbGwgb25seSBldmVyIGFzayBmb3IgXCJpc3JlZnZhclwiIG9yIFwic3RhdGVcIi4gVGhpcyBtYXBzIHRvIG91dHB1dCBuYW1lcy5cbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZpZWxkc1tpXSA9PT0gJ2lzcmVmdmFyJykge1xuICAgICAgICAgICAgICAgIG9iai5pc3JlZnZhcmluID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgIG9iai5pc3JlZnZhcm91dCA9IG91dG5hbWVzICYmIG91dG5hbWVzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmoubGRpbiA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgICAgICBvYmoubGRvdXQgPSBvdXRuYW1lcyAmJiBvdXRuYW1lc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZVJlc3BvbnNlIChkYXRhKSB7XG4gICAgICAgIC8vIFRoZSBMRCBBUEkgcGF5bG9hZCBkb2VzIG5vdCBvYmV5IHN0YW5kYXJkIGZvcm1hdCBjb252ZW50aW9uczsgZG8gbm90IHRyeSB0byB0cmFuc2Zvcm0gaXQuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTEQgcmVmZXJlbmNlIHZhcmlhbnQsIHdoaWNoIGJ5IGRlZmF1bHQgd2lsbCBiZSB0aGUgbW9zdCBzaWduaWZpY2FudCBoaXQgaW4gdGhlIGFzc29jIHJlc3VsdHNcbiAgICAgKiAgIFRoaXMgd2lsbCBiZSB1c2VkIGluIG1ha2luZyB0aGUgb3JpZ2luYWwgcXVlcnkgdG8gdGhlIExEIHNlcnZlciBmb3IgcGFpcndpc2UgTEQgaW5mb3JtYXRpb25cbiAgICAgKiBAcmV0dXJucyB7KnxzdHJpbmd9IFRoZSBtYXJrZXIgaWQgKGV4cGVjdGVkIHRvIGJlIGluIGBjaHI6cG9zX3JlZi9hbHRgIGZvcm1hdCkgb2YgdGhlIHJlZmVyZW5jZSB2YXJpYW50XG4gICAgICovXG4gICAgZ2V0UmVmdmFyKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGxldCBmaW5kRXh0cmVtZVZhbHVlID0gZnVuY3Rpb24ocmVjb3JkcywgcHZhbF9maWVsZCkge1xuICAgICAgICAgICAgLy8gRmluZHMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgaGl0IChzbWFsbGVzdCBwdmFsdWUsIG9yIGxhcmdlc3QgLWxvZzEwcCkuIFdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBhcHByb3ByaWF0ZSBjb21wYXJpc29uLlxuICAgICAgICAgICAgcHZhbF9maWVsZCA9IHB2YWxfZmllbGQgfHwgJ2xvZ19wdmFsdWUnOyAgLy8gVGhlIG9mZmljaWFsIExaIEFQSSByZXR1cm5zIGxvZ19wdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGlzX2xvZyA9IC9sb2cvLnRlc3QocHZhbF9maWVsZCk7XG4gICAgICAgICAgICBsZXQgY21wO1xuICAgICAgICAgICAgaWYgKGlzX2xvZykge1xuICAgICAgICAgICAgICAgIGNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPiBiO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXh0cmVtZVZhbCA9IHJlY29yZHNbMF1bcHZhbF9maWVsZF0sIGV4dHJlbWVJZHggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNtcChyZWNvcmRzW2ldW3B2YWxfZmllbGRdLCBleHRyZW1lVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1lVmFsID0gcmVjb3Jkc1tpXVtwdmFsX2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtZUlkeCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dHJlbWVJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHJlcUZpZWxkcyA9IHRoaXMuZmluZFJlcXVlc3RlZEZpZWxkcyhmaWVsZHMpO1xuICAgICAgICBsZXQgcmVmVmFyID0gcmVxRmllbGRzLmxkaW47XG4gICAgICAgIGlmIChyZWZWYXIgPT09ICdzdGF0ZScpIHtcbiAgICAgICAgICAgIHJlZlZhciA9IHN0YXRlLmxkcmVmdmFyIHx8IGNoYWluLmhlYWRlci5sZHJlZnZhciB8fCAnYmVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZlZhciA9PT0gJ2Jlc3QnKSB7XG4gICAgICAgICAgICBpZiAoIWNoYWluLmJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFzc29jaWF0aW9uIGRhdGEgZm91bmQgdG8gZmluZCBiZXN0IHB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmZpbmRNZXJnZUZpZWxkcyhjaGFpbik7XG4gICAgICAgICAgICBpZiAoIWtleXMucHZhbHVlIHx8ICFrZXlzLmlkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbnMgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoIWtleXMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucyArPSBgJHtjb2x1bW5zLmxlbmd0aCA/ICcsICcgOiAnJ31pZGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgha2V5cy5wdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucyArPSBgJHtjb2x1bW5zLmxlbmd0aCA/ICcsICcgOiAnJ31wdmFsdWVgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIG5lY2Vzc2FyeSBjb2x1bW4ocykgZm9yIG1lcmdlOiAke2NvbHVtbnN9IChhdmFpbGFibGU6ICR7a2V5cy5fbmFtZXNffSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZlZhciA9IGNoYWluLmJvZHlbZmluZEV4dHJlbWVWYWx1ZShjaGFpbi5ib2R5LCBrZXlzLnB2YWx1ZSldW2tleXMuaWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZWYXI7XG4gICAgfVxuXG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIEFjY2VwdCB0aGUgZm9sbG93aW5nIHBhcmFtcyBpbiB0aGlzLnBhcmFtczpcbiAgICAgICAgLy8gLSBtZXRob2QgKHIsIHJzcXVhcmUsIGNvdilcbiAgICAgICAgLy8gLSBzb3VyY2UgKGFrYSBwYW5lbClcbiAgICAgICAgLy8gLSBwb3B1bGF0aW9uIChBTEwsIEFGUiwgRVVSLCBldGMpXG4gICAgICAgIC8vIC0gYnVpbGRcbiAgICAgICAgLy8gVGhlIExEIHNvdXJjZS9wb3AgY2FuIGJlIG92ZXJyaWRkZW4gZnJvbSBwbG90LnN0YXRlIGZvciBkeW5hbWljIGxheW91dHNcbiAgICAgICAgY29uc3QgYnVpbGQgPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQgfHwgJ0dSQ2gzNyc7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzdGF0ZS5sZF9zb3VyY2UgfHwgdGhpcy5wYXJhbXMuc291cmNlIHx8ICcxMDAwRyc7XG4gICAgICAgIGNvbnN0IHBvcHVsYXRpb24gPSBzdGF0ZS5sZF9wb3AgfHwgdGhpcy5wYXJhbXMucG9wdWxhdGlvbiB8fCAnQUxMJzsgIC8vIExEU2VydmVyIHBhbmVscyB3aWxsIGFsd2F5cyBoYXZlIGFuIEFMTFxuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLnBhcmFtcy5tZXRob2QgfHwgJ3JzcXVhcmUnO1xuXG4gICAgICAgIGlmIChzb3VyY2UgPT09ICcxMDAwRycgJiYgYnVpbGQgPT09ICdHUkNoMzgnKSB7XG4gICAgICAgICAgICAvLyBGb3IgYnVpbGQgMzggKG9ubHkpLCB0aGVyZSBpcyBhIG5ld2VyL2ltcHJvdmVkIDEwMDBHIExEIHBhbmVsIGF2YWlsYWJsZSB0aGF0IHVzZXMgV0dTIGRhdGEuIEF1dG8gdXBncmFkZSBieSBkZWZhdWx0LlxuICAgICAgICAgICAgc291cmNlID0gJzEwMDBHLUZSWjA5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRlQnVpbGRTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBidWlsZCwgbnVsbCk7ICAvLyBMRCBkb2Vzbid0IG5lZWQgdG8gdmFsaWRhdGUgYHNvdXJjZWAgb3B0aW9uXG5cbiAgICAgICAgbGV0IHJlZlZhciA9IHRoaXMuZ2V0UmVmdmFyKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgLy8gU29tZSBkYXRhc2V0cywgbm90YWJseSB0aGUgUG9ydGFsLCB1c2UgYSBkaWZmZXJlbnQgbWFya2VyIGZvcm1hdC5cbiAgICAgICAgLy8gIENvZXJjZSBpdCBpbnRvIG9uZSB0aGF0IHdpbGwgd29yayB3aXRoIHRoZSBMRFNlcnZlciBBUEkuIChDSFJPTTpQT1NfUkVGL0FMVClcbiAgICAgICAgY29uc3QgUkVHRVhfTUFSS0VSID0gL14oPzpjaHIpPyhbYS16QS1aMC05XSs/KVtfOi1dKFxcZCspW186fC1dPyhcXHcrKT9bL186fC1dPyhbXl9dKyk/Xz8oLiopPy87XG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmVmVmFyICYmIHJlZlZhci5tYXRjaChSRUdFWF9NQVJLRVIpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlcXVlc3QgTEQgZm9yIGEgbWlzc2luZyBvciBpbmNvbXBsZXRlIG1hcmtlciBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3JpZ2luYWwsIGNocm9tLCBwb3MsIHJlZiwgYWx0XSA9IG1hdGNoO1xuICAgICAgICAvLyBDdXJyZW50bHksIHRoZSBMRCBzZXJ2ZXIgb25seSBhY2NlcHRzIGZ1bGwgdmFyaWFudCBzcGVjczsgaXQgd29uJ3QgcmV0dXJuIExEIHcvbyByZWYrYWx0LiBBbGxvd2luZ1xuICAgICAgICAvLyAgYSBwYXJ0aWFsIG1hdGNoIGF0IG1vc3QgbGVhdmVzIHJvb20gZm9yIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZXMuXG4gICAgICAgIHJlZlZhciA9IGAke2Nocm9tfToke3Bvc31gO1xuICAgICAgICBpZiAocmVmICYmIGFsdCkge1xuICAgICAgICAgICAgcmVmVmFyICs9IGBfJHtyZWZ9LyR7YWx0fWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlc2VydmUgdGhlIHVzZXItcHJvdmlkZWQgdmFyaWFudCBzcGVjIGZvciB1c2Ugd2hlbiBtYXRjaGluZyB0byBhc3NvYyBkYXRhXG4gICAgICAgIGNoYWluLmhlYWRlci5sZHJlZnZhciA9IG9yaWdpbmFsO1xuXG4gICAgICAgIHJldHVybiAgW1xuICAgICAgICAgICAgdGhpcy51cmwsICdnZW5vbWVfYnVpbGRzLycsIGJ1aWxkLCAnL3JlZmVyZW5jZXMvJywgc291cmNlLCAnL3BvcHVsYXRpb25zLycsIHBvcHVsYXRpb24sICcvdmFyaWFudHMnLFxuICAgICAgICAgICAgJz9jb3JyZWxhdGlvbj0nLCBtZXRob2QsXG4gICAgICAgICAgICAnJnZhcmlhbnQ9JywgZW5jb2RlVVJJQ29tcG9uZW50KHJlZlZhciksXG4gICAgICAgICAgICAnJmNocm9tPScsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS5jaHIpLFxuICAgICAgICAgICAgJyZzdGFydD0nLCBlbmNvZGVVUklDb21wb25lbnQoc3RhdGUuc3RhcnQpLFxuICAgICAgICAgICAgJyZzdG9wPScsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS5lbmQpLFxuICAgICAgICBdLmpvaW4oJycpO1xuICAgIH1cblxuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGxldCBrZXlzID0gdGhpcy5maW5kTWVyZ2VGaWVsZHMoY2hhaW4pO1xuICAgICAgICBsZXQgcmVxRmllbGRzID0gdGhpcy5maW5kUmVxdWVzdGVkRmllbGRzKGZpZWxkcywgb3V0bmFtZXMpO1xuICAgICAgICBpZiAoIWtleXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgcG9zaXRpb24gZmllbGQgZm9yIG1lcmdlOiAke2tleXMuX25hbWVzX31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0Sm9pbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGZpZWxkLCByZmllbGQpIHtcbiAgICAgICAgICAgIGxldCBpID0gMCwgaiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlZnQubGVuZ3RoICYmIGogPCByaWdodC5wb3NpdGlvbjIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRbaV1ba2V5cy5wb3NpdGlvbl0gPT09IHJpZ2h0LnBvc2l0aW9uMltqXSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0W2ldW2xmaWVsZF0gPSByaWdodFtyZmllbGRdW2pdO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnRbaV1ba2V5cy5wb3NpdGlvbl0gPCByaWdodC5wb3NpdGlvbjJbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRhZ1JlZlZhcmlhbnQgPSBmdW5jdGlvbiAoZGF0YSwgcmVmdmFyLCBpZGZpZWxkLCBvdXRyZWZuYW1lLCBvdXRsZG5hbWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldW2lkZmllbGRdICYmIGRhdGFbaV1baWRmaWVsZF0gPT09IHJlZnZhcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW291dHJlZm5hbWVdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtvdXRsZG5hbWVdID0gMTsgLy8gRm9yIGxhYmVsL2ZpbHRlciBwdXJwb3NlcywgaW1wbGljaXRseSBtYXJrIHRoZSByZWYgdmFyIGFzIExEPTEgdG8gaXRzZWxmXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtvdXRyZWZuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExEIHNlcnZlcnMgdmFyeSBzbGlnaHRseS4gU29tZSByZXBvcnQgY29yciBhcyBcInJzcXVhcmVcIiwgb3RoZXJzIGFzIFwiY29ycmVsYXRpb25cIlxuICAgICAgICBsZXQgY29yckZpZWxkID0gZGF0YS5yc3F1YXJlID8gJ3JzcXVhcmUnIDogJ2NvcnJlbGF0aW9uJztcbiAgICAgICAgbGVmdEpvaW4oY2hhaW4uYm9keSwgZGF0YSwgcmVxRmllbGRzLmxkb3V0LCBjb3JyRmllbGQpO1xuICAgICAgICBpZiAocmVxRmllbGRzLmlzcmVmdmFyaW4gJiYgY2hhaW4uaGVhZGVyLmxkcmVmdmFyKSB7XG4gICAgICAgICAgICB0YWdSZWZWYXJpYW50KGNoYWluLmJvZHksIGNoYWluLmhlYWRlci5sZHJlZnZhciwga2V5cy5pZCwgcmVxRmllbGRzLmlzcmVmdmFyb3V0LCByZXFGaWVsZHMubGRvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgIH1cblxuICAgIGZldGNoUmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAvLyBUaGUgQVBJIGlzIHBhZ2luYXRlZCwgYnV0IHdlIG5lZWQgYWxsIG9mIHRoZSBkYXRhIHRvIHJlbmRlciBhIHBsb3QuIERlcGFnaW5hdGUgYW5kIGNvbWJpbmUgd2hlcmUgYXBwcm9wcmlhdGUuXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLmdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgICAgIGxldCBjb21iaW5lZCA9IHsgZGF0YToge30gfTtcbiAgICAgICAgbGV0IGNoYWluUmVxdWVzdHMgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsKS50aGVuKCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBheWxvYWQuZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLmRhdGFba2V5XSA9IChjb21iaW5lZC5kYXRhW2tleV0gfHwgW10pLmNvbmNhdChwYXlsb2FkLmRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW5SZXF1ZXN0cyhwYXlsb2FkLm5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoYWluUmVxdWVzdHModXJsKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGF0YSBzb3VyY2UgZm9yIEdXQVMgY2F0YWxvZ3Mgb2Yga25vd24gdmFyaWFudHNcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbml0IENvbmZpZ3VyYXRpb24gKFVSTCBvciBvYmplY3QpXG4gKiBAcGFyYW0ge09iamVjdH0gW2luaXQucGFyYW1zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdC5wYXJhbXMuc291cmNlPTJdIFRoZSBJRCBvZiB0aGUgY2hvc2VuIGNhdGFsb2cuIERlZmF1bHRzIHRvIEVCSSBHV0FTIGNhdGFsb2csIEdSQ2gzN1xuICogQHBhcmFtIHsoJ3N0cmljdCd8J2xvb3NlJyl9IFtpbml0LnBhcmFtcy5tYXRjaF90eXBlPSdzdHJpY3QnXSBXaGV0aGVyIHRvIG1hdGNoIG9uIGV4YWN0IHZhcmlhbnQsIG9yIGp1c3QgcG9zaXRpb24uXG4gKi9cbmNsYXNzIEd3YXNDYXRhbG9nTFogZXh0ZW5kcyBCYXNlQXBpQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX19kZXBlbmRlbnRTb3VyY2UgPSB0cnVlO1xuICAgIH1cblxuICAgIGdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGFsaWduZWQgd2l0aCBhbm90aGVyIHNvdXJjZS0gd2Ugd2lsbCBhc3N1bWUgdGhleSBhcmUgYWx3YXlzIG9yZGVyZWQgYnkgcG9zaXRpb24sIGFzY1xuICAgICAgICAvLyAgKHJlZ2FyZGxlc3Mgb2YgdGhlIGFjdHVhbCBtYXRjaCBmaWVsZClcbiAgICAgICAgY29uc3QgYnVpbGRfb3B0aW9uID0gc3RhdGUuZ2Vub21lX2J1aWxkIHx8IHRoaXMucGFyYW1zLmJ1aWxkO1xuICAgICAgICB2YWxpZGF0ZUJ1aWxkU291cmNlKHRoaXMuY29uc3RydWN0b3IubmFtZSwgYnVpbGRfb3B0aW9uLCBudWxsKTsgLy8gU291cmNlIGNhbiBvdmVycmlkZSBidWlsZC0gbm90IG11dHVhbGx5IGV4Y2x1c2l2ZVxuXG4gICAgICAgIC8vIE1vc3Qgb2Ygb3VyIGFubm90YXRpb25zIHdpbGwgcmVzcGVjdCBnZW5vbWUgYnVpbGQgYmVmb3JlIGFueSBvdGhlciBvcHRpb24uXG4gICAgICAgIC8vICAgQnV0IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIEdXQVMgY2F0YWxvZyB2ZXJzaW9uIGF2YWlsYWJsZSBpbiB0aGUgc2FtZSBBUEksIGZvciB0aGUgc2FtZSBidWlsZC0gYW5cbiAgICAgICAgLy8gICBleHBsaWNpdCBjb25maWcgb3B0aW9uIHdpbGwgYWx3YXlzIHRha2VcbiAgICAgICAgLy8gICBwcmVjZWRlbmNlLlxuICAgICAgICAvLyBTZWU6IGh0dHA6Ly9wb3J0YWxkZXYuc3BoLnVtaWNoLmVkdS9hcGkvdjEvYW5ub3RhdGlvbi9nd2FzY2F0YWxvZy8/Zm9ybWF0PW9iamVjdHNcbiAgICAgICAgY29uc3QgZGVmYXVsdF9zb3VyY2UgPSAoYnVpbGRfb3B0aW9uID09PSAnR1JDaDM4JykgPyA1IDogNjsgIC8vIEVCSSBHV0FTIGNhdGFsb2dcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5wYXJhbXMuc291cmNlIHx8IGRlZmF1bHRfc291cmNlO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy51cmwgIH0/Zm9ybWF0PW9iamVjdHMmc29ydD1wb3MmZmlsdGVyPWlkIGVxICR7c291cmNlfSBhbmQgY2hyb20gZXEgJyR7c3RhdGUuY2hyfScgYW5kIHBvcyBnZSAke3N0YXRlLnN0YXJ0fSBhbmQgcG9zIGxlICR7c3RhdGUuZW5kfWA7XG4gICAgfVxuXG4gICAgZmluZE1lcmdlRmllbGRzKHJlY29yZHMpIHtcbiAgICAgICAgLy8gRGF0YSBmcm9tIHByZXZpb3VzIHNvdXJjZXMgaXMgYWxyZWFkeSBuYW1lc3BhY2VkLiBGaW5kIHRoZSBhbGlnbm1lbnQgZmllbGQgYnkgbWF0Y2hpbmcuXG4gICAgICAgIGNvbnN0IGtub3duRmllbGRzID0gT2JqZWN0LmtleXMocmVjb3Jkcyk7XG4gICAgICAgIC8vIE5vdGU6IEFsbCBBUEkgZW5kb2ludHMgaW52b2x2ZWQgb25seSBnaXZlIHJlc3VsdHMgZm9yIDEgY2hyb21vc29tZSBhdCBhIHRpbWU7IG1hdGNoIGlzIGltcGxpZWRcbiAgICAgICAgY29uc3QgcG9zTWF0Y2ggPSBrbm93bkZpZWxkcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5tYXRjaCgvXFxiKHBvc2l0aW9ufHBvcylcXGIvaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcG9zTWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgZGF0YSB0byBhbGlnbiB3aXRoIEdXQVMgY2F0YWxvZyByZXN1bHRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3Bvcyc6IHBvc01hdGNoIH07XG4gICAgfVxuXG4gICAgZXh0cmFjdEZpZWxkcyAoZGF0YSwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgLy8gU2tpcCB0aGUgXCJpbmRpdmlkdWFsIGZpZWxkIGV4dHJhY3Rpb25cIiBzdGVwOyBleHRyYWN0aW9uIHdpbGwgYmUgaGFuZGxlZCB3aGVuIGJ1aWxkaW5nIGNoYWluIGJvZHkgaW5zdGVhZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBjb21iaW5lQ2hhaW5Cb2R5KGRhdGEsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW4uYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBUT0RPOiBCZXR0ZXIgcmV1c2Ugb3B0aW9ucyBpbiB0aGUgZnV0dXJlLiBUaGlzIHNvdXJjZSBpcyB2ZXJ5IHNwZWNpZmljYWxseSB0aWVkIHRvIHRoZSBQb3J0YWxEZXYgQVBJLCB3aGVyZVxuICAgICAgICAvLyAgIHRoZSBmaWVsZCBuYW1lIGlzIGFsd2F5cyBcImxvZ19wdmFsdWVcIi4gUmVsYXRpdmVseSBmZXcgc2l0ZXMgd2lsbCB3cml0ZSB0aGVpciBvd24gZ3dhcy1jYXRhbG9nIGVuZHBvaW50LlxuICAgICAgICBjb25zdCBkZWNpZGVyID0gJ2xvZ19wdmFsdWUnO1xuICAgICAgICBjb25zdCBkZWNpZGVyX291dCA9IG91dG5hbWVzW2ZpZWxkcy5pbmRleE9mKGRlY2lkZXIpXTtcblxuICAgICAgICBmdW5jdGlvbiBsZWZ0Sm9pbihsZWZ0LCByaWdodCwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHsgLy8gQWRkIGBmaWVsZHNgIGZyb20gYHJpZ2h0YCB0byBgbGVmdGBcbiAgICAgICAgICAgIC8vIEFkZCBhIHN5bnRoZXRpYywgdW4tbmFtZXNwYWNlZCBmaWVsZCB0byBhbGwgbWF0Y2hpbmcgcmVjb3Jkc1xuICAgICAgICAgICAgY29uc3Qgbl9tYXRjaGVzID0gbGVmdFsnbl9jYXRhbG9nX21hdGNoZXMnXSB8fCAwO1xuICAgICAgICAgICAgbGVmdFsnbl9jYXRhbG9nX21hdGNoZXMnXSA9IG5fbWF0Y2hlcyArIDE7XG4gICAgICAgICAgICBpZiAoZGVjaWRlciAmJiBsZWZ0W2RlY2lkZXJfb3V0XSAmJiBsZWZ0W2RlY2lkZXJfb3V0XSA+IHJpZ2h0W2RlY2lkZXJdKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgR1dBUyBjYXRhbG9nIGVudHJ5IGZvciB0aGUgc2FtZSBTTlAuIFRoaXMgc291cmNlIGlzIGludGVuZGVkIGZvciBhIDE6MVxuICAgICAgICAgICAgICAgIC8vICBhbm5vdGF0aW9uIHNjZW5hcmlvLCBzbyBmb3Igbm93IGl0IG9ubHkgam9pbnMgdGhlIGNhdGFsb2cgZW50cnkgdGhhdCBoYXMgdGhlIGJlc3QgLWxvZzEwIHB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRuID0gb3V0bmFtZXNbal07XG5cbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gcmlnaHRbZm5dO1xuICAgICAgICAgICAgICAgIGlmICh0cmFucyAmJiB0cmFuc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB0cmFuc1tqXSh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0W291dG5dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hhaW5OYW1lcyA9IHRoaXMuZmluZE1lcmdlRmllbGRzKGNoYWluLmJvZHlbMF0pO1xuICAgICAgICBjb25zdCBjYXROYW1lcyA9IHRoaXMuZmluZE1lcmdlRmllbGRzKGRhdGFbMF0pO1xuXG4gICAgICAgIHZhciBpID0gMCwgaiA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY2hhaW4uYm9keS5sZW5ndGggJiYgaiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGNoYWluLmJvZHlbaV07XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBkYXRhW2pdO1xuXG4gICAgICAgICAgICBpZiAobGVmdFtjaGFpbk5hbWVzLnBvc10gPT09IHJpZ2h0W2NhdE5hbWVzLnBvc10pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgbXVsdGlwbGUgY2F0YWxvZyBlbnRyaWVzIGZvciBlYWNoIG1hdGNoaW5nIFNOUDsgZXZhbHVhdGUgbWF0Y2ggb25lIGF0IGEgdGltZVxuICAgICAgICAgICAgICAgIGxlZnRKb2luKGxlZnQsIHJpZ2h0LCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0W2NoYWluTmFtZXMucG9zXSA8IHJpZ2h0W2NhdE5hbWVzLnBvc10pIHtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhaW4uYm9keTtcbiAgICB9XG59XG5cbi8qKlxuICogRGF0YSBTb3VyY2UgZm9yIEdlbmUgRGF0YSwgYXMgZmV0Y2hlZCBmcm9tIHRoZSBMb2N1c1pvb20vUG9ydGFsZGV2IEFQSSBzZXJ2ZXIgKG9yIGNvbXBhdGlibGUgZm9ybWF0KVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHZW5lTFogZXh0ZW5kcyBCYXNlQXBpQWRhcHRlciB7XG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkID0gc3RhdGUuZ2Vub21lX2J1aWxkIHx8IHRoaXMucGFyYW1zLmJ1aWxkO1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5wYXJhbXMuc291cmNlO1xuICAgICAgICB2YWxpZGF0ZUJ1aWxkU291cmNlKHRoaXMuY29uc3RydWN0b3IubmFtZSwgYnVpbGQsIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKGJ1aWxkKSB7XG4gICAgICAgICAgICAvLyBJZiBidWlsZCBzcGVjaWZpZWQsIHdlIGF1dG8tc2VsZWN0IHRoZSBiZXN0IGN1cnJlbnQgcG9ydGFsZGV2IEFQSSBkYXRhc2V0IGZvciB0aGF0IGJ1aWxkXG4gICAgICAgICAgICAvLyBJZiBidWlsZCBpcyBub3Qgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGV4YWN0IHNvdXJjZSBJRCBwcm92aWRlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9wb3J0YWxkZXYuc3BoLnVtaWNoLmVkdS9hcGkvdjEvYW5ub3RhdGlvbi9nZW5lcy9zb3VyY2VzLz9mb3JtYXQ9b2JqZWN0c1xuICAgICAgICAgICAgc291cmNlID0gKGJ1aWxkID09PSAnR1JDaDM4JykgPyA0IDogNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy51cmx9P2ZpbHRlcj1zb3VyY2UgaW4gJHtzb3VyY2V9IGFuZCBjaHJvbSBlcSAnJHtzdGF0ZS5jaHJ9JyBhbmQgc3RhcnQgbGUgJHtzdGF0ZS5lbmR9IGFuZCBlbmQgZ2UgJHtzdGF0ZS5zdGFydH1gO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgLy8gR2VuZXMgaGF2ZSBhIHZlcnkgY29tcGxleCBpbnRlcm5hbCBkYXRhIGZvcm1hdC4gQnlwYXNzIGFueSByZWNvcmQgcGFyc2luZywgYW5kIHByb3ZpZGUgdGhlIGRhdGEgbGF5ZXIgd2l0aFxuICAgICAgICAvLyB0aGUgZXhhY3QgaW5mb3JtYXRpb24gcmV0dXJuZWQgYnkgdGhlIEFQSS4gKGlnbm9yaW5nIHRoZSBmaWVsZHMgYXJyYXkgaW4gdGhlIGxheW91dClcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZXh0cmFjdEZpZWxkcyhkYXRhLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbi8qKlxuICogRGF0YSBTb3VyY2UgZm9yIEdlbmUgQ29uc3RyYWludCBEYXRhLCBhcyBmZXRjaGVkIGZyb20gdGhlIGdub21BRCBzZXJ2ZXIgKG9yIGNvbXBhdGlibGUpXG4gKlxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSB0aGUgc2Vjb25kIHJlcXVlc3QgaW4gYSBjaGFpbiwgd2l0aCBzcGVjaWFsIGxvZ2ljIHRoYXQgY29ubmVjdHMgaXQgdG8gR2VuZXMgZGF0YVxuICogIGFscmVhZHkgZmV0Y2hlZC5cbiAqXG4gKiBAcHVibGljXG4qL1xuY2xhc3MgR2VuZUNvbnN0cmFpbnRMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fX2RlcGVuZGVudFNvdXJjZSA9IHRydWU7XG4gICAgfVxuICAgIGdldFVSTCgpIHtcbiAgICAgICAgLy8gR3JhcGhRTCBBUEk6IHJlcXVlc3QgZGV0YWlscyBhcmUgZW5jb2RlZCBpbiB0aGUgYm9keSwgbm90IHRoZSBVUkxcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cbiAgICBnZXRDYWNoZUtleShzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCBidWlsZCA9IHN0YXRlLmdlbm9tZV9idWlsZCB8fCB0aGlzLnBhcmFtcy5idWlsZDtcbiAgICAgICAgLy8gR3JhcGhRTCBBUEk6IHJlcXVlc3Qgbm90IGRlZmluZWQgc29sZWx5IGJ5IHRoZSBVUkxcbiAgICAgICAgLy8gR2F0aGVyIHRoZSBzdGF0ZSBwYXJhbXMgdGhhdCBnb3Zlcm4gY29uc3RyYWludCBxdWVyeSBmb3IgYSBnaXZlbiByZWdpb24uXG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybH0gJHtzdGF0ZS5jaHJ9ICR7c3RhdGUuc3RhcnR9ICR7c3RhdGUuZW5kfSAke2J1aWxkfWA7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmZXRjaFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYnVpbGQgPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIGlmICghYnVpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBzb3VyY2UgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IG11c3Qgc3BlY2lmeSBhICdnZW5vbWVfYnVpbGQnIG9wdGlvbmApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pcXVlX2dlbmVfbmFtZXMgPSBjaGFpbi5ib2R5LnJlZHVjZShcbiAgICAgICAgICAgIC8vIEluIHJhcmUgY2FzZXMsIHRoZSBzYW1lIGdlbmUgc3ltYm9sIG1heSBhcHBlYXIgYXQgbXVsdGlwbGUgcG9zaXRpb25zLiAoaXNzdWUgIzE3OSkgV2UgZGUtZHVwbGljYXRlIHRoZVxuICAgICAgICAgICAgLy8gIGdlbmUgbmFtZXMgdG8gYXZvaWQgaXNzdWluZyBhIG1hbGZvcm1lZCBHcmFwaFFMIHF1ZXJ5LlxuICAgICAgICAgICAgZnVuY3Rpb24gKGFjYywgZ2VuZSkge1xuICAgICAgICAgICAgICAgIGFjY1tnZW5lLmdlbmVfbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gT2JqZWN0LmtleXModW5pcXVlX2dlbmVfbmFtZXMpLm1hcChmdW5jdGlvbiAoZ2VuZV9uYW1lKSB7XG4gICAgICAgICAgICAvLyBHcmFwaFFMIGFsaWFzIG5hbWVzIG11c3QgbWF0Y2ggYSBzcGVjaWZpYyBzZXQgb2YgYWxsb3dlZCBjaGFyYWN0ZXJzOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDU3NTcwNjUvMTQyMjI2OFxuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBgXyR7Z2VuZV9uYW1lLnJlcGxhY2UoL1teQS1aYS16MC05X10vZywgJ18nKX1gO1xuICAgICAgICAgICAgLy8gRWFjaCBnZW5lIHN5bWJvbCBpcyBhIHNlcGFyYXRlIGdyYXBoUUwgcXVlcnksIGdyb3VwZWQgaW50byBvbmUgcmVxdWVzdCB1c2luZyBhbGlhc2VzXG4gICAgICAgICAgICByZXR1cm4gYCR7YWxpYXN9OiBnZW5lKGdlbmVfc3ltYm9sOiBcIiR7Z2VuZV9uYW1lfVwiLCByZWZlcmVuY2VfZ2Vub21lOiAke2J1aWxkfSkgeyBnbm9tYWRfY29uc3RyYWludCB7IGV4cF9zeW4gb2JzX3N5biBzeW5feiBvZV9zeW4gb2Vfc3luX2xvd2VyIG9lX3N5bl91cHBlciBleHBfbWlzIG9ic19taXMgbWlzX3ogb2VfbWlzIG9lX21pc19sb3dlciBvZV9taXNfdXBwZXIgZXhwX2xvZiBvYnNfbG9mIHBMSSBvZV9sb2Ygb2VfbG9mX2xvd2VyIG9lX2xvZl91cHBlciB9IH0gYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBnZW5lcywgc2tpcCB0aGUgbmV0d29yayByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogbnVsbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXJ5ID0gYHske3F1ZXJ5LmpvaW4oJyAnKX0gfWA7IC8vIEdyYXBoUUwgaXNuJ3QgcXVpdGUgSlNPTjsgaXRlbXMgYXJlIHNlcGFyYXRlZCBieSBzcGFjZXMgYnV0IG5vdCBjb21tYXNcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5nZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ3JhcGhxbC5vcmcvbGVhcm4vc2VydmluZy1vdmVyLWh0dHAvXG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7IHF1ZXJ5OiBxdWVyeSB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuXG4gICAgICAgIC8vIEZJWE1FOiBUaGUgZ25vbUFEIEFQSSBzb21ldGltZXMgaGFzIHRlbXBvcmFyeSBDT1JTIGNoYW5nZXMgdGhhdCB0ZW1wb3JhcmlseSBicmVhayB0aGUgZ2VuZXMgdHJhY2tcbiAgICAgICAgLy8gSWYgcmVxdWVzdCBibG9ja2VkLCByZXR1cm4gIGEgZmFrZSBcIm5vIGRhdGFcIiBzaWduYWwgc28gdGhlIGdlbmVzIHRyYWNrIGNhbiBzdGlsbCByZW5kZXIgdy9vIGNvbnN0cmFpbnQgaW5mb1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5LCBoZWFkZXJzIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4gW10pO1xuICAgIH1cblxuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhaW4uYm9keS5mb3JFYWNoKGZ1bmN0aW9uKGdlbmUpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgcGF5bG9hZCBrZXlzIHRoYXQgbWF0Y2ggZ2VuZSBuYW1lcyBpbiB0aGlzIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IGBfJHtnZW5lLmdlbmVfbmFtZS5yZXBsYWNlKC9bXkEtWmEtejAtOV9dL2csICdfJyl9YDsgIC8vIGFsaWFzZXMgYXJlIG1vZGlmaWVkIGdlbmUgbmFtZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBkYXRhW2FsaWFzXSAmJiBkYXRhW2FsaWFzXVsnZ25vbWFkX2NvbnN0cmFpbnQnXTsgLy8gZ25vbWFkIEFQSSBoYXMgdHdvIHdheXMgb2Ygc3BlY2lmeWluZyBtaXNzaW5nIGRhdGEgZm9yIGEgcmVxdWVzdGVkIGdlbmVcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFsbCBmaWVsZHMgZnJvbSBjb25zdHJhaW50IGRhdGEtIGRvIG5vdCBvdmVycmlkZSBmaWVsZHMgcHJlc2VudCBpbiB0aGUgZ2VuZSBzb3VyY2VcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb25zdHJhaW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGNvbnN0cmFpbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSAnbnVtYmVyJyAmJiB2YWwudG9TdHJpbmcoKS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwudG9GaXhlZCgyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lW2tleV0gPSB2YWw7ICAgLy8gVGhlc2UgdHdvIHNvdXJjZXMgYXJlIGJvdGggZGVzaWduZWQgdG8gYnlwYXNzIG5hbWVzcGFjaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgUmVjb21iaW5hdGlvbiBSYXRlIERhdGEsIGFzIGZldGNoZWQgZnJvbSB0aGUgTG9jdXNab29tIEFQSSBzZXJ2ZXIgKG9yIGNvbXBhdGlibGUpXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFJlY29tYkxaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIGdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCBidWlsZCA9IHN0YXRlLmdlbm9tZV9idWlsZCB8fCB0aGlzLnBhcmFtcy5idWlsZDtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMucGFyYW1zLnNvdXJjZTtcbiAgICAgICAgdmFsaWRhdGVCdWlsZFNvdXJjZSh0aGlzLmNvbnN0cnVjdG9yLlNPVVJDRV9OQU1FLCBidWlsZCwgc291cmNlKTtcblxuICAgICAgICBpZiAoYnVpbGQpIHsgLy8gSWYgYnVpbGQgc3BlY2lmaWVkLCBjaG9vc2UgYSBrbm93biBQb3J0YWwgQVBJIGRhdGFzZXQgSURzIChidWlsZCAzNy8zOClcbiAgICAgICAgICAgIHNvdXJjZSA9IChidWlsZCA9PT0gJ0dSQ2gzOCcpID8gMTYgOiAxNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy51cmx9P2ZpbHRlcj1pZCBpbiAke3NvdXJjZX0gYW5kIGNocm9tb3NvbWUgZXEgJyR7c3RhdGUuY2hyfScgYW5kIHBvc2l0aW9uIGxlICR7c3RhdGUuZW5kfSBhbmQgcG9zaXRpb24gZ2UgJHtzdGF0ZS5zdGFydH1gO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3Igc3RhdGljIGJsb2JzIG9mIGRhdGEgYXMgcmF3IEpTIG9iamVjdHMuIFRoaXMgZG9lcyBub3QgcGVyZm9ybSBhZGRpdGlvbmFsIHBhcnNpbmcsIGFuZCBpdCBieXBhc3Nlc1xuICogbmFtZXNwYWNlcy4gVGhlcmVmb3JlIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlciB0byBwYXNzIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHJlYWQgYW5kXG4gKiB1bmRlcnN0b29kIGJ5IHRoZSBjaG9zZW4gcGxvdC0gYSBTdGF0aWNKU09OIHNvdXJjZSBpcyByYXJlbHkgYSBkcm9wLWluIHJlcGxhY2VtZW50LlxuICpcbiAqIFRoaXMgc291cmNlIGlzIGxhcmdlbHkgaGVyZSBmb3IgbGVnYWN5IHJlYXNvbnMuIE1vcmUgb2Z0ZW4sIGEgY29udmVuaWVudCB3YXkgdG8gc2VydmUgc3RhdGljIGRhdGEgaXMgYXMgc2VwYXJhdGVcbiAqICBKU09OIGZpbGVzIHRvIGFuIGV4aXN0aW5nIHNvdXJjZSAod2l0aCB0aGUgSlNPTiB1cmwgaW4gcGxhY2Ugb2YgYW4gQVBJKS5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU3RhdGljU291cmNlIGV4dGVuZHMgQmFzZUFkYXB0ZXIge1xuICAgIHBhcnNlSW5pdChkYXRhKSB7XG4gICAgICAgIC8vIERvZXMgbm90IHJlY2VpdmUgYW55IGNvbmZpZzsgdGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHJhdyBkYXRhLCBlbWJlZGRlZCB3aGVuIHNvdXJjZSBpcyBjcmVhdGVkXG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZGF0YSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogRGF0YSBzb3VyY2UgZm9yIFBoZVdBUyBkYXRhIHJldHJpZXZlZCBmcm9tIGEgTG9jdXNab29tL1BvcnRhbERldiBjb21wYXRpYmxlIEFQSVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmdbXX0gaW5pdC5wYXJhbXMuYnVpbGQgVGhpcyBkYXRhc291cmNlIGV4cGVjdHMgdG8gYmUgcHJvdmlkZWQgdGhlIG5hbWUgb2YgdGhlIGdlbm9tZSBidWlsZCB0aGF0IHdpbGxcbiAqICAgYmUgdXNlZCB0byBwcm92aWRlIHBoZVdBUyByZXN1bHRzIGZvciB0aGlzIHBvc2l0aW9uLiBOb3RlIHBvc2l0aW9ucyBtYXkgbm90IHRyYW5zbGF0ZSBiZXR3ZWVuIGJ1aWxkcy5cbiAqL1xuY2xhc3MgUGhlV0FTTFogZXh0ZW5kcyBCYXNlQXBpQWRhcHRlciB7XG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkID0gKHN0YXRlLmdlbm9tZV9idWlsZCA/IFtzdGF0ZS5nZW5vbWVfYnVpbGRdIDogbnVsbCkgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIGlmICghYnVpbGQgfHwgIUFycmF5LmlzQXJyYXkoYnVpbGQpIHx8ICFidWlsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihbJ0RhdGEgc291cmNlJywgdGhpcy5jb25zdHJ1Y3Rvci5TT1VSQ0VfTkFNRSwgJ3JlcXVpcmVzIHRoYXQgeW91IHNwZWNpZnkgYXJyYXkgb2Ygb25lIG9yIG1vcmUgZGVzaXJlZCBnZW5vbWUgYnVpbGQgbmFtZXMnXS5qb2luKCcgJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IFtcbiAgICAgICAgICAgIHRoaXMudXJsLFxuICAgICAgICAgICAgXCI/ZmlsdGVyPXZhcmlhbnQgZXEgJ1wiLCBlbmNvZGVVUklDb21wb25lbnQoc3RhdGUudmFyaWFudCksIFwiJyZmb3JtYXQ9b2JqZWN0cyZcIixcbiAgICAgICAgICAgIGJ1aWxkLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgYnVpbGQ9JHtlbmNvZGVVUklDb21wb25lbnQoaXRlbSl9YDtcbiAgICAgICAgICAgIH0pLmpvaW4oJyYnKSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHVybC5qb2luKCcnKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBcImNvbm5lY3RvcnNcIi0gdGhpcyBpcyBtZWFudCB0byBiZSBzdWJjbGFzc2VkLCByYXRoZXIgdGhhbiB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEEgY29ubmVjdG9yIGlzIGEgc291cmNlIHRoYXQgbWFrZXMgbm8gc2VydmVyIHJlcXVlc3RzIGFuZCBjYWNoZXMgbm8gZGF0YSBvZiBpdHMgb3duLiBJbnN0ZWFkLCBpdCBkZWNpZGVzIGhvdyB0b1xuICogIGNvbWJpbmUgZGF0YSBmcm9tIG90aGVyIHNvdXJjZXMgaW4gdGhlIGNoYWluLiBDb25uZWN0b3JzIGFyZSB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvIHJlcXVlc3QgKG9yIGNhbGN1bGF0ZSkgc29tZVxuICogIHVzZWZ1bCBwaWVjZSBvZiBpbmZvcm1hdGlvbiBvbmNlLCBidXQgYXBwbHkgaXQgdG8gbWFueSBkaWZmZXJlbnQga2luZHMgb2YgcmVjb3JkIHR5cGVzLlxuICpcbiAqIFR5cGljYWxseSwgYSBzdWJjbGFzcyB3aWxsIGltcGxlbWVudCB0aGUgZmllbGQgbWVyZ2luZyBsb2dpYyBpbiBgY29tYmluZUNoYWluQm9keWAuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IGluaXQgQ29uZmlndXJhdGlvbiBmb3IgdGhpcyBzb3VyY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbml0LnNvdXJjZXMgU3BlY2lmeSBob3cgdGhlIGhhcmQtY29kZWQgbG9naWMgc2hvdWxkIGZpbmQgdGhlIGRhdGEgaXQgcmVsaWVzIG9uIGluIHRoZSBjaGFpbixcbiAqICBhcyB7aW50ZXJuYWxfbmFtZTogY2hhaW5fc291cmNlX2lkfSBwYWlycy4gVGhpcyBhbGxvd3Mgd3JpdGluZyBhIHJldXNhYmxlIGNvbm5lY3RvciB0aGF0IGRvZXMgbm90IG5lZWQgdG8gbWFrZVxuICogIGFzc3VtcHRpb25zIGFib3V0IHdoYXQgbmFtZXNwYWNlcyBhIHNvdXJjZSBpcyB1c2luZy5cbiAqIEB0eXBlIHsqfEZ1bmN0aW9ufVxuICovXG5jbGFzcyBDb25uZWN0b3JTb3VyY2UgZXh0ZW5kcyBCYXNlQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5zb3VyY2VzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3RvcnMgbXVzdCBzcGVjaWZ5IHRoZSBkYXRhIHRoZXkgcmVxdWlyZSBhcyBpbml0LnNvdXJjZXMgPSB7aW50ZXJuYWxfbmFtZTogY2hhaW5fc291cmNlX2lkfX0gcGFpcnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZWxscyB0aGUgY29ubmVjdG9yIGhvdyB0byBmaW5kIHRoZSBkYXRhIGl0IHJlbGllcyBvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgYSBjb25uZWN0b3IgdGhhdCBhcHBsaWVzIGJ1cmRlbiB0ZXN0IGluZm9ybWF0aW9uIHRvIHRoZSBnZW5lcyBsYXllciBtaWdodCBzcGVjaWZ5OlxuICAgICAgICAgKiAge2dlbmVfbnM6IFwiZ2VuZVwiLCBhZ2dyZWdhdGlvbl9uczogXCJhZ2dyZWdhdGlvblwifVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zb3VyY2VfbmFtZV9tYXBwaW5nID0gY29uZmlnLnNvdXJjZXM7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGlzIHNvdXJjZSBoYXMgYmVlbiB0b2xkIGhvdyB0byBmaW5kIHRoZSByZXF1aXJlZCBpbmZvcm1hdGlvblxuICAgICAgICBjb25zdCBzcGVjaWZpZWRfaWRzID0gT2JqZWN0LmtleXMoY29uZmlnLnNvdXJjZXMpO1xuICAgICAgICAvKiogQHByb3BlcnR5IHtTdHJpbmdbXX0gU3BlY2lmaWVzIHRoZSBzb3VyY2VzIHRoYXQgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGUgb3JpZ2luYWwgY29uZmlnIG9iamVjdCAqL1xuXG4gICAgICAgIHRoaXMuX2dldFJlcXVpcmVkU291cmNlcygpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGlmICghc3BlY2lmaWVkX2lkcy5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpeCBjb25zdHJ1Y3Rvci5uYW1lIHVzYWdlIGluIG1pbmlmaWVkIGJ1bmRsZXNcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbmZpZ3VyYXRpb24gZm9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBtdXN0IHNwZWNpZnkgYSBzb3VyY2UgSUQgY29ycmVzcG9uZGluZyB0byAke2t9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN0dWItIGNvbm5lY3RvcnMgZG9uJ3QgaGF2ZSB0aGVpciBvd24gdXJsIG9yIGRhdGEsIHNvIHRoZSBkZWZhdWx0cyBkb24ndCBtYWtlIHNlbnNlXG4gICAgcGFyc2VJbml0KCkge31cblxuICAgIGdldFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgLy8gQ29ubmVjdG9ycyBkbyBub3QgcmVxdWVzdCB0aGVpciBvd24gZGF0YSBieSBkZWZpbml0aW9uLCBidXQgdGhleSAqZG8qIGRlcGVuZCBvbiBvdGhlciBzb3VyY2VzIGhhdmluZyBiZWVuIGxvYWRlZFxuICAgICAgICAvLyAgZmlyc3QuIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGJhc2ljIHZhbGlkYXRpb24sIGFuZCBwcmVzZXJ2ZXMgdGhlIGFjY3VtdWxhdGVkIGJvZHkgZnJvbSB0aGUgY2hhaW4gc28gZmFyLlxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VfbmFtZV9tYXBwaW5nKS5mb3JFYWNoKChucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5fc291cmNlX2lkID0gdGhpcy5fc291cmNlX25hbWVfbWFwcGluZ1tuc107XG4gICAgICAgICAgICBpZiAoY2hhaW4uZGlzY3JldGUgJiYgIWNoYWluLmRpc2NyZXRlW2NoYWluX3NvdXJjZV9pZF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBjYW5ub3QgYmUgdXNlZCBiZWZvcmUgbG9hZGluZyByZXF1aXJlZCBkYXRhIGZvcjogJHtjaGFpbl9zb3VyY2VfaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoYWluLmJvZHkgfHwgW10pO1xuICAgIH1cblxuICAgIHBhcnNlUmVzcG9uc2UoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIC8vIEEgY29ubmVjdG9yIHNvdXJjZSBkb2VzIG5vdCB1cGRhdGUgY2hhaW4uZGlzY3JldGUsIGJ1dCBpdCBtYXkgdXNlIGl0LiBJdCBieXBhc3NlcyBkYXRhIGZvcm1hdHRpbmdcbiAgICAgICAgLy8gIGFuZCBmaWVsZCBzZWxlY3Rpb24gKGJvdGggYXJlIGFzc3VtZWQgdG8gaGF2ZSBiZWVuIGRvbmUgYWxyZWFkeSwgYnkgdGhlIHByZXZpb3VzIHNvdXJjZXMgdGhpcyBkcmF3cyBmcm9tKVxuXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgaG93IHRoZSBjaGFpbiB3b3JrcywgY29ubmVjdG9ycyBhcmUgbm90IHZlcnkgZ29vZCBhdCBhcHBseWluZyBuZXcgdHJhbnNmb3JtYXRpb25zIG9yIG5hbWVzcGFjaW5nLlxuICAgICAgICAvLyBUeXBpY2FsbHkgY29ubmVjdG9ycyBhcmUgY2FsbGVkIHdpdGggYGNvbm5lY3Rvcl9uYW1lOmFsbGAgaW4gdGhlIGZpZWxkcyBhcnJheS5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKG5ld19ib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtoZWFkZXI6IGNoYWluLmhlYWRlciB8fCB7fSwgZGlzY3JldGU6IGNoYWluLmRpc2NyZXRlIHx8IHt9LCBib2R5OiBuZXdfYm9keX07XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21iaW5lQ2hhaW5Cb2R5KHJlY29yZHMsIGNoYWluKSB7XG4gICAgICAgIC8vIFN0dWIgbWV0aG9kOiBzcGVjaWZpZXMgaG93IHRvIGNvbWJpbmUgdGhlIGRhdGFcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgc3ViY2xhc3MnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHNpbmNlIEVTNiBkb2Vzbid0IHN1cHBvcnQgY2xhc3MgZmllbGRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UmVxdWlyZWRTb3VyY2VzKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhbiBhcnJheSB0aGF0IGlkZW50aWZlcyB0aGUga2luZCBvZiBkYXRhIHJlcXVpcmVkIGJ5IHRoaXMgc291cmNlJyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNlQWRhcHRlciwgQmFzZUFwaUFkYXB0ZXIgfTtcblxuZXhwb3J0IHtcbiAgICBBc3NvY2lhdGlvbkxaLFxuICAgIENvbm5lY3RvclNvdXJjZSxcbiAgICBHZW5lQ29uc3RyYWludExaLFxuICAgIEdlbmVMWixcbiAgICBHd2FzQ2F0YWxvZ0xaLFxuICAgIExEU2VydmVyLFxuICAgIFBoZVdBU0xaLFxuICAgIFJlY29tYkxaLFxuICAgIFN0YXRpY1NvdXJjZSxcbn07XG4iLCIvKiogQG1vZHVsZSAqL1xuaW1wb3J0IHRyYW5zZm9ybXMgZnJvbSAnLi4vcmVnaXN0cnkvdHJhbnNmb3Jtcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhZGRyZXNzYWJsZSB1bml0IG9mIGRhdGEgZnJvbSBhIG5hbWVzcGFjZWQgZGF0YXNvdXJjZSwgc3ViamVjdCB0byBzcGVjaWZpZWQgdmFsdWUgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIFdoZW4gdXNlZCBieSBhIGRhdGEgbGF5ZXIsIGZpZWxkcyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcmUtZmV0Y2hlZCBmcm9tIHRoZSBhcHByb3ByaWF0ZSBkYXRhIHNvdXJjZSB3aGVuZXZlciB0aGVcbiAqICAgc3RhdGUgb2YgYSBwbG90IGZldGNoZXMsIGVnIHBhbiBvciB6b29tIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBhZmZlY3Qgd2hhdCBkYXRhIGlzIGRpc3BsYXllZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGQgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIGRhdGFzb3VyY2UsIHRoZSBuYW1lIG9mIHRoZSBkZXNpcmVkIGZpZWxkIHRvIGZldGNoXG4gKiAgIGZyb20gdGhhdCBkYXRhc291cmNlLCBhbmQgYXJiaXRyYXJpbHkgbWFueSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZhbHVlLiBUaGUgbmFtZXNwYWNlIGFuZFxuICogICB0cmFuc2Zvcm1hdGlvbihzKSBhcmUgb3B0aW9uYWwgYW5kIGluZm9ybWF0aW9uIGlzIGRlbGltaXRlZCBhY2NvcmRpbmcgdG8gdGhlIGdlbmVyYWwgc3ludGF4XG4gKiAgIGBbbmFtZXNwYWNlOl1uYW1lW3x0cmFuc2Zvcm1hdGlvbl1bfHRyYW5zZm9ybWF0aW9uXWAuIEZvciBleGFtcGxlLCBgYXNzb2NpYXRpb246cHZhbHVlfG5lZ2xvZzEwYFxuICovXG5jbGFzcyBGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoZmllbGQpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSAvXig/OihbXjpdKyk6KT8oW146fF0qKShcXHwuKykqJC8uZXhlYyhmaWVsZCk7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtTdHJpbmd9ICovXG4gICAgICAgIHRoaXMuZnVsbF9uYW1lID0gZmllbGQ7XG4gICAgICAgIC8qKiBAbWVtYmVyIHtTdHJpbmd9ICovXG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gcGFydHNbMV0gfHwgbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge1N0cmluZ30gKi9cbiAgICAgICAgdGhpcy5uYW1lID0gcGFydHNbMl0gfHwgbnVsbDtcbiAgICAgICAgLyoqIEBtZW1iZXIge0FycmF5fSAqL1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGFydHNbM10gPT0gJ3N0cmluZycgJiYgcGFydHNbM10ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbnMgPSBwYXJ0c1szXS5zdWJzdHJpbmcoMSkuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zLmZvckVhY2goKHRyYW5zZm9ybSwgaSkgPT4gdGhpcy50cmFuc2Zvcm1hdGlvbnNbaV0gPSB0cmFuc2Zvcm1zLmdldCh0cmFuc2Zvcm0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseVRyYW5zZm9ybWF0aW9ucyh2YWwpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhbCA9IHRyYW5zZm9ybSh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHRoZSBmaWVsZCBmb3IgYSBnaXZlbiBkYXRhIGVsZW1lbnQuXG4gICAgICogICBGaXJzdCBsb29rIGZvciBhIGZ1bGwgbWF0Y2ggd2l0aCB0cmFuc2Zvcm1hdGlvbnMgYWxyZWFkeSBhcHBsaWVkIGJ5IHRoZSBkYXRhIHJlcXVlc3Rlci5cbiAgICAgKiAgIE90aGVyd2lzZSBwcmVmZXIgYSBuYW1lc3BhY2UgbWF0Y2ggYW5kIGZhbGwgYmFjayB0byBqdXN0IGEgbmFtZSBtYXRjaCwgYXBwbHlpbmcgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBmbHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUmV0dXJuZWQgZGF0YS9maWVsZHMgaW50byBmb3IgdGhpcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYV0gVXNlci1hcHBsaWVkIGFubm90YXRpb25zIGZvciB0aGlzIHBvaW50IChpbmZvIG5vdCBwcm92aWRlZCBieSB0aGUgc2VydmVyIHRoYXQgd2Ugd2FudFxuICAgICAqICB0byBwcmVzZXJ2ZSBhY3Jvc3MgcmUtcmVuZGVycykuIEV4YW1wbGUgdXNhZ2U6IFwic2hvdWxkX3Nob3dfbGFiZWxcIlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHJlc29sdmUoZGF0YSwgZXh0cmEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW3RoaXMuZnVsbF9uYW1lXSA9PSAndW5kZWZpbmVkJykgeyAvLyBDaGVjayBmb3IgY2FjaGVkIHJlc3VsdFxuICAgICAgICAgICAgbGV0IHZhbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChkYXRhW2Ake3RoaXMubmFtZXNwYWNlfToke3RoaXMubmFtZX1gXSkgIT0gJ3VuZGVmaW5lZCcpIHsgLy8gRmFsbGJhY2s6IHZhbHVlIHNhbnMgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFbYCR7dGhpcy5uYW1lc3BhY2V9OiR7dGhpcy5uYW1lfWBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVt0aGlzLm5hbWVdICE9ICd1bmRlZmluZWQnKSB7IC8vIEZhbGxiYWNrOiB2YWx1ZSBwcmVzZW50IHdpdGhvdXQgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYSAmJiB0eXBlb2YgZXh0cmFbdGhpcy5mdWxsX25hbWVdICE9ICd1bmRlZmluZWQnKSB7IC8vIEZhbGxiYWNrOiBjaGVjayBhbm5vdGF0aW9uc1xuICAgICAgICAgICAgICAgIHZhbCA9IGV4dHJhW3RoaXMuZnVsbF9uYW1lXTtcbiAgICAgICAgICAgIH0gLy8gV2Ugc2hvdWxkIHJlYWxseSB3YXJuIGlmIG5vIHZhbHVlIGZvdW5kLCBidXQgbWFueSBiYWQgbGF5b3V0cyBleGlzdCBhbmQgdGhpcyBjb3VsZCBicmVhayBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBkYXRhW3RoaXMuZnVsbF9uYW1lXSA9IHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25zKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFbdGhpcy5mdWxsX25hbWVdO1xuICAgIH1cbn1cblxuZXhwb3J0IHtGaWVsZCBhcyBkZWZhdWx0fTtcbiIsIi8qKlxuICogRGF0YSBtZXRob2RzIGFuZCBpbnN0YW5jZXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBwdWJsaWNseSBieSB0aGlyZC1wYXJ0eSB1c2Vyc1xuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vc291cmNlcyc7XG5leHBvcnQgeyBCYXNlQWRhcHRlciwgQmFzZUFwaUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzJztcbiIsIi8qKlxuICogIEBtb2R1bGVcbiAqICBAcHJpdmF0ZVxuICovXG5pbXBvcnQgeyBUUkFOU0ZPUk1TIH0gZnJvbSAnLi4vcmVnaXN0cnknO1xuXG4vKipcbiAqIFRoZSBSZXF1ZXN0ZXIgbWFuYWdlcyBmZXRjaGluZyBvZiBkYXRhIGFjcm9zcyBtdWx0aXBsZSBkYXRhIHNvdXJjZXMuIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSBMb2N1c1pvb20gZGF0YSBsYXllcnMuXG4gKiAgIEl0IHBhc3NlcyBzdGF0ZSBpbmZvcm1hdGlvbiBhbmQgZW5zdXJlcyB0aGF0IGRhdGEgaXMgZm9ybWF0dGVkIGluIHRoZSBtYW5uZXIgZXhwZWN0ZWQgYnkgdGhlIHBsb3QuXG4gKlxuICogVGhpcyBvYmplY3QgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIEl0IHNob3VsZCBhbG1vc3QgKipuZXZlcioqIGJlIHJlcGxhY2VkIG9yIG1vZGlmaWVkIGRpcmVjdGx5LlxuICpcbiAqIEl0IGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGNvbnN0cnVjdGluZyBhIFwiY2hhaW5cIiBvZiBkZXBlbmRlbnQgcmVxdWVzdHMsIGJ5IHJlcXVlc3RpbmcgZWFjaCBkYXRhc291cmNlXG4gKiAgIHNlcXVlbnRpYWxseSBpbiB0aGUgb3JkZXIgc3BlY2lmaWVkIGluIHRoZSBkYXRhbGF5ZXIgYGZpZWxkc2AgYXJyYXkuIERhdGEgc291cmNlcyBhcmUgb25seSBjaGFpbmVkIHdpdGhpbiBhXG4gKiAgIGRhdGEgbGF5ZXIsIGFuZCBvbmx5IGlmIHRoYXQgbGF5ZXIgcmVxdWVzdHMgbW9yZSB0aGFuIG9uZSBraW5kIG9mIGRhdGEgc291cmNlLlxuICogQHBhcmFtIHtEYXRhU291cmNlc30gc291cmNlcyBBIHNldCBvZiBkYXRhIHNvdXJjZXMgdXNlZCBzcGVjaWZpY2FsbHkgYnkgdGhpcyBwbG90IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSZXF1ZXN0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcyA9IHNvdXJjZXM7XG4gICAgfVxuXG4gICAgX19zcGxpdF9yZXF1ZXN0cyhmaWVsZHMpIHtcbiAgICAgICAgLy8gR2l2ZW4gYSBmaWVsZHMgYXJyYXksIHJldHVybiBhbiBvYmplY3Qgc3BlY2lmeWluZyB3aGF0IGRhdGFzb3VyY2UgbmFtZXMgdGhlIGRhdGEgbGF5ZXIgc2hvdWxkIG1ha2UgcmVxdWVzdHNcbiAgICAgICAgLy8gIHRvLCBhbmQgaG93IHRvIGhhbmRsZSB0aGUgcmV0dXJuZWQgZGF0YVxuICAgICAgICB2YXIgcmVxdWVzdHMgPSB7fTtcbiAgICAgICAgLy8gUmVndWxhciBleHByZXNzaW9uIGZpbmRzIG5hbWVzcGFjZTpmaWVsZHx0cmFuc1xuICAgICAgICB2YXIgcmUgPSAvXig/OihbXjpdKyk6KT8oW146fF0qKShcXHwuKykqJC87XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKHJhdykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcmUuZXhlYyhyYXcpO1xuICAgICAgICAgICAgdmFyIG5zID0gcGFydHNbMV0gfHwgJ2Jhc2UnO1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gcGFydHNbMl07XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSBUUkFOU0ZPUk1TLmdldChwYXJ0c1szXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RzW25zXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RzW25zXSA9IHtvdXRuYW1lczpbXSwgZmllbGRzOltdLCB0cmFuczpbXX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0c1tuc10ub3V0bmFtZXMucHVzaChyYXcpO1xuICAgICAgICAgICAgcmVxdWVzdHNbbnNdLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIHJlcXVlc3RzW25zXS50cmFucy5wdXNoKHRyYW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCBkYXRhLCBhbmQgY3JlYXRlIGEgY2hhaW4gdGhhdCBvbmx5IGNvbm5lY3RzIHR3byBkYXRhIHNvdXJjZXMgaWYgdGhleSBkZXBlbmQgb24gZWFjaCBvdGhlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBUaGUgY3VycmVudCBcInN0YXRlXCIgb2YgdGhlIHBsb3QsIHN1Y2ggYXMgY2hyb21vc29tZSBhbmQgc3RhcnQvZW5kIHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGZpZWxkcyBUaGUgbGlzdCBvZiBkYXRhIGZpZWxkcyBzcGVjaWZpZWQgaW4gdGhlIGBsYXlvdXRgIGZvciBhIHNwZWNpZmljIGRhdGEgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBnZXREYXRhKHN0YXRlLCBmaWVsZHMpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RzID0gdGhpcy5fX3NwbGl0X3JlcXVlc3RzKGZpZWxkcyk7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgdHJpZ2dlciB0aGUgcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIGRhdGFzb3VyY2VcbiAgICAgICAgdmFyIHJlcXVlc3RfaGFuZGxlcyA9IE9iamVjdC5rZXlzKHJlcXVlc3RzKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc291cmNlIGZvciBuYW1lc3BhY2UgJHtrZXl9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMuZ2V0KGtleSkuZ2V0RGF0YShcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0c1trZXldLmZpZWxkcyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0c1trZXldLm91dG5hbWVzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RzW2tleV0udHJhbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICAvL2Fzc3VtZSB0aGUgZmllbGRzIGFyZSByZXF1ZXN0ZWQgaW4gZGVwZW5kZW50IG9yZGVyXG4gICAgICAgIC8vVE9ETzogYmV0dGVyIG1hbmFnZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVzb2x2ZSh7aGVhZGVyOnt9LCBib2R5OiBbXSwgZGlzY3JldGU6IHt9fSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxdWVzdF9oYW5kbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHNpbmdsZSBkYXRhbGF5ZXIgdXNlcyBtdWx0aXBsZSBzb3VyY2VzLCBwZXJmb3JtIHRoZSBuZXh0IHJlcXVlc3Qgd2hlbiB0aGUgcHJldmlvdXMgb25lIGNvbXBsZXRlc1xuICAgICAgICAgICAgcmV0ID0gcmV0LnRoZW4ocmVxdWVzdF9oYW5kbGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBSZXF1ZXN0ZXI7XG4iLCIvKiogQG1vZHVsZSAqL1xuaW1wb3J0IHtSZWdpc3RyeUJhc2V9IGZyb20gJy4uL3JlZ2lzdHJ5L2Jhc2UnO1xuaW1wb3J0IHsgQURBUFRFUlMgfSBmcm9tICcuLi9yZWdpc3RyeSc7XG5cbi8qKlxuICogQ3JlYXRlIGFuZCBjb29yZGluYXRlIGFuIGVuc2VtYmxlIG9mIChuYW1lc3BhY2VkKSBkYXRhIHNvdXJjZSBpbnN0YW5jZXNcbiAqIFRoaXMgaXMgdGhlIG1lY2hhbmlzbSBieSB3aGljaCB1c2VycyBjcmVhdGUgZGF0YSBzb3VyY2VzIGZvciBhIHNwZWNpZmljIHBsb3QsIGFuZCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZVxuICogIHB1YmxpYyBpbnRlcmZhY2UgZm9yIExvY3VzWm9vbS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIERhdGFTb3VyY2VzIGV4dGVuZHMgUmVnaXN0cnlCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdHJ5QmFzZX0gW3JlZ2lzdHJ5XSBQcmltYXJpbHkgdXNlZCBmb3IgdW5pdCB0ZXN0aW5nLiBXaGVuIGNyZWF0aW5nIHNvdXJjZXMgYnkgbmFtZSwgc3BlY2lmeSB3aGVyZSB0b1xuICAgICAqICBmaW5kIHRoZSByZWdpc3RyeSBvZiBrbm93biBzb3VyY2VzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlZ2lzdHJ5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIFRoaXMgYm90aCBhY3RzIGFzIGEgcmVnaXN0cnkgKG9mIHRoZSBpbnN0YW50aWF0ZWQgc291cmNlcyBmb3IgdGhpcyBwbG90KSwgYW5kIHJlZmVyZW5jZXMgYSByZWdpc3RyeVxuICAgICAgICAvLyAgICh0byBsb2NhdGUgYWRhcHRlciBjbGFzc2VzIGJ5IG5hbWUsIHdoZW4gY3JlYXRpbmcgZnJvbSBjb25maWcpXG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gcmVnaXN0cnkgfHwgQURBUFRFUlM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGRhdGEgc291cmNlcywgdGhlcmUgaXMgYSBzcGVjaWFsIGJlaGF2aW9yIG9mIFwiY3JlYXRlIGl0ZW0gZnJvbSBjb25maWcsIHRoZW4gYWRkXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgZGF0YXNvdXJjZVxuICAgICAqIEBwYXJhbSB7QmFzZUFkYXB0ZXJ8QXJyYXl9IGl0ZW0gQW4gaW5zdGFudGlhdGVkIGRhdGFzb3VyY2UsIG9yIGFuIGFycmF5IG9mIGFyZ3VtZW50cyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogICBjcmVhdGUgYSBrbm93biBkYXRhc291cmNlIHR5cGUuXG4gICAgICogQHBhcmFtIFtvdmVycmlkZT1mYWxzZV0gV2hldGhlciB0byBhbGxvdyBleGlzdGluZyBzb3VyY2VzIHRvIGJlIHJlZGVmaW5lZFxuICAgICAqIEByZXR1cm4ge0RhdGFTb3VyY2VzfSBNb3N0IHJlZ2lzdHJpZXMgcmV0dXJuIHRoZSBjcmVhdGVkIGluc3RhbmNlLCBidXQgdGhpcyByZWdpc3RyeSByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogIGl0c2VsZiAodG8gc3VwcG9ydCBjaGFpbmluZylcbiAgICAgKi9cbiAgICBhZGQobmFtZXNwYWNlLCBpdGVtLCBvdmVycmlkZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWdpc3RyeS5oYXMobmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbmFtZXNwYWNlICR7bmFtZXNwYWNlfSBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIHNvdXJjZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVzcGFjZS5tYXRjaCgvW15BLVphLXowLTlfXS8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgc291cmNlIG5hbWVzcGFjZSBuYW1lcyBjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIG9yIHVuZGVyc2NvcmVzLiBJbnZhbGlkIG5hbWU6ICR7bmFtZXNwYWNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBbdHlwZSwgb3B0aW9uc10gPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuX3JlZ2lzdHJ5LmNyZWF0ZSh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFYWNoIGRhdGFzb3VyY2UgaW4gdGhlIGNoYWluIHNob3VsZCBiZSBhd2FyZSBvZiBpdHMgYXNzaWduZWQgbmFtZXNwYWNlXG4gICAgICAgIGl0ZW0uc291cmNlX2lkID0gbmFtZXNwYWNlO1xuXG4gICAgICAgIHN1cGVyLmFkZChuYW1lc3BhY2UsIGl0ZW0sIG92ZXJyaWRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IERhdGFTb3VyY2VzO1xuIiwiLyoqXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG4vLyBGSVhNRTogQSBwbGFjZSBmb3IgY29kZSB0aGF0IHVzZWQgdG8gbGl2ZSB1bmRlciB0aGUgYExvY3VzWm9vbWAgbmFtZXNwYWNlXG4vLyBFdmVudHVhbGx5IHRoaXMgc2hvdWxkIGJlIG1vdmVkIGludG8gY2xhc3NlcyBvciBzb21lIG90aGVyIG1lY2hhbmlzbSBmb3IgY29kZSBzaGFyaW5nLiBObyBleHRlcm5hbCB1c2VzIHNob3VsZFxuLy8gIGRlcGVuZCBvbiBhbnkgaXRlbXMgaW4gdGhpcyBtb2R1bGUuXG5cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGN1cnRhaW4gb2JqZWN0IGZvciBhIHBsb3QsIHBhbmVsLCBvciBhbnkgb3RoZXIgc3ViZGl2aXNpb24gb2YgYSBsYXlvdXRcbiAqIFRoZSBwYW5lbCBjdXJ0YWluLCBsaWtlIHRoZSBwbG90IGN1cnRhaW4gaXMgYW4gSFRNTCBvdmVybGF5IHRoYXQgb2JzY3VyZXMgdGhlIGVudGlyZSBwYW5lbC4gSXQgY2FuIGJlIHN0eWxlZFxuICogICBhcmJpdHJhcmlseSBhbmQgZGlzcGxheSBhcmJpdHJhcnkgbWVzc2FnZXMuIEl0IGlzIHVzZWZ1bCBmb3IgcmVwb3J0aW5nIGVycm9yIG1lc3NhZ2VzIHZpc3VhbGx5IHRvIGFuIGVuZCB1c2VyXG4gKiAgIHdoZW4gdGhlIGVycm9yIHJlbmRlcnMgdGhlIHBhbmVsIHVudXNhYmxlLlxuICogICBUT0RPOiBJbXByb3ZlIHR5cGUgZG9jIGhlcmVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ3VydGFpbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaG93aW5nOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0b3I6IG51bGwsXG4gICAgICAgIGNvbnRlbnRfc2VsZWN0b3I6IG51bGwsXG4gICAgICAgIGhpZGVfZGVsYXk6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlIHRoZSBjdXJ0YWluLiBBbnkgY29udGVudCAoc3RyaW5nKSBhcmd1bWVudCBwYXNzZWQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGN1cnRhaW4gYXMgcmF3IEhUTUwuXG4gICAgICAgICAqICAgQ1NTIChvYmplY3QpIGNhbiBiZSBwYXNzZWQgd2hpY2ggd2lsbCBhcHBseSBzdHlsZXMgdG8gdGhlIGN1cnRhaW4gYW5kIGl0cyBjb250ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBDb250ZW50IHRvIGJlIGRpc3BsYXllZCBvbiB0aGUgY3VydGFpbiAoYXMgcmF3IEhUTUwpXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjc3MgQXBwbHkgdGhlIHNwZWNpZmllZCBzdHlsZXMgdG8gdGhlIGN1cnRhaW4gYW5kIGl0cyBjb250ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogKGNvbnRlbnQsIGNzcykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnRhaW4uc2hvd2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VydGFpbi5zZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudF9wbG90LnN2Zy5ub2RlKCkucGFyZW50Tm9kZSkuaW5zZXJ0KCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotY3VydGFpbicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIGAke3RoaXMuaWR9LmN1cnRhaW5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnRhaW4uY29udGVudF9zZWxlY3RvciA9IHRoaXMuY3VydGFpbi5zZWxlY3Rvci5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1jdXJ0YWluLWNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnRhaW4uc2VsZWN0b3IuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotY3VydGFpbi1kaXNtaXNzJykuaHRtbCgnRGlzbWlzcycpXG4gICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB0aGlzLmN1cnRhaW4uaGlkZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnRhaW4uc2hvd2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJ0YWluLnVwZGF0ZShjb250ZW50LCBjc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGNvbnRlbnQgYW5kIGNzcyBvZiB0aGUgY3VydGFpbiB0aGF0J3MgY3VycmVudGx5IGJlaW5nIHNob3duLiBUaGlzIG1ldGhvZCBhbHNvIGFkanVzdHMgdGhlIHNpemVcbiAgICAgICAgICogICBhbmQgcG9zaXRpb25pbmcgb2YgdGhlIGN1cnRhaW4gdG8gZW5zdXJlIGl0IHN0aWxsIGNvdmVycyB0aGUgZW50aXJlIHBhbmVsIHdpdGggbm8gb3ZlcmxhcC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgQ29udGVudCB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGN1cnRhaW4gKGFzIHJhdyBIVE1MKVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gY3NzIEFwcGx5IHRoZSBzcGVjaWZpZWQgc3R5bGVzIHRvIHRoZSBjdXJ0YWluIGFuZCBpdHMgY29udGVudHNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogKGNvbnRlbnQsIGNzcykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnRhaW4uc2hvd2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnRhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJ0YWluLmhpZGVfZGVsYXkpO1xuICAgICAgICAgICAgLy8gQXBwbHkgQ1NTIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNzcyA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGFwcGx5U3R5bGVzKHRoaXMuY3VydGFpbi5zZWxlY3RvciwgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgcGFnZV9vcmlnaW4gPSB0aGlzLl9nZXRQYWdlT3JpZ2luKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnRhaW4uc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RvcCcsIGAke3BhZ2Vfb3JpZ2luLnl9cHhgKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbGVmdCcsIGAke3BhZ2Vfb3JpZ2luLnh9cHhgKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCBgJHt0aGlzLmxheW91dC53aWR0aH1weGApXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCBgJHt0aGlzLmxheW91dC5oZWlnaHR9cHhgKTtcbiAgICAgICAgICAgIHRoaXMuY3VydGFpbi5jb250ZW50X3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXgtd2lkdGgnLCBgJHt0aGlzLmxheW91dC53aWR0aCAtIDQwfXB4YClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ21heC1oZWlnaHQnLCBgJHt0aGlzLmxheW91dC5oZWlnaHQgLSA0MH1weGApO1xuICAgICAgICAgICAgLy8gQXBwbHkgY29udGVudCBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJ0YWluLmNvbnRlbnRfc2VsZWN0b3IuaHRtbChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnRhaW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgY3VydGFpblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGltZSB0byB3YWl0IChpbiBtcylcbiAgICAgICAgICovXG4gICAgICAgIGhpZGU6IChkZWxheSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnRhaW4uc2hvd2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnRhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIGRlbGF5IHdhcyBwYXNzZWQgdGhlbiBkZWZlciB0byBhIHRpbWVvdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJ0YWluLmhpZGVfZGVsYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VydGFpbi5oaWRlX2RlbGF5ID0gc2V0VGltZW91dCh0aGlzLmN1cnRhaW4uaGlkZSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnRhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgY3VydGFpblxuICAgICAgICAgICAgdGhpcy5jdXJ0YWluLnNlbGVjdG9yLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJ0YWluLnNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VydGFpbi5jb250ZW50X3NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VydGFpbi5zaG93aW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJ0YWluO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBsb2FkZXIgb2JqZWN0IGZvciBhIHBsb3QsIHBhbmVsLCBvciBhbnkgb3RoZXIgc3ViZGl2aXNpb24gb2YgYSBsYXlvdXRcbiAqXG4gKiBUaGUgcGFuZWwgbG9hZGVyIGlzIGEgc21hbGwgSFRNTCBvdmVybGF5IHRoYXQgYXBwZWFycyBpbiB0aGUgbG93ZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHBhbmVsLiBJdCBjYW5ub3QgYmUgc3R5bGVkXG4gKiAgIGFyYml0cmFyaWx5LCBidXQgY2FuIHNob3cgYSBjdXN0b20gbWVzc2FnZSBhbmQgc2hvdyBhIG1pbmltYWxpc3QgbG9hZGluZyBiYXIgdGhhdCBjYW4gYmUgdXBkYXRlZCB0byBzcGVjaWZpY1xuICogICBjb21wbGV0aW9uIHBlcmNlbnRhZ2VzIG9yIGJlIGFuaW1hdGVkLlxuICogVE9ETyBJbXByb3ZlIHR5cGUgZG9jdW1lbnRhdGlvblxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvd2luZzogZmFsc2UsXG4gICAgICAgIHNlbGVjdG9yOiBudWxsLFxuICAgICAgICBjb250ZW50X3NlbGVjdG9yOiBudWxsLFxuICAgICAgICBwcm9ncmVzc19zZWxlY3RvcjogbnVsbCxcbiAgICAgICAgY2FuY2VsX3NlbGVjdG9yOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IGEgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb250ZW50PSdMb2FkaW5nLi4uJ10gTG9hZGluZyBtZXNzYWdlIChkaXNwbGF5ZWQgYXMgcmF3IEhUTUwpXG4gICAgICAgICAqL1xuICAgICAgICBzaG93OiAoY29udGVudCkgPT4ge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbG9hZGVyXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVyLnNob3dpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlci5zZWxlY3RvciA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudF9wbG90LnN2Zy5ub2RlKCkucGFyZW50Tm9kZSkuaW5zZXJ0KCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotbG9hZGVyJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7dGhpcy5pZH0ubG9hZGVyYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXIuY29udGVudF9zZWxlY3RvciA9IHRoaXMubG9hZGVyLnNlbGVjdG9yLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWxvYWRlci1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXIucHJvZ3Jlc3Nfc2VsZWN0b3IgPSB0aGlzLmxvYWRlci5zZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbHotbG9hZGVyLXByb2dyZXNzLWNvbnRhaW5lcicpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1sb2FkZXItcHJvZ3Jlc3MnKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyLnNob3dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gJ0xvYWRpbmcuLi4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci51cGRhdGUoY29udGVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBsb2FkZXIgYW5kIGVuc3VyZSB0aGUgbmV3IGNvbnRlbnQgaXMgcG9zaXRpb25lZCBjb3JyZWN0bHkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IFRoZSB0ZXh0IHRvIGRpc3BsYXkgKGFzIHJhdyBIVE1MKS4gSWYgbm90IGEgc3RyaW5nLCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyY2VudF0gQSBudW1iZXIgZnJvbSAxLTEwMC4gSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgc3RvcCBhbGwgYW5pbWF0aW9uc1xuICAgICAgICAgKiAgIGluIHByb2dyZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiAoY29udGVudCwgcGVyY2VudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlci5zaG93aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyLmhpZGVfZGVsYXkpO1xuICAgICAgICAgICAgLy8gQXBwbHkgY29udGVudCBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXIuY29udGVudF9zZWxlY3Rvci5odG1sKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gNjsgLy8gaXMgdGhlcmUgYSBiZXR0ZXIgcGxhY2UgdG8gc3RvcmUvZGVmaW5lIHRoaXM/XG4gICAgICAgICAgICBjb25zdCBwYWdlX29yaWdpbiA9IHRoaXMuX2dldFBhZ2VPcmlnaW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlcl9ib3VuZHJlY3QgPSB0aGlzLmxvYWRlci5zZWxlY3Rvci5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5zZWxlY3RvclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndG9wJywgYCR7cGFnZV9vcmlnaW4ueSArIHRoaXMubGF5b3V0LmhlaWdodCAtIGxvYWRlcl9ib3VuZHJlY3QuaGVpZ2h0IC0gcGFkZGluZ31weGApXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgYCR7cGFnZV9vcmlnaW4ueCArIHBhZGRpbmcgIH1weGApO1xuICAgICAgICAgICAgLyogVW5jb21tZW50IHRoaXMgY29kZSB3aGVuIGEgZnVuY3Rpb25hbCBjYW5jZWwgYnV0dG9uIGNhbiBiZSBzaG93blxuICAgICAgICAgICAgdmFyIGNhbmNlbF9ib3VuZHJlY3QgPSB0aGlzLmxvYWRlci5jYW5jZWxfc2VsZWN0b3Iubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuY29udGVudF9zZWxlY3Rvci5zdHlsZSh7XG4gICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IChjYW5jZWxfYm91bmRyZWN0LndpZHRoICsgcGFkZGluZykgKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIEFwcGx5IHBlcmNlbnQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGVyY2VudCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyLnByb2dyZXNzX3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCBgJHtNYXRoLm1pbihNYXRoLm1heChwZXJjZW50LCAxKSwgMTAwKX0lYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbG9hZGluZyBiYXIgdGhhdCBtYWtlcyBpdCBsb29wIGluZmluaXRlbHkgaW4gYSBsb2FkaW5nIGFuaW1hdGlvbi4gVXNlZnVsIHdoZW4gZXhhY3RcbiAgICAgICAgICogICBwZXJjZW50IHByb2dyZXNzIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5wcm9ncmVzc19zZWxlY3Rvci5jbGFzc2VkKCdsei1sb2FkZXItcHJvZ3Jlc3MtYW5pbWF0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogIFNldHMgdGhlIGxvYWRpbmcgYmFyIGluIHRoZSBsb2FkZXIgdG8gcGVyY2VudGFnZSB3aWR0aCBlcXVhbCB0byB0aGUgcGVyY2VudCAobnVtYmVyKSB2YWx1ZSBwYXNzZWQuIFBlcmNlbnRzXG4gICAgICAgICAqICAgIHdpbGwgYXV0b21hdGljYWxseSBiZSBsaW1pdGVkIHRvIGEgcmFuZ2Ugb2YgMSB0byAxMDAuIFdpbGwgc3RvcCBhbGwgYW5pbWF0aW9ucyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICovXG4gICAgICAgIHNldFBlcmNlbnRDb21wbGV0ZWQ6IChwZXJjZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5wcm9ncmVzc19zZWxlY3Rvci5jbGFzc2VkKCdsei1sb2FkZXItcHJvZ3Jlc3MtYW5pbWF0ZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIudXBkYXRlKG51bGwsIHBlcmNlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGxvYWRlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGltZSB0byB3YWl0IChpbiBtcylcbiAgICAgICAgICovXG4gICAgICAgIGhpZGU6IChkZWxheSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlci5zaG93aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBkZWxheSB3YXMgcGFzc2VkIHRoZW4gZGVmZXIgdG8gYSB0aW1lb3V0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlbGF5ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyLmhpZGVfZGVsYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyLmhpZGVfZGVsYXkgPSBzZXRUaW1lb3V0KHRoaXMubG9hZGVyLmhpZGUsIGRlbGF5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgbG9hZGVyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5zZWxlY3Rvci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLnNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmNvbnRlbnRfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIucHJvZ3Jlc3Nfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuY2FuY2VsX3NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLnNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlcjtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIE1vZGVybiBkMyByZW1vdmVkIHRoZSBhYmlsaXR5IHRvIHNldCBtYW55IHN0eWxlcyBhdCBvbmNlIChvYmplY3Qgc3ludGF4KS4gVGhpcyBpcyBhIGhlbHBlciBzbyB0aGF0IGxheW91dHMgd2l0aFxuICogIGNvbmZpZy1vYmplY3RzIGNhbiBzZXQgc3R5bGVzIGFsbCBhdCBvbmNlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IHNlbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhzZWxlY3Rpb24sIHN0eWxlcykge1xuICAgIHN0eWxlcyA9IHN0eWxlcyB8fCB7fTtcbiAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcbiAgICAgICAgc2VsZWN0aW9uLnN0eWxlKHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogUHJldmVudCBhIFVJIGZ1bmN0aW9uIGZyb20gYmVpbmcgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIGluIGEgZ2l2ZW4gaW50ZXJ2YWwuIFRoaXMgYWxsb3dzLCBlZywgc2VhcmNoIGJveGVzIHRvIGRlbGF5XG4gKiAgIGV4cGVuc2l2ZSBvcGVyYXRpb25zIHVudGlsIHRoZSB1c2VyIGlzIGRvbmUgdHlwaW5nXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS4gUmV0dXJucyBhIHdyYXBwZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGltZSB0byB3YWl0IGFmdGVyIGxhc3QgY2FsbCAoaW4gbXMpXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIGRlbGF5ID0gNTAwKSB7XG4gICAgbGV0IHRpbWVyO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICgpID0+IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGRlbGF5XG4gICAgICAgICk7XG4gICAgfTtcbn1cblxuXG5leHBvcnQgeyBhcHBseVN0eWxlcywgZGVib3VuY2UsIGdlbmVyYXRlQ3VydGFpbiwgZ2VuZXJhdGVMb2FkZXIgfTtcbiIsIi8qKlxuICogSGVscGVycyB0aGF0IGNvbnRyb2wgdGhlIGRpc3BsYXkgb2YgaW5kaXZpZHVhbCBwb2ludHMgYW5kIGZpZWxkIHZhbHVlc1xuICogQG1vZHVsZVxuICovXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cbmltcG9ydCBGaWVsZCBmcm9tICcuLi9kYXRhL2ZpZWxkJztcbmltcG9ydCBQbG90IGZyb20gJy4uL2NvbXBvbmVudHMvcGxvdCc7XG5pbXBvcnQge2FwcGx5U3R5bGVzfSBmcm9tICcuL2NvbW1vbic7XG5cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGludGVnZXIgY2hyb21vc29tZSBwb3NpdGlvbiB0byBhbiBTSSBzdHJpbmcgcmVwcmVzZW50YXRpb24gKGUuZy4gMjM0MjM0NTYgPT4gXCIyMy40MlwiIChNYikpXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIFBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW2V4cF0gRXhwb25lbnQgdG8gdXNlIGZvciB0aGUgcmV0dXJuZWQgc3RyaW5nLCBlZyA2PT4gTUIuIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgYXR0ZW1wdCB0byBndWVzc1xuICogICB0aGUgbW9zdCBhcHByb3ByaWF0ZSBTSSBwcmVmaXggYmFzZWQgb24gdGhlIG51bWJlciBwcm92aWRlZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N1ZmZpeD1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gYXBwZW5kIGEgc3VmZml4IChlLmcuIFwiTWJcIikgdG8gdGhlIGVuZCBvZiB0aGUgcmV0dXJuZWQgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbkludFRvU3RyaW5nKHBvcywgZXhwLCBzdWZmaXgpIHtcbiAgICBjb25zdCBleHBfc3ltYm9scyA9IHsgMDogJycsIDM6ICdLJywgNjogJ00nLCA5OiAnRycgfTtcbiAgICBzdWZmaXggPSBzdWZmaXggfHwgZmFsc2U7XG4gICAgaWYgKGlzTmFOKGV4cCkgfHwgZXhwID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGxvZyA9IE1hdGgubG9nKHBvcykgLyBNYXRoLkxOMTA7XG4gICAgICAgIGV4cCA9IE1hdGgubWluKE1hdGgubWF4KGxvZyAtIChsb2cgJSAzKSwgMCksIDkpO1xuICAgIH1cbiAgICBjb25zdCBwbGFjZXNfZXhwID0gZXhwIC0gTWF0aC5mbG9vcigoTWF0aC5sb2cocG9zKSAvIE1hdGguTE4xMCkudG9GaXhlZChleHAgKyAzKSk7XG4gICAgY29uc3QgbWluX2V4cCA9IE1hdGgubWluKE1hdGgubWF4KGV4cCwgMCksIDIpO1xuICAgIGNvbnN0IHBsYWNlcyA9IE1hdGgubWluKE1hdGgubWF4KHBsYWNlc19leHAsIG1pbl9leHApLCAxMik7XG4gICAgbGV0IHJldCA9IGAkeyhwb3MgLyBNYXRoLnBvdygxMCwgZXhwKSkudG9GaXhlZChwbGFjZXMpfWA7XG4gICAgaWYgKHN1ZmZpeCAmJiB0eXBlb2YgZXhwX3N5bWJvbHNbZXhwXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0ICs9IGAgJHtleHBfc3ltYm9sc1tleHBdfWJgO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gU0kgc3RyaW5nIGNocm9tb3NvbWUgcG9zaXRpb24gdG8gYW4gaW50ZWdlciByZXByZXNlbnRhdGlvbiAoZS5nLiBcIjUuOCBNYlwiID0+IDU4MDAwMDAwKVxuICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIGNocm9tb3NvbWUgcG9zaXRpb25cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uU3RyaW5nVG9JbnQocCkge1xuICAgIGxldCB2YWwgPSBwLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLywvZywgJycpO1xuICAgIGNvbnN0IHN1ZmZpeHJlID0gLyhbS01HXSlbQl0qJC87XG4gICAgY29uc3Qgc3VmZml4ID0gc3VmZml4cmUuZXhlYyh2YWwpO1xuICAgIGxldCBtdWx0ID0gMTtcbiAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgIGlmIChzdWZmaXhbMV0gPT09ICdNJykge1xuICAgICAgICAgICAgbXVsdCA9IDFlNjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWZmaXhbMV0gPT09ICdHJykge1xuICAgICAgICAgICAgbXVsdCA9IDFlOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHQgPSAxZTM7IC8vS1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKHN1ZmZpeHJlLCAnJyk7XG4gICAgfVxuICAgIHZhbCA9IE51bWJlcih2YWwpICogbXVsdDtcbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgXCJwcmV0dHlcIiBzZXQgb2YgdGlja3MgKG11bHRpcGxlcyBvZiAxLCAyLCBvciA1IG9uIHRoZSBzYW1lIG9yZGVyIG9mIG1hZ25pdHVkZSBmb3IgdGhlIHJhbmdlKVxuICogICBCYXNlZCBvbiBSJ3MgXCJwcmV0dHlcIiBmdW5jdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3djaC9yLXNvdXJjZS9ibG9iL2IxNTZlM2E3MTE5NjdmNTgxMzFlMjNjMWIxZGMxZWE5MGUyZjBjNDMvc3JjL2FwcGwvcHJldHR5LmNcbiAqIEBwYXJhbSB7TnVtYmVyW119IHJhbmdlIEEgdHdvLWl0ZW0gYXJyYXkgc3BlY2lmeWluZyBbbG93LCBoaWdoXSB2YWx1ZXMgZm9yIHRoZSBheGlzIHJhbmdlXG4gKiBAcGFyYW0geygnbG93J3wnaGlnaCd8J2JvdGgnfCduZWl0aGVyJyl9IFtjbGlwX3JhbmdlPSduZWl0aGVyJ10gV2hhdCB0byBkbyBpZiBmaXJzdCBhbmQgbGFzdCBnZW5lcmF0ZWQgdGlja3MgZXh0ZW5kXG4gKiAgIGJleW9uZCB0aGUgcmFuZ2UuIFNldCB0aGlzIHRvIFwibG93XCIsIFwiaGlnaFwiLCBcImJvdGhcIiwgb3IgXCJuZWl0aGVyXCIgdG8gY2xpcCB0aGUgZmlyc3QgKGxvdykgb3IgbGFzdCAoaGlnaCkgdGljayB0b1xuICogICBiZSBpbnNpZGUgdGhlIHJhbmdlIG9yIGFsbG93IHRoZW0gdG8gZXh0ZW5kIGJleW9uZC5cbiAqICAgZS5nLiBcImxvd1wiIHdpbGwgY2xpcCB0aGUgZmlyc3QgKGxvdykgdGljayBpZiBpdCBleHRlbmRzIGJleW9uZCB0aGUgbG93IGVuZCBvZiB0aGUgcmFuZ2UgYnV0IGFsbG93IHRoZVxuICogIGxhc3QgKGhpZ2gpIHRpY2sgdG8gZXh0ZW5kIGJleW9uZCB0aGUgcmFuZ2UuIFwiYm90aFwiIGNsaXBzIGJvdGggZW5kcywgXCJuZWl0aGVyXCIgYWxsb3dzIGJvdGggdG8gZXh0ZW5kIGJleW9uZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0X3RpY2tfY291bnQ9NV0gVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiB0aWNrcyB5b3Ugd291bGQgbGlrZSB0byBiZSByZXR1cm5lZDsgbWF5IG5vdCBiZSBleGFjdFxuICogQHJldHVybnMge051bWJlcltdfVxuICovXG5mdW5jdGlvbiBwcmV0dHlUaWNrcyhyYW5nZSwgY2xpcF9yYW5nZSwgdGFyZ2V0X3RpY2tfY291bnQpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldF90aWNrX2NvdW50ID09ICd1bmRlZmluZWQnIHx8IGlzTmFOKHBhcnNlSW50KHRhcmdldF90aWNrX2NvdW50KSkpIHtcbiAgICAgICAgdGFyZ2V0X3RpY2tfY291bnQgPSA1O1xuICAgIH1cbiAgICB0YXJnZXRfdGlja19jb3VudCA9ICt0YXJnZXRfdGlja19jb3VudDtcblxuICAgIGNvbnN0IG1pbl9uID0gdGFyZ2V0X3RpY2tfY291bnQgLyAzO1xuICAgIGNvbnN0IHNocmlua19zbWwgPSAwLjc1O1xuICAgIGNvbnN0IGhpZ2hfdV9iaWFzID0gMS41O1xuICAgIGNvbnN0IHU1X2JpYXMgPSAwLjUgKyAxLjUgKiBoaWdoX3VfYmlhcztcblxuICAgIGNvbnN0IGQgPSBNYXRoLmFicyhyYW5nZVswXSAtIHJhbmdlWzFdKTtcbiAgICBsZXQgYyA9IGQgLyB0YXJnZXRfdGlja19jb3VudDtcbiAgICBpZiAoKE1hdGgubG9nKGQpIC8gTWF0aC5MTjEwKSA8IC0yKSB7XG4gICAgICAgIGMgPSAoTWF0aC5tYXgoTWF0aC5hYnMoZCkpICogc2hyaW5rX3NtbCkgLyBtaW5fbjtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coYykgLyBNYXRoLkxOMTApKTtcbiAgICBsZXQgYmFzZV90b0ZpeGVkID0gMDtcbiAgICBpZiAoYmFzZSA8IDEgJiYgYmFzZSAhPT0gMCkge1xuICAgICAgICBiYXNlX3RvRml4ZWQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKE1hdGgubG9nKGJhc2UpIC8gTWF0aC5MTjEwKSk7XG4gICAgfVxuXG4gICAgbGV0IHVuaXQgPSBiYXNlO1xuICAgIGlmICggKCgyICogYmFzZSkgLSBjKSA8IChoaWdoX3VfYmlhcyAqIChjIC0gdW5pdCkpICkge1xuICAgICAgICB1bml0ID0gMiAqIGJhc2U7XG4gICAgICAgIGlmICggKCg1ICogYmFzZSkgLSBjKSA8ICh1NV9iaWFzICogKGMgLSB1bml0KSkgKSB7XG4gICAgICAgICAgICB1bml0ID0gNSAqIGJhc2U7XG4gICAgICAgICAgICBpZiAoICgoMTAgKiBiYXNlKSAtIGMpIDwgKGhpZ2hfdV9iaWFzICogKGMgLSB1bml0KSkgKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9IDEwICogYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0aWNrcyA9IFtdO1xuICAgIGxldCBpID0gcGFyc2VGbG9hdCgoTWF0aC5mbG9vcihyYW5nZVswXSAvIHVuaXQpICogdW5pdCkudG9GaXhlZChiYXNlX3RvRml4ZWQpKTtcbiAgICB3aGlsZSAoaSA8IHJhbmdlWzFdKSB7XG4gICAgICAgIHRpY2tzLnB1c2goaSk7XG4gICAgICAgIGkgKz0gdW5pdDtcbiAgICAgICAgaWYgKGJhc2VfdG9GaXhlZCA+IDApIHtcbiAgICAgICAgICAgIGkgPSBwYXJzZUZsb2F0KGkudG9GaXhlZChiYXNlX3RvRml4ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aWNrcy5wdXNoKGkpO1xuXG4gICAgaWYgKHR5cGVvZiBjbGlwX3JhbmdlID09ICd1bmRlZmluZWQnIHx8IFsnbG93JywgJ2hpZ2gnLCAnYm90aCcsICduZWl0aGVyJ10uaW5kZXhPZihjbGlwX3JhbmdlKSA9PT0gLTEpIHtcbiAgICAgICAgY2xpcF9yYW5nZSA9ICduZWl0aGVyJztcbiAgICB9XG4gICAgaWYgKGNsaXBfcmFuZ2UgPT09ICdsb3cnIHx8IGNsaXBfcmFuZ2UgPT09ICdib3RoJykge1xuICAgICAgICBpZiAodGlja3NbMF0gPCByYW5nZVswXSkge1xuICAgICAgICAgICAgdGlja3MgPSB0aWNrcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xpcF9yYW5nZSA9PT0gJ2hpZ2gnIHx8IGNsaXBfcmFuZ2UgPT09ICdib3RoJykge1xuICAgICAgICBpZiAodGlja3NbdGlja3MubGVuZ3RoIC0gMV0gPiByYW5nZVsxXSkge1xuICAgICAgICAgICAgdGlja3MucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gYW4gaHRtbCBzdHJpbmcgd2l0aCBmaWVsZCB2YWx1ZXMgZGVmaW5lZCBpbiBhIGRhdGEgb2JqZWN0XG4gKiAgT25seSB3b3JrcyBvbiBzY2FsYXIgdmFsdWVzIGluIGRhdGEhIFdpbGwgaWdub3JlIG5vbi1zY2FsYXJzLiBUaGlzIGlzIHVzZWZ1bCBpbiwgZWcsIHRvb2x0aXAgdGVtcGxhdGVzLlxuICpcbiAqICBOT1RFOiBUcnVzdHMgY29udGVudCBleGFjdGx5IGFzIGdpdmVuLiBYU1MgcHJldmVudGlvbiBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGltcGxlbWVudGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIEEgcGxhY2Vob2xkZXIgc3RyaW5nIGluIHdoaWNoIHRvIHN1YnN0aXR1dGUgZmllbGRzLiBTdXBwb3J0cyBzZXZlcmFsIHRlbXBsYXRlIG9wdGlvbnM6XG4gKiAgIGB7e2ZpZWxkX25hbWV9fWAgaXMgYSB2YXJpYWJsZSBwbGFjZWhvbGRlciBmb3IgdGhlIHZhbHVlIG9mIGBmaWVsZF9uYW1lYCBmcm9tIHRoZSBwcm92aWRlZCBkYXRhXG4gKiAgIGB7eyNpZiBmaWVsZF9uYW1lfX0gQ29uZGl0aW9uYWwgdGV4dCB7ey9pZn19YCB3aWxsIGluc2VydCB0aGUgY29udGVudHMgb2YgdGhlIHRhZyBvbmx5IGlmIHRoZSB2YWx1ZSBleGlzdHMuXG4gKiAgICAgU2luY2UgdGhpcyBpcyBvbmx5IGFuIGV4aXN0ZW5jZSBjaGVjaywgKip2YXJpYWJsZXMgd2l0aCBhIHZhbHVlIG9mIDAgd2lsbCBiZSBldmFsdWF0ZWQgYXMgdHJ1ZSoqLlxuICogICAgIFRoaXMgY2FuIGJlIHVzZWQgd2l0aCBuYW1lc3BhY2VkIHZhbHVlcywgYHt7I2lmIGFzc29jOmZpZWxkfX1gOyBhbnkgZHluYW1pYyBuYW1lc3BhY2luZyB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGVcbiAqICAgICBsYXlvdXQgaXMgZmlyc3QgcmV0cmlldmVkLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcGFyc2VGaWVsZHMoZGF0YSwgaHRtbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzOiBkYXRhIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBodG1sICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudHM6IGh0bWwgaXMgbm90IGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIC8vIGB0b2tlbnNgIGlzIGxpa2UgW3Rva2VuLC4uLl1cbiAgICAvLyBgdG9rZW5gIGlzIGxpa2Uge3RleHQ6ICcuLi4nfSBvciB7dmFyaWFibGU6ICdmb298YmFyJ30gb3Ige2NvbmRpdGlvbjogJ2Zvb3xiYXInfSBvciB7Y2xvc2U6ICdpZid9XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgcmVnZXggPSAve3soPzooI2lmICk/KFtBLVphLXowLTlfOnxdKyl8KFxcL2lmKSl9fS87XG4gICAgd2hpbGUgKGh0bWwubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBtID0gcmVnZXguZXhlYyhodG1sKTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7dGV4dDogaHRtbH0pOyBodG1sID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAobS5pbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe3RleHQ6IGh0bWwuc2xpY2UoMCwgbS5pbmRleCl9KTsgaHRtbCA9IGh0bWwuc2xpY2UobS5pbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAobVsxXSA9PT0gJyNpZiAnKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7Y29uZGl0aW9uOiBtWzJdfSk7IGh0bWwgPSBodG1sLnNsaWNlKG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtWzJdKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7dmFyaWFibGU6IG1bMl19KTsgaHRtbCA9IGh0bWwuc2xpY2UobVswXS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1bM10gPT09ICcvaWYnKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7Y2xvc2U6ICdpZid9KTsgaHRtbCA9IGh0bWwuc2xpY2UobVswXS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdG9rZW5pemluZyB0b29sdGlwIHdoZW4gcmVtYWluaW5nIHRlbXBsYXRlIGlzICR7SlNPTi5zdHJpbmdpZnkoaHRtbCl9IGFuZCBwcmV2aW91cyB0b2tlbnMgYXJlICR7SlNPTi5zdHJpbmdpZnkodG9rZW5zKX0gYW5kIGN1cnJlbnQgcmVnZXggbWF0Y2ggaXMgJHtKU09OLnN0cmluZ2lmeShbbVsxXSwgbVsyXSwgbVszXV0pfWApO1xuICAgICAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2UobVswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFzdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbi50ZXh0ICE9PSAndW5kZWZpbmVkJyB8fCB0b2tlbi52YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgdG9rZW4udGhlbiA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vuc1swXS5jbG9zZSA9PT0gJ2lmJykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuLnRoZW4ucHVzaChhc3RpZnkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBtYWtpbmcgdG9vbHRpcCBBU1QgZHVlIHRvIHVua25vd24gdG9rZW4gJHtKU09OLnN0cmluZ2lmeSh0b2tlbil9YCk7XG4gICAgICAgICAgICByZXR1cm4geyB0ZXh0OiAnJyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBgYXN0YCBpcyBsaWtlIFt0aGluZywuLi5dXG4gICAgLy8gYHRoaW5nYCBpcyBsaWtlIHt0ZXh0OiBcIi4uLlwifSBvciB7dmFyaWFibGU6XCJmb298YmFyXCJ9IG9yIHtjb25kaXRpb246IFwiZm9vfGJhclwiLCB0aGVuOlt0aGluZywuLi5dfVxuICAgIGNvbnN0IGFzdCA9IFtdO1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBhc3QucHVzaChhc3RpZnkoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXNvbHZlLmNhY2hlLCB2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmUuY2FjaGVbdmFyaWFibGVdID0gKG5ldyBGaWVsZCh2YXJpYWJsZSkpLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUuY2FjaGVbdmFyaWFibGVdO1xuICAgIH07XG4gICAgcmVzb2x2ZS5jYWNoZSA9IHt9O1xuICAgIGNvbnN0IHJlbmRlcl9ub2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlLnRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlKG5vZGUudmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGlmIChbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddLmluZGV4T2YodHlwZW9mIHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgcHJvY2Vzc2luZyB2YXJpYWJsZSAke0pTT04uc3RyaW5naWZ5KG5vZGUudmFyaWFibGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGB7eyR7bm9kZS52YXJpYWJsZX19fWA7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5jb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcmVzb2x2ZShub2RlLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiB8fCBjb25kaXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudGhlbi5tYXAocmVuZGVyX25vZGUpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgcHJvY2Vzc2luZyBjb25kaXRpb24gJHtKU09OLnN0cmluZ2lmeShub2RlLnZhcmlhYmxlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlbmRlcmluZyB0b29sdGlwIGR1ZSB0byB1bmtub3duIEFTVCBub2RlICR7SlNPTi5zdHJpbmdpZnkobm9kZSl9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhc3QubWFwKHJlbmRlcl9ub2RlKS5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBhIHNpbmdsZSBlbGVtZW50IHdpdGggYSBMb2N1c1pvb20gcGxvdC4gVGhpcyBpcyB0aGUgcHJpbWFyeSBtZWFucyBvZiBnZW5lcmF0aW5nIGEgbmV3IHBsb3QsIGFuZCBpcyBwYXJ0XG4gKiAgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIExvY3VzWm9vbS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfGQzLnNlbGVjdGlvbn0gc2VsZWN0b3IgQ1NTIHNlbGVjdG9yIGZvciB0aGUgY29udGFpbmVyIGVsZW1lbnQgd2hlcmUgdGhlIHBsb3Qgd2lsbCBiZSBtb3VudGVkLiBBbnkgcHJlLWV4aXN0aW5nXG4gKiAgIGNvbnRlbnQgaW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIGNvbXBsZXRlbHkgcmVwbGFjZWQuXG4gKiBAcGFyYW0ge0RhdGFTb3VyY2VzfSBkYXRhc291cmNlIEVuc2VtYmxlIG9mIGRhdGEgcHJvdmlkZXJzIHVzZWQgYnkgdGhlIHBsb3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXQgQSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgbGF5b3V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Bsb3R9IFRoZSBuZXdseSBjcmVhdGVkIHBsb3QgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIGRhdGFzb3VyY2UsIGxheW91dCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2N1c1pvb20ucG9wdWxhdGUgc2VsZWN0b3Igbm90IGRlZmluZWQnKTtcbiAgICB9XG4gICAgLy8gRW1wdHkgdGhlIHNlbGVjdG9yIG9mIGFueSBleGlzdGluZyBjb250ZW50XG4gICAgZDMuc2VsZWN0KHNlbGVjdG9yKS5odG1sKCcnKTtcbiAgICBsZXQgcGxvdDtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0b3IpLmNhbGwoZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIC8vIFJlcXVpcmUgZWFjaCBjb250YWluaW5nIGVsZW1lbnQgaGF2ZSBhbiBJRC4gSWYgb25lIGlzbid0IHByZXNlbnQsIGNyZWF0ZSBvbmUuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0Lm5vZGUoKS5pZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gMDtcbiAgICAgICAgICAgIHdoaWxlICghZDMuc2VsZWN0KGAjbHotJHtpdGVyYXRvcn1gKS5lbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5hdHRyKCdpZCcsIGAjbHotJHtpdGVyYXRvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBsb3RcbiAgICAgICAgcGxvdCA9IG5ldyBQbG90KHRhcmdldC5ub2RlKCkuaWQsIGRhdGFzb3VyY2UsIGxheW91dCk7XG4gICAgICAgIHBsb3QuY29udGFpbmVyID0gdGFyZ2V0Lm5vZGUoKTtcbiAgICAgICAgLy8gRGV0ZWN0IEhUTUwgYGRhdGEtcmVnaW9uYCBhdHRyaWJ1dGUsIGFuZCB1c2UgaXQgdG8gZmlsbCBpbiBzdGF0ZSB2YWx1ZXMgaWYgcHJlc2VudFxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldC5ub2RlKCkuZGF0YXNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRhcmdldC5ub2RlKCkuZGF0YXNldC5yZWdpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRfc3RhdGUgPSBwYXJzZVBvc2l0aW9uUXVlcnkodGFyZ2V0Lm5vZGUoKS5kYXRhc2V0LnJlZ2lvbik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJzZWRfc3RhdGUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcGxvdC5zdGF0ZVtrZXldID0gcGFyc2VkX3N0YXRlW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYW4gU1ZHIHRvIHRoZSBkaXYgYW5kIHNldCBpdHMgZGltZW5zaW9uc1xuICAgICAgICBwbG90LnN2ZyA9IGQzLnNlbGVjdChgZGl2IyR7cGxvdC5pZH1gKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCd2ZXJzaW9uJywgJzEuMScpXG4gICAgICAgICAgICAuYXR0cigneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgYCR7cGxvdC5pZH1fc3ZnYClcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1sb2N1c3pvb20nKVxuICAgICAgICAgICAgLmNhbGwoYXBwbHlTdHlsZXMsIHBsb3QubGF5b3V0LnN0eWxlKTtcblxuICAgICAgICBwbG90LnNldERpbWVuc2lvbnMoKTtcbiAgICAgICAgcGxvdC5wb3NpdGlvblBhbmVscygpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBwbG90XG4gICAgICAgIHBsb3QuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAvLyBJZiB0aGUgcGxvdCBoYXMgZGVmaW5lZCBkYXRhIHNvdXJjZXMgdGhlbiB0cmlnZ2VyIGl0cyBmaXJzdCBtYXBwaW5nIGJhc2VkIG9uIHN0YXRlIHZhbHVlc1xuICAgICAgICBpZiAoZGF0YXNvdXJjZSkge1xuICAgICAgICAgICAgcGxvdC5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGxvdDtcbn1cblxuLyoqXG4gKiBQYXJzZSByZWdpb24gcXVlcmllcyBpbnRvIHRoZWlyIGNvbnN0aXR1ZW50IHBhcnRzXG4gKiBAcGFyYW0ge1N0cmluZ30geCBBIGNocm9tb3NvbWUgcG9zaXRpb24gcXVlcnkuIE1heSBiZSBhbnkgb2YgdGhlIGZvcm1zIGBjaHI6c3RhcnQtZW5kYCwgYGNocjpjZW50ZXIrb2Zmc2V0YCxcbiAqICAgb3IgYGNocjpwb3NgXG4gKiBAcmV0dXJucyB7e2NocjoqLCBzdGFydDogKiwgZW5kOip9IHwge2NocjoqLCBwb3NpdGlvbjoqfX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VQb3NpdGlvblF1ZXJ5KHgpIHtcbiAgICBjb25zdCBjaHJwb3NvZmYgPSAvXihcXHcrKTooW1xcZCwuXStba21nYktNR0JdKikoWy0rXSkoW1xcZCwuXStba21nYktNR0JdKikkLztcbiAgICBjb25zdCBjaHJwb3MgPSAvXihcXHcrKTooW1xcZCwuXStba21nYktNR0JdKikkLztcbiAgICBsZXQgbWF0Y2ggPSBjaHJwb3NvZmYuZXhlYyh4KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKG1hdGNoWzNdID09PSAnKycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IHBvc2l0aW9uU3RyaW5nVG9JbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcG9zaXRpb25TdHJpbmdUb0ludChtYXRjaFs0XSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNocjptYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBzdGFydDogY2VudGVyIC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogY2VudGVyICsgb2Zmc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBzdGFydDogcG9zaXRpb25TdHJpbmdUb0ludChtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgZW5kOiBwb3NpdGlvblN0cmluZ1RvSW50KG1hdGNoWzRdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2ggPSBjaHJwb3MuZXhlYyh4KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNocjptYXRjaFsxXSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblN0cmluZ1RvSW50KG1hdGNoWzJdKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IHBhcnNlRmllbGRzLCBwYXJzZVBvc2l0aW9uUXVlcnksIHBvcHVsYXRlLCBwb3NpdGlvbkludFRvU3RyaW5nLCBwb3NpdGlvblN0cmluZ1RvSW50LCBwcmV0dHlUaWNrcyB9O1xuIiwiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1vZGlmeWluZyBvciB3b3JraW5nIHdpdGggbGF5b3V0IG9iamVjdHNcbiAqICBAbW9kdWxlXG4gKi9cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuY29uc3Qgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG4vLyBEMyB2NSBkb2VzIG5vdCBwcm92aWRlIGEgdHJpYW5nbGUgZG93biBzeW1ib2wgc2hhcGUsIGJ1dCBpdCBpcyB2ZXJ5IHVzZWZ1bCBmb3Igc2hvd2luZyBkaXJlY3Rpb24gb2YgZWZmZWN0LlxuLy8gIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL3NyYy9zeW1ib2wvdHJpYW5nbGUuanNcbmNvbnN0IHRyaWFuZ2xlZG93biA9IHtcbiAgICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgY29uc3QgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLXkgKiAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgeSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgeSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfSxcbn07XG5cbi8qKlxuICogQXBwbHkgbmFtZXNwYWNlcyB0byBsYXlvdXQsIHJlY3Vyc2l2ZWx5XG4gKiBAcHJpdmF0ZVxuICAqL1xuZnVuY3Rpb24gYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnQsIG5hbWVzcGFjZSwgZGVmYXVsdF9uYW1lc3BhY2UpIHtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB7IGRlZmF1bHQ6IG5hbWVzcGFjZSB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXNwYWNlID0geyBkZWZhdWx0OiAnJyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmUgPSAvXFx7XFx7bmFtZXNwYWNlKFxcW1tBLVphLXpfMC05XStcXF18KVxcfVxcfS9nO1xuICAgICAgICBsZXQgbWF0Y2gsIGJhc2UsIGtleSwgcmVzb2x2ZWRfbmFtZXNwYWNlO1xuICAgICAgICBjb25zdCByZXBsYWNlID0gW107XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGVsZW1lbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmFzZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAga2V5ID0gbWF0Y2hbMV0ubGVuZ3RoID8gbWF0Y2hbMV0ucmVwbGFjZSgvKFxcW3xcXF0pL2csICcnKSA6IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlZF9uYW1lc3BhY2UgPSBkZWZhdWx0X25hbWVzcGFjZTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT0gbnVsbCAmJiB0eXBlb2YgbmFtZXNwYWNlID09ICdvYmplY3QnICYmIHR5cGVvZiBuYW1lc3BhY2Vba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkX25hbWVzcGFjZSA9IG5hbWVzcGFjZVtrZXldICsgKG5hbWVzcGFjZVtrZXldLmxlbmd0aCA/ICc6JyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2UucHVzaCh7IGJhc2U6IGJhc2UsIG5hbWVzcGFjZTogcmVzb2x2ZWRfbmFtZXNwYWNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHIgaW4gcmVwbGFjZSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZShyZXBsYWNlW3JdLmJhc2UsIHJlcGxhY2Vbcl0ubmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlX25hbWVzcGFjZSA9ICh0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2UgPT0gJ3N0cmluZycpID8geyBkZWZhdWx0OiBlbGVtZW50Lm5hbWVzcGFjZSB9IDogZWxlbWVudC5uYW1lc3BhY2U7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBtZXJnZShuYW1lc3BhY2UsIG1lcmdlX25hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWVzcGFjZWRfZWxlbWVudCwgbmFtZXNwYWNlZF9wcm9wZXJ0eTtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnbmFtZXNwYWNlJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZXNwYWNlZF9lbGVtZW50ID0gYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnRbcHJvcGVydHldLCBuYW1lc3BhY2UsIGRlZmF1bHRfbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZWRfcHJvcGVydHkgPSBhcHBseU5hbWVzcGFjZXMocHJvcGVydHksIG5hbWVzcGFjZSwgZGVmYXVsdF9uYW1lc3BhY2UpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSBuYW1lc3BhY2VkX3Byb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudFtuYW1lc3BhY2VkX3Byb3BlcnR5XSA9IG5hbWVzcGFjZWRfZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBtZXRob2QgdXNlZCBmb3IgbWVyZ2luZyB0d28gb2JqZWN0cy4gSWYgYSBrZXkgaXMgcHJlc2VudCBpbiBib3RoLCB0YWtlcyB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3Qgb2JqZWN0XG4gKiAgIFZhbHVlcyBmcm9tIGBkZWZhdWx0X2xheW91dGAgd2lsbCBiZSBjbGVhbmx5IGNvcGllZCBvdmVyLCBlbnN1cmluZyBubyByZWZlcmVuY2VzIG9yIHNoYXJlZCBzdGF0ZS5cbiAqXG4gKiBGcmVxdWVudGx5IHVzZWQgZm9yIHByZXBhcmluZyBjdXN0b20gbGF5b3V0cy4gQm90aCBvYmplY3RzIHNob3VsZCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tX2xheW91dCBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdGhhdCBvdmVycmlkZSBvciBhZGQgdG8gZGVmYXVsdHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0X2xheW91dCBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHNldHRpbmdzLlxuICogQHJldHVybnMge29iamVjdH0gVGhlIGN1c3RvbSBsYXlvdXQgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIGFsc28gcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2UoY3VzdG9tX2xheW91dCwgZGVmYXVsdF9sYXlvdXQpIHtcbiAgICBpZiAodHlwZW9mIGN1c3RvbV9sYXlvdXQgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBkZWZhdWx0X2xheW91dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2N1c1pvb20uTGF5b3V0cy5tZXJnZSBvbmx5IGFjY2VwdHMgdHdvIGxheW91dCBvYmplY3RzOyAke3R5cGVvZiBjdXN0b21fbGF5b3V0fSwgJHt0eXBlb2YgZGVmYXVsdF9sYXlvdXR9IGdpdmVuYCk7XG4gICAgfVxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIGRlZmF1bHRfbGF5b3V0KSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRfbGF5b3V0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0eXBlcyBmb3IgY29tcGFyaXNvbi4gVHJlYXQgbnVsbHMgaW4gdGhlIGN1c3RvbSBsYXlvdXQgYXMgdW5kZWZpbmVkIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAvLyAoamF2YXNjcmlwdCB0cmVhdHMgbnVsbHMgYXMgXCJvYmplY3RcIiB3aGVuIHdlIGp1c3Qgd2FudCB0byBvdmVyd3JpdGUgdGhlbSBhcyBpZiB0aGV5J3JlIHVuZGVmaW5lZClcbiAgICAgICAgLy8gQWxzbyBzZXBhcmF0ZSBhcnJheXMgZnJvbSBvYmplY3RzIGFzIGEgZGlzY3JldGUgdHlwZS5cbiAgICAgICAgbGV0IGN1c3RvbV90eXBlID0gY3VzdG9tX2xheW91dFtwcm9wZXJ0eV0gPT09IG51bGwgPyAndW5kZWZpbmVkJyA6IHR5cGVvZiBjdXN0b21fbGF5b3V0W3Byb3BlcnR5XTtcbiAgICAgICAgbGV0IGRlZmF1bHRfdHlwZSA9IHR5cGVvZiBkZWZhdWx0X2xheW91dFtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChjdXN0b21fdHlwZSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShjdXN0b21fbGF5b3V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGN1c3RvbV90eXBlID0gJ2FycmF5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdF90eXBlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KGRlZmF1bHRfbGF5b3V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdHlwZSA9ICdhcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5zdXBwb3J0ZWQgcHJvcGVydHkgdHlwZXM6IHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgICBpZiAoY3VzdG9tX3R5cGUgPT09ICdmdW5jdGlvbicgfHwgZGVmYXVsdF90eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY3VzWm9vbS5MYXlvdXRzLm1lcmdlIGVuY291bnRlcmVkIGFuIHVuc3VwcG9ydGVkIHByb3BlcnR5IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmRlZmluZWQgY3VzdG9tIHZhbHVlOiBwdWxsIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIChjdXN0b21fdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGN1c3RvbV9sYXlvdXRbcHJvcGVydHldID0gZGVlcENvcHkoZGVmYXVsdF9sYXlvdXRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdGggdmFsdWVzIGFyZSBvYmplY3RzOiBtZXJnZSByZWN1cnNpdmVseVxuICAgICAgICBpZiAoY3VzdG9tX3R5cGUgPT09ICdvYmplY3QnICYmIGRlZmF1bHRfdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGN1c3RvbV9sYXlvdXRbcHJvcGVydHldID0gbWVyZ2UoY3VzdG9tX2xheW91dFtwcm9wZXJ0eV0sIGRlZmF1bHRfbGF5b3V0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VzdG9tX2xheW91dDtcbn1cblxuZnVuY3Rpb24gZGVlcENvcHkoaXRlbSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG5hbWUgdG8gc3ltYm9sXG4gKiBMYXlvdXQgb2JqZWN0cyBhY2NlcHQgc3ltYm9sIG5hbWVzIGFzIHN0cmluZ3MgKGNpcmNsZSwgdHJpYW5nbGUsIGV0YykuIENvbnZlcnQgdG8gc3ltYm9sIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gQW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyBhIGRyYXcgbWV0aG9kIChlZyBkMy1zaGFwZSBzeW1ib2xzIG9yIGV4dHJhIExaIGl0ZW1zKVxuICovXG5mdW5jdGlvbiBuYW1lVG9TeW1ib2woc2hhcGUpIHtcbiAgICBpZiAoIXNoYXBlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZWRvd24nKSB7XG4gICAgICAgIC8vIEQzIGRvZXMgbm90IHByb3ZpZGUgdGhpcyBzeW1ib2wgbmF0aXZlbHlcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlZG93bjtcbiAgICB9XG4gICAgLy8gTGVnZW5kIHNoYXBlIG5hbWVzIGFyZSBzdHJpbmdzOyBuZWVkIHRvIGNvbm5lY3QgdGhpcyB0byBmYWN0b3J5LiBFZyBjaXJjbGUgLS0+IGQzLnN5bWJvbENpcmNsZVxuICAgIGNvbnN0IGZhY3RvcnlfbmFtZSA9IGBzeW1ib2wke3NoYXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2hhcGUuc2xpY2UoMSl9YDtcbiAgICByZXR1cm4gZDNbZmFjdG9yeV9uYW1lXSB8fCBudWxsO1xufVxuXG5leHBvcnQgeyBhcHBseU5hbWVzcGFjZXMsIGRlZXBDb3B5LCBtZXJnZSwgbmFtZVRvU3ltYm9sIH07XG4iLCIvKipcbiBIZWxwZXIgZnVuY3Rpb25zIHRhcmdldGVkIGF0IHJlbmRlcmluZyBvcGVyYXRpb25zXG4qL1xuXG5cbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSBmdW5jdGlvbiBhaW1lZCBhdCBzY2F0dGVyIHBsb3RzOiBhdHRlbXB0cyB0byBjb2FsZXNjZSBcImxvdy1zaWduaWZpY2FuY2VcIiBTTlBzIHRoYXQgYXJlIHRvbyBjbG9zZSB0b1xuICogIHZpc3VhbGx5IGRpc3Rpbmd1aXNoLCB0aHVzIGNyZWF0aW5nIGEgZGF0YXNldCB3aXRoIGZld2VyIHBvaW50cyB0aGF0IGNhbiBiZSByZW5kZXJlZCBtb3JlIHF1aWNrbHkuXG4gKlxuICogIFRoaXMgZGVwZW5kcyBvbiB0aGUgc3Ryb25nIGFuZCBleHBsaWNpdCBhc3N1bXB0aW9uIHRoYXQgcG9pbnRzIGFyZSBvcmRlcmVkICh0eXBpY2FsbHkgaW4geCBwb3NpdGlvbiksIHNvIHRoYXRcbiAqICAgIG5lYXJieSBwb2ludHMgY2FuIGJlIGdyb3VwZWQgYnkgaXRlcmF0aW5nIG92ZXIgdGhlIGRhdGEgaW4gc2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YSBQbG90IGRhdGEsIGFubm90YXRlZCB3aXRoIGNhbGN1bGF0ZWQgYHhjYCBhbmQgYHljYCBzeW1ib2xzIGZvciB4IGFuZCB5IGNvb3JkaW5hdGVzIChpbiBweCkuXG4gKiBAcGFyYW0ge051bWJlcn0geF9taW4gVGhlIHNtYWxsZXN0IHggdmFsdWUgb2YgYW4gXCJpbnNpZ25pZmljYW50IHJlZ2lvblwiIHJlY3RhbmdsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhfbWF4IFRoZSBsYXJnZXN0IHggdmFsdWUgb2YgYW4gXCJpbnNpZ25pZmljYW50IHJlZ2lvblwiIHJlY3RhbmdsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhfZ2FwIE1heCBweCBkaXN0YW5jZSwgaW4geCBkaXJlY3Rpb24sIGZyb20gdGhlIGZpcnN0IHBvaW50IGluIGEgc2V0LCB0byBxdWFsaWZ5IGZvciBncm91cGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IHlfbWluIFRoZSBzbWFsbGVzdCB5IHZhbHVlIG9mIGFuIFwiaW5zaWduaWZpY2FudCByZWdpb25cIiByZWN0YW5nbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB5X21heCBUaGUgbGFyZ2VzdCB5IHZhbHVlIG9mIGFuIFwiaW5zaWduaWZpY2FudCByZWdpb25cIiByZWN0YW5nbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB5X2dhcCBNYXggcHggZGlzdGFuY2UsIGluIHkgZGlyZWN0aW9uLCBmcm9tIHRoZSBmaXJzdCBwb2ludCBpbiBhIHNldCwgdG8gcXVhbGlmeSBmb3IgZ3JvdXBpbmdcbiAqIEByZXR1cm4ge09iamVjdFtdfSBUaGUgc2ltcGxpZmllZCBkYXRhc2V0IHdpdGggZmV3ZXIgcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIGNvYWxlc2NlX3NjYXR0ZXJfcG9pbnRzIChkYXRhLCB4X21pbiwgeF9tYXgsIHhfZ2FwLCB5X21pbiwgeV9tYXgsIHlfZ2FwKSB7XG4gICAgbGV0IGZpbmFsX2RhdGEgPSBbXTtcblxuICAgIGNvbnN0IHhjcyA9IFN5bWJvbC5mb3IoJ2x6WCcpO1xuICAgIGNvbnN0IHljcyA9IFN5bWJvbC5mb3IoJ2x6WScpO1xuXG4gICAgbGV0IHhfc3RhcnQgPSBudWxsO1xuICAgIGxldCB5X3N0YXJ0ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudF9ncm91cCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gX2NvbWJpbmUgKCkge1xuICAgICAgICBpZiAoY3VycmVudF9ncm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBwb2ludHMgbmVhciBlYWNoIG90aGVyLCByZXR1cm4gdGhlIG1pZGRsZSBpdGVtIHRvIHJlcHJlc2VudCB0aGUgZ3JvdXBcbiAgICAgICAgICAgIC8vIFdlIHVzZSBhIHJlYWwgcG9pbnQgKHJhdGhlciB0aGFuIGEgc3ludGhldGljIGF2ZXJhZ2UgcG9pbnQpIHRvIGJlc3QgaGFuZGxlIGV4dHJhIGZpZWxkc1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGN1cnJlbnRfZ3JvdXBbTWF0aC5mbG9vcigoY3VycmVudF9ncm91cC5sZW5ndGggLSAxKSAvIDIpXTtcbiAgICAgICAgICAgIGZpbmFsX2RhdGEucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB4X3N0YXJ0ID0geV9zdGFydCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRfZ3JvdXAgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3RhcnRfcnVuKHgsIHksIGl0ZW0pIHtcbiAgICAgICAgeF9zdGFydCA9IHg7XG4gICAgICAgIHlfc3RhcnQgPSB5O1xuICAgICAgICBjdXJyZW50X2dyb3VwLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpdGVtW3hjc107XG4gICAgICAgIGNvbnN0IHkgPSBpdGVtW3ljc107XG5cbiAgICAgICAgY29uc3QgaW5fY29tYmluZV9yZWdpb24gPSAoeCA+PSB4X21pbiAmJiB4IDw9IHhfbWF4ICYmIHkgPj0geV9taW4gJiYgeSA8PSB5X21heCk7XG4gICAgICAgIGlmIChpdGVtLmx6X2hpZ2hsaWdodF9tYXRjaCB8fCAhaW5fY29tYmluZV9yZWdpb24pIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGl0ZW0gaXMgbWFya2VkIGFzIGludGVyZXN0aW5nIGluIHNvbWUgd2F5LCBhbHdheXMgcmVuZGVyIGl0IGV4cGxpY2l0bHlcbiAgICAgICAgICAgIC8vIChhbmQgY29hbGVzY2UgdGhlIHByZWNlZGluZyBwb2ludHMgaWYgYSBydW4gd2FzIGluIHByb2dyZXNzLCB0byBwcmVzZXJ2ZSBvcmRlcmluZylcbiAgICAgICAgICAgIF9jb21iaW5lKCk7XG4gICAgICAgICAgICBmaW5hbF9kYXRhLnB1c2goaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeF9zdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgbm90IHRyYWNraW5nIGEgZ3JvdXAsIHN0YXJ0IHRyYWNraW5nXG4gICAgICAgICAgICBfc3RhcnRfcnVuKHgsIHksIGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZGVjaXNpb24gdG8gcmVuZGVyIHRoZSBwb2ludCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgY2xvc2UgdG8gYSBydW4gb2Ygb3RoZXJcbiAgICAgICAgICAgIC8vICBpbnNpZ25pZmljYW50IHBvaW50c1xuICAgICAgICAgICAgY29uc3QgbmVhcl9wcmlvciA9IE1hdGguYWJzKHggLSB4X3N0YXJ0KSA8PSB4X2dhcCAmJiBNYXRoLmFicyh5IC0geV9zdGFydCkgPD0geV9nYXA7XG5cbiAgICAgICAgICAgIGlmIChuZWFyX3ByaW9yKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9ncm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBcImlmIGluIGNvbWJpbmUgcmVnaW9uLCBhbmQgbm90IG5lYXIgYSBwcmlvciBwb2ludCwgY29hbGVzY2UgYWxsIHByaW9yIGl0ZW1zLCB0aGVuIHRyYWNrIHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyAgYXMgcGFydCBvZiB0aGUgbmV4dCBydW4gdGhhdCBjb3VsZCBiZSBncm91cGVkXCJcbiAgICAgICAgICAgICAgICBfY29tYmluZSgpO1xuICAgICAgICAgICAgICAgIF9zdGFydF9ydW4oeCwgeSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBdCB0aGUgZW5kIG9mIHRoZSBkYXRhc2V0LCBjaGVjayB3aGV0aGVyIGFueSBydW5zIG9mIGFkamFjZW50IHBvaW50cyB3ZXJlIGluIHByb2dyZXNzLCBhbmQgY29hbGVzY2UgaWYgc29cbiAgICBfY29tYmluZSgpO1xuXG4gICAgcmV0dXJuIGZpbmFsX2RhdGE7XG59XG5cbmV4cG9ydCB7IGNvYWxlc2NlX3NjYXR0ZXJfcG9pbnRzIH07XG4iLCIvKipcbiAqIERlZmluZSBmdW5jdGlvbnMgdXNlZCBieSBTY2FsYWJsZSBMYXlvdXQgRGlyZWN0aXZlcy5cbiAqXG4gKiBUaGVzZSBcInNjYWxpbmcgZnVuY3Rpb25zXCIgYXJlIHVzZWQgZHVyaW5nIHJlbmRlcmluZyB0byByZXR1cm4gb3V0cHV0IChlZyBjb2xvcikgYmFzZWQgb24gaW5wdXQgdmFsdWVcbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cbi8qKlxuICogQmFzaWMgY29uZGl0aW9uYWwgZnVuY3Rpb24gdG8gZXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZCBhbmQgcmV0dXJuIGJhc2VkIG9uIGVxdWFsaXR5LlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Kn0gcGFyYW1ldGVycy5maWVsZF92YWx1ZSBUaGUgdmFsdWUgYWdhaW5zdCB3aGljaCB0byB0ZXN0IHRoZSBpbnB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gcGFyYW1ldGVycy50aGVuIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIGZpZWxkIHZhbHVlXG4gKiBAcGFyYW0geyp9IHBhcmFtZXRlcnMuZWxzZSAgVGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgaW5wdXQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGZpZWxkIHZhbHVlLiBPcHRpb25hbC4gSWYgbm90XG4gKiAgIGRlZmluZWQgdGhpcyBzY2FsZSBmdW5jdGlvbiB3aWxsIHJldHVybiBudWxsIChvciB2YWx1ZSBvZiBudWxsX3ZhbHVlIHBhcmFtZXRlciwgaWYgZGVmaW5lZCkgd2hlbiBpbnB1dCB2YWx1ZSBmYWlsc1xuICogICB0byBtYXRjaCBmaWVsZF92YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdmFsdWVcbiAqL1xuY29uc3QgaWZfdmFsdWUgPSAocGFyYW1ldGVycywgaW5wdXQpID0+IHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09ICd1bmRlZmluZWQnIHx8IHBhcmFtZXRlcnMuZmllbGRfdmFsdWUgIT09IGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycy5lbHNlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5lbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy50aGVuO1xuICAgIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gc29ydCBudW1lcmljYWwgdmFsdWVzIGludG8gYmlucyBiYXNlZCBvbiBudW1lcmljYWwgYnJlYWsgcG9pbnRzLiBXaWxsIG9ubHkgb3BlcmF0ZSBvbiBudW1iZXJzIGFuZFxuICogICByZXR1cm4gbnVsbCAob3IgdmFsdWUgb2YgbnVsbF92YWx1ZSBwYXJhbWV0ZXIsIGlmIGRlZmluZWQpIGlmIHByb3ZpZGVkIGEgbm9uLW51bWVyaWMgaW5wdXQgdmFsdWUuIFBhcmFtZXRlcnM6XG4gKiBAZnVuY3Rpb24gbnVtZXJpY2FsX2JpblxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7TnVtYmVyW119IHBhcmFtZXRlcnMuYnJlYWtzICBBcnJheSBvZiBudW1lcmljYWwgYnJlYWsgcG9pbnRzIGFnYWluc3Qgd2hpY2ggdG8gZXZhbHVhdGUgdGhlIGlucHV0IHZhbHVlLlxuICogICBNdXN0IGJlIG9mIGVxdWFsIGxlbmd0aCB0byB2YWx1ZXMgcGFyYW1ldGVyLiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGJyZWFrIG4gYW5kIGxlc3MgdGhhblxuICogICBvciBlcXVhbCB0byBicmVhayBuKzEgKG9yIGJyZWFrIG4rMSBkb2Vzbid0IGV4aXN0KSB0aGVuIHJldHVybmVkIHZhbHVlIGlzIHRoZSBudGggZW50cnkgaW4gdGhlIHZhbHVlcyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbWV0ZXJzLnZhbHVlcyAgQXJyYXkgb2YgdmFsdWVzIHRvIHJldHVybiBnaXZlbiBldmFsdWF0aW9ucyBhZ2FpbnN0IGJyZWFrIHBvaW50cy4gTXVzdCBiZSBvZlxuICogICBlcXVhbCBsZW5ndGggdG8gYnJlYWtzIHBhcmFtZXRlci4gRWFjaCBlbnRyeSBuIHJlcHJlc2VudHMgdGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuXG4gKiAgIG9yIGVxdWFsIHRvIGJyZWFrIG4gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBicmVhayBuKzEgKG9yIGJyZWFrIG4rMSBkb2Vzbid0IGV4aXN0KS5cbiAqIEBwYXJhbSB7Kn0gcGFyYW1ldGVycy5udWxsX3ZhbHVlXG4gKiBAcGFyYW0geyp9IGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuY29uc3QgbnVtZXJpY2FsX2JpbiA9IChwYXJhbWV0ZXJzLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IGJyZWFrcyA9IHBhcmFtZXRlcnMuYnJlYWtzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlcyA9IHBhcmFtZXRlcnMudmFsdWVzIHx8IFtdO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gJ3VuZGVmaW5lZCcgfHwgaW5wdXQgPT09IG51bGwgfHwgaXNOYU4oK2lucHV0KSkge1xuICAgICAgICByZXR1cm4gKHBhcmFtZXRlcnMubnVsbF92YWx1ZSA/IHBhcmFtZXRlcnMubnVsbF92YWx1ZSA6IG51bGwpO1xuICAgIH1cbiAgICBjb25zdCB0aHJlc2hvbGQgPSBicmVha3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgIGlmICgraW5wdXQgPCBwcmV2IHx8ICgraW5wdXQgPj0gcHJldiAmJiAraW5wdXQgPCBjdXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXNbYnJlYWtzLmluZGV4T2YodGhyZXNob2xkKV07XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIHNvcnQgdmFsdWVzIG9mIGFueSB0eXBlIGludG8gYmlucyBiYXNlZCBvbiBkaXJlY3QgZXF1YWxpdHkgdGVzdGluZyB3aXRoIGEgbGlzdCBvZiBjYXRlZ29yaWVzLlxuICogICBXaWxsIHJldHVybiBudWxsIGlmIHByb3ZpZGVkIGFuIGlucHV0IHZhbHVlIHRoYXQgZG9lcyBub3QgbWF0Y2ggdG8gYSBsaXN0ZWQgY2F0ZWdvcnkuXG4gKiBAZnVuY3Rpb24gY2F0ZWdvcmljYWxfYmluXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1ldGVycy5jYXRlZ29yaWVzICBBcnJheSBvZiB2YWx1ZXMgYWdhaW5zdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgaW5wdXQgdmFsdWUuIE11c3QgYmUgb2YgZXF1YWxcbiAqICAgbGVuZ3RoIHRvIHZhbHVlcyBwYXJhbWV0ZXIuIElmIHRoZSBpbnB1dCB2YWx1ZSBpcyBlcXVhbCB0byBjYXRlZ29yeSBuIHRoZW4gcmV0dXJuZWQgdmFsdWUgaXMgdGhlIG50aCBlbnRyeSBpbiB0aGVcbiAqICAgdmFsdWVzIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtZXRlcnMudmFsdWVzICBBcnJheSBvZiB2YWx1ZXMgdG8gcmV0dXJuIGdpdmVuIGV2YWx1YXRpb25zIGFnYWluc3QgY2F0ZWdvcmllcy4gTXVzdCBiZSBvZiBlcXVhbFxuICogICBsZW5ndGggdG8gY2F0ZWdvcmllcyBwYXJhbWV0ZXIuIEVhY2ggZW50cnkgbiByZXByZXNlbnRzIHRoZSB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIGlucHV0IHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBudGhcbiAqICAgdmFsdWUgaW4gdGhlIGNhdGVnb3JpZXMgcGFyYW1ldGVyLlxuICogQHBhcmFtIHsqfSBwYXJhbWV0ZXJzLm51bGxfdmFsdWUgIFZhbHVlIHRvIHJldHVybiBpZiB0aGUgaW5wdXQgdmFsdWUgZmFpbHMgdG8gbWF0Y2ggdG8gYW55IGNhdGVnb3JpZXMuIE9wdGlvbmFsLlxuICovXG5jb25zdCBjYXRlZ29yaWNhbF9iaW4gPSAocGFyYW1ldGVycywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnIHx8ICFwYXJhbWV0ZXJzLmNhdGVnb3JpZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAocGFyYW1ldGVycy5udWxsX3ZhbHVlID8gcGFyYW1ldGVycy5udWxsX3ZhbHVlIDogbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMudmFsdWVzW3BhcmFtZXRlcnMuY2F0ZWdvcmllcy5pbmRleE9mKHZhbHVlKV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBDeWNsZSB0aHJvdWdoIGEgc2V0IG9mIG9wdGlvbnMsIHNvIHRoYXQgdGhlIGVhY2ggZWxlbWVudCBpbiBhIHNldCBvZiBkYXRhIHJlY2VpdmVzIGEgdmFsdWUgZGlmZmVyZW50IHRoYW4gdGhlXG4gKiAgZWxlbWVudCBiZWZvcmUgaXQuIEZvciBleGFtcGxlOiBcInVzZSB0aGlzIHBhbGV0dGUgb2YgMTAgY29sb3JzIHRvIHZpc3VhbGx5IGRpc3Rpbmd1aXNoIDEwMCBhZGphY2VudCBpdGVtc1wiXG4gKiAgQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnNcbiAqICBAcGFyYW0ge0FycmF5fSBwYXJhbWV0ZXJzLnZhbHVlcyBBIGxpc3Qgb2Ygb3B0aW9uIHZhbHVlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuY29uc3Qgb3JkaW5hbF9jeWNsZSA9IChwYXJhbWV0ZXJzLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtZXRlcnMudmFsdWVzO1xuICAgIHJldHVybiBvcHRpb25zW2luZGV4ICUgb3B0aW9ucy5sZW5ndGhdO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBmb3IgY29udGludW91cyBpbnRlcnBvbGF0aW9uIG9mIG51bWVyaWNhbCB2YWx1ZXMgYWxvbmcgYSBncmFkaWVudCB3aXRoIGFyYml0cmFyaWx5IG1hbnkgYnJlYWsgcG9pbnRzLlxuICogQGZ1bmN0aW9uIGludGVycG9sYXRlXG4gKiBAcGFyYW1ldGVycyB7T2JqZWN0fSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW1ldGVycyB7TnVtYmVyW119IHBhcmFtZXRlcnMuYnJlYWtzICBBcnJheSBvZiBudW1lcmljYWwgYnJlYWsgcG9pbnRzIGFnYWluc3Qgd2hpY2ggdG8gZXZhbHVhdGUgdGhlIGlucHV0IHZhbHVlLlxuICogICBNdXN0IGJlIG9mIGVxdWFsIGxlbmd0aCB0byB2YWx1ZXMgcGFyYW1ldGVyIGFuZCBjb250YWluIGF0IGxlYXN0IHR3byBlbGVtZW50cy4gSW5wdXQgdmFsdWUgd2lsbCBiZSBldmFsdWF0ZWQgZm9yXG4gKiAgIHJlbGF0aXZlIHBvc2l0aW9uIGJldHdlZW4gdHdvIGJyZWFrIHBvaW50cyBuIGFuZCBuKzEgYW5kIHRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGludGVycG9sYXRlZCBhdCBhIHJlbGF0aXZlXG4gKiAgIHBvc2l0aW9uIGJldHdlZW4gdmFsdWVzIG4gYW5kIG4rMS5cbiAqIEBwYXJhbWV0ZXJzIHsqW119IHBhcmFtZXRlcnMudmFsdWVzICBBcnJheSBvZiB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgYW5kIHJldHVybiBnaXZlbiBldmFsdWF0aW9ucyBhZ2FpbnN0IGJyZWFrXG4gKiAgIHBvaW50cy4gTXVzdCBiZSBvZiBlcXVhbCBsZW5ndGggdG8gYnJlYWtzIHBhcmFtZXRlciBhbmQgY29udGFpbiBhdCBsZWFzdCB0d28gZWxlbWVudHMuIEVhY2ggZW50cnkgbiByZXByZXNlbnRzXG4gKiAgIHRoZSB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIG50aCBlbnRyeSBpbiBicmVha3MgZXhhY3RseS4gTm90ZSB0aGF0IHRoaXMgc2NhbGUgZnVuY3Rpb25cbiAqICAgdXNlcyBkMy5pbnRlcnBvbGF0ZSB0byBwcm92aWRlIGZvciBlZmZlY3RpdmUgaW50ZXJwb2xhdGlvbiBvZiBtYW55IGRpZmZlcmVudCB2YWx1ZSB0eXBlcywgaW5jbHVkaW5nIG51bWJlcnMsXG4gKiAgIGNvbG9ycywgc2hhcGVzLCBldGMuXG4gKiBAcGFyYW1ldGVycyB7Kn0gcGFyYW1ldGVycy5udWxsX3ZhbHVlXG4gKi9cbmNvbnN0IGludGVycG9sYXRlID0gKHBhcmFtZXRlcnMsIGlucHV0KSA9PiB7XG4gICAgdmFyIGJyZWFrcyA9IHBhcmFtZXRlcnMuYnJlYWtzIHx8IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBwYXJhbWV0ZXJzLnZhbHVlcyB8fCBbXTtcbiAgICB2YXIgbnVsbHZhbCA9IChwYXJhbWV0ZXJzLm51bGxfdmFsdWUgPyBwYXJhbWV0ZXJzLm51bGxfdmFsdWUgOiBudWxsKTtcbiAgICBpZiAoYnJlYWtzLmxlbmd0aCA8IDIgfHwgYnJlYWtzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbHZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PSAndW5kZWZpbmVkJyB8fCBpbnB1dCA9PT0gbnVsbCB8fCBpc05hTigraW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBudWxsdmFsO1xuICAgIH1cbiAgICBpZiAoK2lucHV0IDw9IHBhcmFtZXRlcnMuYnJlYWtzWzBdKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgfSBlbHNlIGlmICgraW5wdXQgPj0gcGFyYW1ldGVycy5icmVha3NbcGFyYW1ldGVycy5icmVha3MubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1ticmVha3MubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHVwcGVyX2lkeCA9IG51bGw7XG4gICAgICAgIGJyZWFrcy5mb3JFYWNoKGZ1bmN0aW9uIChicmssIGlkeCkge1xuICAgICAgICAgICAgaWYgKCFpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJlYWtzW2lkeCAtIDFdIDw9ICtpbnB1dCAmJiBicmVha3NbaWR4XSA+PSAraW5wdXQpIHtcbiAgICAgICAgICAgICAgICB1cHBlcl9pZHggPSBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXBwZXJfaWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbHZhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWxpemVkX2lucHV0ID0gKCtpbnB1dCAtIGJyZWFrc1t1cHBlcl9pZHggLSAxXSkgLyAoYnJlYWtzW3VwcGVyX2lkeF0gLSBicmVha3NbdXBwZXJfaWR4IC0gMV0pO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG5vcm1hbGl6ZWRfaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDMuaW50ZXJwb2xhdGUodmFsdWVzW3VwcGVyX2lkeCAtIDFdLCB2YWx1ZXNbdXBwZXJfaWR4XSkobm9ybWFsaXplZF9pbnB1dCk7XG4gICAgfVxufTtcblxuXG5leHBvcnQgeyBjYXRlZ29yaWNhbF9iaW4sIGlmX3ZhbHVlLCBpbnRlcnBvbGF0ZSwgbnVtZXJpY2FsX2Jpbiwgb3JkaW5hbF9jeWNsZSB9O1xuIiwiLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnM6IHVzZWQgdG8gdHJhbnNmb3JtIGEgcmF3IHZhbHVlIGZyb20gdGhlIEFQSS4gRm9yIGV4YW1wbGUsIGEgdGVtcGxhdGUgb3IgYXhpcyBsYWJlbFxuICogIGNhbiBjb252ZXJ0IGZyb20gcHZhbHVlIHRvIC1sb2cxMHB2YWx1ZVxuICogQG1vZHVsZVxuICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb2cxMCBvZiBhIHZhbHVlLiBDYW4gYmUgY29tcG9zZWQgZm9yLCBlZywgbG9nbG9nIHBsb3RzLlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIHtudWxsfG51bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZzEwICh2YWx1ZSkge1xuICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIC1sb2cgKGJhc2UgMTApLCBhIGNvbW1vbiBtZWFucyBvZiByZXByZXNlbnRpbmcgcHZhbHVlcyBpbiBsb2N1c3pvb20gcGxvdHNcbiAqIEBmdW5jdGlvbiBuZWdsb2cxMFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnbG9nMTAgKHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLU1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIGZyb20gbG9nYXJpdGhtIHRvIHNjaWVudGlmaWMgbm90YXRpb24uIFVzZWZ1bCBmb3IsIGVnLCBhIGRhdGFzb3VyY2UgdGhhdCByZXR1cm5zIC1sb2cocCkgYnkgZGVmYXVsdFxuICogQGZ1bmN0aW9uIGxvZ3Rvc2Npbm90YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ3Rvc2Npbm90YXRpb24gKHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzEnO1xuICAgIH1cbiAgICBjb25zdCBleHAgPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgIGNvbnN0IGRpZmYgPSBleHAgLSB2YWx1ZTtcbiAgICBjb25zdCBiYXNlID0gTWF0aC5wb3coMTAsIGRpZmYpO1xuICAgIGlmIChleHAgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIChiYXNlIC8gMTApLnRvRml4ZWQoNCk7XG4gICAgfSBlbHNlIGlmIChleHAgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIChiYXNlIC8gMTAwKS50b0ZpeGVkKDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtiYXNlLnRvRml4ZWQoMil9IMOXIDEwXi0ke2V4cH1gO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBudW1iZXIgaW4gc2NpZW50aWZpYyBub3RhdGlvblxuICogQGZ1bmN0aW9uIHNjaW5vdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2lub3RhdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnTmFOJztcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuXG4gICAgY29uc3QgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuICAgIGxldCBsb2c7XG4gICAgaWYgKGFicyA+IDEpIHtcbiAgICAgICAgbG9nID0gTWF0aC5jZWlsKE1hdGgubG9nKGFicykgLyBNYXRoLkxOMTApO1xuICAgIH0gZWxzZSB7ICAvLyAwLi4uMVxuICAgICAgICBsb2cgPSBNYXRoLmZsb29yKE1hdGgubG9nKGFicykgLyBNYXRoLkxOMTApO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMobG9nKSA8PSAzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0V4cG9uZW50aWFsKDIpLnJlcGxhY2UoJysnLCAnJykucmVwbGFjZSgnZScsICcgw5cgMTBeJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhUTUwtZXNjYXBlIHVzZXIgZW50ZXJlZCB2YWx1ZXMgZm9yIHVzZSBpbiBjb25zdHJ1Y3RlZCBIVE1MIGZyYWdtZW50c1xuICpcbiAqIEZvciBleGFtcGxlLCB0aGlzIGZpbHRlciBjYW4gYmUgdXNlZCBvbiB0b29sdGlwcyB3aXRoIGN1c3RvbSBIVE1MIGRpc3BsYXlcbiAqIEBmdW5jdGlvbiBodG1sZXNjYXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgSFRNTC1lc2NhcGUgdGhlIHByb3ZpZGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sZXNjYXBlICh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWydcIjw+JmBdL2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuICcmIzAzOTsnO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICcmbHQ7JztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJyZndDsnO1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuICAgICAgICBjYXNlICdgJzpcbiAgICAgICAgICAgIHJldHVybiAnJiN4NjA7JztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIFVSTC1lbmNvZGUgdGhlIHByb3ZpZGVkIHRleHQsIGVnIGZvciBjb25zdHJ1Y3RpbmcgaHlwZXJsaW5rc1xuICogQGZ1bmN0aW9uIHVybGVuY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cmxlbmNvZGUgKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG59XG4iLCIvKipcbiAqIENvbXBhdGliaWxpdHkgbGF5ZXI6IGV4cG9zZSBzeW1ib2xzIHZpYSBVTUQgbW9kdWxlIHRvIG1hdGNoIHRoZSBvbGQgTG9jdXNab29tIEFQSVxuICogQSBsaWJyYXJ5IHVzaW5nIHRoaXMgZmlsZSB3aWxsIG5lZWQgdG8gbG9hZCBgbG9jdXN6b29tLmNzc2Agc2VwYXJhdGVseS5cbiAqL1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi92ZXJzaW9uJztcblxuaW1wb3J0IHtkZWZhdWx0IGFzIERhdGFTb3VyY2VzfSBmcm9tICcuL2RhdGEnO1xuaW1wb3J0IHsgcG9wdWxhdGUgfSBmcm9tICcuL2hlbHBlcnMvZGlzcGxheSc7XG5cbmltcG9ydCB7XG4gICAgQURBUFRFUlMgYXMgQWRhcHRlcnMsXG4gICAgREFUQV9MQVlFUlMgYXMgRGF0YUxheWVycyxcbiAgICBXSURHRVRTIGFzIFdpZGdldHMsXG4gICAgTEFZT1VUUyBhcyBMYXlvdXRzLFxuICAgIFNDQUxBQkxFIGFzIFNjYWxlRnVuY3Rpb25zLFxuICAgIFRSQU5TRk9STVMgYXMgVHJhbnNmb3JtYXRpb25GdW5jdGlvbnMsXG59IGZyb20gJy4vcmVnaXN0cnknO1xuXG5cbmNvbnN0IExvY3VzWm9vbSA9IHtcbiAgICB2ZXJzaW9uLFxuICAgIC8vIEhlbHBlcnMgZm9yIGNyZWF0aW5nIHBsb3RzLSB0aGUgbWFpbiBwdWJsaWMgaW50ZXJmYWNlIGZvciBtb3N0IHVzZSBjYXNlc1xuICAgIHBvcHVsYXRlLFxuICAgIERhdGFTb3VyY2VzLFxuICAgIC8vIFJlZ2lzdHJpZXMgZm9yIHBsdWdpbiBzeXN0ZW1cbiAgICBBZGFwdGVycyxcbiAgICBEYXRhTGF5ZXJzLFxuICAgIExheW91dHMsXG4gICAgU2NhbGVGdW5jdGlvbnMsXG4gICAgVHJhbnNmb3JtYXRpb25GdW5jdGlvbnMsXG4gICAgV2lkZ2V0cyxcblxuICAgIGdldCBLbm93bkRhdGFTb3VyY2VzKCkgeyAvLyBCYWNrd2FyZHMtIGNvbXBhdGliaWxpdHkgYWxpYXNcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiBLbm93bkRhdGFTb3VyY2VzIGhhcyBiZWVuIHJlbmFtZWQgdG8gXCJBZGFwdGVyc1wiJyk7XG4gICAgICAgIHJldHVybiBBZGFwdGVycztcbiAgICB9LFxufTtcblxuXG4vKipcbiAqIEBjYWxsYmFjayBwbHVnaW5DYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IExvY3VzWm9vbSBUaGUgZ2xvYmFsIExvY3VzWm9vbSBvYmplY3RcbiAqL1xuXG5cbmNvbnN0IElOU1RBTExFRF9QTFVHSU5TID0gW107XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7cGx1Z2luQ2FsbGJhY2t9IHBsdWdpbiBUaGUgcGx1Z2luIHNob3VsZCBiZSBhIG1vZHVsZSB0aGF0IGV4cG9ydHMgdGhlIGZ1bmN0aW9uIGFzIGVpdGhlciB0aGUgZGVmYXVsdCBleHBvcnQsXG4gKiAgb3IgYXMgYSBtZW1iZXIgbmFtZWQgXCJpbnN0YWxsXCJcbiAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgcGx1Z2luXG4gKi9cbkxvY3VzWm9vbS51c2UgPSBmdW5jdGlvbihwbHVnaW4sIC4uLmFyZ3MpIHtcbiAgICAvLyBEZWxpYmVyYXRlbHkgc2ltaWxhciBpbXBsZW1lbnRhdGlvbiB0byBWdWUuanMgLnVzZSgpIHBsdWdpbiBzeXN0ZW1cbiAgICBpZiAoSU5TVEFMTEVEX1BMVUdJTlMuaW5jbHVkZXMocGx1Z2luKSkge1xuICAgICAgICAvLyBBdm9pZCBkb3VibGUtaW5zdGFsbGF0aW9uIG9mIGEgcGx1Z2luXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcmdzLnVuc2hpZnQoTG9jdXNab29tKTsgLy8gQWxsIHBsdWdpbnMgYXJlIHBhc3NlZCBhIHJlZmVyZW5jZSB0byBMb2N1c1pvb20gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gbXVzdCBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBMb2N1c1pvb20gb2JqZWN0IGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIElOU1RBTExFRF9QTFVHSU5TLnB1c2gocGx1Z2luKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTG9jdXNab29tO1xuIiwiLyoqXG4gKiBQcmVkZWZpbmVkIGJhc2UgbGF5b3V0cyB1c2VkIHRvIHBvcHVsYXRlIHRoZSBMWiByZWdpc3RyeVxuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgdmVyc2lvbiBmcm9tICcuLi92ZXJzaW9uJztcbmltcG9ydCB7ZGVlcENvcHksIG1lcmdlfSBmcm9tICcuLi9oZWxwZXJzL2xheW91dHMnO1xuXG5jb25zdCBMWl9TSUdfVEhSRVNIT0xEX0xPR1AgPSA3LjMwMTsgLy8gLWxvZzEwKC4wNS8xZTYpXG5cbi8qKlxuICogVG9vbHRpcCBMYXlvdXRzXG4gKi9cbmNvbnN0IHN0YW5kYXJkX2Fzc29jaWF0aW9uX3Rvb2x0aXAgPSB7XG4gICAgbmFtZXNwYWNlOiB7ICdhc3NvYyc6ICdhc3NvYycgfSxcbiAgICBjbG9zYWJsZTogdHJ1ZSxcbiAgICBzaG93OiB7IG9yOiBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJ10gfSxcbiAgICBoaWRlOiB7IGFuZDogWyd1bmhpZ2hsaWdodGVkJywgJ3Vuc2VsZWN0ZWQnXSB9LFxuICAgIGh0bWw6IGA8c3Ryb25nPnt7e3tuYW1lc3BhY2VbYXNzb2NdfX12YXJpYW50fGh0bWxlc2NhcGV9fTwvc3Ryb25nPjxicj5cbiAgICAgICAgUCBWYWx1ZTogPHN0cm9uZz57e3t7bmFtZXNwYWNlW2Fzc29jXX19bG9nX3B2YWx1ZXxsb2d0b3NjaW5vdGF0aW9ufGh0bWxlc2NhcGV9fTwvc3Ryb25nPjxicj5cbiAgICAgICAgUmVmLiBBbGxlbGU6IDxzdHJvbmc+e3t7e25hbWVzcGFjZVthc3NvY119fXJlZl9hbGxlbGV8aHRtbGVzY2FwZX19PC9zdHJvbmc+PGJyPlxuICAgICAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiIFxuICAgICAgICBvbmNsaWNrPVwidmFyIGRhdGEgPSB0aGlzLnBhcmVudE5vZGUuX19kYXRhX187XG4gICAgICAgICAgICAgICAgIGRhdGEuZ2V0RGF0YUxheWVyKCkubWFrZUxEUmVmZXJlbmNlKGRhdGEpO1wiXG4gICAgICAgICAgICAgICAgID5NYWtlIExEIFJlZmVyZW5jZTwvYT48YnI+YCxcbn07XG5cbmNvbnN0IHN0YW5kYXJkX2Fzc29jaWF0aW9uX3Rvb2x0aXBfd2l0aF9sYWJlbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEFkZCBhIHNwZWNpYWwgXCJ0b2dnbGUgbGFiZWxcIiBidXR0b24gdG8gdGhlIGJhc2UgdG9vbHRpcC4gVGhpcyBtdXN0IGJlIHVzZWQgaW4gdGFuZGVtIHdpdGggYSBjdXN0b20gbGF5b3V0XG4gICAgLy8gICBkaXJlY3RpdmUgKGxhYmVsLmZpbHRlcnMgc2hvdWxkIGNoZWNrIGEgYm9vbGVhbiBhbm5vdGF0aW9uIGZpZWxkIGNhbGxlZCBcImx6X3Nob3dfbGFiZWxcIikuXG4gICAgY29uc3QgYmFzZSA9IGRlZXBDb3B5KHN0YW5kYXJkX2Fzc29jaWF0aW9uX3Rvb2x0aXApO1xuICAgIGJhc2UuaHRtbCArPSBgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIiBcbiAgICAgICAgICAgICAgICAgIG9uY2xpY2s9XCJ2YXIgaXRlbSA9IHRoaXMucGFyZW50Tm9kZS5fX2RhdGFfXywgbGF5ZXIgPSBpdGVtLmdldERhdGFMYXllcigpOyBcbiAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbGF5ZXIuZ2V0RWxlbWVudEFubm90YXRpb24oaXRlbSwgJ2x6X3Nob3dfbGFiZWwnKTsgXG4gICAgICAgICAgICAgICAgICBsYXllci5zZXRFbGVtZW50QW5ub3RhdGlvbihpdGVtLCAnbHpfc2hvd19sYWJlbCcsICFjdXJyZW50ICk7XG4gICAgICAgICAgICAgICAgICBsYXllci5wYXJlbnRfcGxvdC5hcHBseVN0YXRlKCk7XCI+VG9nZ2xlIGxhYmVsPC9hPmA7XG4gICAgcmV0dXJuIGJhc2U7XG59KCk7XG5cbmNvbnN0IHN0YW5kYXJkX2dlbmVzX3Rvb2x0aXAgPSB7XG4gICAgY2xvc2FibGU6IHRydWUsXG4gICAgc2hvdzogeyBvcjogWydoaWdobGlnaHRlZCcsICdzZWxlY3RlZCddIH0sXG4gICAgaGlkZTogeyBhbmQ6IFsndW5oaWdobGlnaHRlZCcsICd1bnNlbGVjdGVkJ10gfSxcbiAgICBodG1sOiAnPGg0PjxzdHJvbmc+PGk+e3tnZW5lX25hbWV8aHRtbGVzY2FwZX19PC9pPjwvc3Ryb25nPjwvaDQ+J1xuICAgICAgICArICdHZW5lIElEOiA8YSBocmVmPVwiaHR0cHM6Ly91c2Vhc3QuZW5zZW1ibC5vcmcvaG9tb19zYXBpZW5zL0dlbmUvU3VtbWFyeT9nPXt7Z2VuZV9pZHxodG1sZXNjYXBlfX0mZGI9Y29yZVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyXCI+e3tnZW5lX2lkfGh0bWxlc2NhcGV9fTwvYT48YnI+J1xuICAgICAgICArICdUcmFuc2NyaXB0IElEOiA8c3Ryb25nPnt7dHJhbnNjcmlwdF9pZHxodG1sZXNjYXBlfX08L3N0cm9uZz48YnI+J1xuICAgICAgICArICd7eyNpZiBwTEl9fTx0YWJsZT4nXG4gICAgICAgICsgJzx0cj48dGg+Q29uc3RyYWludDwvdGg+PHRoPkV4cGVjdGVkIHZhcmlhbnRzPC90aD48dGg+T2JzZXJ2ZWQgdmFyaWFudHM8L3RoPjx0aD5Db25zdC4gTWV0cmljPC90aD48L3RyPidcbiAgICAgICAgKyAnPHRyPjx0ZD5TeW5vbnltb3VzPC90ZD48dGQ+e3tleHBfc3lufX08L3RkPjx0ZD57e29ic19zeW59fTwvdGQ+PHRkPnogPSB7e3N5bl96fX08YnI+by9lID0ge3tvZV9zeW59fSAoe3tvZV9zeW5fbG93ZXJ9fSAtIHt7b2Vfc3luX3VwcGVyfX0pPC90ZD48L3RyPidcbiAgICAgICAgKyAnPHRyPjx0ZD5NaXNzZW5zZTwvdGQ+PHRkPnt7ZXhwX21pc319PC90ZD48dGQ+e3tvYnNfbWlzfX08L3RkPjx0ZD56ID0ge3ttaXNfen19PGJyPm8vZSA9IHt7b2VfbWlzfX0gKHt7b2VfbWlzX2xvd2VyfX0gLSB7e29lX21pc191cHBlcn19KTwvdGQ+PC90cj4nXG4gICAgICAgICsgJzx0cj48dGQ+cExvRjwvdGQ+PHRkPnt7ZXhwX2xvZn19PC90ZD48dGQ+e3tvYnNfbG9mfX08L3RkPjx0ZD5wTEkgPSB7e3BMSX19PGJyPm8vZSA9IHt7b2VfbG9mfX0gKHt7b2VfbG9mX2xvd2VyfX0gLSB7e29lX2xvZl91cHBlcn19KTwvdGQ+PC90cj4nXG4gICAgICAgICsgJzwvdGFibGU+PGJyPnt7L2lmfX0nXG4gICAgICAgICsgJzxhIGhyZWY9XCJodHRwczovL2dub21hZC5icm9hZGluc3RpdHV0ZS5vcmcvZ2VuZS97e2dlbmVfaWR8aHRtbGVzY2FwZX19XCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXJcIj5Nb3JlIGRhdGEgb24gZ25vbUFEPC9hPicsXG59O1xuXG5jb25zdCBjYXRhbG9nX3ZhcmlhbnRfdG9vbHRpcCA9IHtcbiAgICBuYW1lc3BhY2U6IHsgJ2Fzc29jJzogJ2Fzc29jJywgJ2NhdGFsb2cnOiAnY2F0YWxvZycgfSxcbiAgICBjbG9zYWJsZTogdHJ1ZSxcbiAgICBzaG93OiB7IG9yOiBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJ10gfSxcbiAgICBoaWRlOiB7IGFuZDogWyd1bmhpZ2hsaWdodGVkJywgJ3Vuc2VsZWN0ZWQnXSB9LFxuICAgIGh0bWw6ICc8c3Ryb25nPnt7e3tuYW1lc3BhY2VbY2F0YWxvZ119fXZhcmlhbnR8aHRtbGVzY2FwZX19PC9zdHJvbmc+PGJyPidcbiAgICAgICAgKyAnQ2F0YWxvZyBlbnRyaWVzOiA8c3Ryb25nPnt7bl9jYXRhbG9nX21hdGNoZXN8aHRtbGVzY2FwZX19PC9zdHJvbmc+PGJyPidcbiAgICAgICAgKyAnVG9wIFRyYWl0OiA8c3Ryb25nPnt7e3tuYW1lc3BhY2VbY2F0YWxvZ119fXRyYWl0fGh0bWxlc2NhcGV9fTwvc3Ryb25nPjxicj4nXG4gICAgICAgICsgJ1RvcCBQIFZhbHVlOiA8c3Ryb25nPnt7e3tuYW1lc3BhY2VbY2F0YWxvZ119fWxvZ19wdmFsdWV8bG9ndG9zY2lub3RhdGlvbn19PC9zdHJvbmc+PGJyPidcbiAgICAgICAgLy8gVXNlciBub3RlOiBpZiBhIGRpZmZlcmVudCBjYXRhbG9nIGlzIHVzZWQsIHRoZSB0b29sdGlwIHdpbGwgbmVlZCB0byBiZSByZXBsYWNlZCB3aXRoIGEgZGlmZmVyZW50IGxpbmsgVVJMXG4gICAgICAgICsgJ01vcmU6IDxhIGhyZWY9XCJodHRwczovL3d3dy5lYmkuYWMudWsvZ3dhcy9zZWFyY2g/cXVlcnk9e3t7e25hbWVzcGFjZVtjYXRhbG9nXX19cnNpZHxodG1sZXNjYXBlfX1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lclwiPkdXQVMgY2F0YWxvZzwvYT4gLyA8YSBocmVmPVwiaHR0cHM6Ly93d3cubmNiaS5ubG0ubmloLmdvdi9zbnAve3t7e25hbWVzcGFjZVtjYXRhbG9nXX19cnNpZHxodG1sZXNjYXBlfX1cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lclwiPmRiU05QPC9hPicsXG59O1xuXG5jb25zdCBjb2FjY2Vzc2liaWxpdHlfdG9vbHRpcCA9IHtcbiAgICBuYW1lc3BhY2U6IHsgJ2FjY2Vzcyc6ICdhY2Nlc3MnIH0sXG4gICAgY2xvc2FibGU6IHRydWUsXG4gICAgc2hvdzogeyBvcjogWydoaWdobGlnaHRlZCcsICdzZWxlY3RlZCddIH0sXG4gICAgaGlkZTogeyBhbmQ6IFsndW5oaWdobGlnaHRlZCcsICd1bnNlbGVjdGVkJ10gfSxcbiAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIG1vcmUgZ2VuZXJpYyB0ZXJtaW5vbG9neT8gKGVnIG5vdCBldmVyeSB0ZWNobmlxdWUgaXMgaW4gdGVybXMgb2YgY2lzLXJlZ3VsYXRvcnkgZWxlbWVudClcbiAgICBodG1sOiAnPHN0cm9uZz5SZWd1bGF0b3J5IGVsZW1lbnQ8L3N0cm9uZz48YnI+JyArXG4gICAgICAgICd7e3t7bmFtZXNwYWNlW2FjY2Vzc119fXN0YXJ0MXxodG1sZXNjYXBlfX0te3t7e25hbWVzcGFjZVthY2Nlc3NdfX1lbmQxfGh0bWxlc2NhcGV9fTxicj4nICtcbiAgICAgICAgJzxzdHJvbmc+UHJvbW90ZXI8L3N0cm9uZz48YnI+JyArXG4gICAgICAgICd7e3t7bmFtZXNwYWNlW2FjY2Vzc119fXN0YXJ0MnxodG1sZXNjYXBlfX0te3t7e25hbWVzcGFjZVthY2Nlc3NdfX1lbmQyfGh0bWxlc2NhcGV9fTxicj4nICtcbiAgICAgICAgJ3t7I2lmIHt7bmFtZXNwYWNlW2FjY2Vzc119fXRhcmdldH19PHN0cm9uZz5UYXJnZXQ8L3N0cm9uZz46IHt7e3tuYW1lc3BhY2VbYWNjZXNzXX19dGFyZ2V0fGh0bWxlc2NhcGV9fTxicj57ey9pZn19JyArXG4gICAgICAgICc8c3Ryb25nPlNjb3JlPC9zdHJvbmc+OiB7e3t7bmFtZXNwYWNlW2FjY2Vzc119fXNjb3JlfGh0bWxlc2NhcGV9fScsXG59O1xuXG4vKipcbiAqIERhdGEgTGF5ZXIgTGF5b3V0czogcmVwcmVzZW50IHNwZWNpZmljIGluZm9ybWF0aW9uIGZyb20gYSBkYXRhIHNvdXJjZVxuICovXG5cbmNvbnN0IHNpZ25pZmljYW5jZV9sYXllciA9IHtcbiAgICBpZDogJ3NpZ25pZmljYW5jZScsXG4gICAgdHlwZTogJ29ydGhvZ29uYWxfbGluZScsXG4gICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICBvZmZzZXQ6IExaX1NJR19USFJFU0hPTERfTE9HUCxcbn07XG5cbmNvbnN0IHJlY29tYl9yYXRlX2xheWVyID0ge1xuICAgIG5hbWVzcGFjZTogeyAncmVjb21iJzogJ3JlY29tYicgfSxcbiAgICBpZDogJ3JlY29tYnJhdGUnLFxuICAgIHR5cGU6ICdsaW5lJyxcbiAgICBmaWVsZHM6IFsne3tuYW1lc3BhY2VbcmVjb21iXX19cG9zaXRpb24nLCAne3tuYW1lc3BhY2VbcmVjb21iXX19cmVjb21iX3JhdGUnXSxcbiAgICB6X2luZGV4OiAxLFxuICAgIHN0eWxlOiB7XG4gICAgICAgICdzdHJva2UnOiAnIzAwMDBGRicsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAnMS41cHgnLFxuICAgIH0sXG4gICAgeF9heGlzOiB7XG4gICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbcmVjb21iXX19cG9zaXRpb24nLFxuICAgIH0sXG4gICAgeV9heGlzOiB7XG4gICAgICAgIGF4aXM6IDIsXG4gICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbcmVjb21iXX19cmVjb21iX3JhdGUnLFxuICAgICAgICBmbG9vcjogMCxcbiAgICAgICAgY2VpbGluZzogMTAwLFxuICAgIH0sXG59O1xuXG5jb25zdCBhc3NvY2lhdGlvbl9wdmFsdWVzX2xheWVyID0ge1xuICAgIG5hbWVzcGFjZTogeyAnYXNzb2MnOiAnYXNzb2MnLCAnbGQnOiAnbGQnIH0sXG4gICAgaWQ6ICdhc3NvY2lhdGlvbnB2YWx1ZXMnLFxuICAgIHR5cGU6ICdzY2F0dGVyJyxcbiAgICBjb2FsZXNjZToge1xuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSxcbiAgICBwb2ludF9zaGFwZToge1xuICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ2lmJyxcbiAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtsZF19fWlzcmVmdmFyJyxcbiAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZmllbGRfdmFsdWU6IDEsXG4gICAgICAgICAgICB0aGVuOiAnZGlhbW9uZCcsXG4gICAgICAgICAgICBlbHNlOiAnY2lyY2xlJyxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHBvaW50X3NpemU6IHtcbiAgICAgICAgc2NhbGVfZnVuY3Rpb246ICdpZicsXG4gICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbbGRdfX1pc3JlZnZhcicsXG4gICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGZpZWxkX3ZhbHVlOiAxLFxuICAgICAgICAgICAgdGhlbjogODAsXG4gICAgICAgICAgICBlbHNlOiA0MCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGNvbG9yOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnaWYnLFxuICAgICAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtsZF19fWlzcmVmdmFyJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBmaWVsZF92YWx1ZTogMSxcbiAgICAgICAgICAgICAgICB0aGVuOiAnIzk2MzJiOCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ251bWVyaWNhbF9iaW4nLFxuICAgICAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtsZF19fXN0YXRlJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBicmVha3M6IFswLCAwLjIsIDAuNCwgMC42LCAwLjhdLFxuICAgICAgICAgICAgICAgIHZhbHVlczogWycjMzU3ZWJkJywgJyM0NmI4ZGEnLCAnIzVjYjg1YycsICcjZWVhMjM2JywgJyNkNDNmM2EnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgICcjQjhCOEI4JyxcbiAgICBdLFxuICAgIGxlZ2VuZDogW1xuICAgICAgICB7IHNoYXBlOiAnZGlhbW9uZCcsIGNvbG9yOiAnIzk2MzJiOCcsIHNpemU6IDQwLCBsYWJlbDogJ0xEIFJlZiBWYXInLCBjbGFzczogJ2x6LWRhdGFfbGF5ZXItc2NhdHRlcicgfSxcbiAgICAgICAgeyBzaGFwZTogJ2NpcmNsZScsIGNvbG9yOiAnI2Q0M2YzYScsIHNpemU6IDQwLCBsYWJlbDogJzEuMCA+IHLCsiDiiaUgMC44JywgY2xhc3M6ICdsei1kYXRhX2xheWVyLXNjYXR0ZXInIH0sXG4gICAgICAgIHsgc2hhcGU6ICdjaXJjbGUnLCBjb2xvcjogJyNlZWEyMzYnLCBzaXplOiA0MCwgbGFiZWw6ICcwLjggPiBywrIg4omlIDAuNicsIGNsYXNzOiAnbHotZGF0YV9sYXllci1zY2F0dGVyJyB9LFxuICAgICAgICB7IHNoYXBlOiAnY2lyY2xlJywgY29sb3I6ICcjNWNiODVjJywgc2l6ZTogNDAsIGxhYmVsOiAnMC42ID4gcsKyIOKJpSAwLjQnLCBjbGFzczogJ2x6LWRhdGFfbGF5ZXItc2NhdHRlcicgfSxcbiAgICAgICAgeyBzaGFwZTogJ2NpcmNsZScsIGNvbG9yOiAnIzQ2YjhkYScsIHNpemU6IDQwLCBsYWJlbDogJzAuNCA+IHLCsiDiiaUgMC4yJywgY2xhc3M6ICdsei1kYXRhX2xheWVyLXNjYXR0ZXInIH0sXG4gICAgICAgIHsgc2hhcGU6ICdjaXJjbGUnLCBjb2xvcjogJyMzNTdlYmQnLCBzaXplOiA0MCwgbGFiZWw6ICcwLjIgPiBywrIg4omlIDAuMCcsIGNsYXNzOiAnbHotZGF0YV9sYXllci1zY2F0dGVyJyB9LFxuICAgICAgICB7IHNoYXBlOiAnY2lyY2xlJywgY29sb3I6ICcjQjhCOEI4Jywgc2l6ZTogNDAsIGxhYmVsOiAnbm8gcsKyIGRhdGEnLCBjbGFzczogJ2x6LWRhdGFfbGF5ZXItc2NhdHRlcicgfSxcbiAgICBdLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGZpZWxkczogWyd7e25hbWVzcGFjZVthc3NvY119fXZhcmlhbnQnLCAne3tuYW1lc3BhY2VbYXNzb2NdfX1wb3NpdGlvbicsICd7e25hbWVzcGFjZVthc3NvY119fWxvZ19wdmFsdWUnLCAne3tuYW1lc3BhY2VbYXNzb2NdfX1sb2dfcHZhbHVlfGxvZ3Rvc2Npbm90YXRpb24nLCAne3tuYW1lc3BhY2VbYXNzb2NdfX1yZWZfYWxsZWxlJywgJ3t7bmFtZXNwYWNlW2xkXX19c3RhdGUnLCAne3tuYW1lc3BhY2VbbGRdfX1pc3JlZnZhciddLFxuICAgIGlkX2ZpZWxkOiAne3tuYW1lc3BhY2VbYXNzb2NdfX12YXJpYW50JyxcbiAgICB6X2luZGV4OiAyLFxuICAgIHhfYXhpczoge1xuICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2Fzc29jXX19cG9zaXRpb24nLFxuICAgIH0sXG4gICAgeV9heGlzOiB7XG4gICAgICAgIGF4aXM6IDEsXG4gICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbYXNzb2NdfX1sb2dfcHZhbHVlJyxcbiAgICAgICAgZmxvb3I6IDAsXG4gICAgICAgIHVwcGVyX2J1ZmZlcjogMC4xMCxcbiAgICAgICAgbWluX2V4dGVudDogWzAsIDEwXSxcbiAgICB9LFxuICAgIGJlaGF2aW9yczoge1xuICAgICAgICBvbm1vdXNlb3ZlcjogW1xuICAgICAgICAgICAgeyBhY3Rpb246ICdzZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb25tb3VzZW91dDogW1xuICAgICAgICAgICAgeyBhY3Rpb246ICd1bnNldCcsIHN0YXR1czogJ2hpZ2hsaWdodGVkJyB9LFxuICAgICAgICBdLFxuICAgICAgICBvbmNsaWNrOiBbXG4gICAgICAgICAgICB7IGFjdGlvbjogJ3RvZ2dsZScsIHN0YXR1czogJ3NlbGVjdGVkJywgZXhjbHVzaXZlOiB0cnVlIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB0b29sdGlwOiBkZWVwQ29weShzdGFuZGFyZF9hc3NvY2lhdGlvbl90b29sdGlwKSxcbn07XG5cbmNvbnN0IGNvYWNjZXNzaWJpbGl0eV9sYXllciA9IHtcbiAgICBuYW1lc3BhY2U6IHsgJ2FjY2Vzcyc6ICdhY2Nlc3MnIH0sXG4gICAgaWQ6ICdjb2FjY2Vzc2liaWxpdHknLFxuICAgIHR5cGU6ICdhcmNzJyxcbiAgICBmaWVsZHM6IFsne3tuYW1lc3BhY2VbYWNjZXNzXX19c3RhcnQxJywgJ3t7bmFtZXNwYWNlW2FjY2Vzc119fWVuZDEnLCAne3tuYW1lc3BhY2VbYWNjZXNzXX19c3RhcnQyJywgJ3t7bmFtZXNwYWNlW2FjY2Vzc119fWVuZDInLCAne3tuYW1lc3BhY2VbYWNjZXNzXX19aWQnLCAne3tuYW1lc3BhY2VbYWNjZXNzXX19dGFyZ2V0JywgJ3t7bmFtZXNwYWNlW2FjY2Vzc119fXNjb3JlJ10sXG4gICAgbWF0Y2g6IHsgc2VuZDogJ3t7bmFtZXNwYWNlW2FjY2Vzc119fXRhcmdldCcsIHJlY2VpdmU6ICd7e25hbWVzcGFjZVthY2Nlc3NdfX10YXJnZXQnIH0sXG4gICAgaWRfZmllbGQ6ICd7e25hbWVzcGFjZVthY2Nlc3NdfX1pZCcsXG4gICAgZmlsdGVyczogW1xuICAgICAgICB7IGZpZWxkOiAne3tuYW1lc3BhY2VbYWNjZXNzXX19c2NvcmUnLCBvcGVyYXRvcjogJyE9JywgdmFsdWU6IG51bGwgfSxcbiAgICBdLFxuICAgIGNvbG9yOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpZWxkOiAnbHpfaGlnaGxpZ2h0X21hdGNoJywgLy8gU3BlY2lhbCBmaWVsZCBuYW1lIHdob3NlIHByZXNlbmNlIHRyaWdnZXJzIGN1c3RvbSByZW5kZXJpbmdcbiAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnaWYnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGZpZWxkX3ZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRoZW46ICcjZmYwMDAwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpZWxkOiAnbHpfaGlnaGxpZ2h0X21hdGNoJywgLy8gU3BlY2lhbCBmaWVsZCBuYW1lIHdob3NlIHByZXNlbmNlIHRyaWdnZXJzIGN1c3RvbSByZW5kZXJpbmdcbiAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnaWYnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGZpZWxkX3ZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aGVuOiAnI0VBRTZFNicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ29yZGluYWxfY3ljbGUnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHZhbHVlczogWycjMWY3N2I0JywgJyNhZWM3ZTgnLCAnI2ZmN2YwZScsICcjZmZiYjc4JywgJyMyY2EwMmMnLCAnIzk4ZGY4YScsICcjZDYyNzI4JywgJyNmZjk4OTYnLCAnIzk0NjdiZCcsICcjYzViMGQ1JywgJyM4YzU2NGInLCAnI2M0OWM5NCcsICcjZTM3N2MyJywgJyNmN2I2ZDInLCAnIzdmN2Y3ZicsICcjYzdjN2M3JywgJyNiY2JkMjInLCAnI2RiZGI4ZCcsICcjMTdiZWNmJywgJyM5ZWRhZTUnXSwgLy8gRHJhd24gZnJvbSBkM3YzIFwiY2F0ZWdvcnkyMFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgeF9heGlzOiB7XG4gICAgICAgIGZpZWxkMTogJ3t7bmFtZXNwYWNlW2FjY2Vzc119fXN0YXJ0MScsXG4gICAgICAgIGZpZWxkMjogJ3t7bmFtZXNwYWNlW2FjY2Vzc119fXN0YXJ0MicsXG4gICAgfSxcbiAgICB5X2F4aXM6IHtcbiAgICAgICAgYXhpczogMSxcbiAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVthY2Nlc3NdfX1zY29yZScsXG4gICAgICAgIHVwcGVyX2J1ZmZlcjogMC4xLFxuICAgICAgICBtaW5fZXh0ZW50OiBbMCwgMV0sXG4gICAgfSxcbiAgICBiZWhhdmlvcnM6IHtcbiAgICAgICAgb25tb3VzZW92ZXI6IFtcbiAgICAgICAgICAgIHsgYWN0aW9uOiAnc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG9ubW91c2VvdXQ6IFtcbiAgICAgICAgICAgIHsgYWN0aW9uOiAndW5zZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb25jbGljazogW1xuICAgICAgICAgICAgeyBhY3Rpb246ICd0b2dnbGUnLCBzdGF0dXM6ICdzZWxlY3RlZCcsIGV4Y2x1c2l2ZTogdHJ1ZSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgdG9vbHRpcDogZGVlcENvcHkoY29hY2Nlc3NpYmlsaXR5X3Rvb2x0aXApLFxufTtcblxuY29uc3QgYXNzb2NpYXRpb25fcHZhbHVlc19jYXRhbG9nX2xheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNsaWdodGx5IG1vZGlmeSBhbiBleGlzdGluZyBsYXlvdXRcbiAgICBsZXQgYmFzZSA9IGRlZXBDb3B5KGFzc29jaWF0aW9uX3B2YWx1ZXNfbGF5ZXIpO1xuICAgIGJhc2UgPSBtZXJnZSh7IGlkOiAnYXNzb2NpYXRpb25wdmFsdWVzY2F0YWxvZycsIGZpbGxfb3BhY2l0eTogMC43fSwgYmFzZSk7XG4gICAgYmFzZS50b29sdGlwLmh0bWwgKz0gJ3t7I2lmIHt7bmFtZXNwYWNlW2NhdGFsb2ddfX1yc2lkfX08YnI+PGEgaHJlZj1cImh0dHBzOi8vd3d3LmViaS5hYy51ay9nd2FzL3NlYXJjaD9xdWVyeT17e3t7bmFtZXNwYWNlW2NhdGFsb2ddfX1yc2lkfGh0bWxlc2NhcGV9fVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyXCI+U2VlIGhpdHMgaW4gR1dBUyBjYXRhbG9nPC9hPnt7L2lmfX0nO1xuICAgIGJhc2UubmFtZXNwYWNlLmNhdGFsb2cgPSAnY2F0YWxvZyc7XG4gICAgYmFzZS5maWVsZHMucHVzaCgne3tuYW1lc3BhY2VbY2F0YWxvZ119fXJzaWQnLCAne3tuYW1lc3BhY2VbY2F0YWxvZ119fXRyYWl0JywgJ3t7bmFtZXNwYWNlW2NhdGFsb2ddfX1sb2dfcHZhbHVlJyk7XG4gICAgcmV0dXJuIGJhc2U7XG59KCk7XG5cbmNvbnN0IHBoZXdhc19wdmFsdWVzX2xheWVyID0ge1xuICAgIG5hbWVzcGFjZTogeyAncGhld2FzJzogJ3BoZXdhcycgfSxcbiAgICBpZDogJ3BoZXdhc3B2YWx1ZXMnLFxuICAgIHR5cGU6ICdjYXRlZ29yeV9zY2F0dGVyJyxcbiAgICBwb2ludF9zaGFwZTogJ2NpcmNsZScsXG4gICAgcG9pbnRfc2l6ZTogNzAsXG4gICAgdG9vbHRpcF9wb3NpdGlvbmluZzogJ3ZlcnRpY2FsJyxcbiAgICBpZF9maWVsZDogJ3t7bmFtZXNwYWNlW3BoZXdhc119fWlkJyxcbiAgICBmaWVsZHM6IFsne3tuYW1lc3BhY2VbcGhld2FzXX19aWQnLCAne3tuYW1lc3BhY2VbcGhld2FzXX19bG9nX3B2YWx1ZScsICd7e25hbWVzcGFjZVtwaGV3YXNdfX10cmFpdF9ncm91cCcsICd7e25hbWVzcGFjZVtwaGV3YXNdfX10cmFpdF9sYWJlbCddLFxuICAgIHhfYXhpczoge1xuICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW3BoZXdhc119fXgnLCAgLy8gU3ludGhldGljL2Rlcml2ZWQgZmllbGQgYWRkZWQgYnkgYGNhdGVnb3J5X3NjYXR0ZXJgIGxheWVyXG4gICAgICAgIGNhdGVnb3J5X2ZpZWxkOiAne3tuYW1lc3BhY2VbcGhld2FzXX19dHJhaXRfZ3JvdXAnLFxuICAgICAgICBsb3dlcl9idWZmZXI6IDAuMDI1LFxuICAgICAgICB1cHBlcl9idWZmZXI6IDAuMDI1LFxuICAgIH0sXG4gICAgeV9heGlzOiB7XG4gICAgICAgIGF4aXM6IDEsXG4gICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbcGhld2FzXX19bG9nX3B2YWx1ZScsXG4gICAgICAgIGZsb29yOiAwLFxuICAgICAgICB1cHBlcl9idWZmZXI6IDAuMTUsXG4gICAgfSxcbiAgICBjb2xvcjogW3tcbiAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtwaGV3YXNdfX10cmFpdF9ncm91cCcsXG4gICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnY2F0ZWdvcmljYWxfYmluJyxcbiAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgbnVsbF92YWx1ZTogJyNCOEI4QjgnLFxuICAgICAgICB9LFxuICAgIH1dLFxuICAgIGZpbGxfb3BhY2l0eTogMC43LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgICAgY2xvc2FibGU6IHRydWUsXG4gICAgICAgIHNob3c6IHsgb3I6IFsnaGlnaGxpZ2h0ZWQnLCAnc2VsZWN0ZWQnXSB9LFxuICAgICAgICBoaWRlOiB7IGFuZDogWyd1bmhpZ2hsaWdodGVkJywgJ3Vuc2VsZWN0ZWQnXSB9LFxuICAgICAgICBodG1sOiBbXG4gICAgICAgICAgICAnPHN0cm9uZz5UcmFpdDo8L3N0cm9uZz4ge3t7e25hbWVzcGFjZVtwaGV3YXNdfX10cmFpdF9sYWJlbHxodG1sZXNjYXBlfX08YnI+JyxcbiAgICAgICAgICAgICc8c3Ryb25nPlRyYWl0IENhdGVnb3J5Ojwvc3Ryb25nPiB7e3t7bmFtZXNwYWNlW3BoZXdhc119fXRyYWl0X2dyb3VwfGh0bWxlc2NhcGV9fTxicj4nLFxuICAgICAgICAgICAgJzxzdHJvbmc+UC12YWx1ZTo8L3N0cm9uZz4ge3t7e25hbWVzcGFjZVtwaGV3YXNdfX1sb2dfcHZhbHVlfGxvZ3Rvc2Npbm90YXRpb258aHRtbGVzY2FwZX19PGJyPicsXG4gICAgICAgIF0uam9pbignJyksXG4gICAgfSxcbiAgICBiZWhhdmlvcnM6IHtcbiAgICAgICAgb25tb3VzZW92ZXI6IFtcbiAgICAgICAgICAgIHsgYWN0aW9uOiAnc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG9ubW91c2VvdXQ6IFtcbiAgICAgICAgICAgIHsgYWN0aW9uOiAndW5zZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb25jbGljazogW1xuICAgICAgICAgICAgeyBhY3Rpb246ICd0b2dnbGUnLCBzdGF0dXM6ICdzZWxlY3RlZCcsIGV4Y2x1c2l2ZTogdHJ1ZSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgICAgdGV4dDogJ3t7e3tuYW1lc3BhY2VbcGhld2FzXX19dHJhaXRfbGFiZWx9fScsXG4gICAgICAgIHNwYWNpbmc6IDYsXG4gICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAnMnB4JyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJyMzMzMzMzMnLFxuICAgICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJzJweCAycHgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbcGhld2FzXX19bG9nX3B2YWx1ZScsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc+PScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDIwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICdmb250LXNpemUnOiAnMTRweCcsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAgICAgICAnZmlsbCc6ICcjMzMzMzMzJyxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuY29uc3QgZ2VuZXNfbGF5ZXIgPSB7XG4gICAgbmFtZXNwYWNlOiB7ICdnZW5lJzogJ2dlbmUnLCAnY29uc3RyYWludCc6ICdjb25zdHJhaW50JyB9LFxuICAgIGlkOiAnZ2VuZXMnLFxuICAgIHR5cGU6ICdnZW5lcycsXG4gICAgZmllbGRzOiBbJ3t7bmFtZXNwYWNlW2dlbmVdfX1hbGwnLCAne3tuYW1lc3BhY2VbY29uc3RyYWludF19fWFsbCddLFxuICAgIGlkX2ZpZWxkOiAnZ2VuZV9pZCcsXG4gICAgYmVoYXZpb3JzOiB7XG4gICAgICAgIG9ubW91c2VvdmVyOiBbXG4gICAgICAgICAgICB7IGFjdGlvbjogJ3NldCcsIHN0YXR1czogJ2hpZ2hsaWdodGVkJyB9LFxuICAgICAgICBdLFxuICAgICAgICBvbm1vdXNlb3V0OiBbXG4gICAgICAgICAgICB7IGFjdGlvbjogJ3Vuc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG9uY2xpY2s6IFtcbiAgICAgICAgICAgIHsgYWN0aW9uOiAndG9nZ2xlJywgc3RhdHVzOiAnc2VsZWN0ZWQnLCBleGNsdXNpdmU6IHRydWUgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHRvb2x0aXA6IGRlZXBDb3B5KHN0YW5kYXJkX2dlbmVzX3Rvb2x0aXApLFxufTtcblxuY29uc3QgZ2VuZXNfbGF5ZXJfZmlsdGVyZWQgPSBtZXJnZSh7XG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGxheWVyIGRvZXNuJ3Qgc2hvdyBldmVyeXRoaW5nLiBPZnRlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGEgcGFuZWwtbGV2ZWwgdG9vbGJhciBcInNob3cgYWxsXCIgYnV0dG9uLlxuICAgIGZpbHRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgZmllbGQ6ICdnZW5lX3R5cGUnLFxuICAgICAgICAgICAgb3BlcmF0b3I6ICdpbicsXG4gICAgICAgICAgICAvLyBBIG1hbnVhbGx5IGN1cmF0ZWQgc3Vic2V0IG9mIEdlbmNvZGUgYmlvdHlwZXMsIGJhc2VkIG9uIHVzZXIgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIC8vICBTZWUgZnVsbCBsaXN0OiBodHRwczovL3d3dy5nZW5jb2RlZ2VuZXMub3JnL2h1bWFuL3N0YXRzLmh0bWxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYXBwcm94aW1hdGVseSBpbnRlbmRlZCB0byBjb3ZlciBlbGVtZW50cyBvZiBnZW5lcmFsbHkga25vd24gZnVuY3Rpb24sIGFuZCBleGNsdWRlIHRoaW5nc1xuICAgICAgICAgICAgLy8gIGxpa2UgcHNldWRvZ2VuZXMuXG4gICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAgICdwcm90ZWluX2NvZGluZycsXG4gICAgICAgICAgICAgICAgJ0lHX0NfZ2VuZScsICdJR19EX2dlbmUnLCAnSUdfSl9nZW5lJywgJ0lHX1ZfZ2VuZScsXG4gICAgICAgICAgICAgICAgJ1RSX0NfZ2VuZScsICdUUl9EX2dlbmUnLCAnVFJfSl9nZW5lJywgJ1RSX1ZfZ2VuZScsXG4gICAgICAgICAgICAgICAgJ3JSTkEnLFxuICAgICAgICAgICAgICAgICdNdF9yUk5BJywgJ010X3RSTkEnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxufSwgZGVlcENvcHkoZ2VuZXNfbGF5ZXIpKTtcblxuXG5jb25zdCBhbm5vdGF0aW9uX2NhdGFsb2dfbGF5ZXIgPSB7XG4gICAgLy8gSWRlbnRpZnkgR1dBUyBoaXRzIHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIEdXQVMgY2F0YWxvZ1xuICAgIG5hbWVzcGFjZTogeyAnYXNzb2MnOiAnYXNzb2MnLCAnY2F0YWxvZyc6ICdjYXRhbG9nJyB9LFxuICAgIGlkOiAnYW5ub3RhdGlvbl9jYXRhbG9nJyxcbiAgICB0eXBlOiAnYW5ub3RhdGlvbl90cmFjaycsXG4gICAgaWRfZmllbGQ6ICd7e25hbWVzcGFjZVthc3NvY119fXZhcmlhbnQnLFxuICAgIHhfYXhpczoge1xuICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2Fzc29jXX19cG9zaXRpb24nLFxuICAgIH0sXG4gICAgY29sb3I6ICcjMDAwMENDJyxcbiAgICBmaWVsZHM6IFtcbiAgICAgICAgJ3t7bmFtZXNwYWNlW2Fzc29jXX19dmFyaWFudCcsICd7e25hbWVzcGFjZVthc3NvY119fWNocm9tb3NvbWUnLCAne3tuYW1lc3BhY2VbYXNzb2NdfX1wb3NpdGlvbicsXG4gICAgICAgICd7e25hbWVzcGFjZVtjYXRhbG9nXX19dmFyaWFudCcsICd7e25hbWVzcGFjZVtjYXRhbG9nXX19cnNpZCcsICd7e25hbWVzcGFjZVtjYXRhbG9nXX19dHJhaXQnLFxuICAgICAgICAne3tuYW1lc3BhY2VbY2F0YWxvZ119fWxvZ19wdmFsdWUnLCAne3tuYW1lc3BhY2VbY2F0YWxvZ119fXBvcycsXG4gICAgXSxcbiAgICBmaWx0ZXJzOiBbXG4gICAgICAgIC8vIFNwZWNpZnkgd2hpY2ggcG9pbnRzIHRvIHNob3cgb24gdGhlIHRyYWNrLiBBbnkgc2VsZWN0aW9uIG11c3Qgc2F0aXNmeSBBTEwgZmlsdGVyc1xuICAgICAgICB7IGZpZWxkOiAne3tuYW1lc3BhY2VbY2F0YWxvZ119fXJzaWQnLCBvcGVyYXRvcjogJyE9JywgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgeyBmaWVsZDogJ3t7bmFtZXNwYWNlW2NhdGFsb2ddfX1sb2dfcHZhbHVlJywgb3BlcmF0b3I6ICc+JywgdmFsdWU6IExaX1NJR19USFJFU0hPTERfTE9HUCB9LFxuICAgIF0sXG4gICAgYmVoYXZpb3JzOiB7XG4gICAgICAgIG9ubW91c2VvdmVyOiBbXG4gICAgICAgICAgICB7IGFjdGlvbjogJ3NldCcsIHN0YXR1czogJ2hpZ2hsaWdodGVkJyB9LFxuICAgICAgICBdLFxuICAgICAgICBvbm1vdXNlb3V0OiBbXG4gICAgICAgICAgICB7IGFjdGlvbjogJ3Vuc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG9uY2xpY2s6IFtcbiAgICAgICAgICAgIHsgYWN0aW9uOiAndG9nZ2xlJywgc3RhdHVzOiAnc2VsZWN0ZWQnLCBleGNsdXNpdmU6IHRydWUgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHRvb2x0aXA6IGRlZXBDb3B5KGNhdGFsb2dfdmFyaWFudF90b29sdGlwKSxcbiAgICB0b29sdGlwX3Bvc2l0aW9uaW5nOiAndG9wJyxcbn07XG5cbi8qKlxuICogSW5kaXZpZHVhbCB0b29sYmFyIGJ1dHRvbnNcbiAqL1xuY29uc3QgbGRsejJfcG9wX3NlbGVjdG9yX21lbnUgPSB7XG4gICAgLy8gKipOb3RlKio6IHRoaXMgd2lkZ2V0IGlzIGFpbWVkIGF0IHRoZSBMRFNlcnZlciBkYXRhc291cmNlLCBhbmQgdGhlIFVNIDEwMDBHIExEU2VydmVyXG4gICAgdHlwZTogJ3NldF9zdGF0ZScsXG4gICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgY29sb3I6ICdibHVlJyxcbiAgICBidXR0b25faHRtbDogJ0xEIFBvcHVsYXRpb246ICcsXG4gICAgc2hvd19zZWxlY3RlZDogdHJ1ZSxcbiAgICBidXR0b25fdGl0bGU6ICdTZWxlY3QgTEQgUG9wdWxhdGlvbjogJyxcbiAgICBzdGF0ZV9maWVsZDogJ2xkX3BvcCcsXG4gICAgLy8gVGhpcyBsaXN0IGJlbG93IGlzIGhhcmRjb2RlZCB0byB3b3JrIHdpdGggdGhlIFVNaWNoIExEU2VydmVyLCBkZWZhdWx0IDEwMDBHIHBvcHVsYXRpb25zXG4gICAgLy8gIEl0IGNhbiBiZSBjdXN0b21pemVkIHRvIHdvcmsgd2l0aCBvdGhlciBMRCBzZXJ2ZXJzIHRoYXQgc3BlY2lmeSBwb3B1bGF0aW9uIGRpZmZlcmVudGx5XG4gICAgLy8gaHR0cHM6Ly9wb3J0YWxkZXYuc3BoLnVtaWNoLmVkdS9sZC9nZW5vbWVfYnVpbGRzL0dSQ2gzNy9yZWZlcmVuY2VzLzEwMDBHL3BvcHVsYXRpb25zXG4gICAgb3B0aW9uczogW1xuICAgICAgICB7IGRpc3BsYXlfbmFtZTogJ0FMTCAoZGVmYXVsdCknLCB2YWx1ZTogJ0FMTCcgfSxcbiAgICAgICAgeyBkaXNwbGF5X25hbWU6ICdBRlInLCB2YWx1ZTogJ0FGUicgfSxcbiAgICAgICAgeyBkaXNwbGF5X25hbWU6ICdBTVInLCB2YWx1ZTogJ0FNUicgfSxcbiAgICAgICAgeyBkaXNwbGF5X25hbWU6ICdFQVMnLCB2YWx1ZTogJ0VBUycgfSxcbiAgICAgICAgeyBkaXNwbGF5X25hbWU6ICdFVVInLCB2YWx1ZTogJ0VVUicgfSxcbiAgICAgICAgeyBkaXNwbGF5X25hbWU6ICdTQVMnLCB2YWx1ZTogJ1NBUycgfSxcbiAgICBdLFxufTtcblxuY29uc3QgZ2VuZV9zZWxlY3Rvcl9tZW51ID0ge1xuICAgIHR5cGU6ICdkaXNwbGF5X29wdGlvbnMnLFxuICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgIGNvbG9yOiAnYmx1ZScsXG4gICAgLy8gQmVsb3c6IHNwZWNpYWwgY29uZmlnIHNwZWNpZmljIHRvIHRoaXMgd2lkZ2V0XG4gICAgYnV0dG9uX2h0bWw6ICdGaWx0ZXIuLi4nLFxuICAgIGJ1dHRvbl90aXRsZTogJ0Nob29zZSB3aGljaCBnZW5lcyB0byBzaG93JyxcbiAgICBsYXllcl9uYW1lOiAnZ2VuZXMnLFxuICAgIGRlZmF1bHRfY29uZmlnX2Rpc3BsYXlfbmFtZTogJ0NvZGluZyBnZW5lcyAmIHJSTkEnLFxuICAgIG9wdGlvbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgZGlzcGxheV9uYW1lOiAnQWxsIGZlYXR1cmVzJyxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdLFxufTtcblxuLyoqXG4gKiBUb29sYmFyIExheW91dHM6IENvbGxlY3Rpb25zIG9mIHRvb2xiYXIgYnV0dG9ucyBldGNcbiAqL1xuY29uc3Qgc3RhbmRhcmRfcGFuZWxfdG9vbGJhciA9IHtcbiAgICB3aWRnZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfcGFuZWwnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICAgICAgICBncm91cF9wb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3ZlX3BhbmVsX3VwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgZ3JvdXBfcG9zaXRpb246ICdtaWRkbGUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnbW92ZV9wYW5lbF9kb3duJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgZ3JvdXBfcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzdHlsZTogeyAnbWFyZ2luLWxlZnQnOiAnMC43NWVtJyB9LFxuICAgICAgICB9LFxuICAgIF0sXG59O1xuXG5jb25zdCBzdGFuZGFyZF9wbG90X3Rvb2xiYXIgPSB7XG4gICAgLy8gU3VpdGFibGUgZm9yIG1vc3QgYW55IHR5cGUgb2YgcGxvdCBkcmF3biB3aXRoIExaLiBUaXRsZSBhbmQgZG93bmxvYWQgYnV0dG9ucy5cbiAgICB3aWRnZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0aXRsZScsXG4gICAgICAgICAgICB0aXRsZTogJ0xvY3VzWm9vbScsXG4gICAgICAgICAgICBzdWJ0aXRsZTogYDxhIGhyZWY9XCJodHRwczovL3N0YXRnZW4uZ2l0aHViLmlvL2xvY3Vzem9vbS9cIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lclwiPnYke3ZlcnNpb259PC9hPmAsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnZG93bmxvYWQnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICBncm91cF9wb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdkb3dubG9hZF9wbmcnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICBncm91cF9wb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgfSxcbiAgICBdLFxufTtcblxuY29uc3Qgc3RhbmRhcmRfYXNzb2NpYXRpb25fdG9vbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdWl0YWJsZSBmb3IgYXNzb2NpYXRpb24gcGxvdHMgKGFkZHMgYSBidXR0b24gZm9yIExEIGRhdGEpXG4gICAgY29uc3QgYmFzZSA9IGRlZXBDb3B5KHN0YW5kYXJkX3Bsb3RfdG9vbGJhcik7XG4gICAgYmFzZS53aWRnZXRzLnB1c2goZGVlcENvcHkobGRsejJfcG9wX3NlbGVjdG9yX21lbnUpKTtcbiAgICByZXR1cm4gYmFzZTtcbn0oKTtcblxuY29uc3QgcmVnaW9uX25hdl9wbG90X3Rvb2xiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gR2VuZXJpYyByZWdpb24gbmF2IGJ1dHRvbnNcbiAgICBjb25zdCBiYXNlID0gZGVlcENvcHkoc3RhbmRhcmRfcGxvdF90b29sYmFyKTtcbiAgICBiYXNlLndpZGdldHMucHVzaChcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3NoaWZ0X3JlZ2lvbicsXG4gICAgICAgICAgICBzdGVwOiA1MDAwMDAsXG4gICAgICAgICAgICBidXR0b25faHRtbDogJz4+JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgZ3JvdXBfcG9zaXRpb246ICdlbmQnLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiAnc2hpZnRfcmVnaW9uJyxcbiAgICAgICAgICAgIHN0ZXA6IDUwMDAwLFxuICAgICAgICAgICAgYnV0dG9uX2h0bWw6ICc+JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgZ3JvdXBfcG9zaXRpb246ICdtaWRkbGUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnem9vbV9yZWdpb24nLFxuICAgICAgICAgICAgc3RlcDogMC4yLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICBncm91cF9wb3NpdGlvbjogJ21pZGRsZScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd6b29tX3JlZ2lvbicsXG4gICAgICAgICAgICBzdGVwOiAtMC4yLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICBncm91cF9wb3NpdGlvbjogJ21pZGRsZScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdzaGlmdF9yZWdpb24nLFxuICAgICAgICAgICAgc3RlcDogLTUwMDAwLFxuICAgICAgICAgICAgYnV0dG9uX2h0bWw6ICc8JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgZ3JvdXBfcG9zaXRpb246ICdtaWRkbGUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnc2hpZnRfcmVnaW9uJyxcbiAgICAgICAgICAgIHN0ZXA6IC01MDAwMDAsXG4gICAgICAgICAgICBidXR0b25faHRtbDogJzw8JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgZ3JvdXBfcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBiYXNlO1xufSgpO1xuXG4vKipcbiAqIFBhbmVsIExheW91dHNcbiAqL1xuXG5jb25zdCBhc3NvY2lhdGlvbl9wYW5lbCA9IHtcbiAgICBpZDogJ2Fzc29jaWF0aW9uJyxcbiAgICB3aWR0aDogODAwLFxuICAgIGhlaWdodDogMjI1LFxuICAgIG1pbl93aWR0aDogNDAwLFxuICAgIG1pbl9oZWlnaHQ6IDIwMCxcbiAgICBwcm9wb3J0aW9uYWxfd2lkdGg6IDEsXG4gICAgbWFyZ2luOiB7IHRvcDogMzUsIHJpZ2h0OiA1MCwgYm90dG9tOiA0MCwgbGVmdDogNTAgfSxcbiAgICBpbm5lcl9ib3JkZXI6ICdyZ2IoMjEwLCAyMTAsIDIxMCknLFxuICAgIHRvb2xiYXI6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBkZWVwQ29weShzdGFuZGFyZF9wYW5lbF90b29sYmFyKTtcbiAgICAgICAgYmFzZS53aWRnZXRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3RvZ2dsZV9sZWdlbmQnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9KSgpLFxuICAgIGF4ZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgICAgbGFiZWw6ICdDaHJvbW9zb21lIHt7Y2hyfX0gKE1iKScsXG4gICAgICAgICAgICBsYWJlbF9vZmZzZXQ6IDMyLFxuICAgICAgICAgICAgdGlja19mb3JtYXQ6ICdyZWdpb24nLFxuICAgICAgICAgICAgZXh0ZW50OiAnc3RhdGUnLFxuICAgICAgICB9LFxuICAgICAgICB5MToge1xuICAgICAgICAgICAgbGFiZWw6ICctbG9nMTAgcC12YWx1ZScsXG4gICAgICAgICAgICBsYWJlbF9vZmZzZXQ6IDI4LFxuICAgICAgICB9LFxuICAgICAgICB5Mjoge1xuICAgICAgICAgICAgbGFiZWw6ICdSZWNvbWJpbmF0aW9uIFJhdGUgKGNNL01iKScsXG4gICAgICAgICAgICBsYWJlbF9vZmZzZXQ6IDQwLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICAgICAgICBvcmlnaW46IHsgeDogNTUsIHk6IDQwIH0sXG4gICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICB9LFxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICAgIGRyYWdfYmFja2dyb3VuZF90b19wYW46IHRydWUsXG4gICAgICAgIGRyYWdfeF90aWNrc190b19zY2FsZTogdHJ1ZSxcbiAgICAgICAgZHJhZ195MV90aWNrc190b19zY2FsZTogdHJ1ZSxcbiAgICAgICAgZHJhZ195Ml90aWNrc190b19zY2FsZTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsX3RvX3pvb206IHRydWUsXG4gICAgICAgIHhfbGlua2VkOiB0cnVlLFxuICAgIH0sXG4gICAgZGF0YV9sYXllcnM6IFtcbiAgICAgICAgZGVlcENvcHkoc2lnbmlmaWNhbmNlX2xheWVyKSxcbiAgICAgICAgZGVlcENvcHkocmVjb21iX3JhdGVfbGF5ZXIpLFxuICAgICAgICBkZWVwQ29weShhc3NvY2lhdGlvbl9wdmFsdWVzX2xheWVyKSxcbiAgICBdLFxufTtcblxuY29uc3QgY29hY2Nlc3NpYmlsaXR5X3BhbmVsID0ge1xuICAgIGlkOiAnY29hY2Nlc3NpYmlsaXR5JyxcbiAgICB3aWR0aDogODAwLFxuICAgIGhlaWdodDogMjI1LFxuICAgIG1pbl93aWR0aDogNDAwLFxuICAgIG1pbl9oZWlnaHQ6IDEwMCxcbiAgICBwcm9wb3J0aW9uYWxfd2lkdGg6IDEsXG4gICAgbWFyZ2luOiB7IHRvcDogMzUsIHJpZ2h0OiA1MCwgYm90dG9tOiA0MCwgbGVmdDogNTAgfSxcbiAgICBpbm5lcl9ib3JkZXI6ICdyZ2IoMjEwLCAyMTAsIDIxMCknLFxuICAgIHRvb2xiYXI6IGRlZXBDb3B5KHN0YW5kYXJkX3BhbmVsX3Rvb2xiYXIpLFxuICAgIGF4ZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgICAgbGFiZWw6ICdDaHJvbW9zb21lIHt7Y2hyfX0gKE1iKScsXG4gICAgICAgICAgICBsYWJlbF9vZmZzZXQ6IDMyLFxuICAgICAgICAgICAgdGlja19mb3JtYXQ6ICdyZWdpb24nLFxuICAgICAgICAgICAgZXh0ZW50OiAnc3RhdGUnLFxuICAgICAgICB9LFxuICAgICAgICB5MToge1xuICAgICAgICAgICAgbGFiZWw6ICdTY29yZScsXG4gICAgICAgICAgICBsYWJlbF9vZmZzZXQ6IDI4LFxuICAgICAgICAgICAgcmVuZGVyOiBmYWxzZSwgIC8vIFdlIGFyZSBtYWlubHkgY29uY2VybmVkIHdpdGggdGhlIHJlbGF0aXZlIG1hZ25pdHVkZXM6IGhpZGUgeSBheGlzIHRvIGF2b2lkIGNsdXR0ZXIuXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBkcmFnX2JhY2tncm91bmRfdG9fcGFuOiB0cnVlLFxuICAgICAgICBkcmFnX3hfdGlja3NfdG9fc2NhbGU6IHRydWUsXG4gICAgICAgIGRyYWdfeTFfdGlja3NfdG9fc2NhbGU6IHRydWUsXG4gICAgICAgIHNjcm9sbF90b196b29tOiB0cnVlLFxuICAgICAgICB4X2xpbmtlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGRhdGFfbGF5ZXJzOiBbXG4gICAgICAgIGRlZXBDb3B5KGNvYWNjZXNzaWJpbGl0eV9sYXllciksXG4gICAgXSxcbn07XG5cbmNvbnN0IGFzc29jaWF0aW9uX2NhdGFsb2dfcGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGJhc2UgPSBkZWVwQ29weShhc3NvY2lhdGlvbl9wYW5lbCk7XG4gICAgYmFzZSA9IG1lcmdlKHtcbiAgICAgICAgaWQ6ICdhc3NvY2lhdGlvbmNhdGFsb2cnLFxuICAgICAgICBuYW1lc3BhY2U6IHsgJ2Fzc29jJzogJ2Fzc29jJywgJ2xkJzogJ2xkJywgJ2NhdGFsb2cnOiAnY2F0YWxvZycgfSwgLy8gUmVxdWlyZWQgdG8gcmVzb2x2ZSBkaXNwbGF5IG9wdGlvbnNcbiAgICB9LCBiYXNlKTtcblxuICAgIGJhc2UudG9vbGJhci53aWRnZXRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnZGlzcGxheV9vcHRpb25zJyxcbiAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgIGNvbG9yOiAnYmx1ZScsXG4gICAgICAgIC8vIEJlbG93OiBzcGVjaWFsIGNvbmZpZyBzcGVjaWZpYyB0byB0aGlzIHdpZGdldFxuICAgICAgICBidXR0b25faHRtbDogJ0Rpc3BsYXkgb3B0aW9ucy4uLicsXG4gICAgICAgIGJ1dHRvbl90aXRsZTogJ0NvbnRyb2wgaG93IHBsb3QgaXRlbXMgYXJlIGRpc3BsYXllZCcsXG5cbiAgICAgICAgbGF5ZXJfbmFtZTogJ2Fzc29jaWF0aW9ucHZhbHVlc2NhdGFsb2cnLFxuICAgICAgICBkZWZhdWx0X2NvbmZpZ19kaXNwbGF5X25hbWU6ICdObyBjYXRhbG9nIGxhYmVscyAoZGVmYXVsdCknLCAvLyBkaXNwbGF5IG5hbWUgZm9yIHRoZSBkZWZhdWx0IHBsb3QgY29sb3Igb3B0aW9uIChhbGxvdyB1c2VyIHRvIHJldmVydCB0byBwbG90IGRlZmF1bHRzKVxuXG4gICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBkcm9wZG93biBtZW51IGl0ZW1cbiAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6ICdMYWJlbCBjYXRhbG9nIHRyYWl0cycsICAvLyBIdW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBmaWVsZCBuYW1lXG4gICAgICAgICAgICAgICAgZGlzcGxheTogeyAgLy8gU3BlY2lmeSBsYXlvdXQgZGlyZWN0aXZlcyB0aGF0IGNvbnRyb2wgZGlzcGxheSBvZiB0aGUgcGxvdCBmb3IgdGhpcyBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd7e3t7bmFtZXNwYWNlW2NhdGFsb2ddfX10cmFpdH19JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IDYsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAnMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnMnB4IDJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBsYWJlbCBwb2ludHMgaWYgdGhleSBhcmUgc2lnbmlmaWNhbnQgZm9yIHNvbWUgdHJhaXQgaW4gdGhlIGNhdGFsb2csIEFORCBpbiBoaWdoIExEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdpdGggdGhlIHRvcCBoaXQgb2YgaW50ZXJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGZpZWxkOiAne3tuYW1lc3BhY2VbY2F0YWxvZ119fXRyYWl0Jywgb3BlcmF0b3I6ICchPScsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogJ3t7bmFtZXNwYWNlW2NhdGFsb2ddfX1sb2dfcHZhbHVlJywgb3BlcmF0b3I6ICc+JywgdmFsdWU6IExaX1NJR19USFJFU0hPTERfTE9HUCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6ICd7e25hbWVzcGFjZVtsZF19fXN0YXRlJywgb3BlcmF0b3I6ICc+JywgdmFsdWU6IDAuNCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwnOiAnIzMzMzMzMycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pO1xuICAgIGJhc2UuZGF0YV9sYXllcnMgPSBbXG4gICAgICAgIGRlZXBDb3B5KHNpZ25pZmljYW5jZV9sYXllciksXG4gICAgICAgIGRlZXBDb3B5KHJlY29tYl9yYXRlX2xheWVyKSxcbiAgICAgICAgZGVlcENvcHkoYXNzb2NpYXRpb25fcHZhbHVlc19jYXRhbG9nX2xheWVyKSxcbiAgICBdO1xuICAgIHJldHVybiBiYXNlO1xufSgpO1xuXG5jb25zdCBnZW5lc19wYW5lbCA9IHtcbiAgICBpZDogJ2dlbmVzJyxcbiAgICB3aWR0aDogODAwLFxuICAgIGhlaWdodDogMjI1LFxuICAgIG1pbl93aWR0aDogNDAwLFxuICAgIG1pbl9oZWlnaHQ6IDExMi41LFxuICAgIHByb3BvcnRpb25hbF93aWR0aDogMSxcbiAgICBtYXJnaW46IHsgdG9wOiAyMCwgcmlnaHQ6IDUwLCBib3R0b206IDIwLCBsZWZ0OiA1MCB9LFxuICAgIGF4ZXM6IHt9LFxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICAgIGRyYWdfYmFja2dyb3VuZF90b19wYW46IHRydWUsXG4gICAgICAgIHNjcm9sbF90b196b29tOiB0cnVlLFxuICAgICAgICB4X2xpbmtlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHRvb2xiYXI6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBkZWVwQ29weShzdGFuZGFyZF9wYW5lbF90b29sYmFyKTtcbiAgICAgICAgYmFzZS53aWRnZXRzLnB1c2goXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jlc2l6ZV90b19kYXRhJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICBidXR0b25faHRtbDogJ1Jlc2l6ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVlcENvcHkoZ2VuZV9zZWxlY3Rvcl9tZW51KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9KSgpLFxuICAgIGRhdGFfbGF5ZXJzOiBbXG4gICAgICAgIGRlZXBDb3B5KGdlbmVzX2xheWVyX2ZpbHRlcmVkKSxcbiAgICBdLFxufTtcblxuY29uc3QgcGhld2FzX3BhbmVsID0ge1xuICAgIGlkOiAncGhld2FzJyxcbiAgICB3aWR0aDogODAwLFxuICAgIGhlaWdodDogMzAwLFxuICAgIG1pbl93aWR0aDogODAwLFxuICAgIG1pbl9oZWlnaHQ6IDMwMCxcbiAgICBwcm9wb3J0aW9uYWxfd2lkdGg6IDEsXG4gICAgbWFyZ2luOiB7IHRvcDogMjAsIHJpZ2h0OiA1MCwgYm90dG9tOiAxMjAsIGxlZnQ6IDUwIH0sXG4gICAgaW5uZXJfYm9yZGVyOiAncmdiKDIxMCwgMjEwLCAyMTApJyxcbiAgICBheGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICAgIHRpY2tzOiB7ICAvLyBPYmplY3QgYmFzZWQgY29uZmlnIChzaGFyZWQgZGVmYXVsdHM7IGFsbG93IGxheWVycyB0byBzcGVjaWZ5IHRpY2tzKVxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICdmb250LXdlaWdodCc6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSg1MCknLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnbGVmdCcsICAvLyBTcGVjaWFsIHBhcmFtIHJlY29nbml6ZWQgYnkgYGNhdGVnb3J5X3NjYXR0ZXJgIGxheWVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeTE6IHtcbiAgICAgICAgICAgIGxhYmVsOiAnLWxvZzEwIHAtdmFsdWUnLFxuICAgICAgICAgICAgbGFiZWxfb2Zmc2V0OiAyOCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGRhdGFfbGF5ZXJzOiBbXG4gICAgICAgIGRlZXBDb3B5KHNpZ25pZmljYW5jZV9sYXllciksXG4gICAgICAgIGRlZXBDb3B5KHBoZXdhc19wdmFsdWVzX2xheWVyKSxcbiAgICBdLFxufTtcblxuY29uc3QgYW5ub3RhdGlvbl9jYXRhbG9nX3BhbmVsID0ge1xuICAgIGlkOiAnYW5ub3RhdGlvbmNhdGFsb2cnLFxuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA0NSxcbiAgICBtaW5faGVpZ2h0OiA0NSxcbiAgICBwcm9wb3J0aW9uYWxfd2lkdGg6IDEsXG4gICAgbWFyZ2luOiB7IHRvcDogMjUsIHJpZ2h0OiA1MCwgYm90dG9tOiAwLCBsZWZ0OiA1MCB9LFxuICAgIGlubmVyX2JvcmRlcjogJ3JnYigyMTAsIDIxMCwgMjEwKScsXG4gICAgdG9vbGJhcjogZGVlcENvcHkoc3RhbmRhcmRfcGFuZWxfdG9vbGJhciksXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgZHJhZ19iYWNrZ3JvdW5kX3RvX3BhbjogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsX3RvX3pvb206IHRydWUsXG4gICAgICAgIHhfbGlua2VkOiB0cnVlLFxuICAgIH0sXG4gICAgZGF0YV9sYXllcnM6IFtcbiAgICAgICAgZGVlcENvcHkoYW5ub3RhdGlvbl9jYXRhbG9nX2xheWVyKSxcbiAgICBdLFxufTtcblxuLyoqXG4gKiBQbG90IExheW91dHNcbiAqL1xuXG5jb25zdCBzdGFuZGFyZF9hc3NvY2lhdGlvbl9wbG90ID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICB3aWR0aDogODAwLFxuICAgIGhlaWdodDogNDUwLFxuICAgIHJlc3BvbnNpdmVfcmVzaXplOiB0cnVlLFxuICAgIG1pbl9yZWdpb25fc2NhbGU6IDIwMDAwLFxuICAgIG1heF9yZWdpb25fc2NhbGU6IDEwMDAwMDAsXG4gICAgdG9vbGJhcjogZGVlcENvcHkoc3RhbmRhcmRfYXNzb2NpYXRpb25fdG9vbGJhciksXG4gICAgcGFuZWxzOiBbXG4gICAgICAgIG1lcmdlKHsgcHJvcG9ydGlvbmFsX2hlaWdodDogMC41fSwgZGVlcENvcHkoYXNzb2NpYXRpb25fcGFuZWwpKSxcbiAgICAgICAgbWVyZ2UoeyBwcm9wb3J0aW9uYWxfaGVpZ2h0OiAwLjV9LCBkZWVwQ29weShnZW5lc19wYW5lbCkpLFxuICAgIF0sXG59O1xuXG5jb25zdCBhc3NvY2lhdGlvbl9jYXRhbG9nX3Bsb3QgPSB7XG4gICAgc3RhdGU6IHt9LFxuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA1MDAsXG4gICAgcmVzcG9uc2l2ZV9yZXNpemU6IHRydWUsXG4gICAgbWluX3JlZ2lvbl9zY2FsZTogMjAwMDAsXG4gICAgbWF4X3JlZ2lvbl9zY2FsZTogMTAwMDAwMCxcbiAgICB0b29sYmFyOiBkZWVwQ29weShzdGFuZGFyZF9hc3NvY2lhdGlvbl90b29sYmFyKSxcbiAgICBwYW5lbHM6IFtcbiAgICAgICAgZGVlcENvcHkoYW5ub3RhdGlvbl9jYXRhbG9nX3BhbmVsKSxcbiAgICAgICAgZGVlcENvcHkoYXNzb2NpYXRpb25fY2F0YWxvZ19wYW5lbCksXG4gICAgICAgIGRlZXBDb3B5KGdlbmVzX3BhbmVsKSxcbiAgICBdLFxufTtcblxuY29uc3Qgc3RhbmRhcmRfcGhld2FzX3Bsb3QgPSB7XG4gICAgd2lkdGg6IDgwMCxcbiAgICBoZWlnaHQ6IDYwMCxcbiAgICBtaW5fd2lkdGg6IDgwMCxcbiAgICBtaW5faGVpZ2h0OiA2MDAsXG4gICAgcmVzcG9uc2l2ZV9yZXNpemU6IHRydWUsXG4gICAgdG9vbGJhcjogZGVlcENvcHkoc3RhbmRhcmRfcGxvdF90b29sYmFyKSxcbiAgICBwYW5lbHM6IFtcbiAgICAgICAgbWVyZ2Uoe3Byb3BvcnRpb25hbF9oZWlnaHQ6IDAuNX0sIGRlZXBDb3B5KHBoZXdhc19wYW5lbCkpLFxuICAgICAgICBtZXJnZSh7XG4gICAgICAgICAgICBwcm9wb3J0aW9uYWxfaGVpZ2h0OiAwLjUsXG4gICAgICAgICAgICBtYXJnaW46IHsgYm90dG9tOiA0MCB9LFxuICAgICAgICAgICAgYXhlczoge1xuICAgICAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdDaHJvbW9zb21lIHt7Y2hyfX0gKE1iKScsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsX29mZnNldDogMzIsXG4gICAgICAgICAgICAgICAgICAgIHRpY2tfZm9ybWF0OiAncmVnaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiAnc3RhdGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBkZWVwQ29weShnZW5lc19wYW5lbCkpLFxuICAgIF0sXG4gICAgbW91c2VfZ3VpZGU6IGZhbHNlLFxufTtcblxuY29uc3QgY29hY2Nlc3NpYmlsaXR5X3Bsb3QgPSB7XG4gICAgc3RhdGU6IHt9LFxuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA0NTAsXG4gICAgcmVzcG9uc2l2ZV9yZXNpemU6IHRydWUsXG4gICAgbWluX3JlZ2lvbl9zY2FsZTogMjAwMDAsXG4gICAgbWF4X3JlZ2lvbl9zY2FsZTogMTAwMDAwMCxcbiAgICB0b29sYmFyOiBkZWVwQ29weShzdGFuZGFyZF9wbG90X3Rvb2xiYXIpLFxuICAgIHBhbmVsczogW1xuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgeyBwcm9wb3J0aW9uYWxfaGVpZ2h0OiAwLjQgfSxcbiAgICAgICAgICAgIGRlZXBDb3B5KGNvYWNjZXNzaWJpbGl0eV9wYW5lbClcbiAgICAgICAgKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVGFrZSB0aGUgZGVmYXVsdCBnZW5lcyBwYW5lbCwgYW5kIGFkZCBhIGN1c3RvbSBmZWF0dXJlIHRvIGhpZ2hsaWdodCBnZW5lIHRyYWNrcyBiYXNlZCBvbiBzaG9ydCBuYW1lXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29tcGFuaW9uIHRvIHRoZSBcIm1hdGNoXCIgZGlyZWN0aXZlIGluIHRoZSBjb2FjY2Vzc2liaWxpdHkgcGFuZWxcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHsgcHJvcG9ydGlvbmFsX2hlaWdodDogMC42IH0sXG4gICAgICAgICAgICAgICAgZGVlcENvcHkoZ2VuZXNfcGFuZWwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBiYXNlLmRhdGFfbGF5ZXJzWzBdO1xuICAgICAgICAgICAgbGF5ZXIubWF0Y2ggPSB7IHNlbmQ6ICdnZW5lX25hbWUnLCByZWNlaXZlOiAnZ2VuZV9uYW1lJyB9O1xuICAgICAgICAgICAgY29uc3QgY29sb3JfY29uZmlnID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdsel9oaWdobGlnaHRfbWF0Y2gnLCAvLyBTcGVjaWFsIGZpZWxkIG5hbWUgd2hvc2UgcHJlc2VuY2UgdHJpZ2dlcnMgY3VzdG9tIHJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ2lmJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVuOiAnI2ZmMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnbHpfaGlnaGxpZ2h0X21hdGNoJywgLy8gU3BlY2lhbCBmaWVsZCBuYW1lIHdob3NlIHByZXNlbmNlIHRyaWdnZXJzIGN1c3RvbSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVfZnVuY3Rpb246ICdpZicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkX3ZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW46ICcjRUFFNkU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICcjMzYzNjk2JyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsYXllci5jb2xvciA9IGNvbG9yX2NvbmZpZztcbiAgICAgICAgICAgIGxheWVyLnN0cm9rZSA9IGNvbG9yX2NvbmZpZztcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9KCksXG4gICAgXSxcbn07XG5cblxuZXhwb3J0IGNvbnN0IHRvb2x0aXAgPSB7XG4gICAgc3RhbmRhcmRfYXNzb2NpYXRpb246IHN0YW5kYXJkX2Fzc29jaWF0aW9uX3Rvb2x0aXAsXG4gICAgc3RhbmRhcmRfYXNzb2NpYXRpb25fd2l0aF9sYWJlbDogc3RhbmRhcmRfYXNzb2NpYXRpb25fdG9vbHRpcF93aXRoX2xhYmVsLFxuICAgIHN0YW5kYXJkX2dlbmVzOiBzdGFuZGFyZF9nZW5lc190b29sdGlwLFxuICAgIGNhdGFsb2dfdmFyaWFudDogY2F0YWxvZ192YXJpYW50X3Rvb2x0aXAsXG4gICAgY29hY2Nlc3NpYmlsaXR5OiBjb2FjY2Vzc2liaWxpdHlfdG9vbHRpcCxcbn07XG5cbmV4cG9ydCBjb25zdCB0b29sYmFyX3dpZGdldHMgPSB7XG4gICAgbGRsejJfcG9wX3NlbGVjdG9yOiBsZGx6Ml9wb3Bfc2VsZWN0b3JfbWVudSxcbiAgICBnZW5lX3NlbGVjdG9yX21lbnUsXG59O1xuXG5leHBvcnQgY29uc3QgdG9vbGJhciA9IHtcbiAgICBzdGFuZGFyZF9wYW5lbDogc3RhbmRhcmRfcGFuZWxfdG9vbGJhcixcbiAgICBzdGFuZGFyZF9wbG90OiBzdGFuZGFyZF9wbG90X3Rvb2xiYXIsXG4gICAgc3RhbmRhcmRfYXNzb2NpYXRpb246IHN0YW5kYXJkX2Fzc29jaWF0aW9uX3Rvb2xiYXIsXG4gICAgcmVnaW9uX25hdl9wbG90OiByZWdpb25fbmF2X3Bsb3RfdG9vbGJhcixcbn07XG5cbmV4cG9ydCBjb25zdCBkYXRhX2xheWVyID0ge1xuICAgIHNpZ25pZmljYW5jZTogc2lnbmlmaWNhbmNlX2xheWVyLFxuICAgIHJlY29tYl9yYXRlOiByZWNvbWJfcmF0ZV9sYXllcixcbiAgICBhc3NvY2lhdGlvbl9wdmFsdWVzOiBhc3NvY2lhdGlvbl9wdmFsdWVzX2xheWVyLFxuICAgIGNvYWNjZXNzaWJpbGl0eTogY29hY2Nlc3NpYmlsaXR5X2xheWVyLFxuICAgIGFzc29jaWF0aW9uX3B2YWx1ZXNfY2F0YWxvZzogYXNzb2NpYXRpb25fcHZhbHVlc19jYXRhbG9nX2xheWVyLFxuICAgIHBoZXdhc19wdmFsdWVzOiBwaGV3YXNfcHZhbHVlc19sYXllcixcbiAgICBnZW5lczogZ2VuZXNfbGF5ZXIsXG4gICAgZ2VuZXNfZmlsdGVyZWQ6IGdlbmVzX2xheWVyX2ZpbHRlcmVkLFxuICAgIGFubm90YXRpb25fY2F0YWxvZzogYW5ub3RhdGlvbl9jYXRhbG9nX2xheWVyLFxufTtcblxuZXhwb3J0IGNvbnN0IHBhbmVsID0ge1xuICAgIGFzc29jaWF0aW9uOiBhc3NvY2lhdGlvbl9wYW5lbCxcbiAgICBjb2FjY2Vzc2liaWxpdHk6IGNvYWNjZXNzaWJpbGl0eV9wYW5lbCxcbiAgICBhc3NvY2lhdGlvbl9jYXRhbG9nOiBhc3NvY2lhdGlvbl9jYXRhbG9nX3BhbmVsLFxuICAgIGdlbmVzOiBnZW5lc19wYW5lbCxcbiAgICBwaGV3YXM6IHBoZXdhc19wYW5lbCxcbiAgICBhbm5vdGF0aW9uX2NhdGFsb2c6IGFubm90YXRpb25fY2F0YWxvZ19wYW5lbCxcbn07XG5cbmV4cG9ydCBjb25zdCBwbG90ID0ge1xuICAgIHN0YW5kYXJkX2Fzc29jaWF0aW9uOiBzdGFuZGFyZF9hc3NvY2lhdGlvbl9wbG90LFxuICAgIGFzc29jaWF0aW9uX2NhdGFsb2c6IGFzc29jaWF0aW9uX2NhdGFsb2dfcGxvdCxcbiAgICBzdGFuZGFyZF9waGV3YXM6IHN0YW5kYXJkX3BoZXdhc19wbG90LFxuICAgIGNvYWNjZXNzaWJpbGl0eTogY29hY2Nlc3NpYmlsaXR5X3Bsb3QsXG59O1xuIiwiLyoqXG4gKiBBIHJlZ2lzdHJ5IG9mIGtub3duIGRhdGEgc291cmNlcy4gQ2FuIGJlIHVzZWQgdG8gZmluZCBzb3VyY2VzIGJ5IG5hbWUsIGVpdGhlciBmcm9tIHByZWRlZmluZWRcbiAqICBjbGFzc2VzLCBvciBwbHVnaW5zLlxuICogIEBtb2R1bGVcbiAqICBAcHJpdmF0ZVxuICovXG5pbXBvcnQge0NsYXNzUmVnaXN0cnl9IGZyb20gJy4vYmFzZSc7XG5cbmltcG9ydCAqIGFzIGFkYXB0ZXJzIGZyb20gJy4uL2RhdGEvYWRhcHRlcnMnO1xuXG5cbi8vIEtub3duRGF0YVNvdXJjZXMgaXMgYSBiYXNpYyByZWdpc3RyeSB3aXRoIG5vIHNwZWNpYWwgYmVoYXZpb3IuXG5jb25zdCByZWdpc3RyeSA9IG5ldyBDbGFzc1JlZ2lzdHJ5KCk7XG5cbmZvciAobGV0IFtuYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhhZGFwdGVycykpIHtcbiAgICByZWdpc3RyeS5hZGQobmFtZSwgdHlwZSk7XG59XG5cbi8vIEFkZCBzb21lIGhhcmQtY29kZWQgYWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbnJlZ2lzdHJ5LmFkZCgnU3RhdGljSlNPTicsIGFkYXB0ZXJzLlN0YXRpY1NvdXJjZSk7XG5yZWdpc3RyeS5hZGQoJ0xETFoyJywgYWRhcHRlcnMuTERTZXJ2ZXIpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHJlZ2lzdHJ5O1xuIiwiLyoqIEBtb2R1bGUgKi9cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgcmVnaXN0cmllc1xuICpcbiAqIExvY3VzWm9vbSBpcyBwbHVnaW4tZXh0ZW5zaWJsZSwgYW5kIGxheW91dHMgYXJlIHN0cmluZy1iYXNlZCBhbmQgSlNPTiBzZXJpYWxpemFibGUuIFRoaXMgaXMgYWNoaWV2ZWQgdGhyb3VnaCB0aGUgdXNlXG4gKiAgb2YgYSBjZW50cmFsIHJlZ2lzdHJ5IHRoYXQgaG9sZHMgYSByZWZlcmVuY2UgdG8gZWFjaCBwb3NzaWJsZSBmZWF0dXJlLlxuICpcbiAqIEVhY2ggcmVnaXN0cnkgaGFzIHNvbWUgc3ludGFjdGljYWwgc3VnYXIsIHdpdGggY29tbW9uIGVsZW1lbnRzIGFyZSBkZWZpbmVkIGluIGEgYmFzZSBjbGFzc1xuICovXG5jbGFzcyBSZWdpc3RyeUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJlZ2lzdHJ5IG1lbWJlci4gSWYgdGhlIHJlZ2lzdHJ5IHN0b3JlcyBjbGFzc2VzLCB0aGlzIHJldHVybnMgdGhlIGNsYXNzLCBub3QgdGhlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGdldChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5faXRlbXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gbm90IGZvdW5kOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgaXRlbSB0byB0aGUgcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaXRlbSB0byBhZGQgdG8gdGhlIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIGJlIGFkZGVkIChjb25zdHJ1Y3RvciwgdmFsdWUsIGV0YylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVycmlkZT1mYWxzZV0gQWxsb3cgcmVkZWZpbmluZyBhbiBleGlzdGluZyBpdGVtP1xuICAgICAqIEByZXR1cm4geyp9IFRoZSBhY3R1YWwgb2JqZWN0IGFzIGFkZGVkIHRvIHRoZSByZWdpc3RyeVxuICAgICAqL1xuICAgIGFkZChuYW1lLCBpdGVtLCBvdmVycmlkZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghb3ZlcnJpZGUgJiYgdGhpcy5faXRlbXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gJHtuYW1lfSBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pdGVtcy5zZXQobmFtZSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRhdGFzb3VyY2UgZnJvbSB0aGUgcmVnaXN0cnkgKGlmIHByZXNlbnQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBpdGVtIHJlbW92ZWQsIGZhbHNlIGlmIGl0ZW0gd2FzIG5ldmVyIHByZXNlbnRcbiAgICAgKi9cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuZGVsZXRlKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBpdGVtIGlzIHJlZ2lzdGVyZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmFtZXMgb2YgZWFjaCBhbGxvd2VkXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGxpc3QoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2l0ZW1zLmtleXMoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcmVnaXN0cnkgd2hvc2UgbWVtYmVycyBhcmUgY2xhc3MgY29uc3RydWN0b3JzLiBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzXG4gKiAgYW5kIHN1YmNsYXNzZXMuXG4gKi9cbmNsYXNzIENsYXNzUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeUJhc2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIGNsYXNzIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IGFyZ3MgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjcmVhdGUobmFtZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgYmFzZSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2hpbGQgY2xhc3MgZm9yIGFuIGl0ZW0gaW4gdGhlIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogVGhpcyBpcyAoYWxtb3N0LCBidXQgbm90IHF1aXRlKSBhIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG9sZCBzaXRlcyB0aGF0IHVzZWQgbG9jdXN6b29tXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHByaW1hcmlseSBhaW1lZCBhdCBsb3ctdG9vbGluZyBlbnZpcm9ubWVudHMuIEl0IGlzIHN5bnRhY3RpYyBzdWdhciwgcm91Z2hseSBlcXVpdmFsZW50IHRvOlxuICAgICAqICAgYHJlZ2lzdHJ5LmdldChiYXNlKTsgcmVnaXN0cnkuYWRkKG5hbWUsIGNsYXNzIEEgZXh0ZW5kcyBiYXNlIHt9KTtgXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIHRoaXMgYnlwYXNzZXMgZXM2IGNsYXNzIG1lY2hhbmljcywgY2VydGFpbiB0aGluZ3MsIGVzcCBzdXBlciBjYWxscywgbWF5IG5vdCB3b3JrIGFzIHdlbGwgYXMgdXNpbmcgdGhlXG4gICAgICogICBcInJlYWxcIiBjbGFzcyBleHByZXNzaW9uLiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBzb2xlbHkgZm9yIGNvbnZlbmllbmNlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYSBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBvbGQgdmVyc2lvbnMuIEJvcm4gdG8gYmUgZGVwcmVjYXRlZCFcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVzaXJlZCBwYXJlbnQgY2xhc3MgYXMgcmVwcmVzZW50ZWQgaW4gdGhlIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZV9uYW1lIFRoZSBkZXNpcmVkIG5hbWUgb2YgdGhlIGNsYXNzIHRvIGJlIGNyZWF0ZWQsIGFzIGl0IHdpbGwgYmUgbmFtZWQgaW4gdGhlIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG92ZXJyaWRlcyBBbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIGV4dGVuZChwYXJlbnRfbmFtZSwgc291cmNlX25hbWUsIG92ZXJyaWRlcykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IC5leHRlbmQgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMsIGluIGZhdm9yIG9mIGV4cGxpY2l0IEVTNiBzdWJjbGFzc2VzJyk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIHRvIC5leHRlbmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmdldChwYXJlbnRfbmFtZSk7XG4gICAgICAgIGNsYXNzIHN1YiBleHRlbmRzIGJhc2Uge31cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdWIucHJvdG90eXBlLCBvdmVycmlkZXMsIGJhc2UpO1xuICAgICAgICB0aGlzLmFkZChzb3VyY2VfbmFtZSwgc3ViKTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVnaXN0cnlCYXNlO1xuZXhwb3J0IHtSZWdpc3RyeUJhc2UsIENsYXNzUmVnaXN0cnl9O1xuIiwiLyoqXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5pbXBvcnQge0NsYXNzUmVnaXN0cnl9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgKiBhcyBsYXllcnMgZnJvbSAnLi4vY29tcG9uZW50cy9kYXRhX2xheWVyJztcblxuY29uc3QgcmVnaXN0cnkgPSBuZXcgQ2xhc3NSZWdpc3RyeSgpO1xuZm9yIChsZXQgW25hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKGxheWVycykpIHtcbiAgICByZWdpc3RyeS5hZGQobmFtZSwgdHlwZSk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgcmVnaXN0cnk7XG4iLCIvKipcbiAqIFJlZ2lzdHJpZXMgdGhhdCB0cmFjayBhbGwgcmVnaXN0ZXJlZCBmZWF0dXJlcyBhdmFpbGFibGUgdG8gTG9jdXNab29tIChpbmNsdWRpbmcgYWN0aXZlIHBsdWdpbnMpXG4gKiBAbW9kdWxlXG4gKiBAcHVibGljXG4gKi9cbmltcG9ydCBBREFQVEVSUyBmcm9tICcuL2FkYXB0ZXJzJztcbmltcG9ydCBEQVRBX0xBWUVSUyBmcm9tICcuL2RhdGFfbGF5ZXJzJztcbmltcG9ydCBMQVlPVVRTIGZyb20gJy4vbGF5b3V0cyc7XG5pbXBvcnQgU0NBTEFCTEUgZnJvbSAnLi9zY2FsYWJsZSc7XG5pbXBvcnQgVFJBTlNGT1JNUyBmcm9tICcuL3RyYW5zZm9ybXMnO1xuaW1wb3J0IFdJREdFVFMgZnJvbSAnLi93aWRnZXRzJztcblxuZXhwb3J0IHsgQURBUFRFUlMsIERBVEFfTEFZRVJTLCBMQVlPVVRTLCBTQ0FMQUJMRSwgVFJBTlNGT1JNUywgV0lER0VUUyB9O1xuIiwiLyoqXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5pbXBvcnQge1JlZ2lzdHJ5QmFzZX0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7YXBwbHlOYW1lc3BhY2VzLCBkZWVwQ29weSwgbWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvbGF5b3V0cyc7XG5pbXBvcnQgKiBhcyBsYXlvdXRzIGZyb20gJy4uL2xheW91dHMnO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igd29ya2luZyB3aXRoIHByZWRlZmluZWQgbGF5b3V0c1xuICpcbiAqIFRoaXMgaXMgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZSB3aXRoIExvY3VzWm9vbSBhbmQgYSBtYWpvciB3YXkgdGhhdCB1c2VycyBpbnRlcmFjdCB0byBjb25maWd1cmUgcGxvdHMuXG4gKlxuICogRWFjaCBsYXlvdXQgb2JqZWN0IHRoYXQgaXMgYWRkZWQgb3IgcmV0cmlldmVkIGhlcmUgaXMgYSBkZWVwIGNvcHkgYW5kIHRvdGFsbHkgaW5kZXBlbmRlbnQgZnJvbSBhbnkgb3RoZXIgb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIExheW91dFJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnlCYXNlIHtcbiAgICAvLyBJbXBsZW1lbnRlZCBhcyBhIFwicmVnaXN0cnkgb2YgcmVnaXN0cmllc1wiLSBvbmUgbG9va3VwIGVhY2ggZm9yIHBhbmVscywgcGxvdHMsIGV0Yy4uLlxuICAgIGdldCh0eXBlLCBuYW1lLCBvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICBpZiAoISh0eXBlICYmIG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBib3RoIHRoZSB0eXBlIGFuZCBuYW1lIGZvciB0aGUgbGF5b3V0IGRlc2lyZWQuIFNlZSAubGlzdCgpIGZvciBhdmFpbGFibGUgb3B0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgYSByZWdpc3RyeSBvZiByZWdpc3RyaWVzLiBGZXRjaGluZyBhbiBpdGVtIG1heSBhcHBseSBhZGRpdGlvbmFsIGN1c3RvbSBiZWhhdmlvcnMsIHN1Y2ggYXNcbiAgICAgICAgLy8gIGFwcGx5aW5nIG92ZXJyaWRlcyBvciB1c2luZyBuYW1lc3BhY2VzIHRvIGNvbnZlcnQgYW4gYWJzdHJhY3QgbGF5b3V0IGludG8gYSBjb25jcmV0ZSBvbmUuXG4gICAgICAgIGxldCBiYXNlID0gc3VwZXIuZ2V0KHR5cGUpLmdldChuYW1lKTtcbiAgICAgICAgYmFzZSA9IG1lcmdlKG92ZXJyaWRlcywgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLnVubmFtZXNwYWNlZCkge1xuICAgICAgICAgICAgZGVsZXRlIGJhc2UudW5uYW1lc3BhY2VkO1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBDb3B5KGJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0X25hbWVzcGFjZSA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UubmFtZXNwYWNlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkZWZhdWx0X25hbWVzcGFjZSA9IGJhc2UubmFtZXNwYWNlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBiYXNlLm5hbWVzcGFjZSA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhiYXNlLm5hbWVzcGFjZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJhc2UubmFtZXNwYWNlLmRlZmF1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0X25hbWVzcGFjZSA9IGJhc2UubmFtZXNwYWNlLmRlZmF1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRfbmFtZXNwYWNlID0gYmFzZS5uYW1lc3BhY2VbT2JqZWN0LmtleXMoYmFzZS5uYW1lc3BhY2UpWzBdXS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRfbmFtZXNwYWNlICs9IGRlZmF1bHRfbmFtZXNwYWNlLmxlbmd0aCA/ICc6JyA6ICcnO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhcHBseU5hbWVzcGFjZXMoYmFzZSwgYmFzZS5uYW1lc3BhY2UsIGRlZmF1bHRfbmFtZXNwYWNlKTtcblxuICAgICAgICByZXR1cm4gZGVlcENvcHkocmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0eXBlIG9mIGxheW91dCB0byB0aGUgcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBhZGQodHlwZSwgbmFtZSwgaXRlbSwgb3ZlcnJpZGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoISh0eXBlICYmIG5hbWUgJiYgaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gYWRkIGEgbGF5b3V0LCB0eXBlLCBuYW1lLCBhbmQgaXRlbSBtdXN0IGFsbCBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjb25maWd1cmF0aW9uIHRvIGJlIGFkZGVkIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICBzdXBlci5hZGQodHlwZSwgbmV3IFJlZ2lzdHJ5QmFzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBlYWNoIHVzZSBvZiBhIGxheW91dCBjYW4gYmUgbW9kaWZpZWQsIGJ5IHJldHVybmluZyBhIGNvcHkgaXMgaW5kZXBlbmRlbnRcbiAgICAgICAgY29uc3QgY29weSA9IGRlZXBDb3B5KGl0ZW0pO1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KHR5cGUpLmFkZChuYW1lLCBjb3B5LCBvdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgYXZhaWxhYmxlIHR5cGVzIG9mIGxheW91dCAoZWcgdG9vbGJhciwgcGFuZWwsIGV0YykuIElmIGEgc3BlY2lmaWMgdHlwZSBuYW1lIGlzIHByb3ZpZGVkLCBsaXN0IHRoZVxuICAgICAqICBsYXlvdXRzIGZvciB0aGF0IHdpZGdldCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHR5cGUgb2YgbGF5b3V0IChlZyB0b29sYmFyLCBwYW5lbCwgZXRjKVxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfE9iamVjdH1cbiAgICAgKi9cbiAgICBsaXN0KHR5cGUpIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBbdHlwZSwgY29udGVudHNdIG9mIHRoaXMuX2l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0gY29udGVudHMubGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KHR5cGUpLmxpc3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgYWxpYXMgdG8gYSBoZWxwZXIgbWV0aG9kLiBQcmVzZXJ2ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBzbyB0aGF0IFVNRCB1c2VycyBjYW4gYWNjZXNzIHRoaXMgbWV0aG9kLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBtZXJnZShjdXN0b21fbGF5b3V0LCBkZWZhdWx0X2xheW91dCkge1xuICAgICAgICByZXR1cm4gbWVyZ2UoY3VzdG9tX2xheW91dCwgZGVmYXVsdF9sYXlvdXQpO1xuICAgIH1cbn1cblxuY29uc3QgcmVnaXN0cnkgPSBuZXcgTGF5b3V0UmVnaXN0cnkoKTtcblxuZm9yIChsZXQgW3R5cGUsIGVudHJpZXNdIG9mIE9iamVjdC5lbnRyaWVzKGxheW91dHMpKSB7XG4gICAgZm9yIChsZXQgW25hbWUsIGNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoZW50cmllcykpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHR5cGUsIG5hbWUsIGNvbmZpZyk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHJlZ2lzdHJ5O1xuXG4vLyBFeHBvcnQgYmFzZSBjbGFzcyBmb3IgdW5pdCB0ZXN0aW5nXG5leHBvcnQge0xheW91dFJlZ2lzdHJ5IGFzIF9MYXlvdXRSZWdpc3RyeX07XG4iLCIvKipcbiAqIEBtb2R1bGVcbiAqIEBwcml2YXRlXG4gKi9cbmltcG9ydCB7UmVnaXN0cnlCYXNlfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgc2NhbGFibGUgZnJvbSAnLi4vaGVscGVycy9zY2FsYWJsZSc7XG5cbmNvbnN0IHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5QmFzZSgpO1xuZm9yIChsZXQgW25hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHNjYWxhYmxlKSkge1xuICAgIHJlZ2lzdHJ5LmFkZChuYW1lLCB0eXBlKTtcbn1cblxuLy8gQWxpYXMgZm9yIHRoZSBcImlmX3ZhbHVlXCIgZnVuY3Rpb24gKGNhbid0IGV4cG9ydCByZXNlcnZlZCBsYW5ndWFnZSBrZXl3b3JkcyBkaXJlY3RseSlcbnJlZ2lzdHJ5LmFkZCgnaWYnLCBzY2FsYWJsZS5pZl92YWx1ZSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgcmVnaXN0cnk7XG4iLCIvKipcbiAqIEBtb2R1bGVcbiAqIEBwcml2YXRlXG4gKi9cbmltcG9ydCB7UmVnaXN0cnlCYXNlfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0ICogYXMgdHJhbnNmb3JtcyBmcm9tICcuLi9oZWxwZXJzL3RyYW5zZm9ybXMnO1xuXG4vKipcbiAqIFJlZ2lzdHJ5IG9mIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0aGF0IG1heSBiZSBhcHBsaWVkIHRvIHRlbXBsYXRlIHZhbHVlcy5cbiAqIFByb3ZpZGVzIHN5bnRhY3RpYyBzdWdhciBhdG9wIGEgc3RhbmRhcmQgcmVnaXN0cnkuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBUcmFuc2Zvcm1hdGlvbkZ1bmN0aW9ucyBleHRlbmRzIFJlZ2lzdHJ5QmFzZSB7XG4gICAgX2NvbGxlY3RUcmFuc2Zvcm1zKHRlbXBsYXRlX3N0cmluZykge1xuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCB0dXJucyBhIHNlcXVlbmNlIG9mIGZ1bmN0aW9uIG5hbWVzIGludG8gYSBzaW5nbGUgY2FsbGFibGVcbiAgICAgICAgY29uc3QgZnVuY3MgPSB0ZW1wbGF0ZV9zdHJpbmdcbiAgICAgICAgICAgIC5tYXRjaCgvXFx8KFtefF0rKS9nKVxuICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gc3VwZXIuZ2V0KGl0ZW0uc3Vic3RyaW5nKDEpKSk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmNzLnJlZHVjZShcbiAgICAgICAgICAgICAgICAoYWNjLCBmdW5jKSA9PiBmdW5jKGFjYyksXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gdGVtcGxhdGVzLCB3ZSBvZnRlbiB1c2UgYSBzaW5nbGUgY29uY2F0ZW5hdGVkIHN0cmluZyB0byBhc2sgZm9yIHNldmVyYWwgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIGF0IG9uY2U6XG4gICAgICogIGB2YWx1ZXxmdW5jMXxmdW5jMmBcbiAgICAgKiBUaGlzIGNsYXNzIG9mZmVycyBzeW50YWN0aWNhbCBzdWdhciB0byByZXRyaWV2ZSB0aGUgZW50aXJlIHNlcXVlbmNlIG9mIHRyYW5zZm9ybWF0aW9ucyBhcyBhIHNpbmdsZSBjYWxsYWJsZVxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICovXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHNvbWV0aW1lcyBjYWxsZWQgd2l0aCBubyB2YWx1ZSwgYW5kIHRoZSBleHBlY3RlZCBiZWhhdmlvciBpcyB0byByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAvLyAgYSBjYWxsYWJsZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSAnfCcpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBhcnRpZmFjdCBvZiBob3cgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQtIGlmIGEgcGlwZSBpcyBwcmVzZW50LCB0aGlzIGlzIHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICAgICAgICAgIC8vICAoYHxmdW5jMXxmdW5jMi4uLmApLCByYXRoZXIgdGhhbiBhbnkgb25lIHNpbmdsZSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbi5cbiAgICAgICAgICAgIC8vIEEgc2VxdWVuY2Ugb2YgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIGlzIGV4cGVjdGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdFRyYW5zZm9ybXMobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBub3QgYSB0ZW1wbGF0ZSBzdHJpbmcsIHRoZW4gdXNlciBpcyBhc2tpbmcgZm9yIGFuIGl0ZW0gYnkgbmFtZSBkaXJlY3RseVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgcmVnaXN0cnkgPSBuZXcgVHJhbnNmb3JtYXRpb25GdW5jdGlvbnMoKTtcbmZvciAobGV0IFtuYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh0cmFuc2Zvcm1zKSkge1xuICAgIHJlZ2lzdHJ5LmFkZChuYW1lLCB0eXBlKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RyeTtcbi8vIEV4cG9ydCBoZWxwZXIgY2xhc3MgZm9yIHVuaXQgdGVzdGluZ1xuZXhwb3J0IHsgVHJhbnNmb3JtYXRpb25GdW5jdGlvbnMgYXMgX1RyYW5zZm9ybWF0aW9uRnVuY3Rpb25zIH07XG4iLCIvKipcbiAqIEBtb2R1bGVcbiAqIEBwcml2YXRlXG4gKi9cbmltcG9ydCB7Q2xhc3NSZWdpc3RyeX0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCAqIGFzIHdpZGdldHMgZnJvbSAnLi4vY29tcG9uZW50cy90b29sYmFyL3dpZGdldHMnO1xuXG5jb25zdCByZWdpc3RyeSA9IG5ldyBDbGFzc1JlZ2lzdHJ5KCk7XG5cbmZvciAobGV0IFtuYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh3aWRnZXRzKSkge1xuICAgIHJlZ2lzdHJ5LmFkZChuYW1lLCB0eXBlKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RyeTtcbiIsImV4cG9ydCBkZWZhdWx0ICcwLjEzLjAtYmV0YS4yJztcbiIsIm1vZHVsZS5leHBvcnRzID0gZDM7Il0sInNvdXJjZVJvb3QiOiIifQ==